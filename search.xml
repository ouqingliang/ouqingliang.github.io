<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>模板</title>
    <url>/2022/01/01/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>[TOC]</p>
<span id="more"></span>

<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ll extend[N],ne[N],ans;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getne</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ne,<span class="number">0</span>,<span class="built_in">sizeof</span>(ne));</span><br><span class="line">    ne[<span class="number">0</span>]=len;</span><br><span class="line">    ll a,p;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( a&lt;len &amp;&amp; s[a]==s[a<span class="number">-1</span>]) a++;</span><br><span class="line">    ne[<span class="number">1</span>]=a<span class="number">-1</span>;</span><br><span class="line">    a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=a+ne[a]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((i<span class="number">-1</span>)+ne[i-a]&lt;p) ne[i]=ne[i-a];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=<span class="built_in">max</span>(p-i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++;</span><br><span class="line">            ne[i]=j; a=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exkmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getne</span>();</span><br><span class="line">    ll a=<span class="number">0</span>,p;</span><br><span class="line">    p=len;</span><br><span class="line">    extend[<span class="number">0</span>]=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=a+extend[a]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>((i<span class="number">-1</span>)+ne[i-a]&lt;p) extend[i]=ne[i-a];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=<span class="built_in">max</span>(p-i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(j&lt;len&amp;&amp;i+j&lt;len&amp;&amp;s[i+j]==s[j]) j++;</span><br><span class="line">            extend[i]=j; a=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lyndon-分解"><a href="#Lyndon-分解" class="headerlink" title="Lyndon 分解"></a>Lyndon 分解</h3><p>最小表示的初始位置为 $s+s$ 的Lyndon分解中字符串初始位置 $\le |s|$ 且最大的那个。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>); n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k;i&lt;=n;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=i,k=i+<span class="number">1</span>;k&lt;=n&amp;&amp;s[j]&lt;=s[k];j=(s[j]==s[k++])?j+<span class="number">1</span>:i);</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;=j;i+=k-j,ans^=(i<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br></pre></td></tr></table></figure>

<h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> ne[N][Size],fail[N],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,Size) <span class="keyword">if</span>(ne[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ne[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,Size)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v=ne[u][i];</span><br><span class="line">			<span class="keyword">if</span>(!v) ne[u][i]=ne[fail[u]][i];</span><br><span class="line">			<span class="keyword">else</span> fail[v]=ne[fail[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),u=<span class="number">0</span>,c;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!ne[u][c]) ne[u][c]=++cnt;</span><br><span class="line">		u=ne[u][c];</span><br><span class="line">		<span class="comment">//do sth</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=siz;i++) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),fa[i]=len[i]=<span class="number">0</span>;</span><br><span class="line">    las=siz=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cur=++siz;</span><br><span class="line">	len[cur]=len[las]+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> p=las;</span><br><span class="line">	<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">	<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> q=ne[p][c];</span><br><span class="line">		<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> clone=++siz;</span><br><span class="line">			len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">			fa[clone]=fa[q];</span><br><span class="line">			<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">			fa[cur]=fa[q]=clone;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	las=cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> t[x]==t[y]&amp;&amp;t[x+k]==t[y+k];&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuufixArray</span>&#123;</span><br><span class="line">    <span class="type">int</span> height[N],sa[N],rk[N],f[N][K],len; ll sum[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">        len=n; s[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=i,rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">rsort</span>(n,<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">            <span class="built_in">rsort</span>(n,p);</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">            rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">            <span class="keyword">for</span>(j=sa[rk[i]<span class="number">-1</span>],(k?(k--):<span class="number">0</span>);s[i+k]==s[j+k];k++);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i],sum[i]=sum[i<span class="number">-1</span>]+(n-sa[i]+<span class="number">1</span>)-height[i];</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,K<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">return</span> len-x+<span class="number">1</span>;</span><br><span class="line">        x=rk[x]; y=rk[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        x++; <span class="type">int</span> k=l2[y-x+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="manacher"><a href="#manacher" class="headerlink" title="manacher"></a>manacher</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">(<span class="type">char</span> *a,<span class="type">int</span> *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(a); s[<span class="number">0</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) s[(i&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]=a[i],s[(i&lt;&lt;<span class="number">1</span>)+<span class="number">2</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> id=<span class="number">0</span>,mx=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	n=n*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mx&gt;i) f[i]=<span class="built_in">min</span>(f[(id&lt;&lt;<span class="number">1</span>)-i],mx-i); <span class="keyword">else</span> f[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i-f[i]&gt;=<span class="number">0</span> &amp;&amp; i+f[i]&lt;n &amp;&amp; s[i+f[i]] == s[i-f[i]]) f[i]++;</span><br><span class="line">		<span class="keyword">if</span>(i+f[i]&gt;mx) id=i,mx=i+f[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PAM"><a href="#PAM" class="headerlink" title="PAM"></a>PAM</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">	<span class="type">int</span> n,s[N],num[N],p,las,nex[N][S],fail[N],len[N],sz[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) s[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=p;i++) len[i]=fail[i]=sz[i]=<span class="number">0</span>,<span class="built_in">memset</span>(nex[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(nex[i]));</span><br><span class="line">		s[n=<span class="number">0</span>]=len[p=<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">		fail[las=<span class="number">1</span>]=fail[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getfail</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">for</span>(;s[n<span class="number">-1</span>-len[x]]!=s[n];x=fail[x]); <span class="keyword">return</span> x;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[++n]=c;</span><br><span class="line">		<span class="type">int</span> cur=<span class="built_in">getfail</span>(las);</span><br><span class="line">		<span class="keyword">if</span>(!nex[cur][c])</span><br><span class="line">		&#123;</span><br><span class="line">			len[++p]=len[cur]+<span class="number">2</span>;</span><br><span class="line">			fail[p]=nex[<span class="built_in">getfail</span>(fail[cur])][c];</span><br><span class="line">			<span class="keyword">if</span>(!fail[p]) fail[p]=<span class="number">1</span>;</span><br><span class="line">			nex[cur][c]=p;</span><br><span class="line">		&#125;</span><br><span class="line">		las=nex[cur][c];</span><br><span class="line">		sz[las]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="杨氏图表"><a href="#杨氏图表" class="headerlink" title="杨氏图表"></a>杨氏图表</h2><p>插入一个数 $x$：</p>
<ol>
<li>找到当前行中最小的比 $x$ 大的数 $y$：<ul>
<li>若有，$x$ 将 $y$ 替换，往下一行插入 $y$；</li>
<li>否则将 $x$ 放置</li>
</ul>
</li>
</ol>
<h2 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">	<span class="type">int</span> son[N][<span class="number">2</span>],val[N],siz[N],rnd[N],cnt,root;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> u=++cnt;</span><br><span class="line">		val[u]=v; siz[u]=<span class="number">1</span>; rnd[u]=<span class="built_in">rand</span>()+(<span class="built_in">rand</span>()&lt;&lt;<span class="number">15</span>);</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;siz[u]=siz[son[u][<span class="number">0</span>]]+siz[son[u][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;son[x][<span class="number">1</span>]=<span class="built_in">merge</span>(son[x][<span class="number">1</span>],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;son[y][<span class="number">0</span>]=<span class="built_in">merge</span>(x,son[y][<span class="number">0</span>]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_val</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(val[u]&lt;=k) x=u,<span class="built_in">split_val</span>(son[x][<span class="number">1</span>],k,son[x][<span class="number">1</span>],y);</span><br><span class="line">		<span class="keyword">else</span> y=u,<span class="built_in">split_val</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_rank</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=siz[son[u][<span class="number">0</span>]]) y=u,<span class="built_in">split_rank</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">else</span> x=u,<span class="built_in">split_rank</span>(son[x][<span class="number">1</span>],k-siz[son[u][<span class="number">0</span>]]<span class="number">-1</span>,son[x][<span class="number">1</span>],y);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> s=siz[son[u][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s==k) <span class="keyword">return</span> u;</span><br><span class="line">		<span class="keyword">if</span>(s&lt;k) <span class="keyword">return</span> <span class="built_in">kth</span>(son[u][<span class="number">1</span>],k-s);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">kth</span>(son[u][<span class="number">0</span>],k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x,y,z,ans;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(root,v,x,y);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,<span class="built_in">newnode</span>(v)),y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(root,v,x,y);</span><br><span class="line">		<span class="built_in">split_val</span>(x,v<span class="number">-1</span>,x,z);</span><br><span class="line">		root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,z=<span class="built_in">merge</span>(son[z][<span class="number">0</span>],son[z][<span class="number">1</span>])),y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(root,v<span class="number">-1</span>,x,y);</span><br><span class="line">		ans=siz[x]+<span class="number">1</span>;</span><br><span class="line">		root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Kth</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;<span class="keyword">return</span> val[<span class="built_in">kth</span>(root,v)];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(root,v<span class="number">-1</span>,x,y);</span><br><span class="line">		ans=val[<span class="built_in">kth</span>(x,siz[x])];</span><br><span class="line">		root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nex</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(root,v,x,y);</span><br><span class="line">		ans=val[<span class="built_in">kth</span>(y,<span class="number">1</span>)];</span><br><span class="line">		root=<span class="built_in">merge</span>(x,y);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line">	<span class="type">int</span> ch[N][<span class="number">2</span>],fa[N]; <span class="type">bool</span> r[N];</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc ch[u][0]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc ch[u][1]</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> son(x) (ch[fa[x]][1]==x)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> isr(x) (ch[fa[x]][1]!=x&amp;&amp;ch[fa[x]][0]!=x)</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;siz[u]=<span class="number">1</span>+siz[lc]+siz[rc]+si[u];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">torev</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;<span class="built_in">swap</span>(lc,rc); r[u]^=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;<span class="keyword">if</span>(r[u]) <span class="built_in">torev</span>(lc),<span class="built_in">torev</span>(rc),r[u]=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x],z=fa[y],d=<span class="built_in">son</span>(x);</span><br><span class="line">		fa[x]=z; <span class="keyword">if</span>(!<span class="built_in">isr</span>(y)) ch[z][<span class="built_in">son</span>(y)]=x;</span><br><span class="line">		fa[ch[y][d]=ch[x][<span class="number">1</span>-d]]=y;</span><br><span class="line">		fa[ch[x][<span class="number">1</span>-d]=y]=x;</span><br><span class="line">		<span class="built_in">pushup</span>(y); <span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;<span class="keyword">if</span>(!<span class="built_in">isr</span>(u)) <span class="built_in">push</span>(fa[u]); <span class="built_in">pushdown</span>(u);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="built_in">push</span>(x);<span class="keyword">for</span>(<span class="type">int</span> y=fa[x];!<span class="built_in">isr</span>(x);<span class="built_in">rotate</span>(x),y=fa[x]) <span class="keyword">if</span>(!<span class="built_in">isr</span>(y)) <span class="built_in">rotate</span>(<span class="built_in">son</span>(x)==<span class="built_in">son</span>(y)?y:x);<span class="built_in">pushup</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;) <span class="built_in">splay</span>(x),si[x]+=siz[ch[x][<span class="number">1</span>]],ch[x][<span class="number">1</span>]=y,si[x]-=siz[y],<span class="built_in">pushup</span>(x),y=x,x=fa[x];&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">access</span>(x);<span class="built_in">splay</span>(x);<span class="built_in">torev</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="built_in">makeroot</span>(x);<span class="built_in">access</span>(y);<span class="built_in">splay</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="built_in">makeroot</span>(x);<span class="built_in">makeroot</span>(y);fa[x]=y;si[y]+=siz[x];<span class="built_in">pushup</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="built_in">split</span>(x,y);ch[y][<span class="number">0</span>]=fa[x]=<span class="number">0</span>;<span class="built_in">pushup</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">access</span>(x);<span class="built_in">splay</span>(x);<span class="keyword">for</span>(;ch[x][<span class="number">0</span>];x=ch[x][<span class="number">0</span>]); <span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KD-Tree"><a href="#KD-Tree" class="headerlink" title="KD-Tree"></a>KD-Tree</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,o;</span><br><span class="line"><span class="type">int</span> a,b,c,d;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> v[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">point</span> ()&#123;&#125;</span><br><span class="line">	<span class="built_in">point</span> (<span class="type">int</span> x,<span class="type">int</span> y) &#123;v[<span class="number">0</span>]=x; v[<span class="number">1</span>]=y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> == (point a,point b) &#123;<span class="keyword">return</span> a.v[<span class="number">0</span>]==b.v[<span class="number">0</span>]&amp;&amp;a.v[<span class="number">1</span>]==b.v[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;= (point a,point b) &#123;<span class="keyword">return</span> a.v[<span class="number">0</span>]&lt;=b.v[<span class="number">0</span>]&amp;&amp;a.v[<span class="number">1</span>]&lt;=b.v[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (point a,point b) &#123;<span class="keyword">return</span> a.v[<span class="number">0</span>]&lt;b.v[<span class="number">0</span>]||a.v[<span class="number">1</span>]&lt;b.v[<span class="number">1</span>]; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a,point b,<span class="type">int</span> c)</span> </span>&#123;<span class="keyword">return</span> a.v[c]&lt;b.v[c]; &#125;</span><br><span class="line"><span class="function">point <span class="title">min</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">point</span>(<span class="built_in">min</span>(a.v[<span class="number">0</span>],b.v[<span class="number">0</span>]),<span class="built_in">min</span>(a.v[<span class="number">1</span>],b.v[<span class="number">1</span>])); &#125;</span><br><span class="line"><span class="function">point <span class="title">max</span><span class="params">(point a,point b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">point</span>(<span class="built_in">max</span>(a.v[<span class="number">0</span>],b.v[<span class="number">0</span>]),<span class="built_in">max</span>(a.v[<span class="number">1</span>],b.v[<span class="number">1</span>])); &#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	point l,r,v;</span><br><span class="line">	<span class="type">int</span> lc,rc;</span><br><span class="line">	<span class="type">int</span> q,s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> rt,la,nt,cnt;</span><br><span class="line">node t[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[u].s=t[u].q;t[u].l=t[u].v;t[u].r=t[u].v;</span><br><span class="line">	<span class="keyword">if</span> (t[u].lc)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].s+=t[t[u].lc].s;</span><br><span class="line">		t[u].l=<span class="built_in">min</span>(t[u].l,t[t[u].lc].l);</span><br><span class="line">		t[u].r=<span class="built_in">max</span>(t[u].r,t[t[u].lc].r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t[u].rc)</span><br><span class="line">	&#123;</span><br><span class="line">		t[u].s+=t[t[u].rc].s;</span><br><span class="line">		t[u].l=<span class="built_in">min</span>(t[u].l,t[t[u].rc].l);</span><br><span class="line">		t[u].r=<span class="built_in">max</span>(t[u].r,t[t[u].rc].r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> d,point s,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!u) &#123;u=++nt; t[u].l=s; t[u].r=s; t[u].v=s;&#125;</span><br><span class="line">	<span class="keyword">if</span> (s==t[u].v) &#123;t[u].s+=c; t[u].q+=c; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cmp</span>(s,t[u].v,d)) <span class="built_in">ins</span>(t[u].lc,d^<span class="number">1</span>,s,c);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">ins</span>(t[u].rc,d^<span class="number">1</span>,s,c);</span><br><span class="line">	<span class="built_in">update</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d,point l,point r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=t[u].l&amp;&amp;t[u].r&lt;=r) <span class="keyword">return</span> t[u].s;</span><br><span class="line">	<span class="keyword">if</span> (r&lt;t[u].l||t[u].r&lt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l&lt;=t[u].v&amp;&amp;t[u].v&lt;=r) ret+=t[u].q;</span><br><span class="line">	ret+=<span class="built_in">qry</span>(t[u].lc,d^<span class="number">1</span>,l,r)+<span class="built_in">qry</span>(t[u].rc,d^<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	a=l; b=r;</span><br><span class="line">	point x=t[(l+r)&gt;&gt;<span class="number">1</span>].v;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">cmp</span>(t[a].v,x,d)) a++;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">cmp</span>(x,t[b].v,d)) b--;</span><br><span class="line">		<span class="keyword">if</span> (a&lt;=b) <span class="built_in">swap</span>(t[a],t[b]),a++,b--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (a&lt;=b);</span><br><span class="line">	<span class="keyword">if</span> (k&gt;=a&amp;&amp;a&lt;r) <span class="built_in">kth</span>(a,r,k,d);</span><br><span class="line">	<span class="keyword">if</span> (k&lt;=b&amp;&amp;l&lt;b) <span class="built_in">kth</span>(l,b,k,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mid</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> d,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (l==r)&#123;u=l;<span class="built_in">update</span>(u);<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">kth</span>(l,r,(l+r)&gt;&gt;<span class="number">1</span>,d);</span><br><span class="line">	u=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">mid</span>(t[u].lc,d^<span class="number">1</span>,l,u<span class="number">-1</span>); <span class="built_in">mid</span>(t[u].rc,d^<span class="number">1</span>,u+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">update</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nt;i++) t[i].lc=t[i].rc=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">mid</span>(rt,<span class="number">0</span>,<span class="number">1</span>,nt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;o);</span><br><span class="line">		<span class="keyword">if</span> (o==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">			a^=la;b^=la;c^=la;</span><br><span class="line">			<span class="built_in">ins</span>(rt,<span class="number">0</span>,<span class="built_in">point</span>(a,b),c);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt%<span class="number">5000</span>==<span class="number">0</span>) <span class="built_in">rebuild</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">			a^=la;b^=la;c^=la;d^=la;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,la=<span class="built_in">qry</span>(rt,<span class="number">0</span>,<span class="built_in">point</span>(a,b),<span class="built_in">point</span>(c,d)););</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (o==<span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左偏树"><a href="#左偏树" class="headerlink" title="左偏树"></a>左偏树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br><span class="line"><span class="type">int</span> fa[N],val[N],dis[N],ls[N],rs[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">	<span class="keyword">if</span>(val[x]&gt;val[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	rs[x]=<span class="built_in">merge</span>(rs[x],y);</span><br><span class="line">	<span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">	dis[x]=dis[rs[x]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fa[x]=<span class="built_in">merge</span>(ls[x],rs[x]);</span><br><span class="line">	fa[fa[x]]=fa[x]; ls[x]=rs[x]=val[x]=dis[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) val[i]=<span class="built_in">read</span>(),fa[i]=i;</span><br><span class="line">	<span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> T=<span class="built_in">read</span>(),x,y,fx,fy;T--;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(flag[x]||flag[y]) <span class="keyword">continue</span>;</span><br><span class="line">			fx=<span class="built_in">find</span>(x); fy=<span class="built_in">find</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(fx==fy) <span class="keyword">continue</span>;</span><br><span class="line">			fa[fx]=fa[fy]=<span class="built_in">merge</span>(fx,fy);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(flag[x=<span class="built_in">read</span>()]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">			flag[x=<span class="built_in">find</span>(x)]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[x]);</span><br><span class="line">			<span class="built_in">pop</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><h3 id="斯特林数"><a href="#斯特林数" class="headerlink" title="斯特林数"></a>斯特林数</h3><p>$ S_2(n,k) = S_2(n-1,k-1) + k S_2(n-1,k)$</p>
<p>$ S_2(n,m)=\frac{1}{m!}\sum_{i=0}^m(-1)^{m-i}\binom{m}{i}i^n$</p>
<p>$ S_1(n,k) = S_1(n-1,k-1) + (n-1) S_1(n-1,k) $</p>
<p>$ F_n(x) = \sum_{i=0}^n S_1(n,i) x^i = \prod_{i=0}^{n-1}  (x+i) $</p>
<p>$ x^{\overline{n}}=\sum_{k} S_1(n,k)x^k $</p>
<p>$ x^n=\sum_{k} S_2(n,k)  (-1)^{n-k}  x^{\overline{  k }  } $</p>
<p>$ x^{\underline{n}}=\sum_{k} S_1(n,k) (-1) ^ { n- k } x^k $</p>
<p>$ x^n=\sum_{k} S_2(n,k) x^{\underline{  k }  } $</p>
<h3 id="贝尔数"><a href="#贝尔数" class="headerlink" title="贝尔数"></a>贝尔数</h3><p>$B_{n+1} = \sum_{k=0}^n\binom{n}{k} B_k$</p>
<p>$B_n = \sum_{k=0}^n S_2(n,k)$</p>
<h3 id="伯努利数"><a href="#伯努利数" class="headerlink" title="伯努利数"></a>伯努利数</h3><p>$S_m(n) = \sum_{k=0}^{n-1} k^m = \frac{1}{m+1} \sum_{k=0}^m \binom{m+1}{k}B_kn^{m+1-k}$</p>
<p>$B(x) = \sum_{i} \frac{B_i}{i!}x^i = \frac{x}{e^x-1}$.</p>
<h2 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(<span class="type">const</span> ll &amp;a,<span class="type">const</span> ll &amp;b,<span class="type">const</span> ll &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll d=((<span class="type">long</span> <span class="type">double</span>)a/p*b+<span class="number">1e-9</span>),res=a*b-d*p;</span><br><span class="line">	<span class="keyword">return</span> res&lt;<span class="number">0</span>?res+p:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ex-CRT-and-Pollard-rho"><a href="#ex-CRT-and-Pollard-rho" class="headerlink" title="ex_CRT and Pollard rho"></a>ex_CRT and Pollard rho</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b,<span class="type">const</span> ll &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(a%=p,b%=p;b;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) &#123;ans+=a; <span class="keyword">if</span>(ans&gt;=p) ans-=p;&#125;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>; a+=a; <span class="keyword">if</span>(a&gt;=p) a-=p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll a,ll b,<span class="type">const</span> ll &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="built_in">mul</span>(a,a,p)) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=<span class="built_in">mul</span>(ans,a,p);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> !y?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x=<span class="number">1</span>; y=<span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll d=<span class="built_in">ex_gcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x; <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,d;</span><br><span class="line">    d=<span class="built_in">ex_gcd</span>(a,m,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+m)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> QuadraticResidue&#123;</span><br><span class="line">	ll mod,n,w;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">num</span>&#123;</span><br><span class="line">		ll a,b;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> num <span class="keyword">operator</span> *(<span class="type">const</span> num &amp;A,<span class="type">const</span> num &amp;B)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> (num)&#123;(A.a*B.a+A.b*B.b%mod*w)%mod,(A.b*B.a+A.a*B.b)%mod&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(num x,ll y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		num ans=(num)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x;</span><br><span class="line">		<span class="keyword">return</span> ans.a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">L</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ll ans=<span class="built_in">Pow</span>(x,(mod<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> (ans==mod<span class="number">-1</span>)?<span class="number">-1</span>:ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x%=mod; <span class="type">int</span> l=<span class="built_in">L</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(l!=<span class="number">1</span>) <span class="keyword">return</span> l;</span><br><span class="line">		ll a=<span class="built_in">rand</span>()%mod;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">L</span>(w=(a*a%mod-x+mod)%mod)!=<span class="number">-1</span>;a=<span class="built_in">rand</span>()%mod);</span><br><span class="line">		num y=(num)&#123;a,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Pow</span>(y,(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> CRT&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exCRT</span><span class="params">(<span class="type">int</span> n,ll *a,ll *m,ll &amp;A)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll M;<span class="comment">//lcm</span></span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=(a[i]%m[i]+m[i])%m[i];</span><br><span class="line">        A=a[<span class="number">1</span>],M=m[<span class="number">1</span>];</span><br><span class="line">        ll c,d,x,y,t;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            c=a[i]-A;</span><br><span class="line">            d=<span class="built_in">exgcd</span>(M,m[i],x,y);</span><br><span class="line">            <span class="keyword">if</span>(c%d!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            t=m[i]/d; x=<span class="built_in">mul</span>(x,c/d,t); x=(x%t+t)%t;</span><br><span class="line">            A=A+M*x; M=M/d*m[i]; A=(A+M)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        A=(A+M<span class="number">-1</span>)%M+<span class="number">1</span>; <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Pollard_Rho&#123;</span><br><span class="line">	<span class="type">const</span> __int128 ONE=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">RandInt</span><span class="params">(ll l,ll r)</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="type">static</span> mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line">		<span class="function">uniform_int_distribution&lt;ll&gt; <span class="title">dis</span><span class="params">(l,r)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">dis</span>(rnd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y,ll mod)</span> </span>&#123;</span><br><span class="line">		ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=ONE*x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ONE*ans*x%mod;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">		<span class="type">static</span> vector&lt;ll&gt; p = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">3</span>||(!(n&amp;<span class="number">1ll</span>))) <span class="keyword">return</span> n==<span class="number">2ll</span>;</span><br><span class="line">		ll a=n<span class="number">-1</span>,b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;!(a&amp;<span class="number">1</span>);a&gt;&gt;=<span class="number">1</span>) b++;</span><br><span class="line">		<span class="keyword">auto</span> chk = [&amp;](<span class="type">const</span> ll &amp;x) &#123;</span><br><span class="line">			ll v = <span class="built_in">Pow</span>(x,a,n);</span><br><span class="line">			<span class="keyword">if</span>(v==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(;j&lt;=b;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(v==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">				v=ONE*v*v%n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(n&gt;<span class="number">37</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:p) <span class="keyword">if</span>(!<span class="built_in">chk</span>(x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:p) <span class="keyword">if</span>(n==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">Pollard_Rho</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">		ll s=<span class="number">0</span>,t=<span class="number">0</span>,c=<span class="built_in">RandInt</span>(<span class="number">1</span>,n<span class="number">-1</span>),val=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">auto</span> f = [&amp;](<span class="type">const</span> ll &amp;x) &#123;<span class="built_in">return</span> (ONE*x*x+c)%n;&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> g=<span class="number">1</span>;;g&lt;&lt;=<span class="number">1</span>,s=t,val=<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> st=<span class="number">1</span>;st&lt;=g;st++) &#123;</span><br><span class="line">				t=<span class="built_in">f</span>(t);</span><br><span class="line">				val = (ONE*val*<span class="built_in">abs</span>(t-s))%n;</span><br><span class="line">				<span class="keyword">if</span>(st%<span class="number">127</span>==<span class="number">0</span>) &#123;</span><br><span class="line">					ll d = __gcd(val,n);</span><br><span class="line">					<span class="keyword">if</span>(d&gt;<span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ll d = __gcd(val,n);</span><br><span class="line">			<span class="keyword">if</span>(d&gt;<span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll Ans;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Miller_Rabin</span>(n)) &#123;</span><br><span class="line">			Ans=<span class="built_in">max</span>(Ans,n);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll p = n;</span><br><span class="line">		<span class="keyword">for</span>(;p==n;) p = <span class="built_in">Pollard_Rho</span>(n);</span><br><span class="line">		<span class="built_in">Divide</span>(n/p); <span class="built_in">Divide</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Powerful-Number"><a href="#Powerful-Number" class="headerlink" title="Powerful Number"></a>Powerful Number</h2><p>一个数 $n$ 满足 $\forall p((p\in \mathbb{P} \and p|n )\rightarrow p^2|n )$，则称 $n$ 为Powerful Number（简称PN）。</p>
<p>求出 $n$ 以内的PN数可以暴力搜索质因数。</p>
<p>假设我们要求 $\sum_{i=1}^nf(i)$，构造两个函数 $g,h$ 使得：</p>
<ul>
<li>$g$ 是积性函数。且 $g$ 的前缀和 $S_g(n)$ 容易求出。</li>
<li>$\forall p\in \mathbb{P},g(p)=f(p)$。</li>
<li>$f=g * h$。</li>
</ul>
<p>那么，将原式变一变：</p>
<p>$$\sum_{i=1}^n f(i)\=\sum <em>{i=1}^n\sum</em>{d|i}h(d)g(i/d)\=\sum_{i=1}^nh(i)\sum_{j=1}^{n/i}g(j)\=\sum_{i=1}^n h(i)S_g(\left \lfloor \frac{n}{i} \right \rfloor)$$</p>
<p>可以发现 $f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)$，又因为有 $g(p)=f(p)$，因此 $h(p)=0$。</p>
<p>显然 $h$ 是个积性函数，那么由积性函数的定义，对于 $h$ 的所有非 PN 数下标的取值均为 $0$。</p>
<p>我们只需快速求出所有 PN 数下标的 $h$ ，就可以了。</p>
<p>只需要求出 $h(p^k)$ 就可以了。这个可以通过推式子或者递推等解决。</p>
<h2 id="类欧几里得"><a href="#类欧几里得" class="headerlink" title="类欧几里得"></a>类欧几里得</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Ans</span>&#123;</span><br><span class="line">	ll f,g,h;</span><br><span class="line">	<span class="comment">// f = \sum_&#123;i=0&#125;^n (ai+b)/c</span></span><br><span class="line">	<span class="comment">// g = \sum_&#123;i=0&#125;^n [(ai+b)/c]^2</span></span><br><span class="line">	<span class="comment">// h = \sum_&#123;i=0&#125;^n i[(ai+b)/c]</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Ans <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!a) <span class="keyword">return</span> &#123;</span><br><span class="line">		(ll)b/c*(n+<span class="number">1</span>)%mod,</span><br><span class="line">		(ll)<span class="built_in">Sqr</span>(b/c)*(n+<span class="number">1</span>)%mod,</span><br><span class="line">		(ll)b/c*n%mod*(n+<span class="number">1</span>)%mod*inv2%mod</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(a&gt;=c||b&gt;=c) &#123;</span><br><span class="line">		Ans d=<span class="built_in">solve</span>(a%c,b%c,c,n);</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			((ll)a/c*n%mod*(n+<span class="number">1</span>)%mod*inv2+(ll)b/c*(n+<span class="number">1</span>)+d.f)%mod,</span><br><span class="line">			((ll)n*(n+<span class="number">1</span>)%mod*(n*<span class="number">2ll</span>+<span class="number">1</span>)%mod*inv6%mod*<span class="built_in">Sqr</span>(a/c)+</span><br><span class="line">				(ll)(n+<span class="number">1</span>)*<span class="built_in">Sqr</span>(b/c)+(ll)n*(n+<span class="number">1</span>)%mod*(a/c)%mod*(b/c)+</span><br><span class="line">				b/c*<span class="number">2ll</span>*d.f+a/c*<span class="number">2ll</span>%mod*d.h+d.g)%mod,</span><br><span class="line">			((ll)n*(n+<span class="number">1</span>)%mod*(n*<span class="number">2ll</span>+<span class="number">1</span>)%mod*inv6%mod*(a/c)+</span><br><span class="line">				(ll)n*(n+<span class="number">1</span>)%mod*inv2%mod*(b/c)+d.h)%mod</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> m=((ll)a*n+b)/c;</span><br><span class="line">		Ans d=<span class="built_in">solve</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			((ll)n*m-d.f+mod)%mod,</span><br><span class="line">			((ll)n*m%mod*m%mod-d.f-d.h*<span class="number">2</span>+mod*<span class="number">3</span>)%mod,</span><br><span class="line">			((ll)n*m%mod*(n+<span class="number">1</span>)-d.g-d.f+mod+mod)%mod*inv2%mod</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//y^x==z (mod p) −&gt;x=?</span></span><br><span class="line"><span class="built_in">scanf</span>(”%d%d%d”,&amp;y,&amp;z,&amp;p),y%=p,z%=p;j=z;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>)&#123;<span class="built_in">puts</span>(”Cannot␣find␣x”);<span class="keyword">continue</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(k=s=<span class="number">1</span>;k*k&lt;=p;k++);</span><br><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++,s=<span class="number">1LL</span>*s*y%p,j=<span class="number">1LL</span>*j*y%p)hash[j]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=s;i&lt;=k&amp;&amp;!flag;i++,j=<span class="number">1LL</span>*j*s%p)</span><br><span class="line"><span class="keyword">if</span>(hash.<span class="built_in">count</span>(j))ans=i*k−hash[j],flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">0</span>)<span class="built_in">puts</span>(”Cannot find x”);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(”%d\n”,ans);</span><br><span class="line"><span class="comment">//exBSGS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsgs</span><span class="params">(<span class="type">int</span> a,ll b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a%=p,b%=p,b==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll t=<span class="number">1</span>;<span class="type">int</span> f,g,delta=<span class="number">0</span>,m=<span class="built_in">sqrt</span>(p)+<span class="number">1</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(g=<span class="built_in">gcd</span>(a,p);g!=<span class="number">1</span>;g=<span class="built_in">gcd</span>(a,p))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b%g)<span class="keyword">return</span> −<span class="number">1</span>;</span><br><span class="line">		b/=g,p/=g,t=t*(a/g)%p,delta++;</span><br><span class="line">		<span class="keyword">if</span>(b==t)<span class="keyword">return</span> delta;</span><br><span class="line">	&#125;</span><br><span class="line">	std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;hash;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++,b=b*a%p)hash[b]=i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>,f=<span class="built_in">power</span>(a,m);i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">	<span class="keyword">if</span>(t=t*f%p,hash.<span class="built_in">count</span>(t))<span class="keyword">return</span> i*m−hash[t]+delta;</span><br><span class="line">	<span class="keyword">return</span> −<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展Lucas"><a href="#扩展Lucas" class="headerlink" title="扩展Lucas"></a>扩展Lucas</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="number">1</span>; y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x,y,d;</span><br><span class="line">	d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">	<span class="keyword">if</span>(d!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> (x%b+b)%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ll,ll&gt; <span class="title">excrt</span><span class="params">(<span class="type">int</span> n,ll *c,ll *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll nc=c[<span class="number">1</span>],nm=m[<span class="number">1</span>],d;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		d=<span class="built_in">gcd</span>(m[i],nm);</span><br><span class="line">		<span class="keyword">if</span>((c[i]-nc)%d!=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">		nc=<span class="built_in">inv</span>(nm/d,m[i]/d)*((c[i]-nc)/d)*nm+nc;</span><br><span class="line">		nm=nm/d*m[i];</span><br><span class="line">		nc=(nc%nm+nm)%nm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(nc,nm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">namespace</span> ExLucas&#123;</span><br><span class="line">	ll sum[M];</span><br><span class="line">	<span class="type">int</span> t,p;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _p,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p=_p; t=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) t=t*p;</span><br><span class="line">		sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,t) sum[i]=(sum[i<span class="number">-1</span>]*((i%p==<span class="number">0</span>)?<span class="number">1</span>:i))%t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> nq,sq;</span><br><span class="line">	<span class="function">ll <span class="title">fac</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		nq+=n/p;</span><br><span class="line">		<span class="keyword">if</span>(sum[t]==<span class="number">1</span>||(n/t)%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> sum[n%t]*<span class="built_in">fac</span>(n/p)%t;</span><br><span class="line">		<span class="keyword">return</span> (t-sum[n%t]%t*<span class="built_in">fac</span>(n/p)%t)%t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m,<span class="type">int</span> p,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">init</span>(p,k); sq=<span class="number">0</span>;</span><br><span class="line">		ll ans,sum;</span><br><span class="line">		nq=<span class="number">0</span>; ans=<span class="built_in">fac</span>(n); sq+=nq;</span><br><span class="line">		nq=<span class="number">0</span>; sum=<span class="built_in">fac</span>(m); sq-=nq;</span><br><span class="line">		nq=<span class="number">0</span>; sum=sum*<span class="built_in">fac</span>(n-m)%t; sq-=nq;</span><br><span class="line">		<span class="keyword">return</span> ans*<span class="built_in">inv</span>(sum,t)%t*<span class="built_in">Pow</span>(p,sq,t)%t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,mod,q,c[<span class="number">100</span>],mo[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod; q=mod;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">if</span>(q%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;q%i==<span class="number">0</span>;q/=i) t++;</span><br><span class="line">			++top;</span><br><span class="line">			c[top]=ExLucas::<span class="built_in">C</span>(n,m,i,t);</span><br><span class="line">			mo[top]=ExLucas::t;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(q!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c[++top]=ExLucas::<span class="built_in">C</span>(n,m,q,<span class="number">1</span>);</span><br><span class="line">		mo[top]=ExLucas::t;</span><br><span class="line">	&#125;</span><br><span class="line">	pair&lt;ll,ll&gt; ans=<span class="built_in">excrt</span>(top,c,mo);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans.fi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Min25筛"><a href="#Min25筛" class="headerlink" title="Min25筛"></a>Min25筛</h2><p>前提：积性函数；表示为 $\sum_{i\in \mathbb{P}}i^k$ 或 直接算；$f(p^k)$ 快速算。</p>
<p>$g(n,j)=\sum_{i=1}^{n}[i\in \mathbb{P} \text{ or }\min_i(p)&gt; P_j]$</p>
<p>$$<br>g(n,j)=\begin{cases}<br>    g(n,j-1) &amp; \text{ if } P_j^2&gt;n \newline<br>    g(n,j-1)-P_j^k\left ( g(\left \lfloor \frac{n}{P_j} \right \rfloor,j-1)-g(P_{j-1},j-1) \right ) &amp; \text{ otherwise }<br>\end{cases}<br>$$</p>
<p>$\sum_{i=1}^n[i\in \mathbb{P}]i^k=g(n,\pi( \left \lfloor  \sqrt n\right \rfloor))$。</p>
<p>$$S(n,j)=\left ( g(n,\pi( \left \lfloor  \sqrt n\right \rfloor)) \right )-g(P_{j-1},j-1))+ \sum_{k=j}^{\sqrt n}\sum_{P_k^{q+1}\leq n}(f(P_k^q)S(\left \lfloor \frac{n}{P_k^q} \right \rfloor,k+1)+f(P_{k}^{q+1}))$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000000</span>;</span><br><span class="line">ll n,m,Sqr,pri[N],sp[N],id1[N],id2[N],w[N];</span><br><span class="line">ll h[N],g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];<span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) &#123;pri[++tot]=i; sp[tot]=(sp[tot<span class="number">-1</span>]+i)%mod;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;<span class="number">1ll</span>*i*pri[j]&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>||pri[j]&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll t=(n&lt;=Sqr)?id1[n]:id2[::n/n];</span><br><span class="line">    ll ans=(mod+(g[t]-sp[j<span class="number">-1</span>])-(h[t]-(j<span class="number">-1</span>))%mod)%mod;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">1</span>) ans+=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=tot&amp;&amp;pri[k]*pri[k]&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll tmp=pri[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">1</span>;tmp*pri[k]&lt;=n;q++,tmp*=pri[k])</span><br><span class="line">            ans=<span class="built_in">Add</span>(ans,<span class="built_in">Add</span>(pri[k]^(q+<span class="number">1</span>),<span class="built_in">Mul</span>(pri[k]^q,<span class="built_in">S</span>(n/tmp,k+<span class="number">1</span>))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n); Sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">init_prime</span>(Sqr);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j=n/(n/i); w[++m]=n/i;</span><br><span class="line">        h[m]=(w[m]<span class="number">-1</span>)%mod;</span><br><span class="line">        g[m]=(w[m]%mod)*((w[m]+<span class="number">1</span>)%mod)%mod*inv2%mod<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w[m]&lt;=Sqr) id1[w[m]]=m;</span><br><span class="line">        <span class="keyword">else</span> id2[j]=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll k=pri[i]*pri[i];<span class="comment">//可用long double 优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;k&lt;=w[j];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=(w[j]/pri[i]&lt;=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];</span><br><span class="line">            h[j]=<span class="built_in">Add</span>(h[j],(mod-(h[t]-(i<span class="number">-1</span>)%mod))%mod);</span><br><span class="line">            g[j]=<span class="built_in">Add</span>(g[j],mod<span class="number">-1ll</span>*pri[i]*(g[t]-sp[i<span class="number">-1</span>]+mod)%mod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="built_in">S</span>(n,<span class="number">1</span>)+<span class="number">1</span>)%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_or</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;N;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">                <span class="keyword">if</span>(opt==<span class="number">1</span>)a[i+j+k]=(a[j+k]+a[i+j+k])%MOD;</span><br><span class="line">                <span class="keyword">else</span> a[i+j+k]=(a[i+j+k]+MOD-a[j+k])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_and</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;N;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">                <span class="keyword">if</span>(opt==<span class="number">1</span>)a[j+k]=(a[j+k]+a[i+j+k])%MOD;</span><br><span class="line">                <span class="keyword">else</span> a[j+k]=(a[j+k]+MOD-a[i+j+k])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;N;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> X=a[j+k],Y=a[i+j+k];</span><br><span class="line">                a[j+k]=(X+Y)%MOD;a[i+j+k]=(X+MOD-Y)%MOD;</span><br><span class="line">                <span class="keyword">if</span>(opt==<span class="number">-1</span>)a[j+k]=<span class="number">1ll</span>*a[j+k]*inv2%MOD,a[i+j+k]=<span class="number">1ll</span>*a[i+j+k]*inv2%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">Com</span>(db _x=<span class="number">0</span>,db _y=<span class="number">0</span>) &#123;x=_x,y=_y;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Com <span class="keyword">operator</span> + (<span class="type">const</span> Com &amp;A,<span class="type">const</span> Com &amp;B)</span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="built_in">Com</span>(A.x+B.x,A.y+B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Com <span class="keyword">operator</span> - (<span class="type">const</span> Com &amp;A,<span class="type">const</span> Com &amp;B)</span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="built_in">Com</span>(A.x-B.x,A.y-B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Com <span class="keyword">operator</span> * (<span class="type">const</span> Com &amp;A,<span class="type">const</span> Com &amp;B)</span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="built_in">Com</span>(A.x*B.x-A.y*B.y,A.x*B.y+B.x*A.y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">21</span>;</span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">	<span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> R[M]; Com W[M];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fft</span><span class="params">(Com *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		Com w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">					w=W[i+k]*a[i+j+k],</span><br><span class="line">					a[i+j+k]=a[j+k]-w,</span><br><span class="line">					a[j+k]=a[j+k]+w;</span><br><span class="line">		<span class="keyword">if</span>(opt!=<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">			<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].x/=n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">				W[i+j]=<span class="built_in">Com</span>(<span class="built_in">cos</span>(pi*j/i),<span class="built_in">sin</span>(pi*j/i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="拆系数FFT"><a href="#拆系数FFT" class="headerlink" title="拆系数FFT"></a>拆系数FFT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">db pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">    db x,y;</span><br><span class="line">    <span class="built_in">P</span>(db _x=<span class="number">0</span>,db _y=<span class="number">0</span>) &#123;x=_x,y=_y;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> +(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)&#123;<span class="keyword">return</span> (P)&#123;A.x+B.x,A.y+B.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> -(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)&#123;<span class="keyword">return</span> (P)&#123;A.x-B.x,A.y-B.y&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> *(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)&#123;<span class="keyword">return</span> (P)&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> /(<span class="type">const</span> P&amp;A,<span class="type">const</span> db &amp;x)&#123;<span class="keyword">return</span> (P)&#123;A.x/x,A.y/x&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">P <span class="title">conj</span><span class="params">(P A)</span> </span>&#123;<span class="keyword">return</span> (P)&#123;A.x,-A.y&#125;;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">P W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">            W[i+j]=(P)&#123;<span class="built_in">cos</span>(pi*j/i),<span class="built_in">sin</span>(pi*j/i)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;P&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(P *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    P w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k],</span><br><span class="line">                a[i+j+k]=a[j+k]-w,</span><br><span class="line">                a[j+k]=a[j+k]+w;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]+B[i];</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Real(A) ((ll)floor(A.x+0.5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Imag(A) ((ll)floor(A.y+0.5))</span></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Poly C,D;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    C.<span class="built_in">resize</span>(len); D.<span class="built_in">resize</span>(len); A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(P)&#123;<span class="built_in">Real</span>(A[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(A[i])&gt;&gt;<span class="number">15</span>&#125;,D[i]=(P)&#123;<span class="built_in">Real</span>(B[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(B[i])&gt;&gt;<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="built_in">ntt</span>(C,len,<span class="number">1</span>); <span class="built_in">ntt</span>(D,len,<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,len)</span><br><span class="line">    &#123;</span><br><span class="line">        P d4,d0,d1,d2,d3;</span><br><span class="line">        j=(len-i)&amp;(len<span class="number">-1</span>);</span><br><span class="line">        d4=<span class="built_in">conj</span>(C[j]); d0=(d4+C[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>); d1=(d4-C[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">        d4=<span class="built_in">conj</span>(D[j]);  d2=(d4+D[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>); d3=(d4-D[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">        A[i]=d0*d2+d1*d3*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        B[i]=d0*d3+d1*d2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(<span class="built_in">Real</span>(A[i]) + (<span class="built_in">Imag</span>(A[i]) % mo &lt;&lt; <span class="number">30</span>) + (<span class="built_in">Real</span>(B[i]) % mo &lt;&lt; <span class="number">15</span>))%mo;</span><br><span class="line">    C.<span class="built_in">resize</span>(k); <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">ll W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">    A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Mul</span>(A[i],k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">    B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">    Poly g,h;</span><br><span class="line">    g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">    <span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">        <span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">        <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">    <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Ln</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	A=<span class="built_in">jf</span>((~A)*<span class="built_in">df</span>(A));</span><br><span class="line">	A.<span class="built_in">resize</span>(n); <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Exp</span><span class="params">(<span class="type">const</span> Poly &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1</span>; <span class="keyword">for</span>(;n&lt;A.<span class="built_in">size</span>();n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	Poly B,C,D; B.<span class="built_in">clear</span>(); B.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=B; C.<span class="built_in">resize</span>(m); D=A; D.<span class="built_in">resize</span>(m);</span><br><span class="line">		C=D-<span class="built_in">Ln</span>(C); C[<span class="number">0</span>]=<span class="built_in">Add</span>(C[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">		B=B*C; B.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()); <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ^(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!A.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	ll tmp=A[<span class="number">0</span>],w=<span class="built_in">Pow</span>(tmp,k);</span><br><span class="line">	tmp=<span class="built_in">Pow</span>(tmp,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*tmp%mod;</span><br><span class="line">	A=<span class="built_in">Exp</span>(<span class="built_in">Ln</span>(A)*k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*w%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Cos</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)+<span class="built_in">Exp</span>(A*(mod-w4)))*((mod+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sin</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)-<span class="built_in">Exp</span>(A*(mod-w4)))*(<span class="built_in">Pow</span>(w4,mod<span class="number">-2</span>)*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sqrt</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly C,D,<span class="built_in">B</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	C.<span class="built_in">clear</span>(); D.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">4</span>;(l&gt;&gt;<span class="number">2</span>)&lt;n;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=A; C.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		D=B; D.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>); D=(~D);</span><br><span class="line">		C.<span class="built_in">resize</span>(l); D.<span class="built_in">resize</span>(l);</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">1</span>); <span class="built_in">ntt</span>(D,l,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,l) C[i]=C[i]*D[i]%mod;</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">-1</span>);</span><br><span class="line">		B.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,(l&gt;&gt;<span class="number">1</span>)) B[i]=<span class="built_in">Add</span>(C[i],B[i])*((mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>/(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>,deg=A.<span class="built_in">size</span>()-B.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A)); <span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;=deg;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); B=~B; B.<span class="built_in">resize</span>(deg);</span><br><span class="line">	A=A*B; A.<span class="built_in">resize</span>(deg);</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>%(<span class="type">const</span> Poly &amp;A,<span class="type">const</span> Poly &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;B.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	Poly C=A-(A/B)*B;</span><br><span class="line">	C.<span class="built_in">resize</span>(B.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Pow</span><span class="params">(Poly A,ll n,Poly M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly B=A; n--;</span><br><span class="line">	<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,A=(A*A)%M) <span class="keyword">if</span>(n&amp;<span class="number">1ll</span>) B=(B*A)%M;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">64005</span>*<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc ((u&lt;&lt;1)|1)</span></span><br><span class="line">Poly P[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll ans[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">MulT</span><span class="params">(Poly A,Poly B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	B.<span class="built_in">clear</span>();</span><br><span class="line">	len--;</span><br><span class="line">	<span class="built_in">fo</span>(i,m<span class="number">-1</span>,n+m<span class="number">-2</span>) B.<span class="built_in">pb</span>(A[i&amp;len]);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		P[u].<span class="built_in">pb</span>(<span class="number">1</span>); P[u].<span class="built_in">pb</span>(<span class="built_in">Dec</span>(<span class="number">0</span>,a[l]));<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">	P[u]=P[lc]*P[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(ans[l]=A[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid,<span class="built_in">MulT</span>(A,P[rc])); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r,<span class="built_in">MulT</span>(A,P[lc]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">Poly F,G;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">max</span>(n,m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) F.<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">	F.<span class="built_in">resize</span>(n+k+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">	F=<span class="built_in">MulT</span>(F,(~P[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k,F);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll fc[N],fv[N],iv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PolyInit</span>();</span><br><span class="line">    fc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    fv[n]=<span class="built_in">Pow</span>(fc[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) fv[i<span class="number">-1</span>]=fv[i]*i%mod;</span><br><span class="line">    iv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) iv[i]=(mod-mod/i)*iv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcS</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//第一类斯特林数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) &#123;s[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;s[<span class="number">1</span>]=<span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calcS</span>(n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fd</span>(i,n,<span class="number">1</span>) s[i]=<span class="built_in">Add</span>(s[i<span class="number">-1</span>],<span class="built_in">Mul</span>(s[i],n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calcS</span>(n&gt;&gt;<span class="number">1</span>); <span class="type">int</span> l=n&gt;&gt;<span class="number">1</span>,len;</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        d[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,l) d[i]=d[i<span class="number">-1</span>]*l%mod;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) d[i]=d[i]*fv[i]%mod,c[i]=s[i]*fc[i]%mod;</span><br><span class="line">        <span class="built_in">reverse</span>(&amp;d[<span class="number">0</span>],&amp;d[l+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">1</span>); <span class="built_in">ntt</span>(c,len,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=d[i]*c[i]%mod;</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) d[i]=d[i+l]*fv[i]%mod;</span><br><span class="line">        <span class="built_in">fo</span>(i,l+<span class="number">1</span>,len<span class="number">-1</span>) d[i]=c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) c[i]=s[i];</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">1</span>); <span class="built_in">ntt</span>(c,len,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=d[i]*c[i]%mod;</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n) s[i]=d[i];</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=c[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcB</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"><span class="comment">//求伯努利数</span></span></span><br><span class="line"><span class="function"><span class="comment">//原理:伯努利数的EGF=x/(e^x-1)</span></span></span><br><span class="line"><span class="function"><span class="comment">//sum(i=[0,n-1])[B_i*C(n,i)]=0(n&gt;1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n+=<span class="number">2</span>;</span><br><span class="line">    B.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) B[i]=fv[i+<span class="number">1</span>];</span><br><span class="line">    B=~B;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n) B[i]=B[i]*fc[i]%mod;</span><br><span class="line">    B.<span class="built_in">resize</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><h3 id="矩阵相关"><a href="#矩阵相关" class="headerlink" title="矩阵相关"></a>矩阵相关</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">502</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	ll a[N][N];</span><br><span class="line">	<span class="built_in">matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Mat&#123;</span><br><span class="line">	<span class="type">static</span> ll a[N][N],b[N][N+N],c[N][N],d[N][N];</span><br><span class="line">	<span class="type">static</span> matrix B,C;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">det</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span><span class="comment">//行列式</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		ll d=<span class="number">1</span>,iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=i;</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n) <span class="keyword">if</span>(a[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) &#123;<span class="built_in">fo</span>(j,i,n) <span class="built_in">swap</span>(a[k][j],a[i][j]); d=(mod-d)%mod;&#125;</span><br><span class="line">			<span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			iv=<span class="built_in">Pow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=a[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n) a[j][k]=<span class="built_in">Dec</span>(a[j][k],a[i][k]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">			d=d*a[i][i]%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> matrix <span class="title">inv</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span><span class="comment">//求逆</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) b[i][j+n]=<span class="number">0</span>,b[i][j]=A.a[i][j];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i][i+n]=<span class="number">1</span>;</span><br><span class="line">		ll iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=n+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n) <span class="keyword">if</span>(b[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) <span class="built_in">fo</span>(j,<span class="number">1</span>,n+n) <span class="built_in">swap</span>(b[i][j],b[k][j]);</span><br><span class="line">			iv=<span class="built_in">Pow</span>(b[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=b[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n+n) b[j][k]=<span class="built_in">Dec</span>(b[j][k],b[i][k]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			iv=<span class="built_in">Pow</span>(b[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n+n) b[i][j]=b[i][j]*iv%mod;</span><br><span class="line">			<span class="built_in">fd</span>(j,i<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span>(b[j][i])</span><br><span class="line">				&#123;</span><br><span class="line">					tmp=b[j][i];</span><br><span class="line">					<span class="built_in">fo</span>(k,i,n+n) b[j][k]=<span class="built_in">Dec</span>(b[j][k],b[i][k]*tmp%mod);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		B.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) B.a[i][j]=b[i][j+n];</span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">r</span><span class="params">(<span class="type">const</span> matrix A,<span class="type">int</span> n)</span><span class="comment">//求秩</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		<span class="type">int</span> d=<span class="number">0</span>;</span><br><span class="line">		ll iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=n+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n) <span class="keyword">if</span>(a[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			d++;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) <span class="built_in">fo</span>(j,i,n) <span class="built_in">swap</span>(a[i][j],a[k][j]);</span><br><span class="line">			iv=<span class="built_in">Pow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=a[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n) a[j][k]=<span class="built_in">Dec</span>(a[j][k],tmp*a[i][k]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> ll v[N],w[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ins</span><span class="params">(ll *v,<span class="type">int</span> n,<span class="type">int</span> id,ll *ans)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) w[i]=<span class="number">0</span>;</span><br><span class="line">		w[id]=<span class="number">1</span>;</span><br><span class="line">		ll tmp;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(v[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!c[i][i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">fd</span>(j,i,<span class="number">1</span>) c[i][j]=v[j];</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">1</span>,n) d[i][j]=w[j];</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				tmp=<span class="built_in">Pow</span>(c[i][i],mod<span class="number">-2</span>)*v[i]%mod;</span><br><span class="line">				<span class="built_in">fd</span>(j,i,<span class="number">1</span>) v[j]=<span class="built_in">Dec</span>(v[j],c[i][j]*tmp%mod);</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">1</span>,n) w[j]=<span class="built_in">Dec</span>(w[j],d[i][j]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans[i]=w[i];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_G</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n,ll *p)</span><span class="comment">//解齐次线性方程非零解</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c)); <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,n) v[j]=a[j][i];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ins</span>(v,n,i,p)) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> matrix <span class="title">solve</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span><span class="comment">//求所有代数余子式</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> rank=<span class="built_in">r</span>(A,n);</span><br><span class="line">		<span class="keyword">if</span>(rank == n)</span><br><span class="line">		&#123;</span><br><span class="line">			ll d=<span class="built_in">det</span>(A,n);</span><br><span class="line">			B=<span class="built_in">inv</span>(A,n);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) C.a[i][j]=B.a[j][i]*d%mod;</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rank &lt;= n<span class="number">-2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			C.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">static</span> ll p[N],q[N];</span><br><span class="line">			<span class="built_in">get_G</span>(A,n,q);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) B.a[j][i]=A.a[i][j];</span><br><span class="line">			<span class="built_in">get_G</span>(B,n,p);</span><br><span class="line">			<span class="type">int</span> c=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(q[i]) &#123;c=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(p[i]) &#123;r=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(i!=r)</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">						<span class="keyword">if</span>(j!=c)</span><br><span class="line">							B.a[i-(i&gt;r)][j-(j&gt;c)]=A.a[i][j];</span><br><span class="line">			ll d=<span class="built_in">det</span>(B,n<span class="number">-1</span>);</span><br><span class="line">			C.a[r][c]=((r+c)%<span class="number">2</span>==<span class="number">1</span>)?(mod-d)%mod:d;</span><br><span class="line">			ll iv=<span class="built_in">Pow</span>(q[c]*p[r]%mod,mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">					C.a[i][j]=C.a[r][c]*iv%mod*p[i]%mod*q[j]%mod;</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="KM算法"><a href="#KM算法" class="headerlink" title="KM算法"></a>KM算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> n,w[N][N],l[N];</span><br><span class="line">	<span class="type">int</span> lx[N],ly[N],slk[N],pre[N];</span><br><span class="line">	<span class="type">bool</span> visy[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) pre[i]=visy[i]=<span class="number">0</span>,slk[i]=inf;</span><br><span class="line">		l[v]=u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t,d,id;;)</span><br><span class="line">		&#123;</span><br><span class="line">			t=l[v]; d=inf; visy[v]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(!visy[i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(slk[i]&gt;lx[t]+ly[i]-w[t][i])</span><br><span class="line">						slk[i]=lx[t]+ly[i]-w[t][i],pre[i]=v;</span><br><span class="line">					<span class="keyword">if</span>(d&gt;slk[i]) d=slk[i],id=i;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(!visy[i]) slk[i]-=d;</span><br><span class="line">				<span class="keyword">else</span> lx[l[i]]-=d,ly[i]+=d;</span><br><span class="line">			v=id;</span><br><span class="line">			<span class="keyword">if</span>(l[v]==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(;v;l[v]=l[pre[v]],v=pre[v]);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">KM</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//calculate w</span></span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) lx[i]=ly[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) lx[i]=<span class="built_in">max</span>(lx[i],w[i][j]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">bfs</span>(i);</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans+=w[l[i]][i];</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line">	<span class="type">int</span> n,s,t,d[N]; queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">int</span> head[N],cur[N],ne[M],ver[M],val[M],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) head[i]=<span class="number">0</span>; tot=<span class="number">1</span>; n=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) cur[i]=head[i];</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) d[i]=<span class="number">-1</span>; q.<span class="built_in">push</span>(s); d[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flow||u==t) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,r,v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==d[u]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i]));</span><br><span class="line">				<span class="keyword">if</span>(!r) <span class="keyword">continue</span>;</span><br><span class="line">				val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">				res-=r; <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> flow=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">bfs</span>()) flow+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra优化费用流"><a href="#Dijkstra优化费用流" class="headerlink" title="Dijkstra优化费用流"></a>Dijkstra优化费用流</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s,t;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],cost[M],ne[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; cost[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; cost[tot]=-c;ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> h[N],dis[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=inf;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(h[s]=<span class="number">0</span>,q.<span class="built_in">push</span>(s);!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;h[v=ver[i]]&gt;h[u]+cost[i])</span><br><span class="line">				&#123;</span><br><span class="line">					h[v]=h[u]+cost[i];</span><br><span class="line">					<span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			vis[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> u,dis;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)&#123;<span class="keyword">return</span> A.dis&gt;B.dis;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> pv[N],pe[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">MCMF</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>,co=<span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;node&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">			<span class="keyword">for</span>(dis[s]=<span class="number">0</span>,q.<span class="built_in">push</span>((node)&#123;s,dis[s]&#125;);!q.<span class="built_in">empty</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				node now=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">int</span> u=now.u;</span><br><span class="line">				<span class="keyword">if</span>(dis[u]&lt;now.dis) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					v=ver[i];</span><br><span class="line">					<span class="keyword">if</span>(dis[v]+h[v]&gt;dis[u]+h[u]+cost[i])</span><br><span class="line">						dis[v]=dis[u]+h[u]+cost[i]-h[v],</span><br><span class="line">						q.<span class="built_in">push</span>((node)&#123;v,dis[v]&#125;),</span><br><span class="line">						pv[v]=u,pe[v]=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dis[t]==inf) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]+=dis[i];</span><br><span class="line">			<span class="type">int</span> tmp=inf;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=pv[u]) tmp=<span class="built_in">min</span>(tmp,val[pe[u]]);</span><br><span class="line">			flow+=tmp; co+=h[t]*tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t,i;u!=s;u=pv[u]) i=pe[u],val[i]-=tmp,val[i^<span class="number">1</span>]+=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,flow,co);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="k短路（可持久化可并堆优化）"><a href="#k短路（可持久化可并堆优化）" class="headerlink" title="k短路（可持久化可并堆优化）"></a>k短路（可持久化可并堆优化）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2.6e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N*<span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">2e7</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> head[N],ne[M],ver[M],tot;</span><br><span class="line">	ll val[M];</span><br><span class="line">	<span class="built_in">Edge</span>()&#123;tot=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;E1,E2;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u;ll d;</span><br><span class="line">	node* <span class="keyword">operator</span>=(node a)&#123;u=a.u,d=a.d; <span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(node A,node B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.d&gt;B.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt,lc[K],rc[K],d[K];</span><br><span class="line">	node v[K];</span><br><span class="line">	<span class="built_in">Heap</span>()&#123;d[<span class="number">0</span>]=<span class="number">-1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(node w)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v[++cnt]=w;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="keyword">if</span>(v[x]&lt;v[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="type">int</span> u=++cnt;</span><br><span class="line">		lc[u]=lc[x];</span><br><span class="line">		v[u]=v[x];</span><br><span class="line">		rc[u]=<span class="built_in">merge</span>(rc[x],y);</span><br><span class="line">		<span class="keyword">if</span>(d[lc[u]]&lt;d[rc[u]]) <span class="built_in">swap</span>(lc[u],rc[u]);</span><br><span class="line">		d[u]=d[rc[u]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;st;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="type">bool</span> bo[N],vis[N],on_tree[M];</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bo[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=E2.head[u],v;i;i=E2.ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=E2.ver[i];</span><br><span class="line">		<span class="keyword">if</span>(bo[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(dis[v]==dis[u]+E2.val[i])</span><br><span class="line">			fa[v]=u,on_tree[i]=<span class="number">1</span>,<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;s,<span class="number">0</span>&#125;); dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> a=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[a.u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[a.u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=E2.head[a.u],v;i;i=E2.ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			v=E2.ver[i];</span><br><span class="line">			<span class="keyword">if</span>(dis[v]&gt;dis[a.u]+E2.val[i])</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[a.u]+E2.val[i];</span><br><span class="line">				q.<span class="built_in">push</span>(&#123;v,dis[v]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bo[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(fa[u]) rt[u]=st.<span class="built_in">merge</span>(rt[u],rt[fa[u]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=E2.head[u],v;i;i=E2.ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=E2.ver[i];</span><br><span class="line">		<span class="keyword">if</span>(!bo[v]&amp;&amp;fa[v]==u) <span class="built_in">dfs2</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	E1.<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	E2.<span class="built_in">add</span>(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); z=<span class="built_in">read</span>(); <span class="built_in">add</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">	s=<span class="number">1</span>; t=n;</span><br><span class="line">	<span class="built_in">dijkstra</span>(t);</span><br><span class="line">	<span class="built_in">dfs</span>(t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dis[s]);</span><br><span class="line">	k--;</span><br><span class="line">	<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(u,s,t)</span><br><span class="line">		<span class="keyword">if</span>(vis[u])</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=E1.head[u],v;i;i=E1.ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!on_tree[i]&amp;&amp;vis[v=E1.ver[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			rt[u]=st.<span class="built_in">merge</span>(rt[u],st.<span class="built_in">newnode</span>(&#123;v,dis[v]-dis[u]+E1.val[i]&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,s,t) bo[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(t);</span><br><span class="line">	<span class="keyword">if</span>(rt[s]) q.<span class="built_in">push</span>((node)&#123;rt[s],dis[s]+st.v[rt[s]].d&#125;);</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> now=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		k--; <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,now.d);</span><br><span class="line">		<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(st.lc[now.u]) q.<span class="built_in">push</span>((node)&#123;st.lc[now.u],now.d-st.v[now.u].d+st.v[st.lc[now.u]].d&#125;);</span><br><span class="line">		<span class="keyword">if</span>(st.rc[now.u]) q.<span class="built_in">push</span>((node)&#123;st.rc[now.u],now.d-st.v[now.u].d+st.v[st.rc[now.u]].d&#125;);</span><br><span class="line">		<span class="type">int</span> u=rt[st.v[now.u].u];</span><br><span class="line">		<span class="keyword">if</span>(u) q.<span class="built_in">push</span>((node)&#123;u,now.d+st.v[u].d&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="弦图"><a href="#弦图" class="headerlink" title="弦图"></a>弦图</h2><p>$N(x)$，与 $x$ 直接相连的点集。</p>
<p>单纯点：${x}+N(x)$ 的诱导子图为一个团。</p>
<p>完美消除序列：$v_1,v_2,\cdots,v_n$，其中 $v_i$ 在 $\{v_i,v_{i+1},\cdots,v_n\}$ 中为单纯点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v即为完美消除序列，pos即为点i在完美消除序列上的位置</span></span><br><span class="line"><span class="comment">//判断v是否为完美消除序列，根据定义即可 O(n+m) 判断。</span></span><br><span class="line"><span class="comment">//极大团可通过不存在nxt_y=x且|N(x)|+1&lt;=|N(y)|判断</span></span><br><span class="line"><span class="comment">//完美消除序列从后往前染色=色数=最大团点数</span></span><br><span class="line"><span class="comment">//完美消除序列从后往前选能选的点=最大独立集=最小团覆盖</span></span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);&#125;</span><br><span class="line"><span class="type">int</span> head[N],ne[N],ver[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> best,label[N];</span><br><span class="line"><span class="type">bool</span> bo[N];</span><br><span class="line"><span class="type">int</span> pos[N],v[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[i]; head[i]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head[i]=ne[head[i]];</span><br><span class="line">	<span class="keyword">for</span>(;!head[best];best--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">MCS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	best=<span class="number">0</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">add</span>(<span class="number">0</span>,i),label[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=ver[head[best]];</span><br><span class="line">		<span class="keyword">while</span>(bo[x]) <span class="built_in">del</span>(best),x=ver[head[best]];</span><br><span class="line">		bo[x]=<span class="number">1</span>;</span><br><span class="line">		pos[x]=i; v[i]=x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> y:adj[x]) <span class="keyword">if</span>(!bo[y]) <span class="built_in">add</span>(++label[y],y),best=<span class="built_in">max</span>(best,label[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=v[i],num=c;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> y:adj[x]) <span class="keyword">if</span>(pos[y]&gt;pos[x]) num--;</span><br><span class="line">		ans=ans*num%<span class="number">1000000007ll</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小树形图（朱-刘算法）"><a href="#最小树形图（朱-刘算法）" class="headerlink" title="最小树形图（朱-刘算法）"></a>最小树形图（朱-刘算法）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> val,v,id;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;<span class="keyword">return</span> A.val&gt;B.val;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	node v[N];</span><br><span class="line">	<span class="type">int</span> dis[N],ls[N],rs[N],tag[N];</span><br><span class="line">	<span class="type">bool</span> del[N];</span><br><span class="line">	<span class="type">int</span> rt[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span>&#123;<span class="keyword">if</span>(u) tag[u]+=t,v[u].val+=t;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushtag</span>(ls[u],tag[u]);</span><br><span class="line">		<span class="built_in">pushtag</span>(rs[u],tag[u]);</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="keyword">if</span>(v[x].val&gt;v[y].val) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">pushtag</span>(y,-tag[x]);</span><br><span class="line">		rs[x]=<span class="built_in">merge</span>(rs[x],y);</span><br><span class="line">		<span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">		dis[x]=dis[rs[x]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(x); <span class="keyword">return</span> <span class="built_in">merge</span>(ls[x],rs[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> va,<span class="type">int</span> id,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v[id]=(node)&#123;va,to,id&#125;;</span><br><span class="line">		rt[y]=<span class="built_in">merge</span>(rt[y],id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> v)</span> </span>&#123;<span class="built_in">pushtag</span>(id,-v);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> node <span class="title">top</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;rt[u]&amp;&amp;<span class="built_in">find</span>(v[rt[u]].v)==u;) rt[u]=<span class="built_in">pop</span>(rt[u]);</span><br><span class="line">		<span class="keyword">if</span>(!rt[u]) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">		v[rt[u]].v=<span class="built_in">find</span>(v[rt[u]].v);</span><br><span class="line">		<span class="keyword">return</span> v[rt[u]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Heap h;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u=<span class="built_in">find</span>(u); v=<span class="built_in">find</span>(v);</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">	h.rt[v]=h.<span class="built_in">merge</span>(h.rt[u],h.rt[v]),fa[u]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,rt,pre[N],bel[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); rt=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">read</span>();</span><br><span class="line">		h.<span class="built_in">ins</span>(y,z,i,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt=n;</span><br><span class="line">	node now;</span><br><span class="line">	bel[rt]=rt;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n&lt;&lt;<span class="number">1</span>) fa[i]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=i;</span><br><span class="line">		<span class="keyword">for</span>(;!bel[j];)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(!bel[j]) bel[j]=i,now=h.<span class="built_in">top</span>(j),ans+=now.val,j=now.v;</span><br><span class="line">			<span class="keyword">if</span>(bel[j]!=i) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(;bel[j]!=<span class="number">-1</span>;) bel[j]=<span class="number">-1</span>,j=pre[j]=(now=h.<span class="built_in">top</span>(j)).v,h.<span class="built_in">dec</span>(now.id,now.val);</span><br><span class="line">			++cnt;</span><br><span class="line">			<span class="keyword">for</span>(;bel[j]!=i;) bel[j]=i,<span class="built_in">Union</span>(j,cnt),j=pre[j];</span><br><span class="line">			j=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带花树-O-n-3"><a href="#带花树-O-n-3" class="headerlink" title="带花树 $O(n^3)$"></a>带花树 $O(n^3)$</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> n,tim;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> fa[N],t[N],vst[N],pre[N],matc[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tim++; x=fa[x]; y=fa[y];</span><br><span class="line">		<span class="keyword">for</span>(;vst[x]!=tim;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(x)</span><br><span class="line">			&#123;</span><br><span class="line">				vst[x]=tim; x=fa[pre[matc[x]]];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">swap</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">blossom</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lca)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;fa[x]!=lca;)</span><br><span class="line">		&#123;</span><br><span class="line">			pre[x]=y; y=matc[x];</span><br><span class="line">			<span class="keyword">if</span>(t[y]==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t[y]=<span class="number">0</span>; q.<span class="built_in">push</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">			fa[x]=fa[y]=fa[lca]; x=pre[y];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Augument</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) t[i]=<span class="number">-1</span>;</span><br><span class="line">		q=<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">		t[s]=<span class="number">0</span>; q.<span class="built_in">push</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> v:adj[u])</span><br><span class="line">				<span class="keyword">if</span>(t[v]==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					pre[v]=u; t[v]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(!matc[v])</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> to=v,from=u;to;from=pre[to])</span><br><span class="line">						&#123;</span><br><span class="line">							matc[to]=from;</span><br><span class="line">							<span class="built_in">swap</span>(matc[from],to);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					t[matc[v]]=<span class="number">0</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(matc[v]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(t[v]==<span class="number">0</span>&amp;&amp;fa[u]!=fa[v])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line">					<span class="built_in">blossom</span>(u,v,lca);</span><br><span class="line">					<span class="built_in">blossom</span>(v,u,lca);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> _n,<span class="type">int</span> m,<span class="type">int</span> *x,<span class="type">int</span> *y,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &amp;vec)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		n=_n;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(x[i],y[i]);</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>) <span class="keyword">if</span>(!matc[i]) ans+=<span class="built_in">Augument</span>(i);</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(matc[i]&amp;&amp;i&lt;matc[i]) vec.<span class="built_in">pb</span>(<span class="built_in">make_pair</span>(i,matc[i]));</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) matc[i]=t[i]=fa[i]=pre[i]=vst[i]=<span class="number">0</span>,adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SCC"><a href="#SCC" class="headerlink" title="SCC"></a>SCC</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	low[u]=dfn[u]=++tim; s.<span class="built_in">push</span>(u); vis[u]=<span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> len=adj[u].<span class="built_in">size</span>(),v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v=adj[u][i]]) <span class="built_in">Tarjan</span>(v),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(vis[v]) low[u] = <span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]!=low[u]) <span class="keyword">return</span>; </span><br><span class="line">	SCC_num++;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		v = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); vis[v] = <span class="literal">false</span>;</span><br><span class="line">		SCC[SCC_num].<span class="built_in">push_back</span>(v);</span><br><span class="line">	&#125;<span class="keyword">while</span>(v!=u); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BCC"><a href="#BCC" class="headerlink" title="BCC"></a>BCC</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++tim; st[++top]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v,x;i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v=ver[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(v); low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u])<span class="comment">/*if(low[v]&gt;dfn[u])*/</span></span><br><span class="line">            &#123;</span><br><span class="line">                Tree::val[++n]=<span class="number">1</span>; x=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    x=st[top--]; Tree::<span class="built_in">add</span>(x,n); Tree::val[n]++;</span><br><span class="line">                &#125;<span class="keyword">while</span>(x!=v);</span><br><span class="line">                Tree::<span class="built_in">add</span>(u,n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/*if(v!=pre)*/</span> low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="树论"><a href="#树论" class="headerlink" title="树论"></a>树论</h1><h2 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//虚树清空必须使用dfs清空所有东西。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; _adj[N];</span><br><span class="line"><span class="type">void</span> _add(<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">	_adj[x].<span class="built_in">pb</span>(y); _adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="type">int</span> st[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span> </span>&#123;</span><br><span class="line">	rt=a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:a) rt=<span class="built_in">lca</span>(rt,v);</span><br><span class="line">	a.<span class="built_in">pb</span>(rt);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(a),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">	a.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(a))-a.<span class="built_in">begin</span>());</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:a) &#123;</span><br><span class="line">		<span class="keyword">if</span>(top) &#123;</span><br><span class="line">			y=<span class="built_in">lca</span>(x,st[top]);</span><br><span class="line">			<span class="keyword">if</span>(y!=st[top]) &#123;</span><br><span class="line">				<span class="keyword">for</span>(;top&gt;=<span class="number">2</span>&amp;&amp;dep[st[top<span class="number">-1</span>]]&gt;=dep[y];top--) _add(st[top],st[top<span class="number">-1</span>]);</span><br><span class="line">				<span class="keyword">if</span>(st[top]!=y) _add(st[top],y),st[top]=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(st[top]!=x) st[++top]=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(top) <span class="keyword">for</span>(;--top;) _add(st[top],st[top+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> db inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">sqr</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">Point</span>() &#123;x=y=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">Point</span>(db _x,db _y) &#123;x=_x,y=_y;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;x,&amp;y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> == (Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(A.x-B.x)==<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>(A.y-B.y)==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(A.x-B.x)==<span class="number">0</span>?<span class="built_in">sgn</span>(A.y-B.y)&lt;<span class="number">0</span>:A.x&lt;B.x;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span> - (Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span> + (Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span> * (Point A,db k)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x*k,A.y*k);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span> / (Point A,db k)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x/k,A.y/k);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span> ^(Point A,Point B)&#123;<span class="keyword">return</span> A.x*B.y-A.y*B.x;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span> *(Point A,Point B)&#123;<span class="keyword">return</span> A.x*B.x+A.y*B.y;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x*x+y*y;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">len2</span>());&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">angle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y,x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">rad</span><span class="params">(Point A,Point B)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Point P=*<span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">atan2</span>((A-P)^(B-P),(A-P)*(B-P)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Point <span class="title">trunc</span><span class="params">(db r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db l=<span class="built_in">len</span>(); <span class="keyword">if</span>(!<span class="built_in">sgn</span>(l)) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		r/=l; <span class="keyword">return</span> <span class="built_in">Point</span>(x*r,y*r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Point <span class="title">rotate_left</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(-y,x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Point <span class="title">rotate_right</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(y,-x);&#125;</span><br><span class="line">	<span class="comment">//anticlockwise</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(Point P,db ang)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Point v=(*<span class="keyword">this</span>)-P;</span><br><span class="line">		db c=<span class="built_in">cos</span>(ang),s=<span class="built_in">sin</span>(ang);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Point</span>(P.x+v.x*c-v.y*s,P.y+v.x*s+v.y*c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Point <span class="title">rotate</span><span class="params">(db ang)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">rotate</span>(<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">0</span>),ang);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">area</span><span class="params">(Point A,Point B,Point C)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((A-B)^(C-B))/<span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">	Point s,e;</span><br><span class="line">	<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Line</span>(Point _s,Point _e) &#123;s=_s; e=_e;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;s.<span class="built_in">input</span>();e.<span class="built_in">input</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(e&lt;s) <span class="built_in">swap</span>(e,s);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Line A,Line B)&#123;<span class="keyword">return</span> A.s==B.s&amp;&amp;A.e==B.e;&#125;</span><br><span class="line">	<span class="built_in">Line</span>(Point p,db ang)</span><br><span class="line">	&#123;</span><br><span class="line">		s=p;</span><br><span class="line">		e=p+(<span class="built_in">sgn</span>(ang-pi/<span class="number">2</span>)==<span class="number">0</span>?<span class="built_in">Point</span>(<span class="number">0</span>,<span class="number">1</span>):<span class="built_in">Point</span>(<span class="number">1</span>,<span class="built_in">tan</span>(ang)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Line</span>(db a,db b,db c)<span class="comment">//ax+by+c==0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(a)==<span class="number">0</span>) s=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b),e=<span class="built_in">Point</span>(<span class="number">1</span>,-c/b);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">sgn</span>(b)==<span class="number">0</span>) s=<span class="built_in">Point</span>(-c/a,<span class="number">0</span>),e=<span class="built_in">Point</span>(-c/a,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> s=<span class="built_in">Point</span>(<span class="number">0</span>,-c/b),e=<span class="built_in">Point</span>(<span class="number">1</span>,(-c-a)/b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (e-s).<span class="built_in">len</span>();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">angle2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(e.y-s.y,e.x-s.x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">angle</span><span class="params">()</span><span class="comment">//angle in [0,pi)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db k=<span class="built_in">angle2</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(k)&lt;<span class="number">0</span>) k+=pi;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(k-pi)==<span class="number">0</span>) k-=pi;</span><br><span class="line">		<span class="keyword">return</span> k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">(Point p)</span><span class="comment">//1:p on line&#x27;s left;3:p on line</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> c=<span class="built_in">sgn</span>((p-s)^(e-s));</span><br><span class="line">		<span class="keyword">return</span> !c?<span class="number">3</span>:<span class="number">1</span>+(c&gt;<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">PointOnSegment</span><span class="params">(Point p)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>((p-s)^(e-s))==<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>((p-s)*(p-e))&lt;=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">parallel</span><span class="params">(Line v)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>((e-s)^(v.e-v.s))==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="comment">// 2 规范相交；1 非规范相交；0 不相交</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">segcrossseg</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> d1 = <span class="built_in">sgn</span>((e-s)^(v.s-s));</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>((e-s)^(v.e-s));</span><br><span class="line">        <span class="type">int</span> d3 = <span class="built_in">sgn</span>((v.e-v.s)^(s-v.s));</span><br><span class="line">        <span class="type">int</span> d4 = <span class="built_in">sgn</span>((v.e-v.s)^(e-v.s));</span><br><span class="line">        <span class="keyword">if</span>( (d1^d2)==<span class="number">-2</span> &amp;&amp; (d3^d4)==<span class="number">-2</span> )<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (d1==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((v.s-s)*(v.s-e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">            (d2==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((v.e-s)*(v.e-e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">            (d3==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((s-v.s)*(s-v.e))&lt;=<span class="number">0</span>) ||</span><br><span class="line">            (d4==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((e-v.s)*(e-v.e))&lt;=<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">linecrossseg</span><span class="params">(Line v)</span><span class="comment">//*this is line</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> d1 = <span class="built_in">sgn</span>((e-s)^(v.s-s));</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>((e-s)^(v.e-s));</span><br><span class="line">        <span class="keyword">if</span>((d1^d2)==<span class="number">-2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (d1==<span class="number">0</span>||d2==<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">linecrossline</span><span class="params">(Line v)</span><span class="comment">//0 平行；1 重合；2 相交</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((*<span class="keyword">this</span>).<span class="built_in">parallel</span>(v)) <span class="keyword">return</span> v.<span class="built_in">relation</span>(s)==<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Intersection</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db a1=(v.e-v.s)^(s-v.s);</span><br><span class="line">        db a2=(v.e-v.s)^(e-v.s);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">db <span class="title">dispointtoline</span><span class="params">(Point p)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((p-s)^(e-s))/<span class="built_in">len</span>();&#125;<span class="comment">//点到直线的距离</span></span><br><span class="line">    <span class="function">db <span class="title">dispointtoseg</span><span class="params">(Point p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>((p-s)*(e-s))&lt;<span class="number">0</span> || <span class="built_in">sgn</span>((p-e)*(s-e))&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>((p-s).<span class="built_in">len</span>(),(p-e).<span class="built_in">len</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispointtoline</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//`返回线段到线段的距离`</span></span><br><span class="line">    <span class="comment">//`前提是两线段不相交，相交距离就是0了`</span></span><br><span class="line">    <span class="function">db <span class="title">dissegtoseg</span><span class="params">(Line v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">min</span>(<span class="built_in">dispointtoseg</span>(v.s),<span class="built_in">dispointtoseg</span>(v.e)),<span class="built_in">min</span>(v.<span class="built_in">dispointtoseg</span>(s),v.<span class="built_in">dispointtoseg</span>(e)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//点p在直线上的投影</span></span><br><span class="line">    <span class="function">Point <span class="title">lineprog</span><span class="params">(Point p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + ( ((e-s)*((e-s)*(p-s)))/((e-s).<span class="built_in">len2</span>()) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//点p关于直线的对称点</span></span><br><span class="line">    <span class="function">Point <span class="title">symmetrypoint</span><span class="params">(Point p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        Point q = <span class="built_in">lineprog</span>(p);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(<span class="number">2</span>*q.x-p.x,<span class="number">2</span>*q.y-p.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    Point p; db r;</span><br><span class="line">    <span class="built_in">Circle</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">Circle</span>(Point p,db r)&#123;<span class="keyword">this</span>-&gt;p=p; <span class="keyword">this</span>-&gt;r=r;&#125;</span><br><span class="line">    <span class="built_in">Circle</span>(db x,db y,db r)&#123;p=<span class="built_in">Point</span>(x,y); <span class="keyword">this</span>-&gt;r=r;&#125;</span><br><span class="line">    <span class="built_in">Circle</span>(Point a,Point b,Point c,<span class="type">bool</span> opt)<span class="comment">//0 外接圆；1 内切圆</span></span><br><span class="line">    &#123;</span><br><span class="line">        Line u,v;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            u=<span class="built_in">Line</span>((a+b)/<span class="number">2</span>,((a+b)/<span class="number">2</span>)+((b-a).<span class="built_in">rotate_left</span>()));</span><br><span class="line">            v=<span class="built_in">Line</span>((b+c)/<span class="number">2</span>,((b+c)/<span class="number">2</span>)+((c-b).<span class="built_in">rotate_left</span>()));</span><br><span class="line">            p=u.<span class="built_in">Intersection</span>(v);</span><br><span class="line">            r=(p-a).<span class="built_in">len</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            db m = <span class="built_in">atan2</span>(b.y-a.y,b.x-a.x), n = <span class="built_in">atan2</span>(c.y-a.y,c.x-a.x);</span><br><span class="line">            u.s = a;</span><br><span class="line">            u.e = u.s + <span class="built_in">Point</span>(<span class="built_in">cos</span>((n+m)/<span class="number">2</span>),<span class="built_in">sin</span>((n+m)/<span class="number">2</span>));</span><br><span class="line">            v.s = b;</span><br><span class="line">            m = <span class="built_in">atan2</span>(a.y-b.y,a.x-b.x) , n = <span class="built_in">atan2</span>(c.y-b.y,c.x-b.x);</span><br><span class="line">            v.e = v.s + <span class="built_in">Point</span>(<span class="built_in">cos</span>((n+m)/<span class="number">2</span>),<span class="built_in">sin</span>((n+m)/<span class="number">2</span>));</span><br><span class="line">            p = u.<span class="built_in">Intersection</span>(v);</span><br><span class="line">            r = <span class="built_in">Line</span>(a,b).<span class="built_in">dispointtoseg</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> == (Circle A,Circle B) &#123;<span class="keyword">return</span> A.p==B.p&amp;&amp;<span class="built_in">sgn</span>(A.r-B.r)==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function">db <span class="title">area</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> pi*r*r;&#125;</span><br><span class="line">    <span class="function">db <span class="title">circumference</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">2</span>*pi*r;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">(Point b)</span><span class="comment">//0 圆外；1 圆上；2 圆内</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">sgn</span>((b-p).<span class="built_in">len</span>()-r);</span><br><span class="line">        <span class="keyword">return</span> opt&lt;<span class="number">0</span>?<span class="number">2</span>:(opt==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">relationseg</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">sgn</span>(v.<span class="built_in">dispointtoseg</span>(p)-r);</span><br><span class="line">        <span class="keyword">return</span> opt&lt;<span class="number">0</span>?<span class="number">2</span>:(opt==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">relationline</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="type">int</span> opt=<span class="built_in">sgn</span>(v.<span class="built_in">dispointtoline</span>(p)-r);</span><br><span class="line">        <span class="keyword">return</span> opt&lt;<span class="number">0</span>?<span class="number">2</span>:(opt==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 5 相离</span></span><br><span class="line">	<span class="comment">// 4 外切</span></span><br><span class="line">	<span class="comment">// 3 相交</span></span><br><span class="line">	<span class="comment">// 2 内切</span></span><br><span class="line">	<span class="comment">// 1 内含</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">relationcircle</span><span class="params">(Circle A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db d=(p-A.p).<span class="built_in">len</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(d-r-A.r)&gt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(d-r-A.r)==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>+<span class="built_in">sgn</span>(d-<span class="built_in">fabs</span>(r-A.r));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">vector&lt;Point&gt; <span class="title">pointcrossline</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;Point&gt; vec; vec.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">if</span>(!(*<span class="keyword">this</span>).<span class="built_in">relationline</span>(v)) <span class="keyword">return</span> vec;</span><br><span class="line">        Point a=v.<span class="built_in">lineprog</span>(p);</span><br><span class="line">        db d=v.<span class="built_in">dispointtoline</span>(p);</span><br><span class="line">        d=<span class="built_in">sqrt</span>(r*r-d*d);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(d)==<span class="number">0</span>) vec.<span class="built_in">pb</span>(a);</span><br><span class="line">        <span class="keyword">else</span> vec.<span class="built_in">pb</span>(a+(v.e-v.s).<span class="built_in">trunc</span>(d)),vec.<span class="built_in">pb</span>(a-(v.e-v.s).<span class="built_in">trunc</span>(d));</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">vector&lt;Point&gt; <span class="title">pointcrosscircle</span><span class="params">(Circle A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;Point&gt; vec; vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">relationcircle</span>(A);</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">5</span>||t==<span class="number">1</span>) <span class="keyword">return</span> vec;</span><br><span class="line">		db d=(p-A.p).<span class="built_in">len</span>();</span><br><span class="line">		db l=(d*d+r*r-A.r*A.r)/(<span class="number">2.</span>*d);</span><br><span class="line">		db h=<span class="built_in">sqrt</span>(r*r-l*l);</span><br><span class="line">		Point q=p+(A.p-p).<span class="built_in">trunc</span>(l);</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">2</span>||t==<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			vec.<span class="built_in">pb</span>(q); <span class="keyword">return</span> vec;</span><br><span class="line">		&#125;</span><br><span class="line">		vec.<span class="built_in">pb</span>(q+((A.p-p).<span class="built_in">rotate_left</span>()).<span class="built_in">trunc</span>(h));</span><br><span class="line">		vec.<span class="built_in">pb</span>(q+((A.p-p).<span class="built_in">rotate_right</span>()).<span class="built_in">trunc</span>(h));</span><br><span class="line">		<span class="keyword">return</span> vec;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//最小圆覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Circle <span class="title">smallestcircle</span><span class="params">(Point *_p,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i<span class="number">-1</span>]=_p[i];</span><br><span class="line">	<span class="built_in">random_shuffle</span>(<span class="built_in">all</span>(p));</span><br><span class="line">	Circle C=<span class="built_in">Circle</span>(p[<span class="number">0</span>],<span class="number">0.0</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(C.<span class="built_in">relation</span>(p[i])==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			C=<span class="built_in">Circle</span>(p[i],<span class="number">0.0</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">if</span>(C.<span class="built_in">relation</span>(p[j])==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					C=<span class="built_in">Circle</span>((p[i]+p[j])/<span class="number">2</span>,(p[i]-p[j]).<span class="built_in">len</span>()/<span class="number">2</span>);</span><br><span class="line">					<span class="built_in">fo</span>(k,<span class="number">0</span>,j<span class="number">-1</span>)</span><br><span class="line">						<span class="keyword">if</span>(C.<span class="built_in">relation</span>(p[k])==<span class="number">0</span>)</span><br><span class="line">							C=<span class="built_in">Circle</span>(p[i],p[j],p[k],<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Polygon</span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	vector&lt;Point&gt; p;</span><br><span class="line">	vector&lt;Line&gt; l;</span><br><span class="line">	<span class="built_in">Polygon</span>(vector&lt;Point&gt; a)</span><br><span class="line">	&#123;</span><br><span class="line">		n=a.<span class="built_in">size</span>(); p=a; l.<span class="built_in">resize</span>(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) l[i]=<span class="built_in">Line</span>(p[i],p[(i+<span class="number">1</span>)%n]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">db <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++) ans+=(p[i]-p[<span class="number">0</span>])^(p[i<span class="number">-1</span>]-p[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">fabs</span>(ans)/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Polygon <span class="title">Convex</span><span class="params">(vector&lt;Point&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; p;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Polygon</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Polygon <span class="title">HalfPlanes</span><span class="params">(vector&lt;Line&gt; l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;Point&gt; p;</span><br><span class="line">	<span class="type">int</span> n=l.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">auto</span> cmp = [](Line A,Line B) &#123;</span><br><span class="line">		db r=A.<span class="built_in">angle2</span>()-B.<span class="built_in">angle2</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(r)!=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">sgn</span>(r)&lt;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sgn</span>((A.e-A.s)^(B.e-A.s))&lt;<span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(l),cmp);</span><br><span class="line">	<span class="function">vector&lt;Line&gt; <span class="title">q</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;Point&gt; <span class="title">b</span><span class="params">(n+<span class="number">2</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>]=l[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">sgn</span>(l[i].<span class="built_in">angle2</span>()-l[i<span class="number">-1</span>].<span class="built_in">angle2</span>())!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(head&lt;tail&amp;&amp;q[head].<span class="built_in">parallel</span>(q[head+<span class="number">1</span>])) <span class="keyword">return</span> <span class="built_in">Polygon</span>(p);</span><br><span class="line">			<span class="keyword">if</span>(head&lt;tail&amp;&amp;q[tail].<span class="built_in">parallel</span>(q[tail<span class="number">-1</span>])) <span class="keyword">return</span> <span class="built_in">Polygon</span>(p);</span><br><span class="line">			<span class="keyword">while</span>(head&lt;tail&amp;&amp;l[i].<span class="built_in">relation</span>(b[tail<span class="number">-1</span>])==<span class="number">2</span>) tail--;</span><br><span class="line">			<span class="keyword">while</span>(head&lt;tail&amp;&amp;l[i].<span class="built_in">relation</span>(b[head])==<span class="number">2</span>) head++;</span><br><span class="line">			q[++tail]=l[i];</span><br><span class="line">			<span class="keyword">if</span>(head&lt;tail) b[tail<span class="number">-1</span>]=q[tail].<span class="built_in">Intersection</span>(q[tail<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;tail&amp;&amp;l[head].<span class="built_in">relation</span>(b[tail<span class="number">-1</span>])==<span class="number">2</span>) tail--;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;tail&amp;&amp;l[tail].<span class="built_in">relation</span>(b[head])==<span class="number">2</span>) head++;</span><br><span class="line">	<span class="keyword">if</span>(tail-head&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Polygon</span>(p);</span><br><span class="line">	b[tail]=q[head].<span class="built_in">Intersection</span>(q[tail]);</span><br><span class="line">	p.<span class="built_in">resize</span>(tail-head+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head;i&lt;=tail;i++) p[i-head]=b[i];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Polygon</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>训练合集</title>
    <url>/2021/10/20/%E8%AE%AD%E7%BB%83%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>XCPC训练合集。</p>
<span id="more"></span>

<h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><ol>
<li>2021ICPC网络赛第二场 :Rank $77$</li>
<li><a href="/2021/10/21/2021CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B-%E9%87%8D%E8%B5%9B/" title="2021CCPC网络赛-重赛">2021CCPC网络赛-重赛</a> :Rank $29$ ,</li>
<li><a href="/2021/11/14/2021-CCPC-%E5%B9%BF%E5%B7%9E%E7%AB%99/" title="2021 CCPC 广州站">2021 CCPC 广州站</a> :Rank $22/224$ ，</li>
<li>2021-CCPC-威海站* :Rank $29/323$ ,</li>
<li><a href="/2021/12/05/2021-ICPC-%E5%8D%97%E4%BA%AC%E7%AB%99/" title="2021 ICPC 南京站">2021 ICPC 南京站</a>:Rank $14/637$ ，</li>
<li>2021-ICPC-澳门站 :Rank $18/153$ ,</li>
<li>2021-ICPC-EC-final :Rank ?</li>
<li>2021-CCPC-final :Rank $26/115$ ,</li>
<li>2022-CCPC-桂林站 :Rank $31/321$ ,</li>
<li>2022-CCPC-威海站* :Rank $5/285$ ,</li>
<li>2022-ICPC-西安站 :Rank？</li>
</ol>
<h2 id="各种营"><a href="#各种营" class="headerlink" title="各种营"></a>各种营</h2><h3 id="2022-Huawei-ICPC-Camp"><a href="#2022-Huawei-ICPC-Camp" class="headerlink" title="2022 Huawei ICPC Camp"></a>2022 Huawei ICPC Camp</h3><a href="/2022/02/09/2022-Huawei-ICPC-Camp/" title="2022 Huawei ICPC Camp">2022 Huawei ICPC Camp</a>

<h3 id="2022-Byte-Camp"><a href="#2022-Byte-Camp" class="headerlink" title="2022 Byte Camp"></a>2022 Byte Camp</h3><ol>
<li><a href="/2022/07/11/Byte-Camp-2022-Day1/" title="Byte Camp 2022 Day1">Byte Camp 2022 Day1</a>，Rank $32/48$，
</li>
<li><a href="/2022/07/11/Byte-Camp-2022-Day2/" title="Byte Camp 2022 Day2">Byte Camp 2022 Day2</a>，Rank $25/46$，
</li>
<li><a href="/2022/07/13/Byte-Camp-2022-Day3/" title="Byte Camp 2022 Day3">Byte Camp 2022 Day3</a>，Rank $15/44$，
</li>
<li><a href="/2022/07/13/Byte-Camp-2022-Day4/" title="Byte Camp 2022 Day4">Byte Camp 2022 Day4</a>，Rank $20/45$,
</li>
<li><p>Byte-Camp-2022-Final-Contest, Rank $21/44$.</p>
</li>
</ol>
<p>前四场情况：</p>
<p>总排名：$21$；中国队伍排名：$8$；学校排名：$7$。</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><ol>
<li><a href="/2021/09/01/2017-2018-ACM-ICPC-Asia-Tsukuba-Regional-Contest/" title="2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest">2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest</a> </li>
<li><a href="/2021/09/18/ICPC-2019-2020-North-Western-Russia-Regional-Contest/" title="ICPC 2019-2020 North-Western Russia Regional Contest">ICPC 2019-2020 North-Western Russia Regional Contest</a></li>
<li><a href="/2021/09/15/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest/" title="2019-2020 ICPC Asia Hong Kong Regional Contest">2019-2020 ICPC Asia Hong Kong Regional Contest</a>$</li>
<li>2017-2018 ACM-ICPC Latin American Regional Programming Contest</li>
<li><a href="/2021/10/20/The-2020-ICPC-Asia-Macau-Regional-Contest/" title="The 2020 ICPC Asia Macau Regional Contest">The 2020 ICPC Asia Macau Regional Contest</a></li>
<li><a href="/2021/11/11/2021-Jiangxi-Provincial-Collegiate-Programming-Contest/" title="2021 Jiangxi Provincial Collegiate Programming Contest">2021 Jiangxi Provincial Collegiate Programming Contest</a></li>
<li><a href="/2021/11/17/2021-CCPC-%E6%A1%82%E6%9E%97%E7%AB%99/" title="2021 CCPC 桂林站">2021 CCPC 桂林站</a></li>
<li><a href="/2021/12/02/2021-ICPC-%E4%B8%8A%E6%B5%B7%E7%AB%99/" title="2021 ICPC 上海站">2021 ICPC 上海站</a></li>
<li><a href="/2022/02/25/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Krakow/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Krakow">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Krakow</a></li>
<li><a href="/2022/03/06/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Nizhny-Novgorod/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Nizhny Novgorod">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Nizhny Novgorod</a></li>
<li><a href="/2022/03/22/2020-Petrozavodsk-Winter-Camp-Jagiellonian-U-Contest/" title="2020 Petrozavodsk Winter Camp, Jagiellonian U Contest">2020 Petrozavodsk Winter Camp, Jagiellonian U Contest</a></li>
<li><a href="/2022/03/31/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Suwon/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Suwon">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Suwon</a></li>
<li><a href="/2022/03/17/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Belarus/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Belarus">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Belarus</a></li>
<li><a href="/2022/04/07/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Tokyo/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Tokyo">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Tokyo</a></li>
<li><a href="/2022/05/26/2022-Hubei-Provincial-Collegiate-Programming-Contest/" title="2022 Hubei Provincial Collegiate Programming Contest">2022 Hubei Provincial Collegiate Programming Contest</a></li>
<li><a href="/2022/04/07/2021-2022-ACM-ICPC-Latin-American-Regional-Programming-Contest/" title="2021-2022 ACM-ICPC Latin American Regional Programming Contest">2021-2022 ACM-ICPC Latin American Regional Programming Contest</a></li>
<li><a href="/2022/07/05/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Samara/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of Samara">XXI Open Cup named after E.V. Pankratiev. Grand Prix of Samara</a></li>
<li><a href="/2022/07/07/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-NorthBeach/" title="XXI Open Cup named after E.V. Pankratiev. Grand Prix of NorthBeach">XXI Open Cup named after E.V. Pankratiev. Grand Prix of NorthBeach</a></li>
<li><a href="/2022/09/15/Lesnoe-Ozero-2016-BSUIR-Open-2016-Finals/" title="Lesnoe Ozero 2016. BSUIR Open 2016 Finals">Lesnoe Ozero 2016. BSUIR Open 2016 Finals</a>


</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>(2021.11.13) 可能输出-0.000000，输出小数的时候要注意。</li>
<li>(2021.11.16) 分块大小不能为 $0$，可以和 $1$ 取个 <code>max</code>。</li>
<li>(2021.11.17) 计算几何题一定要注意精度。尤其注意三点共线。尽量用 <code>long double</code>。</li>
<li>(2021,11,17) <code>vector</code> 的空间可以理解为普通数组的两倍，因此空间比较紧的时候需要注意使用。</li>
<li>(2021.11.17) 求区间 $[l,r]$ 的和使用前缀和时，注意 $l$ 是否为 $0$。</li>
<li>(2021.12.05) 矩阵乘法尽量优化常数！如果是 $0$ 就不要继续乘了。</li>
<li>初始化最好要连边界的后几位也清了。</li>
<li>注意取模，需要<code>long long</code> 的地方不要写成 <code>int</code>。</li>
<li><code>nth_element</code> 求第 $k$ 小，应为：<code>nth_element(a+1,a+k,a+n+1,cmp);</code>。</li>
<li>清空虚树信息（如<code>vector</code>）时要注意不能只清空原本的节点，需要新开一个<code>vector</code>记录虚树中所有节点，然后再询问后进行清空（因为虚树可能会新加节点）。</li>
<li>树链剖分中，由于我的模板里<code>dfs2(int u,int tp)</code> 有 <code>if(!top[v])</code>，因此多组数据时，<code>top</code>数组和时间戳 <code>tim</code> 需要清空。</li>
<li>注意，带有 <code>A.size()</code> 相关的运算最好写成 <code>((int)A.size())</code>，否则会将表达式转换成无符号数，从而无法实现带负数的运算。</li>
</ol>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>2022 ICPC 沈阳站</title>
    <url>/2022/11/10/2022-ICPC-%E6%B2%88%E9%98%B3%E7%AB%99/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2022 CCPC 威海站</title>
    <url>/2022/11/10/2022-CCPC-%E5%A8%81%E6%B5%B7%E7%AB%99/</url>
    <content><![CDATA[<p>成功打星（</p>
<span id="more"></span>

<p>不过还是有不尽人意的地方，赛中B题没有给调出来，比较缺乏写暴力的能力。L题比较简单的线性代数也没能想出来。一直在往比较麻烦的贪心上想。</p>
<p>做不出来需要及时更换另一种思路！</p>
<h2 id="A-Dunai"><a href="#A-Dunai" class="headerlink" title="A. Dunai"></a>A. Dunai</h2><p>一个比较简单的题目，但我没想好直接WA了一发。</p>
<p>显然只有两种限制：每个种类的制约，以及获得过冠军的总数。</p>
<p>两者求 min 就OK了。</p>
<h2 id="B-Recruitment"><a href="#B-Recruitment" class="headerlink" title="B. Recruitment"></a>B. Recruitment</h2><p>可以发现，当 $s_i-1=s_{i+1}$ 时，$x+y-xy=1$。即 $(x-1)(y-1)=0$，$x,y$ 里面至少一个 $1$。</p>
<p>那么只有大于 $1$ 的点是有用的。而 $\prod x_i=s_{n-1}\le 10^9$，那么有用的状态就很少了。</p>
<p>于是直接从开始搜索，用 <code>map&lt;vector&lt;int&gt;,status&gt;</code> 记录所有状态以及前驱就ok了。</p>
<p>需要注意一些细节，及时判掉不合法的状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) f|=(ch==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASES int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(random_device&#123;&#125;())</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divide</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="built_in">sqrt</span>(n))</span><br><span class="line">        <span class="keyword">if</span>(n%i == <span class="number">0</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">pb</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i*i!=n)</span><br><span class="line">                vec.<span class="built_in">pb</span>(n/i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> bel[<span class="number">60</span>],pos[<span class="number">60</span>],col[<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> tim;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!adj[u].<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ++tim;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,col[u]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(adj[u].<span class="built_in">size</span>() == <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(adj[u][<span class="number">0</span>]);</span><br><span class="line">    pos[bel[u]] = tim;</span><br><span class="line">    <span class="built_in">dfs</span>(adj[u][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[N],cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    map&lt;vector&lt;<span class="type">int</span>&gt;,node&gt;::iterator ite;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;vector&lt;<span class="type">int</span>&gt;,node&gt; ma[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> vector&lt;<span class="type">int</span>&gt; <span class="title">update</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> z = x*y,i;</span><br><span class="line">    i = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(a),z)-a.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">ff</span>(j,i,a.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(a),x)-a.<span class="built_in">begin</span>();</span><br><span class="line">    a.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="built_in">fd</span>(j,a.<span class="built_in">size</span>()<span class="number">-2</span>,i)</span><br><span class="line">        <span class="built_in">swap</span>(a[j+<span class="number">1</span>],a[j]);</span><br><span class="line">    </span><br><span class="line">    i = <span class="built_in">lower_bound</span>(<span class="built_in">all</span>(a),y)-a.<span class="built_in">begin</span>();</span><br><span class="line">    a.<span class="built_in">pb</span>(y);</span><br><span class="line">    <span class="built_in">fd</span>(j,a.<span class="built_in">size</span>()<span class="number">-2</span>,i)</span><br><span class="line">        <span class="built_in">swap</span>(a[j+<span class="number">1</span>],a[j]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = w.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">DEBUG</span>(m);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">    b.<span class="built_in">pb</span>(a[n]);</span><br><span class="line"></span><br><span class="line">    ma[m<span class="number">-1</span>][b] = &#123;ma[<span class="number">0</span>].<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=m<span class="number">-1</span>;t&gt;=<span class="number">0</span>;t--)</span><br><span class="line">        <span class="keyword">if</span>(ma[t].<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ma_it = ma[t].<span class="built_in">begin</span>(); ma_it != ma[t].<span class="built_in">end</span>(); ma_it++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> s = ma_it -&gt; fi;</span><br><span class="line">                <span class="built_in">ff</span>(i,<span class="number">0</span>,s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> z = s[i];</span><br><span class="line">                    <span class="built_in">fo</span>(x,<span class="number">2</span>,<span class="built_in">sqrt</span>(z))</span><br><span class="line">                        <span class="keyword">if</span>(z%x==<span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> y = z/x;</span><br><span class="line">                            <span class="keyword">if</span>(z-x-y != w[t<span class="number">-1</span>])</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            ma[t<span class="number">-1</span>][<span class="built_in">update</span>(s,x,y)] = &#123;ma_it,x,y&#125;;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; val;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> v = (ma[t].<span class="built_in">begin</span>()) -&gt; fi;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:v) &#123;</span><br><span class="line">                ++tot;</span><br><span class="line">                col[tot]=x;</span><br><span class="line">                val.<span class="built_in">insert</span>(&#123;x,tot&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">DEBUG</span>(tot);</span><br><span class="line">            <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = val.<span class="built_in">lower_bound</span>(&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">                <span class="type">int</span> xx = (*it).se;</span><br><span class="line">                val.<span class="built_in">erase</span>(it);</span><br><span class="line">                it = val.<span class="built_in">lower_bound</span>(&#123;y,<span class="number">0</span>&#125;);</span><br><span class="line">                <span class="type">int</span> yy = (*it).se;</span><br><span class="line">                val.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">                val.<span class="built_in">insert</span>(&#123;x*y,++tot&#125;);</span><br><span class="line">                bel[tot] = z;</span><br><span class="line">                adj[tot].<span class="built_in">pb</span>(xx);</span><br><span class="line">                adj[tot].<span class="built_in">pb</span>(yy);</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">auto</span> it = ma[t].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = it -&gt; se;</span><br><span class="line">                <span class="built_in">add</span>(u.x,u.y,j);</span><br><span class="line">                it = u.ite;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(tot);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,k=n<span class="number">-1</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">if</span>(a[i] - a[i<span class="number">-1</span>] == <span class="number">-1</span>)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k--);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pos[++j]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(a[i] - a[i<span class="number">-1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] - a[i<span class="number">-1</span>] &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            w.<span class="built_in">pb</span>(a[i] - a[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = <span class="built_in">divide</span>(a[n]);</span><br><span class="line">    <span class="comment">//for(auto x:d) printf(&quot;%d\n&quot;,x);</span></span><br><span class="line">    <span class="built_in">check</span>();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Grass"><a href="#C-Grass" class="headerlink" title="C. Grass"></a>C. Grass</h2><p>$5$ 个点有解当且仅当这 $5$ 个点不共线。</p>
<p>随便找到五个不共线的点，然后枚举 $A$ 点构造即可。</p>
<h2 id="D-Sternhalma"><a href="#D-Sternhalma" class="headerlink" title="D. Sternhalma"></a>D. Sternhalma</h2><p>一眼状压DP，不过建图非常麻烦。</p>
<p>可以在图的左下角加多一个三角形就方便很多了。</p>
<h2 id="E-Python-Will-be-Faster-than-C"><a href="#E-Python-Will-be-Faster-than-C" class="headerlink" title="E. Python Will be Faster than C++"></a>E. Python Will be Faster than C++</h2><p>签到题。</p>
<h2 id="F-Mooncake-Delivery"><a href="#F-Mooncake-Delivery" class="headerlink" title="F. Mooncake Delivery"></a>F. Mooncake Delivery</h2><p>将一条路径分为若干个极大相同颜色连续段，一条路径的权值等于（连续段权值和+下一个点的点权）的最大值。</p>
<p>对于相同颜色的点，用Floyd求出两两最短路，然后建一个新图，$(u,w)$ 边权为：枚举与 $u$ 相同颜色的点 $v$ 且 $(v,w)\in E$，连边 $(u,w,dis_{u,v} + val_w)$。</p>
<p>在新图上跑最大值的Floyd即可。</p>
<h2 id="G-Grade-2"><a href="#G-Grade-2" class="headerlink" title="G. Grade 2"></a>G. Grade 2</h2><p>发现 $k$ 中大于 $2^{\text{Popcount(x)}}$ 的是没用的，也就是构成一个 $2$ 的次幂的循环节。</p>
<p>然后预处理一下就OK了。</p>
<h2 id="H-Party-Animals"><a href="#H-Party-Animals" class="headerlink" title="H. Party Animals"></a>H. Party Animals</h2><p>留坑。。。</p>
<h2 id="I-Dragon-Bloodline"><a href="#I-Dragon-Bloodline" class="headerlink" title="I. Dragon Bloodline"></a>I. Dragon Bloodline</h2><p>由于每种是 $2^i$，那么贪心就是正确的，因为肯定存在某种最优解是贪心的策略。</p>
<p>于是二分，然后从大到小贪心就ok了。</p>
<h2 id="J-Eat-Sleep-Repeat"><a href="#J-Eat-Sleep-Repeat" class="headerlink" title="J. Eat, Sleep, Repeat"></a>J. Eat, Sleep, Repeat</h2><p>可以发现，所有的数都不能越过 $limit_x=0$。</p>
<p>用 $limit_x=0$ 分段，然后统计次数的奇偶性就ok了。</p>
<h2 id="K-I-Wanna-Maker"><a href="#K-I-Wanna-Maker" class="headerlink" title="K. I Wanna Maker"></a>K. I Wanna Maker</h2><p>对于 $1$ 条件，可以合并成一个。</p>
<p>对于 $2$ 条件，可以枚举左端点的区间，然后右端点的合法方案数是一个分段函数。</p>
<h2 id="L-Novice-Magician"><a href="#L-Novice-Magician" class="headerlink" title="L. Novice Magician"></a>L. Novice Magician</h2><p>首先，若 $\sum b_i$ 不被 $2^{n-1}$ 整除，那么无解。</p>
<p>将 $2,4,6,\cdots$ 这些随便分配到要操作的数中。</p>
<p>那么，每次操作相当于给一半的数加 $x$。</p>
<p>那么相当于要构造一个 $2^n\times 2^n$ 的矩阵 $A$，使得每一行中恰好有一半的是 $1$，一半是 $0$。满足 $xA=b’$ 有整数解，其中 $x,b’ $ 是 $1\times 2^n$ 的矩阵。</p>
<p>若 $A$ 必须有逆，则可以直接求出来。也就是这 $2^n$ 个向量线性无关。</p>
<p>可以如下构造（$n=3$）：</p>
<p>$$<br>A = \begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp;  &amp;  &amp;  &amp; \\<br> &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp;  &amp;  &amp; \\<br> &amp;  &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp;  &amp; \\<br> &amp;  &amp;  &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; \\<br>1 &amp; 1 &amp; 1 &amp;  &amp;  &amp;  &amp;  &amp; 1\\<br> &amp; 1 &amp; 1 &amp; 1 &amp;  &amp;  &amp;  &amp; 1\\<br> &amp;  &amp; 1 &amp; 1 &amp; 1 &amp;  &amp;  &amp; 1\\<br> &amp;  &amp;  &amp; 1 &amp; 1 &amp; 1 &amp;  &amp; 1<br>\end{bmatrix}<br>$$</p>
<p>这样就一定有逆元，打表找找逆元的规律就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2050</span>;</span><br><span class="line"><span class="type">int</span> f[N][N],a[N];</span><br><span class="line"><span class="type">bool</span> b[N][N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> m = (<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m) &#123;</span><br><span class="line">        <span class="built_in">read</span>(a[i]);</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum % (m/<span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m/<span class="number">2</span>)</span><br><span class="line">            a[i+j] -= <span class="number">2</span>*j,b[i][i+j] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m/<span class="number">2</span><span class="number">-1</span>)</span><br><span class="line">            a[i+j] -= <span class="number">2</span>*j,b[i+(m/<span class="number">2</span>)][i+j] = <span class="number">1</span>;</span><br><span class="line">        a[m<span class="number">-1</span>] -= (m<span class="number">-2</span>);</span><br><span class="line">        b[i+(m/<span class="number">2</span>)][m<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m/<span class="number">2</span><span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==i||j-(m/<span class="number">2</span><span class="number">-1</span>)==i)</span><br><span class="line">                ans[i] += <span class="number">1ll</span> * ((m/<span class="number">2</span>)<span class="number">-1</span>) * a[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i] -= a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[m/<span class="number">2</span><span class="number">-1</span>] = <span class="number">1ll</span> * (m/<span class="number">2</span>) * a[m<span class="number">-2</span>];</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>==i||j-(m/<span class="number">2</span><span class="number">-1</span>)==i)</span><br><span class="line">                ans[i+(m/<span class="number">2</span>)] -= <span class="number">1ll</span> * ((m/<span class="number">2</span>)<span class="number">-1</span>) * a[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans[i+(m/<span class="number">2</span>)] += a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m) ans[i] /= (m/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n%d\n&quot;</span>,m);</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans[i]);</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m)</span><br><span class="line">            <span class="keyword">if</span>(b[i][j])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M-String-Master"><a href="#M-String-Master" class="headerlink" title="M. String Master"></a>M. String Master</h2><p>为了让字典序最大，我们需要让一尽可能地多。</p>
<p>先去掉一些边边角角的情况。</p>
<p>然后考虑枚举开始时二进制的长度 $i$，枚举从第 $j$ 位开始。贪心，从 $j$ 开始选，为了字典序最大，我们要使得 $j\sim 0$ 位都是 $1$。</p>
<p>然后写一堆比较函数之类的就ok了。</p>
<p>```c++<br>const int M = 59;</p>
<p>struct node{<br>    ll n;<br>    int l,p;<br>    node() {n=p=0; l=1;}<br>    node(ll _n,int _l,int _p) {n=_n,l=_l,p=_p;}<br>    inline bool x() {return (n&gt;&gt;(l-p-1))&1;}<br>    friend inline bool operator&lt;(const node &amp;A,const node &amp;B) {<br>        if(A.n!=B.n)<br>            return A.n&lt;B.n;<br>        return A.p&lt;B.p;<br>    }<br>    friend inline bool operator&gt;(const node &amp;A,const node &amp;B) {<br>        if(A.n!=B.n)<br>            return A.n&gt;B.n;<br>        return A.p&gt;B.p;<br>    }</p>
<pre><code>inline void set(ll x) &#123;
    if(x == 0) &#123;
        return;
    &#125;
    ll sum = 0;
    fo(i,1,M) &#123;
        ll tmp = (1ll&lt;&lt;i) - (1ll&lt;&lt;(i-1));
        if(i==1) tmp++;
        if(sum + tmp * i &gt; x) &#123;
            l = i; break;
        &#125;
        sum += tmp * i;
    &#125;
    sum = x-sum;
    n = ((l==1)?0:(1ll&lt;&lt;(l-1))) + (sum/l);
    p = sum % l;
&#125;
inline ll get() &#123;
    if(l==1)
        return n;
    ll sum = 1;
    ff(i,1,l)
        sum += 1ll * ((1ll&lt;&lt;i) - (1ll&lt;&lt;(i-1))) * i;
    return sum + (n - (1ll&lt;&lt;(l-1))) * l + p;
&#125;
inline void nxt() &#123;
    p++;
    if(p!=l)
        return;
    p = 0; n++;
    if(lowbit(n) == n &amp;&amp; n != 1) &#123;
        l++;
    &#125;
&#125;</code></pre><p>};</p>
<p>inline bool cmp(node A,node B,int n) {<br>    if(A.n &lt; 0)<br>        return 0;<br>    fo(i,1,n) {<br>        if(A.x() != B.x())<br>            return A.x() &gt; B.x();<br>        A.nxt(); B.nxt();<br>    }<br>    return 0;<br>}<br>inline void print(node A,int n) {<br>    ff(i,0,n)<br>        putchar(A.x()+’0’),A.nxt();<br>    putchar(‘\n’);<br>}</p>
<p>inline void work(ll l,ll r,int n) {<br>    node L,R,ans={-1,-1,-1},x;<br>    for(ll i = l;i &lt;= min(10ll,r);i ++) {<br>        x.set(i);<br>        ans = cmp(ans,x,n)?ans:x;<br>    }<br>    for(ll i = max(r-M,l);i &lt;= r; i++) {<br>        x.set(i);<br>        ans = cmp(ans,x,n)?ans:x;<br>    }</p>
<pre><code>l = max(11ll,l);
L.set(l); R.set(r);
fo(i,2,M) &#123;
    node nl = &#123;1ll&lt;&lt;(i-1), i, 0&#125;, nr = &#123;(1ll&lt;&lt;i)-1, i, i-1&#125;;
    if(nl&gt;R || nr&lt;L)
        continue;
    if(nl &lt; L) nl = L;
    if(nr &gt; R) nr = R;
    ff(j,0,i) &#123;
        ll tmp = 1ll&lt;&lt;(j+1);
        x = &#123;nr.n|(tmp-1), i, i-1-j&#125;;
        if(x &gt; nr) x.n -= tmp;
        if(!(x&lt;nl)) ans = cmp(ans,x,n)?ans:x;
    &#125;
&#125;
print(ans,n);</code></pre><p>}</p>
<p>int main() {<br>    CASES {<br>        ll l,r;<br>        int n;<br>        read(l,r,n);<br>        work(l-1,r-n,n);<br>    }<br>    return 0;<br>}</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>dfs</tag>
        <tag>状压DP</tag>
        <tag>线性代数</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 CCPC 桂林站</title>
    <url>/2022/11/10/2022-CCPC-%E6%A1%82%E6%9E%97%E7%AB%99/</url>
    <content><![CDATA[<p>2022CCPC桂林站。</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>百度之星2022复赛题解</title>
    <url>/2022/09/15/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F2022%E5%A4%8D%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>Astar2022 复赛 Solution.</p>
<span id="more"></span>

<h2 id="A-子序列"><a href="#A-子序列" class="headerlink" title="A. 子序列"></a>A. 子序列</h2><p>签到题。</p>
<p>显然，前面的递增条件完全没用。</p>
<p>答案就是所有数加起来。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="B-分组"><a href="#B-分组" class="headerlink" title="B. 分组"></a>B. 分组</h2><p>简单树形DP。</p>
<p>设 $f_{i,j,k}$ 表示以 $i$ 为根的子树中，与 $i$ 相连的连通块中，所有点与 $i$ 的最大距离为 $j$，连通块大小为 $k$ 的方案数。枚举与 $i$ 相连的每个点，选择是否与 $i$ 合并，然后DP即可。</p>
<p>时间复杂度 $O(nkm)$。</p>
<h2 id="C-最大值"><a href="#C-最大值" class="headerlink" title="C. 最大值"></a>C. 最大值</h2><p>本题是本场比赛通过人数第二多的题。</p>
<p>答案即为 $n\times \sum_{i=1}^mi^{n-1}$。</p>
<p>当 $m\le B$ 时，暴力。时间复杂度 $O(m\log n)$。</p>
<p>当 $m&gt;B$ 时，拉格朗日插值，或者求出伯努利数或第二类斯特林数算自然数幂和即可。时间复杂度 $O(n\log n)$。</p>
<p>取 $B=\sqrt{nm}$，时间复杂度 $O(\sqrt{nm}\log n)$。可适当调整块大小。</p>
<h2 id="D-子序列2"><a href="#D-子序列2" class="headerlink" title="D. 子序列2"></a>D. 子序列2</h2><p>将询问按 $k$ 从小到大排序，设 $f_{l,r,0/1,1/1}$ 表示区间 $[l,r]$ 内子序列的开头是否 $&lt;k$ ，结尾是否 $&lt;k$ 的方案数。</p>
<p>动态DP，用线段树维护矩阵转移即可。</p>
<p>时间复杂度 $O((n+m)\log n)$。</p>
<h2 id="E-项链"><a href="#E-项链" class="headerlink" title="E. 项链"></a>E. 项链</h2><p>设字符串总长为 $k$。</p>
<p>由 Polya 定理，答案为 $g(n)=\frac{\sum_{d|n}f(\frac{n}{d})\varphi(d)}{n}$。</p>
<p>其中 $f(m)$ 表示长度为 $m$ 的环，没有循环同构的答案。</p>
<p>可以发现，求出所有的 $f(m)$ 后，预处理欧拉函数</p>
<p>考虑反面，我们算出所有的不是好串的串。</p>
<p>那么建出所有串的Trie树，并构造出AC自动机。那么题目相当于在AC自动机上跳，不经过某个串的结尾的情况。</p>
<p>假设最后AC自动机在节点 $k$ 结束。因为有环，我们可以从一开始直接从节点 $k$ 开始走，然后最后必须在 $k$ 这里结束。</p>
<p>算出这个AC自动机的转移矩阵 $A$，可以发现，对于 $f(m)$，最终就是要求转移矩阵 $A$ 的 $m$ 次方的迹 $\text{tr}(A^m)$，即 $(A^m)<em>{1,1}+(A^m)</em>{2,2}+\cdots $。</p>
<p>直接算，复杂度 $O(n\times k^3)$，不足以通过。</p>
<p>可以使用以下的方法处理：</p>
<ul>
<li>设 $w=\lfloor \sqrt{n} \rfloor$，预处理出：$A^0\sim A^w-1,A^{1\times w}\sim A^{\lceil \frac{n}{w} \rceil}\times w$，即可用 $O(k^2)$ 算出 $A^m$ 的迹。总的时间复杂度 $O(\sqrt{n}k^3+nk^2)$。</li>
</ul>
<p>需要注意，当 $m$ 比较小时，不能将 $&gt; m$ 的字符串扔进AC自动机里。</p>
<p>那么对于 $m\le 50$ 的答案，可以选择暴力重构AC自动机去计算 $f(m)$。</p>
<p>然后狄利克雷卷积算出所有的 $g$ 即可。总的时间复杂度 $O(nk^2+\sqrt{n}k^3+n\log n)$，足以通过本题。</p>
<h2 id="F-字符串"><a href="#F-字符串" class="headerlink" title="F. 字符串"></a>F. 字符串</h2><p>建出SA，将 height数组按 $\geq k$ 的点分成若干<strong>段</strong>。</p>
<p>设 $f(m)=2^m-m-1$。</p>
<p>对于每个区间 $[l,r]$，设区间内的所有后缀在某个<strong>段</strong>里的个数是 $m$，那么其答案为所有这些<strong>段</strong>的 $f(m)$ 值的和。</p>
<p>莫队，维护这些和即可。</p>
<p>时间复杂度 $O(n\log n+n\sqrt{m})$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Lesnoe Ozero 2016. BSUIR Open 2016 Finals</title>
    <url>/2022/09/15/Lesnoe-Ozero-2016-BSUIR-Open-2016-Finals/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7f1849bd4adc171d6df387090e21daf6d5ae611835e6cd8b34330634ca27cf55">99251fdceb9fe96a1f47814acd3007f0549d00b65887b9d96eb4be82b779c0f6dad6de155bf63a8fb5092abfc1dfc5a0794f643eb79e80d19b99a78cb1be37dbd70a13f86dd3e85dea8a8fd4581e12df2320644033198c4530778ccccf3b668afb745f9638f5db60c72abd3b25ec8a3fcb24c5a007d3fb94666ea2f0516af1332c29f906880ae16810c899200bb4f6f1c206579829b4b29846eeafdc10f61111e8b39f58ece9bc3f25d1a7d4f27580f2569646d1fb82a9b350d05d119b048d66ec10c2d88e288146e05a9cfa3b7970026bbf432e1f2c862e1061ba0e943248668116e6f75ea870ddd2f3e5b32c402effe711511e4527da73a40cd53113a9f24b02df64abcaa23a54128dea87c683f3b4a47fc045a4f230d65544b08b845a173edabc23686d28f7cd85a4c6c80b477a05ffd0f20a23332a33d9c5a434700ea8f788090b383952d3511d4bfbb7b36ef95f4a464f213432d4ce9c2618de59c9fedc6f2fa9a76f695808b58dd0cd706e89f30f1f7a8c7a2b009621b0bfda7ddd92ad22667edc89083ff4c322d0598b0532a6c1afbb969f70008a24d92ad2cba70c4510048e4d0ac6377a36f16c363e5eb81f5d90da0fdca87d8683715509b49e71b5278d4187761853c27693a1d453fb996215882d0017d90707eb993badb5cbcfea60ac07fbf04604e812ffb65867c27cc0863864409ffff625f4ed4f565a106a7c6ca1e655ae8bafe4538d7f22427d46dfdbd6dce25e79684a6b570844033cbca5f34fca41cbcc047776480aecf30c2764afc4b8bc9ff3fc20f0cbdf7ef4fd07a4a636505338dd3b39745791dfc92cb151af9388a162235af4fd31357f5c9169ea7692e5b1870cd79bab367f7f4e14f99553752113ede49c501e0013107b345d3d1d02d3658b468e11ebaadca437924423323cbd7a08340b4e56fd382d6f4b1cef9a35b4bd08c004a5277cc4150213bfed37048aa84ee35d5af9517bde5d59d4640c5b803edd0c40d8ccd2276d16c5bf5f66a6c13bfff5adae517aa3b6d464508691c5281234d1068150ef4af542b407fdf6df3fb39c49e4e5118c938613fcde34b78018ceeb2badebbc0528b18eaa0b8bb719223397ac2f4b168ae2fdd8fb8c96d0c3d702b7181f531712507be9a39a9da1a1cfd86d60371f8bb4411cbf120f1d7e8567c785ba4946b7e0b072016e29d75c7a8190e4780b1667e6bbc2e00f825ff8dbb5e22888608b37a34766d36e0a9626cfa655652ff772bba1376a1cbf9b217e24160d4b062a1f9a088f2b2b021034f8174bb61827e5dc44acecdb75d53d50aa0ff95f361202a3228a7dbc22862158e0386f9063ea353134f4224277bd3ebc2cf1949d2d7e9f5e3f61034796b7906608f81164c602fb8c9fb8d4a8b9a78d6d614d5f57a9b707586d303613fef753582564b16a73099748114e80a4df97085cc4f907a9210c30b16747be14027b7605c2183edad9ed4c1fd085bdd646721a3f54e7c7bac35145c3f79dc26866235904bb2cf2542b684081bacb5be367fd6c3cabbf86f279764d528d7d99973c7380f53879f0682c2c32a32be62fb8758108fbe34d87e510f175af55b4b3baf333a1306f6e2259e94fac5298262cc966b0b78a3d73486da93c7c5d5049d4e92517a0edf39690529360c5afb4f6b654537d12102ae215b62d6145bb95cd4afcde2e530ad7a175a7ff83b5ef4bfdbfe3ed7e5b32a115f285d599babc109f966e22c9f82ee06f57f87a6d9bfa52cd663291ed7f4afb9ee37a9df150717c30dc7b4ecad01efa0409ad8b0ce2b5f81be8bbd4ce2a52a8d186ba97c45570ff24d07153808cfa4a82542db4351f33c196d8940235aeae4a7c1c4bc81cbf6d77059083cb3cf34d3bc0aaed5f04ce6685379777f3fcf1ae437866c51e7d6e3494fa2e34a4401977e9650ee7bae6b83fbe8c21a810d505830c633818e49ea6c656150ee03bd1c06c4d5000d613f921fdd936760995b4fcbd8a52f1e6f552cadda0e07235a7ac78a49929c9b914dab3b9ad68125b472513dc21d2faaaf8c1ef054adb6c21b7931669cd8f48707e8f454926a3b16cc188ef885cca7effec9deda386cd0c89f748003df239ec2ecd65297737a661d25fb4ff724303fb4e970da719d8cf2657319edebb6cc47a5043328d12871168b62a22c856a5f5c46631ce5a2f96b829cc7b6cf43d02c8e04ecd27277bc04668f9f434b0c2eb2e7b4f39bf67bd32d7ec2fb1400b4c18e99f703ccf816dd952a82bd1abb43e3b6ae978a26efeb7848e9c56dcc1ce45295f17ef1e97eacc8e207ad570b93b2336dc5608f10bfb14579c9fea177f1f5dd449b028fb1a2aa77edc6544faf0e592bbadfd7ff2e1c80a75469f19cd1fe99fd2325818dde66c6ea0a145a61873cd27b22dd649ef19714a8d5b6b9cea8feceefccbaf24d10f381b85e10b201c687e623458421d84e8204b61392fba4c2f6b85daded397f5a1312dea6fc97a2d278a1f5abd136323e5b481aa6fc3379d607a2e1170bb001c4a29d77d6da9b6d17916cf63f029066ab3d08065a7b0f5ba3eed214427c3237e7d77a275099c196ca82fa5f4d3ae9d054638d110171886db916351378518576e106ca1a1e92da1913dc22992e9c76aa2ba71cf342c02bcec7254b25f8b5112527bc5543f8de25946a933b827db7d98c750b01ddc8e246cc1249a61cfc184c5e278603f00afb843eecebc183d64fe0ba23fb6e25498150aaf0dcb96fa245e6d0ee7f1ff0c7842d2fad28de4d0145b370c832e6826642a217687970b59caeb6724cade6ec16843a6a7fd0a81e5be979f6d86b5428fc150e08c2dfba1719b414bad78257404cef6ae4887793fde55dd59e4d5ee1efa0cdd3d8464cbbf7982ba21931563d6a1fc820d421d17bf75ec2c9830af3b99a1a9828b2529bf1f9be2ce1716ea7c7602a3d2fc6a231f17ca33227261ba9bd4317a0f9e267fb3fccbab27cc32ebad35ecffdf33d0a80888faf0ab8ee10f900e22886113a42f9b9b006b54afbda40b30d1de8cd89262b9aa32b438fc778bdce6bdc5a929bf81b0c45ab855a5729de50af80d4ccf2b60a6f7bba4ca7ac2c0dae9e86ffe7e63a39cd0a6491c684d919e908523796d4d5f97612d6f248a49baf005e2fa8f6a442ef0bc43ae06ff38a6d1e1a1fdcf533ed8a2dca5f4d348a9570b7c2b6ba897d8abc003ac9454a4dee56b6f7911fb2c14950415c2f741acf614b90b06c1de19d8cb3e16850f7795d5b28c0a25d89abd1fa0322381c2ac28624fdf01a5a8618f421026d81696568837106d67310512d6a2b6b6619860a7524bab2759cc5f5f52f89e580154d94d3103248ef5aed0eea409fb0aad2849670e147be5e721b509d5f5abcce507ff08c3a92f0840e64f5cf429674c85b8d74efc715efdc4f9b22411bb6c14ee5df6d75dea100357b5c8be11ece98a81642864144a828697f86f744349da7ccf9ea24ae68099e3f560ab9f4fb262b06336fd74a86e28a5a47125ce44ef4db1901b97c131d3ee20800539b9d9f3d2f52976958e9fc0b299c4c7625f8cadf0d3fc11f473cbb47d14da1ea9062ce8fec70322b73c658606ef4bc1f3197f134dc3b0298c0aa36ad2d8f7a9154b9a59564a89845d7dc2f1b32887d16c268ec788c67caec88bd63d22d2a70590b53a0dbb5b3d0ae3d910a985aa7303ce8acff6f2facaf3ef5b315aad7b7bad91a08b1993915c4c1f6c21a37e1227d1348576da6b0e3775db4a6d460644dee01f66673b7a40554621ae4a255fd9e7e8c2d45016d1c83cd0ec88742e4d9deb2de6af42db3191aa653e6d7090031f7ba17c836281d6bae3684cdbf623cd1e57997288f939c90eff25da1d89e681810ccde2f26fc8f4c8b3148f576573e4698ac8fd6facd49e1b2379abf9d4985ba71f1f3ae2a526718290589dd90b6841dc76f0b9363ad3b1ab9ba4796228ea56a94027cb08203f093c3e2c3ea105be2471937eb6394b6b997723a5ec29f526b572e80eb8a5ad728f3378f7b75c652151567705fa218a7140460773817691e43ab7086a562eed8762d3c276c689fde83e02033623edbbad220346fb9d14646a38323bfa4544e289de56dac3adce21d4e43e7c780f294c75be8d6d70f2f0618a93fd7ab57a2d95a188fc329181815eb249464059c714e2bd098c5625e6bb2e0b26bb418df6c28fd13722f817a99697c9da9146c995b658e4d3c8bd3c27b3d7af23f9fc1f6a4518d6ac57e2688b4762874902c1d9a8ca1a356e0336d6e11f3c4a490bfa3cfcf4998efa573ac0147f9643075dd1448a5c4f41d9fcc857809e336b200515e9cbcadac3f7c2c0cee2d692345dd73c4232a4596d395e2dab51a4344101057b256211a078533eb606d4f669938b7a83eee50c1148d62b5c08506729235d656e757711754dc2c9904f752cd88c78e3cf1b14c53071f31aead62cf5b132a1255fa4914f7cc6aff5cac1fc4a0738444745b7fd7ebe6ef9175c2f498c8cadc48d6a51b293c9715bda921026a80256d7ed93fcc907cb133a2e4ee26ca2371aeee1d3f844a1dfa4aca1c2a6ee706f8461a623bfc9f14d79f83ebdd222c74db48bb5b28f8017ac925788e56d409377a627abcafb957b717d4e862fae745b8351d2b3f8fc29c5e84cd1911b01cb7bf4f926228c6948da868a19b50cba999773afdc1f7cfb3897b4f9963e6a5563dd80d2443e37666dbe0e63e8642a96ce1628e4a5d3e1fd22ee08fb0a0b1a2ff17e8fede3c94d6a1a98e49ad06dd4b292f836eac256e47ddc8aea88bf538706902cfc68193c722a403415491baf916a6eb765a96474eb106c0563bf66a5aa3f8b2e463b9a76806e3696150ddda21a50994cd3620c4b51be1599b2425c5e39dcb3e5ee60c4dcdeec1b23b4c82282a9b534e8472b4696d96b0033fac6a2d1ec975985dd7e2972bf28d8719c7bd2f4590da66a99153444ee4eda27988f9692517018a05ee02a1e2a74554e5d99135004f36f06ad339e225ff7f12f8537a61ec692a3e12ae397e8e7c5bca863351d9813bcbb5d7d7290ed4ae5bfd4ed6557a5f91a91f9b5f9ad9148dc6e90d1cff14509684e4bfca5fe4efd6f0f47588bcce0b2a6120a4c314ea720ae6d624b49660aaf4bd7222d0cde8878ac344deaf7fe368c0517313dfb92f3262fe9a41ebe4d1c7621ad9eb3197f64ab38f4c4eef4f6e6ab606db7923d387aaf54cb9e77f25f3ae007f9c480aa6aa44d0961e18f39af0f83408f351693fbba8aba70597c857bd255cd7fcb373ac90f80f0eed915ab211fb0332d79360e825153317f74a0c6eba4fe9213dd31ec7f5deffdab6ac610ae277fb26b6afd6c1d74419b8bac88673dddcf23f707e12c8eeb7e7e5dd777769b82c49fa9b2e6c29e91a17841d04281523e6198b737527029892cf3caefdb2d24f982505bc851e4860495927d6c5ba590c424d046c2d4468d562b6b88b6900d5f5b4f8d0e1fc7a1b93a0599ad18b2e93a252eaa2b3e29cf06483ff6472db54e97fd069aa9fb7311a0c170c35c007dd26444fff173c71cbfa42f294469bdadf993219f78707e5eb10587ba5636f07dfea93a1d5ebd36a1578f36d5d4a801e96e73869cedd9cd3757ef308360a85f5dbfe9c78a81273f6b3762cda69433bbef612f01a8bb30d812ef055a328d012633ff3049e412243c3e6b3d186d8d484e2d0ee7fd9b1b5a85afa11a9dedc18627131eb3bbd18aac8a7830bac6faac924b24f967148718debb3d0aa7ffafb80d8e87f45a58745c0bd717a660335cd930913536fdb2a6d85397429b726cc44d862d4e107ede2f9b7efee4701a3302b598b1dbd5e2675a376129de0949205345ae926cac9564f865ef77ffd51db8238361bc89b9e6b22a34a6de3eb3b3daa2080f451bfbdad77cde8c8c6e74c80bbffd90e1b3c7ae8a9af517696781b07b6ef7956066b03ecc2d3d01eaf57af884dba919089d1d25f1b8236c6c1c7ddb5405460f3f201d818506d8870ad72229c06332348e042c8e8070d3a1d60127a9220ccbaab4439d6fad706b429cc0365f0699609055f2a776b599c820a7ef35d72c0dc02e96d93f26b9e2880fe3d2ae60f81c9c0c10171be8caa6b80c2b931dd5e52caea15dff6a9bc7db5a13247e805c52be7ce4a99327034bd6d9223b09d376579da10ca108b8335cf9fcac2571972755d364dbcaa13cbeb7fd372010d8f612decb1857a07afdee51a248a0ceaba96cb790f75e921246c3a6a41583fb8ebef26d38337f658fc474563f5a2b6c4b909d5675f5c5c9e4580fc4f64769330395ee723fc08ff1e0a1a4884d959ba5c4de72fd772d19fa5094e4ca42dd49bc6f23420d4a65ac1f3a71843a840e6808bddafb009f6b1b9192bc57818e55c377a74008ed5f59e4fb2e07d3c1d0dda12f25bdb8c7bc2de695cf96526c455a98c65600ff0503226aeacd3ea4bf86d49a46670c9b8d90c8cc6faf1c43ac9a6fc27c16395a21bc7e7d03577b60c91f1b6f2f3fa4ff6fdfe83c0f4d59c3b6ed1bcb45c1b928e4415d435935c8c8b233c6ad36913932272170cd1d89658720f8b5c588a5004abf468b48a40ed9e9855bd5359c5a5c042836caca8689cf5dbceff4e4e6bd9228e469ab41a7282ec353527bb6662ab2039e75d9de1c7fde28fc6ae8fb8440a866cce767e6327c6b2b8061761fa413292b587144c497b81cc87ac7d4fdd42fca35b06528f8cd174065e1f0fc39fba98cb0522ee79aff9e93c0f760bcd33fec6dcf27a45ac19105cabd8e1a7ddeb177dcbd396076378491dce17093337afa79d760437ed1547f535677d82b785defb2f0f886c4bea3dc78ff559787933ff896f32f37f87b45e82f3598cc5342e7676696bee1b45ad0a94e218e1ee7aece65777cfda6298645e1a61e6f0f14cfc9556c8016fad8e2694560c2748a414f882d59b532a0621f6f659d96b2e7e07d86b23df0b837ef5857313bf5e4c3ceb473f12c5884d98883c4d0132da8a982a20d7ed0a889a78d3473ad3a358c8f94eaa5a7f0ef14b78b39ee9c0041ea72d67a8d7c2083fe0c271059a02a6cd5d587aaa4054f664dfb1fd9306ef3456942862880d5e7b524da784df41491cbe29888ed5497cff77782ef9c48e1e4e4f58972ed9a62ebb49b1d4c57c53a7da2f537ea460e52a15204ef9ac22234b2ca0d9825544007e67c5678d2dc471f9a004a59324568f14a9c2517850dde9ef308e24f37a9a69f60e9f9948f352b8f6c1387b53cc724c89662ef907976312f53ecb5f5afff2c7e88052c160c6f841851f548356af25500219c8075c9465d59a3bea0ca6a59ed386cbd2ed23211fe60a8d81f556597dbeb9063ac00996fdeefd91f5b2324100caba57828c77524acba12004bfa893daa7ee11122b558635503b7a587ba11497d98aa40a4d8e055bc865de0dadb32c0f49e7e050e7b922f89e667dd1c84a94a3aa3d52dc51724d1089783b2bfff7a2245d91bcc0c046cbf6f21bfbd6d78c1137f033ce8a61baf35ebf8c2ac083b0c739644bf21ac6add97b41a376e2ffe7cc52b0d70b0f3de5cd3573de9c69cc1388196048c13e4346bee1cbaf5360bd3ce609a69370a3d7b00afd87d9f6e3827ba5984f195c3235db274b4c2861bc571294e19e32c400093fd9dc148a953d896b02e394b8255e4970076835d2befdc7ac6aa8f60d74f7c740771f49e11e0766a1593169fc4585d8f4dd6db28854d10f1383eea4850855ede210cc786a8b289c24267a24770c45a6a56c04b0bd4c093e63a8e0bba9ac1ebbf17d25b0f14e6c1140e3cbbfd2d24bcf5041ee24a936587351b5789d245e9f3e9fb339bcbd50c53b919e395875e93a7570e5e34cc811ebea38829facadf3b8b95cc72a173412098c1e9f4e1f965797cc93147f32f293d077fd920cd2d2088d31b1fbdb1bbc05e8ae29656442369ce3076b1aa7197ee3633452b5c95ee32bef1ebedf8dc05da13b76519216b7f68dbddbce69e4002e248124501d4ba3c3ed966d8652e4957dffa273dc8aaf2182d7bc236e053ee91e1391608b2a2b4d41adcfc3f2ec5061406c5c6a64bf4bbcd7520d6e10804703caacf4d54072c396df357e146e31e222fb6420373dbbd98171501f54ace0c701ab53d4ed1e85722f7b93f00db8981ea1f55c0f6e12849c569f1fc14d26f41021743c29996cb9375959f060d2c857bcecbcdd7e060aacb6ef632b85ac14805a55fa3e9d697d7689c30ce04cc0c0ab26e4da7c1f37dd6a64776d83e8dfcbc1c5dad5eff952978a0c14afc764982be77dd57bbb3916d7c7c1df2dacc9954850f21d77e94b1e4307a22528e10bc973449ff0e4a4d5f10f949f58c43fddbcdb23cc8833aebfe8724049418f916151b70d737ee1931bd65f99e6b179648298e77c221bf0dcb6e7ff06e5bf059aff7110f8a7035ba0eb027e0ae234e4095989d3c46f1995c1ce50dff591216f8569f8666dba0272c1145af012f537aa1bfda8683eb7afbba0c9c3dd95a65bc1cb98d8dd5184a2c3c15c41c55c901ff17f5be0746f30180dc264823c44b5134c283e816950b058f1c9e3f341ef9e9d444e22b825ec73788e3ebacc97e3ac94aeaf6edda8e16624c231891b54268b9bb5635a25d7c28956400ca765a2b09003414f793f50509e8ebdb64c12b4b965c0d011f0d8edeaa9e8d70033665314ff2b226535b57237a6896955038f3efd1dac8b8cfe3acff7344f308cc27cb5669b5ec78e7514d957d62bedfe4d4136cd96dd76d596e9fecdeb11d53ab465dac38fc50d532173143e34652c986177c46d9b2a6f04e9b5971c9b4cd7ad857037bc3fff64cecddde2430ec7caedbb22adda02b397b3132fa4ffaedc2217967180835d1e96b9c6ed6ace32c8e6d71bf5e1cf2b9d32dbef9537e32cb1d02f4a3fcfcce4f4b33111473d51f7ef2b544d58d79cca69aec06f1610ad55d3e856c4ffbe80b5e128d53443d52e8ee897dabfa386fc7d664134a69d098fc748def7d6cb47f54b19862fa8dbf80a2977a14edcdf4fa0839865c6b834157c42490cf746017a22f515961585736db02e010287f780cfe7a3478deb54f856cc7fc826bc428f49dc3919f72368a9ff868f250ac5972610150c55fffe19acb03ec8c7976f1af9404cfa3e437f7f33fb4c3f5a46e1830a1153dc62ecda3c1343c150646927987e49d8a6e5f900653705ed304ede47add36ec2a96f6de900212fe3e8ca086077df0ab9ac957cc33b82a16bef3c28fd5cf098dc27173a0c53571f8f9fb953f84b8bf2cddb2a782075f00946b025cd222cb1fb22b2e53bf16955b1436f2782a79bd13964b0df7be756b78749ac835bb0240b1157453d5db536031694b3f2a26ba88116b074539061cd0b6078439722ff999dc003723c2d05f2c61fd3e367e556c49d28591ab40cdc0075e436002abb929de6d5078a0e8878a76919b78cdb5c1076e13e58b5d736a29b67e155c62df4189547692edca2b343d61e9baa68a62bc2f1b024651e80cbde53f49288c0b0b8d064112185938383a54b7cd17bbc10c2647eea369a51931c47bae3e72eddf7616ff34208ee31c10c6de3bebb38217edcc344eb1c44eadeed225e37d555b8861e576c1ebadccfc5f26b39458e56c299fc0e5b2b088159d4c9a0aec4f45be07e3a8e3f54e3e31b4c485ee88b30349ff78509048b0f5224746eed101f75886b4d4f7838b7df22cd329d5cd7f5506b74e930bb4259b9b46dcdc221b5c64073c2c8ce454c281cdd3b978ed68a801d481fcb59d76f5e9aaafab33d9b37a211889df8c708fb9d1b99866e3dd124663c4b233b67083075e8a2f0ec5a3126ccfd337bdea854abb9ceff94bdfc83229ca17f442cc50f563b431e4d89308df23c8e1e906185b5114e9835b7db4481ae9bf28ba05a18ab3b1262b982943409af9d6af7fef090a127df6a4b5de8c86e346f68c47b703333a34832005aca8597101e43d3c6972e673c4c2366249bf4e16c1f265b0b2fa176f0a2376a5d46a67b69b6798c9925e2ab588d913b49a4e2010f25405d91a1e38dacc76280324b64bce0213464fc4e9242b5934a11db3d9dee9ded5618186df46aaf8d5ddce1aeec4fba79e1e2481f9013a94ecb8a8709b4cc70cd8b8d1c3cd8f2eabe8097177011c984a37c0147662f5f71f0c4425bd9c56486ee7466ea8c87a2faa6b90a976c825b3c785b300bd844a0115f39d5c8d0d4a3c15a0ac385ff9f088f044c01f89aff779a7262a843e3b07dca8540c11393af667016426239d5e59651465eaeebef7f5395359f979bd2864ac329587c62144dd057bf9648a1507b23c9865af8fe110191ffbc03a97e5d00ec9772383d50a0ecccb7061928baa8f05b304d3a814584c863ed8f0d98c59b5a37eaad1dc72e0e17f4e2ba648c561607109e57ddf1eb005435d7a407d06b4d66a74b838b4f8ccad7759a0e69bd1bab6fd5a35e532950869c59bce8b8d42b2c5cfcc28fab90efe3c47b7799d2add01ba7a3659418b4b7a37d3e69d144dcdaf9d15e94f11e88eb3c14fd2820bbee2496d8dd27002eb85ad3ca1ce7587c7bd807a5b87cd01e348b9519ac2be43f6d3162e3bea20340e2456e1f2751ce00e606410a2e2fb53851c667f37a9692c6e0bf95ce8128be2e3067524c3b21315454079488794d0e536f5a7ec047ebbbb54ed63fba57467307a0c08283d7b09edd3eed900ed31ac51402b5a4a8a8fd09eec2ce36bc1ba9b66d9801fbd87f63bdd2dbbea4cbc4efba76faa1564acc7622f6a72d66db04c517c637236a901c4552ae601a692f2a26b1efad903fa267daa45e08ac54aef1e0db761171b6249e0e47c4426e7411aee9a055c719818629722ca504000a201f1a2a8f1b58b0e435b9fa075afd56c3086694f38f8fc1d5dbf3f6710047b0ec55235134dccd2d90786faf26378c70bf1bc6f84a05a25ca6f7950b0851d6d17220cce3709039cfa8877ecc0444ccd530638cf15a71e27faf6e0e2878f16be5d300c61596e0b794ee6fe0611f32eb39cb294d299fbcbeb2d7e006109fc55bd47a844deee62884db0a4b92b87cfa5267ecd4337b2bbcf85ec13f4cffc277715878ad1f67f73dcdb9c47bcd74987b4e0beecc8823c4b26ef756fd7f42af1110f0e42582466de3c3f077140efd92972c4b873ab4adc0479dff5ebac1dae9c3afcc5da2a8d2d4520ce2e9384169e62ed5cff52b04649726e75494bed1bf20b4b168b673dfa3f840d4d207949c8c38a52bc66139fa02a24f7abf849727b7b3562f969f0db5197960d1544fd37fc0d5ab413f51dd2af5f3a5cd13192a3bd9176d13aeace210fc8d950cdd58d8ef4abb9f064879529900dace1b26db5a90beb7bfd77954af61049bce100697ff91fa886f1f8d91e02257d866f5fc84f89dfe68f5173bc59b83636eefdaffb66acdb53158f6414cd43c0aed42a3d0dc75abcba2c574a5283f7c5575d8065d6e16b7d544aaea242f942898744724cea5f95f9298136fb4edd614f334f971bafb22a0a16e7c793db64b817ff6b18f61f2a3db8f11d652781c74b46bf35ae135087f2dd556d642543559eb44c4f46fe98ccc76423969337903953a3121db4f7957cbd7af8012753b9760a7dcf5e548efa9ab6ae13bad10bbb51ecbf601210ee768f027fc307d354d5717dd103285464090033f2eba2124176c7e3e702af4f4f1a7c477cb1faa28730fc00a3824598bb3d56bb82c22e6665e51bae9210fb378febb3ed96819fac8772092ed22ded3c264b98b2b6471aa6b39dce885f87c6e3b4d0281d8687fdb3421926bc024f239f63adeb1d4a56ba741dfb48804c547580938236b652fc639959b8d28dba6c8c5c5978ed31444d34e3630f47981c398b97f4c3be3cdde768fb8ef1d808038e98a6e0e2efcf8cb68f7c18d3039841b6afb5bc570457527ba76c21939ccf378f9b138f6f185758dd3c64cd63ecd4ce619773e54fac0bad8475a1b6c21145ebfff5feb6293fd005e933633bac738a0cc355f8389e71190633ab1f22ca57a22ab6a5f2b9de37352e5cd2e7146bdbcc4516de6602b0d9337f82be1909c381f61dd98a0ad27364deaede8848562fd0714cf49ef28e33e853918cc6f5566378db705ce763afc415652861cae4d69ab29f767b40793d9c34b341a3726628c4df6ba8fe5228f9705ab2e726c4b9c6abb71086c875d465f8bd0508376dca5feb229ccb99991f4d720458bc3dfa7276f99111e59a6c976253193f8375eb6d389d4658981f52c9565b8bab8e49c990ce931cb7a4e74b6045104f5d6300d9e69a56cfa72e4c03144261b594e82291d68f1a9d2dabd6ef67afa8ab60bddbabaa29f2cbd36837cea1bcd78490b74e7777f53a85b1a2447e80fedec042cac205f3eff7929b506349c76064401ca9bd5e9be7e4c30b8e4a28ed79c096d5bec64d5fafade23e41a884d66dd3eeff51436ab55d02463fa4cd99538749c148f3e1f7d74d503d0764f43e449612918e6c6f76bc4289ea770e5b7a7b9930679d397d31b35b8496369dc3e25c65aff7efb2b416fd793e4a0fe3960dfbb0d83dfe047f09b07c5342035f5f5f95eda1f59c38c9b225afba36f8eb152b7f2f811aeea1d36dccfdfd4e97041dc3faa62b64ebc75ebf5fbfe19e1498926a776c6be1af45e58822406f2ddd26fb2701ac6750c774779ccb5f30d56cb59aaa3cc1e21088fbfa56f0ae194269ef1d23c1aee20be7075efb0ce71f8804cf973db28727896b980d3ca5f75fd85f259b460301d2ab32f704db8c63c19b9f0151df8e42e79ddf8292a8d18d17af34d522250ce024a786d9e7b095aaa2bbc2639a181afc3affc4f1971cacf9ffe3a6c026a7d5b5b3e2ba660bf00c353ee200edbdec247923b58dc4c01601417af9102ac933c4436770334fe7afb7cca6490ef1f2df99286a47f150e29d40fc9f59639d38a98edf6a264095179bfb39cd6c4bfd4e0a721c6b8a636e503e5b8efd37aec616db24bbd97d5d697f36b1712a8d266f0992890d92482dfee9a67d5b804f119ec808b58ce93f58058e087cc5d941cf269ab697e50cd6510c937bda4727476254d3e80a424d1332e9cc2bee5b172d4f935d545fdac9925abb219b1e51e38bbe5b40725d441d52c6292c6b665857eb85e6545230f5562d1a54badeedb5dca84443a34eb386773188ce6f6b1298b2c6cf00c472c7627e26680fb99686fa29b00bef3545b129f9b245cd291035cdd5ab333a158744e0de368cf0ebfc5e84d53969bad6c21484fbe16273338c3f73c73a8bc26973f6d73f36d2d385cd4f68b00503cca3ee72928076b220de28298682dce5512cbd5bf68fb2f9fecebd13dc793d3664a18888d01e005074410ac5cc199c889cd1b28245f1f76cf3d465eb4e537c55bb712a32e3c7ab7f5be5b341d276e25040101ca3a7463312cc361af9df5b6d3f34decf1efb91c658bb6597b31087154a047944ad129e35d7935ffc573ba6b20bb9ec522929a0fc8a97027cc13e9cddf72002b2907830d37fea3ea58802cb6df355f4b3ebdf474f0305cf78008d57066ee359a4e12aa9d033d3398b65fafabac78ef97b782f2fda7bfaadd9852afd330cc44d84e5edb79a07e7b161c9baf84ca6ff247c037444d4753b88a91fe10e4d9a37cd08753c664b8db1574cb1223f80f975b658c5e7efcc9f3e5b48c6c324d3a20bab1da49c27380ad12c04fbd04238da5ba3c4d49f76a631903fa1318a6b4d41f93e7de0ce293169d23ec48944ced304e9b4a113a537da2082d9af22d853b8a891b825152cf7de8cf4c42454ae34f7df3d2ab0c1a6e451153dcc41d195151e82ef6013b4d74f08bb97be0d0bfa921332696e0413fa1ad2fd3024b74d5ef0990c8d7f62fc75d516ef38baea1fcf5a85f44d67a3448c2a69babc2d1bc6f1a3bc72ab3d07ec727bea96d1cdb36cdf2d5336b0fd8dbb90923100fa41ccaad782bd93b1c62cd44273222996362dd02275834feb07aac153bdc5ded31ab649e52248791e22d7912dd2a361d7470ee413fa47606e2e294e4ce7522656926f90089cf204336c738702e5b7efa797974c784f2096e1b2df84ddf43d087e448373f27d7122df1cf08d8b1dfc304f5ac2edbb22659a9e657e274fbabaeb29431de1460fc3490d158c00be05361b36070e99ad1998cec0cf23e755e2605a45d7f9e0195f5771906175bd542ac2b38c86cfb3ae2dd93d36d65730a484e3fe37c2117a994f097b07a846cce18ce2bf105427c743422c31c3906ad04fd80f848c48135bf75b5197f4c3c2ff283e587063cb56c56b229890cb1dd3a5677be67583cc47fad488849924300a9b1a238d5133cef9a3745e2ef8b0f0518a7bb09c4516c4af9645ee94ff0149867e330886b62ba17f4bfc48438ab26ed2aff544b67cb70653a01a18d8c2e0112ee80eeb25bce4c49e2e64b7abdc68b8b36fb8d675bfc047984c21357987c7148ed5c9b8066ad493db3fd0bd910af97ee96608c5f7ecc62a5e85432c947fd1b7fee1db44c4d60afe2d893a539d8f5b3a72fb0c768fcdb2033ed21b5292f3818f3eae82e779dc84d1da902a80c258aa821c3411917f710bcd585237955bfb72ad0999e25de9e2ffd3b8992357facde11252b3e007cc144c98ea9b7318e626a9ea1fb18f9bafcb9f555aed1bb212c6a05d58e3c4ab1ccc9c2ca0cf5e9b4ce5cf4dc2cf24ac0cb02a1fea219bab2c27ee9bc69bd7870d0294f47db46569a5e9fc725dc9c526f57fef8158fee6d941aa48ba15c5e29c7e85f6da39df9b82e2707bb42ce97ed36639604a00d1798948d1590c8140e6e76fb2949c29d744d3d8a4fefe7bb63d46cc4ca675856f8f07a6ad85dd4092c66af830180d61a70a78361c85b950977450a2c19c993131e32809bb335a087aef027178a6a04c2bd811df1306911ca5df2065644f9e09f95ca4f812560af5301f9b5fa228fe495e4b7505dd94ba400bb607f72c2c5b31a0feb0173eb927deab281562c0bcf0976224f7e5efae212ec518d96defda005189164834dd7ab675f8eede93993415e716c9c0cfd9d56ef2cc4325d55b279339360f318fa91aeed456cf59a6add6b04839c10ec20b32690253470c07a0ea7a64c3451ee1906b614f678969dcc53006f7c1e659c75236750acfa8ba6863842028fe49812c84200bda241c5348045e3fe326a13d0a6048d823f43230a0c68d842a45fc03cc56b59eb7121c00ee2a78b584cf8b4c0206caf40457be0d3b3504cbc88702718d14d2e448d7afd36f5d0a80571b583de02aeeeed1a83bf9ae7f673a49eeeff6fac9d1c3a1b749420cf22b9d87652843e16becf4eb2afa2178b23e5f7e39aaa3d196b88855c14d313870ba12c86ffa1e1e27a1b3af2ff31bdd2dd1c60f49fc1862e05833da5c485e4c25bf5f22cf6ed83f9e1304478394cda2c0ac2879c5289675dc3fd407392fa0948f4a45b210551ad42511d74d72332a8328f0a179d531132823ede2132fd098b8b0689bae489121212adc333df34a1224a706f5a723529e51d90898b0dc880c526dea4916805a88eeb993f83fbd47c931db56aa8ba5cf7652516e1be51b4b3bd00526618dc861699903046590d181469ab85bed9b71d67212c26d4e8fa95e599bd3f8306917588e0d33d0b269f2d6c0de8987886222fe0d5b2dfc2f5122b6ee69511b4309a6d8d1db98b7b32c8ac8cfdf1003dd9850f56e665ef63edba9cdaa2b5b2770d86ddff9e0271ab926ef1dd50bc2cdbe3f8f324b7681b114c2c776cafeb945515cfad769c467dddc0cfdb6d6ea03abdadb0ba407c16b304c8871cd3bcd3536b07d90c7b7991b3267ba0f8bfcb21d64d9807db7713b2eafa86c648227ad775d8629a3795a85f66d43e84eabfd67b0a3f48ca7d11100f703e7af08992848e0b11d4e7c97d52f8a42fbd177209958f1fb37e92b578bb81f4f0c42bf7d2e93245312cebbdcacc75c1397c06dbe52b4c1b193f6b52e5580d661357589abc27c27a906618cda706785fbf249c42c4d9118e4a9265d7bfcfe5c9df78d4342a8d27cb7220c5513fcd857767b3f5ea2d523532307ebdeacdfa221c77a4a9b586bfa045b5cb2c79ed73a2f6151bbe0c60a6b35144e06a9cc5809c184629b78fedda6b49b7b3a8433e1863c7bd7b7a799bd032feb91b8bef723a31add0ee15c438e5b40c5895846474aea0a22cf3f35b2dc0e86a7f1bdd8ac0b1a2a8105921197f5c1a2b833ee8bb72fa4ad7aea81bc53b813e916e153c4ef5babd0dc9e95cbe9b6f6daf2a99875bdb7c2abbac093d0526dc919222038c5226b4a23c2d8f34a019b69741eb2c6465b2ac7eb7caf2f5e3392e0a3f2ed2b1649ddc99629d26fbfa05cae945a80ff98fd82fc4b1b077f4a36e9325a088bd2d0c2692d24832d0af0dc6ec5d5d45cc09f3de309ded5f6e3dc63d46dfe232338aab6e6aff791a857d0e045e7768b0887b7bf7d318ba1dafe287171e6cb86ea6ec4835b9a3df495456f53222e38965a13df38c1a1ff35130a0a8b3390c231a99c55e56a38b35269b0ae5c293f1906f824d00d337ac5cfa66e456c425fdf411f50484039bb998a1ab2cf4821e733580ad70485e88391eca29a60c3de5e944e00ba12ab080c4eb067c18439612d9bccaa16d77483278c877add2e718e1047b3c5f4f80bd9b1f9da591ea04e66df70a6a65f134d9711bc3d67f683fa10ad3a2bf82a43abb885cd122effaed96868d290f513f178ccd6eb6b55537d4470efc82d6e3f67440e647c7ecc6a393a560d61b7caf08b4a80eec74e902a6bbd1eb104baf9292c7e68f1bcbf2518465ab7a3b98c391e5b36ce9e2c6f5d1df9d07fafdaa109d3f60c2a9bf1b76ed93e3d84c9d7290c8affc57e07c52fb37263bd2092e1d32478f36541fc6ef1bb9c794c63bd9953a8e63597a9a0b3898451598249d8068b1e929ff8b3777f0125cc165a16e3957046dffd74a6f4d4a52e269430b2765beb159ac7cc73b38452f7adbf0be5e9be881290e658f913a5a204294e3c06fa7335e4072361de7f471c7a61a57f52b5720c33af07ec0300fdce492aa12041864e98c93ce3b8ccfbe5e660c620a177c4608e50086202f7811003ed65428cc0dc1bd84cf3039002e3d731bbeed75e73747b4e16d99dd7c52175e41af67e648cf17e13ee40a8b899d4a2a14aa4f189d0caf53fddd2bded27819aaa045f695f480bce083905d47309df752d244b6d200eef682305854af18632b7317cbc3b2f487ff44a4f61c36fb2188b4ff5770a83ec246038cea72744f86441b1efda5738080c6bd25148c4a39a84cc836fd34f3ac299605c9fd236d3033e8eb23bcd146096d715f7f6f7dc6bc5befc74ef55629b005641e008d893b5c6d6d672eb5924bc34b3c683007a7c6b953c85a09d95b0ce139a1d381a12b3427bd4a1c114a1eb9e9e0e2f1ad93fbe15950a1b14e6cc7a4b77b86948897d7d0b4f9695a686e1b734509a1489a3f74fe9131e0e15e77a9cc435bde898041b18120b08fff9f88adc01d9f97106462c9eb28662c92196f66bbaf00e931d3a3c39a5834370f649de169a1adc4e72d59430bfc9f4e4c11058998f5bb080e842a9148253053fb9084d3177e9c53f87e8abccd7238e4dd50a46533fcf7e8f87a4d9257abd9c245b971d93a7f91e40a936a90d38bf1d2a5aea5f9d49292da15488e424f417d89b45b4b15067a8fec0d0635b0c635ba872715b4f6e60973aebb711c753a49949e1f9e5e3ebdcb6bc7e3211d360882c1991e37701fecefed9552fd8e9ff5ecf404198f7c3f24d02279131ca0f3d6b4f61f56ac27f191e21c7cb0256e5ee0affc03d9449a006f9cbdf3f3f51d5fc9292083d18e69d4cbc609f1bd65b1fc06b808c4a668516fd5527e923c1cca020a3878d86e99b0dd2fe3c0659ae6048b263c47b3579feba4373f5b20e2b9bef101e9a838f3f89437b01ef9b990e3cb5b3c3ba3f697b6c166e5f349d230cd6e3b83452edcadb83308dffb47f5203a67adbb29069d558a0662c5a7c1cd6dee8c46bc15249840b00492fc18736f336eb1be434b11ff415d183581c392883b27ef2f184610d07c8f9667ec8833ac13ed63715b09c6a591fecddb60f2ae3a385da0d0614f72f0e6e1d2751b63e8b5313f307e37a0ae74fa05ab3bbb2a7206446662cef3737470a6b377a9dc2bf29df77284c60cffd525c9cd06f63371d444b115398fd71f4b51c4210ad54693cba62ea720cb46842f69faa6599b31aaf64368a758007cdc92d9e354d1c9886575a38f333e414d85660e7166557e3a104ca188ca6e7b60bc42dce9755d37d93dbba1066abed9a77220e47ae1dc31211b24b99486a50d3ff7c232e3fb469141a471e9ff467af618dd83bdb259313b2b77e6f68996c8529ebdcfbafcd424fb54777757b65bd06345b31a13394861031cc0674f53c13f9f7ee00ec329cb731bb524646842270cd166e684f4563b678d83a3de490f457a8ddd277f2e8d6a3baf09594a09fe53ec7539a4e930c743484644bebfbd99ea626d08b6bab0b04b055c5fd6013de7e4311b62024b418481495a5555f16267290c083ea259efda787ac6738d03e40eb94dc2dc8c3030f2c15e344e24156e2c2164130b48972b6898817f3890467166ff7fbbc0f5c358bc376294f6949a08a49a258db3e013b66e723ff747a51cf88c1e0ac9d99f6a3f4fbff0f9c8f2922e0077f831297d802917a5f659f87f7537023fb64d3517b2f4b6fce71a85d901ddbe2e75fd9cae918f84b15099c05a1368aad538f6ce7c5dedd94ba10b8bf9b7fb5fccabb0bbc3e98f6af9061e9624009a48893c46019959563d678f574de67b0be2dd40690c802cab0f0078ece219699fb82874bc87ea55fc4a0f615b0571c103224a030034cd25df3bb8283ea7774281aef382baf812e4fa32ca442a076decf3585d46d19d02b8d0b1bd7ba672424a6d42f51121e5dd6a040d4c24ac075f692e1861182495b3b55763cbf999713c57f07fa8796c635698f984799253e1351dfea7c5ef80e3f58262da09baad5e8a5af2cab32e5ef3e7dfdea762802dccffeab68b121ab7834e6b3a50c53be4f7576d781cbbefffb7efeb85202581d8170698517a8a8cd0df029be9f30e271d4b161a7f49d4e2576d2a8a41e81a32181736f0738e66b429082ce6593dc55fe1c76d25ec698e770fd3b2162b743e4b850b99d11231ddf33b6061c95687a84f1eb826fba07428c6a17ccb01487ce83cb03c1598580cc244c67b4b44deda7289d69abe81594e5ecbefa3a14f15e9d8d8a89533f9c1250be8623708c02b205fc04d3d2e9ffc8b3624389f6271f01711d6cca3695e1d4187b2a56f48897493e91d32786679d12674e4754f4cd137fd67217c30bf310f6d3071354704385c7ae81e25a2284fe74541c6cee8bc1a3361890eed029a044de5523402efd282eb09c1512535765b725823978e5c0bb3a2a97bd9548c14eab7541d429d07815c268db8bc9f8542fb9d307652d690bc28916c66f642483270585929796014abae2bf0b5f85bef116750f7d63ae4da52a92cce85ebb435a3266a2966f8f4e094267ea34df963804b6ca4af06028d2629c5369b92517e553e4b9487ce33d0d733b10f80e6154413004dbd7d2c2139b75f77d947f063452e5644033eb2ba4e8fe15717dc15fc83a79dfe2a590dc2aa99400cd4e375e8fedf387aae852ab68d20fff1fcfa0eaccb14add807ceb16e9e8b830027e307a07c7509418b0fe35576900c33ce10ae946b6593acea7a85c4f34372a41d3af691f2cbbc177608e43e2ee24418038169c19a3af8f4f3cfa17f82f5ca829fcae7ee4b7821f592d2cad3a1a1210ba427bab8550d0811336929b0a75c5cd8aa1121bc41d1160b117e0b345b60b3e80a7da0e10e8b6281ca94137339dc89cb7e7b99e77d01014667e1478cf80a9be30f2d35be3fa21fcd547c762f6273003c14a5816477d7d732241c2b4915bd5545777392a3c4bd5f838279c00134278eccf46824e7cd13598ba643752e0b94f89df4954b9eb02acd8fc762e8ff0fee49f28a91791a630dfe6f4fed36dffc8ecabbebb6ec868df343b14b853824c1bc7269636eddf60d757cb65298a2e75bad1a374d4511d4946d9a1a9a36d8b3e13bc07f77a7baac25422b3683cbff683b20d04e1b2090355a3f7c0a5f64ff0b27963fa2051e2e74e3c25e31845a1606725705976b8a8cfa53d26b15a566cf079a6e8563c737c91c7eee72d18815a03b83c46eb4925253b59b114df57a3d64863f9145ecefaf4e1c46d3e841b18228141a3dd0ab328656f75d18dfd8888451b1914384b7cac7e5a940bce33c8d9440198c004f874b16d7216543373995ae407f30e322b7197a7f9a1e9e5ff9c9e83cdfae7ed11476151c77ef2bd2d82da3492a68a8efb8d39267963277d84ea7424c67855037d63618f8cafb7403f4c284b9b2f5bb40377892e542b64d12e77b73fb97e229c19b910b1faf4790fd6a078aba53a513be60d92f4e91a9961b49d4eaa050a7fb20f2a2af7d75d24c4d261e38e47d6c1933f7d413c81ae2db25b6d7a80890bc4b43a38b8206c7bc91f4b89aa02dcf097ff23e3510ee790d5d2c91994a2b01736f37bcabec7ef17dafb4216d2994e7caf43a6577270bc3da13bf89e33c4cadb033752d9974852d03d6ecde72f47f11bb9e2a37ed09f05102116e1988f32386a0cd658379769f49d1a937383b65b901449926ef5ed0565ddd0778b4ebdea7b5213015a86a6775510b585f466bb43b289cbd1105fd3e16ad912dd0ee0c72e8689f646e16abaf7e52aae43a82440fc944a5355f76690edfc299eae5fc7229bef05f42865de164602f4c78208622060c9e9d80f010665d0ac35b16ee7b18ce2f763676639e6cbbab3f51b6874729bf127344bb95df92c7294d4f570d66c2fda536f27267eb5532081370467949f4532d1f8b744cec96295b5da9b3f59eb2f79864f73ac2741bb794e8d6708e78fab81d03bcfeb587379adfbc3a658ef45b458aa45cb014e0969cf745baf13212eacfd0661f72099edbaa8dbca9fcd795635b43ad589a4e48623e3a502b8b86c4e3bfa8e1acead23388daf146a006a903c3ea95a63b5e66fe1a7907ebf7a73436750587016291815637f01cf00c1b688f139caa2cb3d8c1b14dd90a24d3f25e871568e82be75a43f68bb9ff9c7a30bd0782120e305a59e32df44c7ccfa6c8391877f08ecdc3a15a5f586fbdd9f0f5e9e9d14aba3bf8e7c53434fd95f6d27c58ac58a5ce87b3ad7b75e86c99d4045a91030d9b38f41ca829076a3877bd39b37ca9262bda55e8060a55d0df5e76bc4808a231fad778fbfd8761a4a96b6589fea7ef6f1667656194a01135fe0d2af502ab1576c22e8a7004701c7e67c4f4ca2f43e4e127704954357083bb174edfa7bbfc258ef50b0680dd0136bfbdccc77a2490fb346eb9b2de2f657d8281760863f56257239c50ad8c615b93b947f4e339f1ac0c82ebea489da56af6061eff0169364cbda9069ee4b75590564b277ddefc065dd5f271ca20af6b8753966baa2adcadc48f639164dacdcc799ce62cd3fcd370fa53ab76dad8b2deaa9293a22b195706b37c80f0b6011dadf764e67eb2cd8fea9d72fe4e9fb563a629cbfb17c2c8ffb844b5e030ac897ec6a364bcaa689104475366c17b8b7bd68e778c1022bfea513cc448fa9f8816f03d1a99eefa7ce068e99d90b5ac34b044254dccd9d196f120f328ef4e0c67c49652a6e71b475c96a1b6cc8e980ec5c34c1d8465f73c51313875d9e93710f17f81daf9c987d9c3f57ec4b5514ba17f1c339857c548575123c02e820ca5bffe0b355b50ba927c0b0631ed720ebc16cae0a1713ebbc41eeb4333247ec3ed7547f47bab8a1c3be3587bf6bfb93628971049a8cc8c906f3594297be994c2e7cd11a92373db027be3654d7781a081e0f4273279336ffce8960c82393c556a4211c96f143b8f535ff6a89083aa16488a9bf34933834826c484400d3884f8e6c57790a3593eb6910a17012a85a6c7f8c6e5a4a3521d916f583ba2ee700ffe78848a5947115fbbecc66348c811b3060922e63ab6248b31b7de3743c5581ac4de91f51b193c1bdabd46277e1b713bb70f05d52c7e35dadbb40d5eb67d82e4f16acc82e807fde699059581acdf745ed2b12017ccf0be732474e37f8643b0974e0fd755faa3a5f1b29db808147f8bf69710b54a561b207ed5a2c66836fc5d9ec9a504b4175b8977d4188722c12986d6a3a79e0ecad25b59b410e305421956a423bbcb600e213169c448dc901a4e57091faba1504ddb47864dea463b20eadaef59b61ab87e7a129b15ac6bb31b30c4a8e073e8ce4881851c0e5c9cdf327df513b38e79f91b81eb1fb09702b9474630a31707bbf2eafb18fe7d96abe69330644d2993e86e8ddcf9d6cd6374e1fbbbd957409d7c5e65615f9f86bfcbc6e63602b0ad0c0121d7b56d4d7dc2208bac590c697408963f6052cb014c721c54445d06a00e7d20f4094b7c28ecc9f99f9facef597efc0fab4e53000178cb5527fab710b1f8a9e9e59667f991fca1480465bfb9aa4aa2bcf0c73966f0d220b0cdcc9d92783787b4bd542ad98a664057bdc4c03bd03cfecccfde847f50363fa44376a6f4184534e028ec0fb029d3f5fbbc9cc6ee7e8c72da1560d02ba06c055b53bc142c391ca05dffcc77ad2e87c0c45487868e71564fc35d692ccf98d131d90b897cb61c780b45f45b0aa8b89719889e85cf54866c7fe9169bb5b0decfd0b80e3476c13944f9632d573d0c8aece39df08626afb199632383d4b05f87f4bf7450baf11e5251404d30b76a5e179717d717d6f34cd2f50ea842ed3e6d386f718e920d2eb043a798dd00cef5a83cb34681deb7652ad6e0aab49cb58ea181bf7797c1c9aedb7df1089e15c00a328ba41ed74e3dc8793a576f7b8f4f75ee75ed5c61a74f0593915882c1f0d28ea6e1b0450d81bbfe019b3e8a2069ab4bac8ed388e0d998e8513ed6d489092bab87378d33d2f5860c91f922fff99d5d4ed59b2094b994fb247b5bc89df1e800e2f8679e5badc1ddd1e9157725599753ae37b49cb2fd02148a50d1762c217bab609c3425623afdc5fd87be41f5d5ada337e29923930e001ac73f139ab0c37984fa415fd964c03d305d441f3cb79d3f915e336350c56f4132305203e0a66a9f06097d77aab0424541e477bff32e773d4697b38933f4d27fd8f008f266d685359d35400a72a74706a1e19da6e8fed87f55b4a7b5f6fec079295b6b66fcae5cc9c0798ca04d113be4d02a7b35e188112e5aa0e9be8d698323f0141e19c6fd6ac627135b4ffa9441cb317b8a4eb5157ca7bc6aedd19907ede1a3ef136dc84369fc50934c0fd29e52ab5e14eb2972792f1b4863243a6efa060872d8b288b0009cce5ceec35953a7984f8b65ba1bb90480559d9539598fc829137a4b92dddc40e26adcb5a6a9a396171b945b69c5e72dace2bc59a289e8f0445dec8031e772d3b7db7a464322e0f79701bb35b89c5842e02584f2486bbbf8721337124aeddd5b8fd3fcd7fc79e5eaf96dd9650252990a0b56143793f17e168ed1beb5006192b12d9251117db866fceac518c984a24b2066e282d0126aa907b504f440520c3acb67ea0632a4d534337751a2d1e1e30a21d5b3d7a5ac77a39801a5dd8695f5efe89e8b85ca3e7f0e23277c7f70d9d6247b6d471e8285f4a4cc5279c48185c6efdde39fd205f900ca6e7573fa6cbf7034dc41de75130a3391b74e1ddd0a4f09211ae707fe9d4ff8f306ba69420620ddec0e00ddb3ace47813184da2e0509ce0ebf4fdc7c4b21daa112c5316b61769de7a6fbbf9ed6aeca77202a7789760b665a750d6fd484f3961e53586c3bc09a2335215ccab17197276eab7b8dbb77afeb68f82571ecb1d6e57cec955ef73a14a6bf4b45e0ab32628eb9b9d2f42ba7ea8ff3215e7dbc311fedf415c2677bd78af018e2d47edfc023d3a6a76568237a10d103b7ea7ae052194eed2efea99c528ab2148d0d5e202ae15aa5d12eb0888f86d2d2b85b31365445e8d228e5cf397e47bbaa0fc9061709a02291bd0b960128ad351aa021893f7b55f1c6b6418e04857d64af27c3d02ac5277ff9336281ac2830f219b06c52f47743ec7c94685920c04a951efd8270c512326d3afc2e516e70557dcc266cb1681607ddd6e843b07595e32a7717d2a9cd663c33c0ba5c1e6bfda11eed34963e68b536e6dd1ee732a54a4779b39861c26ca7c9514e5a4255e1668192380085a26de6a61b33bd8ab8964445dd3ca3a4bd7edc9bc1d40d8c763b69c9996a22dfadae7cb48c94419b7202d1d98ea4d06195deb7f38c26b85dd285b2562a9cb05b82fd13113a3c3773d0809f43acc5d139f0a35efd0b9e672cb2b0d28ed803de93a975b1d8efc8b62445dd45d64411a259aac4ba95fd8ed23cbdd920c0ee83a329b41e0ae47f956fe8d7720e9abd466a685ad766c9bbd77b2675fb212009831644b95dc2c681b9300a4e08d274e9169505412283a04b33ffb1b31d9dea894d62a889e7005dd47c745e5d2cc97b613564ff84f3c830ad2e4f7d76ed994b18fee813012084e7ff068e3b745bd292f043692d381ca81d2ae2a4e6cdc75464400a700d3f947d4e993c8b5c12f9b12010289fd07bc21870fab6c460f4f290740497da0266e456cb57c8c2b37975177c0e33126b95afd0094278635d5574b722e1c7463af5f86c65f3c118c2a71f4798f6b99488dc85ccab93e5e36f98b815d83fbb0db834cacaa76e3d95890766bfc94703fa2f2f1adcce7dc9607d9d685679fdee4e781b8b9344726bb4cfc31ecbefbdfc3acb7b83735d66f807d9e893e87c369ee2d02ecb1cc9c4f72d9d0e72b075d3cf590e2d8065377774c9eb54dacad11f47679cfad18e0657b9edffb562d712335a723c23cdb9214c756a5bfa46c8540eac35d22b00a6b3a0947fdeac0a8b703d13fe655508232c1bcc893731b5bdfa667f840a30505016e9aff3a026a877e0d3f678217ba04c63bcd88d50360ff2a0a20304789e26dbb50f7a0dcec9ffa1143d5920318bc61be2210aa5123161ee13f9e95b04cd8f564a46f5c82c7e23712543aa5d1b9d23d04abf785c0567084b9b9a3a83eb963baad554d6d47bc127369bb0b95c46bfd66ab9e51916ddb5117e4aa9d4f1e13802a3abcb6d28d447eadacad120c7ea510aa6c914eef29e638c7a8bc6daf6621acf492c956c5f4f5cf36cfa9cfb427eb7290d7f7f44292b99f35720b47cb27ee30842275c606b24f8b25471ca533b7a88fc15d4a8860c2504e150fdc498dfc9b961c15f3b3040d3273a538ad855890afdd9757326cfd046f0031a205c3387943b2108d0f3f816049b3da32484d7472dbb64d64185fd789b27db941aed0c103d0c3e4a60ec113b408cea58b1c9fbf1850b69033615d6c7e2391f9bdd3a379173f4ec91facda47aba3c925e34b7ba2e9e846e2f8f7197464e55c13f900ea6bcd5a0fc792eb358002497d9abcb55904da26f47a7dbe85d2e21ffe663ab6ce825873a04e866b324cfd2dbb723684ba6a932c10f63db2a9a4bd558c363139fcd6e3b8dc9c7ce6bf9d5f4e8570c344c30c20696488452a08a07b5b694eb6272e68713e10d7e61dc6427d39385743e97af3369530deb9cf0787d84868bfa204d1e3021444361673ec247a64d848588e18b70db66ecc266231a1dd1579a9d557f4dce7bfbb0bbeb55d542d984d11c3129f8ce74346ce93baa5664d9b69556d592337ad09a9b398a58da73d6e4cefc04895562e7bae7f63a866960daa522a4f907a70980aea455467c1f97a38ed8c475174e945fbc3d44fd04bafca2c0fab6585cc4fa5b760cb58d6a11eec035ba0c3a45ba657530e03ee2c8a918ab7426242e3c04a8493137c19d63ac39d8bc2649c0f7ad82f022796a21358ce23502545ef0c1031bbe64d8a8c43e9a6f7328124379dc4aa3b95f01671b25cb7c863ff2bdd164dc7fdab0fd29805b36f34f3fb6b218be1cdae489e2043dd524cb2f549f665abecf2b5334cc51a5e26dec0e203722066924b24c0a6c8571eb598838877971ca93974e162f8f12594a4aba97bdb21d7c36edac8db05fb1c420687ff2f7d295c07cbba39803babc852e41b2eee533dfee839d08b0b4fdcdd83510496ac154377b3989dbe7006512a87ced12ec5a6349b18df54e55a2ca191142fdb80db2a650688cb5d8db09765717878e998e143ef114b1366da039ba1d867ca764cd7c49a20d5dd24c43d3cb07246c46826ee00d08278da277ed74e99f1dc5df98b8af39edeb08b99aac1c0d3452c7684ac3d9e830fa7fa92b793842719ffc22de689e6217539591b292bc8dfa160ba8ab43c8b599c435f5bae75999a71ab3b324c77e9b308eb7ac0ea621584c8552092c862ad171f4f76fbc2135f27d3b2bbc275967aabf3896e8c56591fd38fdb587d375403cb7547f8f2ac0326a0d57e3259cbae86fdc9ca796fcc2517230e5d8f7e7ed4e1079207ec4e3a11c669a6cc1727654b87ae14d42ec7b3fc5c7df0dd2909719f6a7147720d2cd591242059a634b978bffdfe343edbddf4df7c165c6ca1ac4783ee572ef09ae56786d8924170b3eb9d91a6635ae5a1c48bd85a244bd2b561ac888f416d548f8ca16d987324941f6c7c47540e936a59318dee99db5cf273c91927d081668c72363718c6de5d4ff56c452cfe7e2a10f99a30ca66ea48ebccc9f8e6287b8546be4e6f524b2e9617fa5d7a2daa395c8f0250997d4f9ab3ae11c5312c3f0174ab11e585754a7c69939d6b4896216a2a8bdbc1dccc3aab7ff296855094be69436959c6eca59e18ab465ab1c7df2920e1c969aa411e8c9ee1d1acf5cace7360de8bf3b48f98944cc83052ea092b7df2a3745fec146834694fe1c28323a1433eaf690a7fe222e7f11a5dca1625a68c3945288fcf3199217267a6dfe1c04137bc2039aee5be62d6832d9ea966857d17020820b4d70ef12fded33f4f31bbb2ccd582567a62f226c021e8330049276a0984319d8c8dfb3db7fec28679017f9ba3161de264d6033349fa4f45debb722362d46fe3483d3a25dcde9fbc9244de63aa4fd74f49cd105559f83271d7924d2c31db02cb851714879b97e5c558a173c04e5da36ef53cadf0d132519f60ba6a10cc5455a2c25ae69c389fa45d62ad71be3783a2fb8d9f50ade2e34d27639fcf54173e3df480de12e07e91fb00cdcbf50d6c71541591eac7bd70a50f29781edfbcf19d2dcff2c5bdb636506dac7167c21c0f996b1f3d58e6dd8800921ddf4eb89b2214b81a00d7c5a79b398599b32cf4abbc4096a41fbdbc20d1c7fb48399a6591a3012fb849c82de17d298031916392104e573be85e1b33532d3641d1f9ebfebbb4232c6deaeb5a64cbb3d573a8267c0529a7e8597023cef2713d5e8735084924ecf8a16781280e483ec576a35a0f3475b15a54ee9a0bb67b88897d458f66308fa6afcdf898a1ed8709beb359a9be699042271dd9b9ebb48c35efac58aef6efc957749f8484d59a4c93ced11c7f77162ab69a1c9bc8b275390b917eeb726b0d69340c0b4bd25d41b1c0ae9c316a4d85953923517373994cf3d8790f563310a06216726fadc6d214dfc3f536dbbae5d075544eb33966f7a395d40c1072ceaa885bd19db84f660251ebb0e7f547f8a34f1f568e8ac5763a6186db45fe65cf4e668a1357d9916599953e137a6a3634518315c3f8dc9eaa45fb7d92508bf29565f1faedced5fe07bba9bee2c7d8ce0b902ed6e6e943a2a6039f2b55f1633ad939e2fb8b09631a9338d116290c5c8c9559fdfcd12b41e98228fcc0c3434ea23ab9574cbe0f60cd1ff28e4fd991f8ae2e7fea45fa19d3299724505b0a9d4be871227ff97d7e20ad2fd82dbb92c4347777f2022032c84bbbb1e8b20079e54176b4d2622cbba0caf1aeffe2fd73b345d3847002dbaa98e54eb33a5699e054d4fb3dc86ffe74149d01d94b059ff6311ad70a1a624780fb955b9bdd63b1ceca98358b5ba164870068d93764db24b82e8ca48e1468b011f7bdd8cb7a333a2c0fb4a319ffe38f88bb644b253ae37bd70ae61c3fed93204b25f6d60b1a37d3d1492f1438993e15aa52b76a031593610b6b311eb29618cde0c20bcdedcf07943928fd4998e0b05085f3ee18a343723f123d32d76300a2673899ddfa0c285d187004825d2aec72a7c6b07f7f39c9fbe7082cdfc70132e1d297ca70a4396639af4cffb249dfb1f8277947029faef178a8423be26d2e43d1b02cd9d1367b67a42506143b84d77661a515e156bd68676a887b4665e303d8bf7b4b61340aaa3166a06ed414abeb9d27fe29fd491f4ec532de79c0b14b9530c8f20c3f0fface4fe37818c1cb5fdb0cb076a886c017873dbb6a7796e934155ca24658c8fc6b7999a6b01d7b22cefb1f66fa0c1aac1f5dd35bad4833592c532699d0b4f20a0ac69fe0b345a6a155c1c120665e9f8bea908c29c9e1ce02608f10a8b49cd8199e58db4d87fd83cb4aa54bcb6c0d90a5681c08e168f635c0ee45d7453af0975e6fa8de45b4fbf92c7801c62b65500d2182d83e711a79657b971e00b018d24f990d993010e4832f1e664aabe074fbe80eedfc490b0b279f5cf601e8abbd5411e5bf3778116ca36d9f4f18a6399bffbcf70b5660d8b746a7e2d0fdf1ddc90948c824b93545a0f683537b13693cbaab0a241ce809e8b81546d69becfffc689c12d2c8027e7696c24b4c710c7f237754eebc891352dc977cb64ffac98f0ee63d957c503d783dbc0a7b4d2381555f1ccc212d6cb0fcaceafcf5dc9667ea78a2e74d95da4e522151956bb6067ee02ffd5349590357e37473598d9cfeb3255c74b45c44606ac9ac2e65b9e446058d9cc5db96c94d76099f8fd2f3f891f22a3ab22ebde9d22bcd793c65fc4a0c8c0defb85d9a8697771de98befe0c03df06ee51b7f274e3accbf9a54ff65fd62045331866f8d9b15e5b8f5f89e99f76208dc5e96388a65a39b2b6e1b18647e20fe4920a5fae3c34f7fe8f90d288048a31751c48e1dde7ab3f946f0705cec824494ce0b2c42f045f2f3c9da83653999eb5c3bdd703cc0f7a0f67370ee0c12108bc29821c0e5b9cdc405ad3c119802c2814d25c1f1e5a440f0febf44b8b09f1e0b7e69bf730d5d8bf1f9e1df836563763ff83efa3ea5ba11da61aeee3ee25b9b2a93fab6da4bea987bb23b952f9419d02261ec26e679b3d242e4c460cb05ec21ba3c7d378e15fe28bf82bfa9688479907c966f5d851299d8f077dd7bc629e2abddd0e73f838e479ca48e9312d19e74ada08b7de532f379dffa6e6289045959a8898f8313c697e8ae98554cea8c8839b42d5a22d3cb38d26f27503621469c8d079a197eabf0636d9291f43ce0fef7fab20506e55340ee505ef43ae21af755c8e72155fed9fb084d979943d7910056459a398df3271d82c018912b38605375c2219a8ed90e585f848df2ee2cf3a2b068b189f6e9e1cb5b789b2f208726d2a88c5ca4f07d5ec339ddb3ddc1ab2b214126ba73a09fb5d596355920cd0c2204f6f11806f4240d643368259a93ad810a29e2f697b82f533bcd36a968e49b572d2b8fe6c3248728ab96c32836236d481c3703b4876d10090f3a1427733abf37b2c9dab172813fbccb3ccb23b02d6366e00073f565eb5a08bf47ce9f4e774c5b15a1675c937c3d89e1b2cd3aa0c41ec57e51f3e1fe758db5dd2e87472105e096790016ae74d102c868ed94885521ee99fdf2dc2c2dd206bf52527dbd287c1f8a544b496edb0047de9781f7660d708ee404f50cabfade62eeca7edb5bad0e5e16c82154d6dd91fdf394dd66574db240c4e78d7d92e9069970baa69472ba41a349ba8032c677a1888d8050887073e5d07872170ab6ddab2bb8a2e34bda111ec377ccf60172633f0e906f62909f2400fae884a8bb09153125e8b190123fb6b3b5b7d917702bdb3238b8cb99b7bff03211ba5ee6c7268b235ab76dd11072045feb758cd4b388a9088b0b748dc372f306d9345e4aac5c7630bb87bcf29edc8cedefc42a7915c6afeea44c556392a789db1e881deff74194d62308a6fc8f8d51815de2b71afc320b83c4e21ff817d325a81955226305a43c80a9d2f092d8647e4c2243940c7a46be6a0cf3e18f88f0bbbf1eb05c08eb64adc3f463a42698d09b6510a52a303a0402f2576953c84d17b7424e7063235a01141c2fda1edf7ccecbf3fcaa1e9d786e4a984d4421505e2d731cbf6049f2dba3c2c781d027cbf0a17aa0f0d31810ca7002b86bcce2ab77ac82342d8b066680490821893429e26e96548c17cbb36f906e42031066a867f611e06855e056a60e4aac6cdcbc3f6f10c10c3524598737093057395fb168f61c203b71770e4061fccd3c449bd9542caf724e09b7a533733cda57cd3e71eea50bffc898535acab273b1cfc5b78dc60e1aa7b515cb835932e42284a084a5ad513385aa94abe8f1a2d2ccd30182a9e6f389e50ba242a8e476d71807258a07469d76619e1826c7bc92cc3ad246a970261f4fba92c08c8e6ce260d52ba3cfa66f7a9beaf0f0329266037b5b289e44008aa6895d2f7fdd45533f6bcb094e48b2baecfb21963d6cea3d8cdfd4606b01be3fd12d5d437ab42bb0160b8f545fd8f8769ebbd3c4527034e31b046932ff80e600f8e102027a3cdb6cece5e137a20e6dd6d73fa9bc1b3bd0ec4e72b7227f3a9bbdc7fa55f1d6d36c07141e4dfd97cb955ada27b844c2eefc277cb523566745f3a4fe7839efde836d7ecbde6133219d5d66a15d89f52f9f30903c76ddf893a4926f68858380fbcc1c5ff05b9139dee14c3db00afa2ad883fdb07ae61a77e271528174d57e865c1e150df52a12874886d81eef3f7cffae333ab1c64f2c94b52fd8a1c4d5d9467dfa6a396280139d4a77b16f751498c15c664de3314acd3042c196b9e70cd31aa7b89b25e7a3a7151a59aaafed633057e9f960be47136c63edfaeee49d2ad2f9dca4cb5632d7e2e377ad11ce744040fb0a8ac838699413e28c4a4f8fcf7ac0a9e10b1065e205cd84dd726fe24e73c805dde4452ad77e8c4718e043e796e476113307b21bffced513f9aba7e2cc356c530ac76e990b5b206ea7cd3a3d41f54fc987af8cada9952cd72c40504cb2b719c1c19e111b6a34d197184b40b4807519eb57ef9500487152d71a9d8822a68ad0f52d07af74df018573a60f616a8d82279b40d8b2a2bc85b6c0be03f27f7f1e120ff6befb38953c293bb386db8ba82f3e0b288afe15f912b4526e15c74f58263eba8ca2ed3b052e796635fe05e3f30c8636673a70ba2f9a5553f78a2fd062e6a2cfcaf2da61cf7612bf777efdcc906e87507e878c9a62d301c8a8e59322162b02094e8811adbfdebbc2681d02346a8a1f0ddca2f25779a24074a92843202557882fe938aa6848e4755efabfe0dd039775d96d0799058a19d4dd6ecd0c2976c8afefe6f8bdae8bca4967bbe5f16aca1e155bfcfd02a9d3d3ca036c93ed4232ed2f5cb7ab910c0099ff11213bf041d55ed208febd118a65d2e7ae53b65d09d07e0df59a2a6da511ba528f4bf8875aa290dd98dbb14ebc33736b4fc9e853930a9753a81aa979f696c4e98ffb9542d11b03c7a48df0e012584eacc92b55d32b4453c709321165ebd6be1132a0e187a203261dced0a84cfbef43b059c30ba19f3629c0fd3a7c458604c701fe1e9418b345e2d5511dc5f332f3b6a1577ad480370d95036386e63d2c324877e7fdd0f5eb7a429037cc0464b63ca77eed450cff4361ae3a74671871c4d99f72c3a8da0f05f030450b3bd2b9417815a9c727e7432acae44b679ca009c9888764150d5447194b7dd1d02b48d5ac074cbb615b51e034f9469d15cbdc5be4cb001268d0bf59121e1b3b3fa91f8a87a2cb183eb1285ef1222d99efa90b2094969f2d3efacb3e4d3c81cf3ce5600c2d924059f641b0ada580415268a233e32ca7a086ae6824ca8a941301499cf8e1bb9f822cc952cc2d792d20b9577b10169006680c57540e07131fe6bd3fb6e6b39c32e10869450737970a85563890531c884d819ccaf4bbaf4f9a59ff5be386c0bb06b54711813f38ab1650c2d4f7d4af4c3e85520d71c9d633d05310f67da5993e484fed8110af70593bc4285b01eddec0332fdaee79f866ab7a3e860a248a2696591c7890cb45d4a6d51a0c51d839724b6ac903847748eb0fb54a19999ce817d64c8720b94a6f8518cc7cc16344c3f342e83b6e40dbf845eadb3bb5bf4eeeb4f6b027dd1799537979c4506e4601bc443adcdeb7f2868b1f1052cd9fced5598204db4cbef9e73bea8beb8dd25016de69cb5b9cfaf4c69380324d67dd05b255bad63146032a425708cea2602a47807f350cee2934690d693af2f376428b3859fd2de9782bc6996d56a0baf9cb52b54dbeb84ec94936b59d43a6a5bf0592ebefee028eb369ad64a54f295a047e794c973972cb76194ed54d232d306650d8592f22e76201b3a679d4a06faea91d3f3deadbbef72539392993fbfea9d9673d9818a051c2ee7c1420236c003677b69881cbcc6bc05786602053b2476579bad1896f9dc3122a8ba464603951d032df1b5f3f7e416cdad7ce7b8fb8e5b187a092693b2076277a6f7b087f807584b4de275e4fab941135bb5d652c33ab56ba8d536af863d40b3750af13f6326fbbc20be621f01ad359cea56a8fa32581c51d88960b01584cfc15e983fefc0dd75237f6e45660754766b05e7a28f3aadf94982a5c8a628a28bcd85a5cf5457d95cbeee16d262d51421217253e5304670cdc9c23d3b4e5ddea264ae100570666623a6ea3a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>线性规划</title>
    <url>/2022/08/25/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="fd5b083ee8751f32b756694fc3a75ed0134d9874797f532051d0523d1b637602">99251fdceb9fe96a1f47814acd3007f0027030bc071d069be4fd818bd2e392c39adcf108948d6a426a3ab95ad599e38e9a8f5eb286f563d9d1fcf73bf5357b5d9ba799183ca07c3e8a90b8332166b131b0b91224a356de1f989f769355b41bfd10bc8845e1f63fcf2f5a086657dfa95ad14d921a0b7fe723cdc81c9a05763503e16b1f3e6d03a77db96e644f5dda16555c4b020c3704ce7e27b24f5718fb6ae4d8b74d5e353129e89b0df99b4292592c7728e2ca8dd616108430225a3b63184d1134c8aa546a4b2bc282c4c6a215851e7e272f1a79b06f0d794cca00ad898e631dc4bcca5323ed7409e6a0c56be8dd981c05c9b22f78aadaaea20c1cca9d4a5a761a5ee75009e13cbd7ba086f9fcb89a6e27544a4a254355a935f30b47986018b1ef26d546b927a611da1f02bfdff254c0365250d0128b5a0bbbc38bec69c0e4eb1ef424e663e3e175411e56115972284769c0bb07c0d39a32fc32a693ab631d0d0e86879d91af6f507fd6d5ffc8d7a65b715c6ccaa6ce487c78be38170a41b1c3c5dec3625fc999d65872170d66639d481cc0211f176a4fd52545a7df7d4028031d95e0d0c7bcba33ba89ec0459935277212763d46de1abbf2295db9dde2e37596c8bb41b9df2225c271457e59253fdb40e3ca3d05fd8ff39b6b6a87034b7665544b40044e5cc3b06137ff4ce5598e7b7375302a355a1e17c2f12389a48aee339f8a45ff67b65e2289390e3b139c70ef94a11b9efeb56a0b1d366ce9a8795600ed34fe484ca6f44b93cb0a6b4c46318f8cbfb5945eaece313817846f21620cfcfad1f1c4fdfe2a652da9656164736bbb821adc7595935dd89ab3daec9439299c872520a7d8b1ee9de5680eb370ee1f7cb1b8226ebf26e073010317937cac7f6bdab1ca3ea36a656f24709e1deb3dec6df0459e63c1f2598b0cef677a1c3dc11f9d484db1a082858eb1f4400e8935f59aa59165a3335bbd5eea2a9deffc08ce4d646b63417e25beb0ba80933cada0b8f2e90e6cf6ae0c30f6bd011791ce879d303acb1a3934e9594501b35aae9814dd3058364e55040db9aadfcb1747f68b882</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Powerful Number</title>
    <url>/2022/08/12/Powerful-Number/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Powerful-Number"><a href="#Powerful-Number" class="headerlink" title="Powerful Number"></a>Powerful Number</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数 $n$ 满足 $\forall p((p\in \mathbb{P} \wedge p|n )\rightarrow p^2|n )$，则称 $n$ 为Powerful Number（简称PN）。</p>
<p>显然，所有的PN都可表示为 $a^2b^3$ （其中 $(a,b)=1$ ）的形式。</p>
<h3 id="个数"><a href="#个数" class="headerlink" title="个数"></a>个数</h3><ul>
<li>$n$ 以内的PN数是 $O(\sqrt{n})$ 个的。</li>
</ul>
<p>证明：$n$ 以内PN数的个数 $\le \int_{1}^{\sqrt{n}}(\frac{n}{x^2})^{1/3}\text{ d}x=O(\sqrt{n})$。</p>
<p>求出 $n$ 以内的PN数可以暴力搜索质因数。</p>
<h2 id="PN筛"><a href="#PN筛" class="headerlink" title="PN筛"></a>PN筛</h2><p>通过 Powerful Number 可以求出一系列积性函数的前缀和。</p>
<p>假设我们要求 $\sum_{i=1}^nf(i)$，构造两个函数 $g,h$ 使得：</p>
<ul>
<li>$g$ 是积性函数。且 $g$ 的前缀和 $S_g(n)$ 容易求出。</li>
<li>$\forall p\in \mathbb{P},g(p)=f(p)$。</li>
<li>$f=g * h$。</li>
</ul>
<p>那么，将原式变一变：</p>
<p>$$<br>\sum_{i=1}^n f(i) \\ =\sum_ {i=1}^n\sum_{d|i }h(d)  g ( \frac{i}{d}  ) \\ =\sum_{i=1}^n h(i)\sum_{j=1} ^ { \frac{n}{i}  }g(j) \\ =\sum_{i=1}^n h(i)S_g(\left \lfloor \frac{n}{i} \right \rfloor)<br>$$</p>
<p>观察一下 $h$ 的取值：可以发现 $f(p)=g(1)h(p)+g(p)h(1)=h(p)+g(p)$，又因为有 $g(p)=f(p)$，因此 $h(p)=0$。</p>
<p>显然 $h$ 是个积性函数，那么由积性函数的定义，对于 $h$ 的所有非 PN 数下标的取值均为 $0$。</p>
<p>我们只需快速求出所有 PN 数下标的 $h$ ，就可以了。</p>
<p>只需要求出 $h(p^k)$ 就可以了。这个可以通过推式子或者递推等解决。</p>
<p>时间复杂度一般是 $O(\sqrt{n})$ 的。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流相关总结</title>
    <url>/2022/07/28/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="50c9d4116eac4dee118f1efb49842877af2c1fdb6b632b9c9746b3efea73a572">99251fdceb9fe96a1f47814acd3007f0584e347b808f4e820e07dbf0d4d9e406cc0c01c3e8fc196c66ac35a60fe23c76673959e54d1f618fadaa0d8e77d4370093ee2551639b01204702bf5ef74847fb4c1220629df15f005a3e3700d893b043ff3b54726476653b94c1cb8f5a7c9a81e2665fe8b57818d84154b2e05d4414de5eb39c6203421fc97cf1a43f59f78a89b48058cc1672a850d3ad6c9d5f0f7c5effd968e97698d93306b9f36b31b7e138f817e46528bfa74a0d341d987df9fbccedae7c8c58d5fbbb4104908fda41c941955c9296e4c175e7f61a594492ec99a5cf13b3870f79e223799bc74c42502fbdc710c3aaeb9565897611fff9b0b95fbecd4d1a7ff6e0ce337e9f88d1f9d17a2b87f119ae5bdbff5c751587df645b2ecea7c7def8383411948f8721e484ab70559fc5ac910380cf8c67d4ad3fbbcd9a7a2c82d02d8a4611bb11cd4afc9e2fef071219ac1b83b15bbab7761805750ff17f196730b93efdfb42d88b0f80e583f0f174dcef829c6b5dc8f45b5613700a85123f90f99ffa4e702bae3d69db7f889c32363f218f4fa648f0410d7536102e0d3bb7699cd0f0acf049c11dd41125abf70b08a040ff9fe584704fffa588c361a25e324c61b7ce29cef7467d0827c9c9411f8d13d265b4c8c54e91cab3a186cf9cb2428e768331fd4cfff45dab1e4c748db3c4def071d05b40c9d6e9d5c75a683ff528af9a7665da59347d388c4a12b1b3c6ab89b804f3d5bbfc2eac8132112a67ea8eb4acf4844cc2358ec8fe9aa887e8791d4348a8dfddd57fee96509839ca9b55b9ff6599f6e1c5f4370f3d44765cb7b955d671f78324dca9d4de0a88471cbb8da92dead401a1d08671d7328af5c78ba0286f63ce595bed385135b572c18ca54175df9ba8d46ad124730bb3bccf6636a9d1a8d5a29a59e69ff8a67b0b89d49dec97a3b55bb5e9d3a0499dfe460e5a8d58a4fae9bf953c4510fd2c9f6739a3e71e70b19c32f2f211ba7ae5cf3719fa56d1cff50182327dedab65776ded2400343a91a98f4ce59df774b4b0bb0db6d4070a817dc615ac5fa0aacf4289d3771a2cf66b7dcb1f6efafe5fa1497053b518b265855927ff1bee0f8dc0043def17e34b47bcc995da34b816242a03bc1babbecca2daec06d3042c6fa730a16b7ba7e02e9fc5599920d5c52d4c74a8d209601788f2df45f86ce7648b6a9ae136fad17200ccee03110bd9c930ac9a71541169b8ab87415db7044c05e7015bd4dee3424a2499c8cee49f2fcd48878ea1f3ff174716c270c72d8d9911aff31d62d83d74b62b20d5367552d5aeb4538f9c2ae8101838c2d71bf214d763faadea0e15ab2b347517d6be6f58d865bb6b31e8e3815fa9bbab86b8ea8496c6b311781413b52156e9128459e79bb1287372ee4409210994639b68a960b74c8df4d92bcf5d7ee612b22473f54999d9dd20f97628a1f99a6eff880e3ebc75d7dbe96934d2c5f79d473e074c489c731ace5efab0b0b0ef48ddf75a0389fa0778e62d226fb1e0c27ff93f0947d79f5e32e2cd95c872979875e529bc61314b3cce95f476301ffafb8e55667358e459aaa71a8836af5112a596ae260deec442b53bbefd85f879fc03e315d325e0985b57b08b0a833ca617a17ae6dca69e060e3d2a83a864d30b30f679498f75d36eb371ff2c12134c430468d19ae50cb76dc36c7ff59137aef1e710c93e61dd9b65c3985de91699df98e4187ceb65dfcce372f83be05bef7c8d71f4e77250793e9994341f2b04d1c983b8db2652cddbd2ddf86ea88b509115127c5f643f688709d51ff1a103dc9c7141eacf6ec646cfd8300e63f76504018c16034dc90f56c51b6764988bc5bb4828e3a7c7b488167c7a5b0f346308908fcf4c1bdb3cdfebac568a9f5cfb0f3b1e56aaa3dc313013fc02937c4260843942f791746dfc5a50df9d8834e5c1d86b76b9316ee8e9df00dd1d95955bdf740c2b0a98f5673c1becb7682df20147dfe54a206465bcea8e5976fa04c41835c46f3e47ff90b0bc81b91b9e5caaec1f01cd334e2692c6ac02a3a62c3bc8f5505882c0786235b1142ac9a7f84d1f0ac543d400d216d54e9f34bb1bd910949b7c6edf30314b24e7842ecdc3e3b2b3c31269c604a531372fd956b928b12ce420c53cf069574c59f7291dba38489c67c55f8e4b3aee6d7150c48bed985afacfe3bcb2ff5be78ef9e3f3f7635936507f187984978aff36600c0c7950d4824fa220043021492a06fded7fac0a7f9448d903fce9162087e8287a5efb41c488d3512f0b3a238844c8ffa655138e9e6ee9207e61ef09e482af97b1562d0342bff84b40c9105a83b563e6e612576dcd77cacf8a0e6f2d6534d9cd8522ade4d2cd74037075ca49694e7fa20c7689727db2c25dc7cca37d1cf55692604cc8367ce991b67a220f53b9bc9eb8ef6d65f4627a64288a2fe7896b023784d663c0e085d2d25145851e1a0d888b22eb168a862a39105b00cb56fbe4906130b4a8a0c8652c92149a88d9e053dd41307a172b710a8f2504592a62dcb36e18c6bbd76db845980ab0d22e3ae6729670f13926572834e79cbc42456cc9f6a2baa28203f5386b10cb14ca4cb2a9c1bf45becf6afc7ef16ee221ad94b8f3d1a67f7578fd03501b66ab0b6ca442f921ccf6ef6930d3739b404612dac6cefa5f86fcb6e2aa42a60a2dff76fb860445880283c46597c56152cc5ec467f47af8912f95cd8037a1c907d529c5572849a857eb52eac89c366ba007ab9ca94e0a14dcf0fa269ce1f7b678306dc3d4ab58bc32a475b64f1a31b45a217c20c9c7c1ffa3a39d0370976b291185948e260f8b808712a4f124943b9e5e3eaa9c2cedd1077918d231e5cfaf2d847c2331302c8e41d165c0d27563d288b434ec9abe7c6753458c4e5dfbd107ae4c54f43e3930920283e57d65501d70d1e31f1c7291933811a6b942dddf779791ba232566ddfa235aad7dc37dcd1cbb71e9fb7ab1d5fa73dfa663675c76bc2deab648a3650e35dabb179e0e75e2011afb50a3ee9b1e4569f752345f0f6d8af0fd9659d7ddc9865707bf06cd78682e46070deaef7b9d167f0e5e98b442b99c174693356e56c7fd9500c7cf61d954c5110ca84bf8cca36125a675b89f117ad97489d34c45d01a99569f5cd8bd6cfe2070965c9bd55e6bfa0eebfde604609fdc32afa829c7f73827d3070d206cdd80fe290aca1f102a554738398e5539a9ec92bea3e8ed920fab109d58939a6db3d76c245439e2284f29b3f49c95a66906ec8df84dcf07ec8692ffeba8e8e97a9156716edf70648b503f7b06dfef7ac8f6ac30a835541fdf5100d22b0c3b6a713ddfa203e89ac14dc3a6d066597ef80f299ab5e8efd3fedaef09205d81070ee19164eca25a7c6f1bfed18296d62a964de9aa14fb99b3208644f14d55597355ceb8eb00048cb78fba973f05e860b2af055611ea8c4ebfa47372c31922d7cb904a0e89ac2e9d21cbea56fe14caa30b6f4969eb5897461a4f02010d37ce149030865feca6b95caa77edad5482e259ac03fc9175e546f40efea325bd99c620c7536749225c2ea94c49be3a261a8b45bb06ce2d9304af7e5cc5cf032e2afef65efc1b85861d8bfc1c6fa486fabe4efef98ff487a8884e47f33574ead62f03c6a8a6ea6cf59e7b26492b6735b2bce481520f1be66d140d3343bd31dd3c7f507094035196caa1fab4854662541d3aec4d20747b169676509927d33e033cbc63537e4dcded58b1c189c18cd0ee7e427d752678f369e556bcaca163c3372aa35d2792d9ef3dd3124e4f07427f2ad448a9a03de4fe53e9b71b9a85da879af6f0e72f5ae7c89bcbfd2fb0e8f6f5d4b21d6cbd639afc668d400c29f1c4a04479d09a699fc6c7ef6402897bfd1163717412f4dd94183f875aab34532a75596b4bafcb18e04c4eb814af3c3cb3b645497d886e3f994a524cd2609610e90c772ea8d50a534ab7950ce7f5c49aa26460b60a8b65cc5e796cf2ddd770cdac3f33f69913ab9411733725f92ecc373bc805a8639fa1bf3957d1fcbae19a4927eaaad22bf03965df78be7da17827ba60a3a2167e960fad57c851c95cc4ef2d51120da04fe36e4ebcfb4bdf32762a3e96062492900afdec90ed36754a595d5a38de9a36fe6479adc82a9f98cfadf0a8d67f4c32c0f676c62e945c0424bb2858b74a6d3ce7a6d6917ec01a14554e8e4ae38250e82a0fb06798a3b6c13f232b9d43778de770e8c58fd664d917ee824f0c177a6f2d532966d170b6b76d9c326f0310b50c7b8d81d59fa4499151c8cb0693a1990fb12cac8a9527f6092a41971c1c2715dbcf7767687e957bc503b8ae7a03f707f769007dbb384f71ddc0d2d980e48dc3678545df50f707ab1fff79c91718b7c682e2cacd4f22fc2d20ec383bd73c547c4ea0d9f488bd963a4e95eb3a01243c371c860d6852fb24ab8297099156b71a64340c5d3d54688054251eed8494cf549035c15551aa5ad259d6563c51b76c2600c30a6e57c18ec2946ac884b8906ff226d3bfa361f09c4bcbc5106ee2b91466b9e04a2d3ad5e1a96a35ba0024f6318aea706141288b8a0c6a7ac0f49165bb9a03c5c8121848e90e462875cd6ddc58c2626cb798646af6fda957923f2f51a7560fdf61fda5307b38d2ab31fc4cead95e4cc5a833af88484393c4823af4492acb90e4e795c24507f6259ed1b63d43fb023bcc5b6650e85281c96cf40ed21f702240b5978bdd29863c8acc91e784c4c01af93d0aec8fa61f1333a65ab328e81c348a02690c307806cf90e007b95b2485171cf35c251f8e15a55c4f34a603676743070bff701c06990c730b25c782b8718ff6e0420a158ac4697d74abc66e4853fbfebf028285b053fb615cd0cbe3d4366d101a71ae6b54310066e09969513fbdd8c595a9725056a2544cc4d74e4c19c554c59f71b8d88161f0946843430127e1e3cfb53168e11c768655a0a6741b81f2190157d8a9071c6ad5369ea705d2a434365877a47672da7aa906dd847e100f47240c6ab5e46b4b7714776b1c75c18e3108e93597a12db5725b901b57c3aae8a0aeac17f078e818569faf045df909919fd64eea36f39a0677b760832e990507cde247681dc431be5ad131f13b7dbfbf00533e45f9e51ed3340cdcaa4e5d64771e12f0f3f75ce549fdda088a11a68953766e8ba05be2ac1cd14e994c327ab1b0f9a0d2e29c193137f87cb4e0e87eef57b9a3ab777a7932232f59e90dd8b3451cea001e3279d755ac5e09b90035778d91cd87967ec51223cb4ef4bb796471abb03493fd8d0d09ff845d9985b3e0cce600adf7a34605ade314e78ecf22933b2ef70840903e7dd5cd8a3f7685af4a373cd86fb7b4c067fae68c9a403836d27cc8008451741dbc5b79424a6d58c9bb5d1423994bff4895ab41caeb98b10fd9ad8636b448d72b7930e5a09a2352c63cb3ec49d709d8c0e37f5f2a40d7490a0076a1a2f5a37a90e406dec3e357786843a13a0239ef4faf4cfa109b2a943b216f361f492016e19ae11702f8d0ba13590a2809fe62ce3ecef4d62ef6207eed2cf1acf43ec031fc1bb2e651b68801641beeda8f25a454d54849e52df31ffaaed3150605c4d802d4a2e3163d29398b5995ad3f1b45fdef68dece3ac9dcd59d68ca789bd334c26fc0710d00119f5ae78db045483fc4679ea2234eee389b7dec79042fabdf58013ccf41d69a7592fbcaf80868057b3ff1538633560ef0f153cdce4078e1c8297eea70117b867d669e214aac9bcc51cb7b0be7ba2200ea6c74dab82cc53177206248509ee1c9e28acdd170a004097f8432b65cf0f43cf5ce846b3adf40cf728620871450dbc23b7695b150afa4a86ef53bb309a958a4f168ab5952713e4cd2704c0ca97eea4e237300cd1be34ffb9f4bfa11d29ac70819b9eb0a87a2272885bf8cae908a452b5eff897ddaf9ff3886ae7c4caf428d7cf7e6dfebdb4fa801d3cf1f2e0120a3fc2b92dea58347cd46e611acc4c9f16bdd6dbabe049decfd0c1b65433f43a389e1f28683e048c6d86ba574e638111cc074f3a33a1e1ffffe98f1fc64726b1d44b56f93141ea9e4db1e37dbed8dc685f3a75936193ce8fd895a579aab7ba745a1d01cce5f2fc81e0f023b4d4b05d47c0b04a2fb51c4d4bb5fc946b3a4a2ed6a2942919e5fe57392b5ced9c2cf5394de10274a81dece960648788118e8e8bfba0cdedf2eabaa782335b35a2dd27fd3c06c99ebb27f1d15a54e4f1dea0f2c77155c2c637bb7054962b23182808a17b5e832d1f137ea16d90d5bc0d7e8ee6bbcbdcfdfb084636ce18b83e7a5f022b32aa82e443539dadbd97b41e49c56ed849560f7242679aec5224fc3744b69b77b6d09e0d4bbf4ad3102d7a9ab1b23379a6cd97dc1b91a67d84c6c036ab97fe5f98e94cd70b285a4fa73c16c206d1d559bcec4e60991dd6dec74fa4282164fcdcc3a3db77c088d8b2e521a3d9f585ba84808f0ef370da2df3dda68e75661643ef4c230495fb51c63066f5f063363f627f2cf2163e9ace23e0b25b173a6d39acc4801b65dcd1a61c9cd87469f11a8e28aa1594ecabe689d7f0ca32d17f86109bebf32f2a0406da900bb5c203eb606edb7e5ab04077e80a515d0809c2e82bbea169c86bd883a6a94615a46cebab3c640b2094869820b909a58e820b79eb74e389d499c3b3909844a7c1afd8f6d1137bb4cd4a4e40b336898a0a9387759443f89b86bff91d17472fd03c0161b05a70e85b2a0a8b8d374199a9e04d1fca4fff9a559119f96fc635ef6953655993064ee76071a2c68f513896fa4895ebf0a56afbbe7c5e489585537f2336630fa43c4cdf0278349339b21cc892183279c39857325bfc465317d3a45abd2b1d0b77c0aba4e7cd4db050449afdf65bff453f5aed7d76fc40b1b9ef1350dd0260643365657ce141d30a11d533e42f270db589d74369ac70c3dcd49ec0e0e49085bf012fcd8e077f25239c9a3137bbbdc93d2331309bf9453053c96698fc2a78f8ca208021fb459369cfe2098952eca0bd8a381ffd2236afefb868d2751782ac86ce62362d044571ee3262cf4bbd6ac5280c027e135131e9772ffc0429d35d20c96cc3ea98e8de8f801ac1e97a3a47468d5700b07cbfd261c18a155c95f06f5e0ec6560e44ed09530a3aee31408e9b7d7a337a93f26542e25d1ac542ae629adfdfb26bdd10ef6ac72e7440c6b78f3fc3ec59d7964082c4a419a4f45bbec7f173fc21e952516c71e199fc8042212e34cc0468f53223660f7d9b41751a8250716bfe677c8e2c13bda03e58bdfb4c3679536861c9ae6ed7f48a1d6ea9cdac99ff33a3f3c6663481afad0fe58285af6a9db15750660527997bd8a5654fa286ed7f492d3bee292fd82bb979778835ac016d50bf0d9e153e2ff046acca5bedd98fc7b44b79b4b780bd32a65</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2022牛客多校2</title>
    <url>/2022/07/25/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/33187">link</a></p>
<span id="more"></span>

<h2 id="C-Link-with-Nim-Game"><a href="#C-Link-with-Nim-Game" class="headerlink" title="C. Link with Nim Game"></a>C. Link with Nim Game</h2><p>对于 Alice 先手必胜的情况，Alice会取走尽可能多的石子使得最后异或和为零。</p>
<p>对于先手必败的情况，Alice会取走一个 $1$，使得剩下的情况满足大家都必须只能取走一个就可以了。</p>
<h2 id="D-Link-with-Game-Glitch"><a href="#D-Link-with-Game-Glitch" class="headerlink" title="D. Link with Game Glitch"></a>D. Link with Game Glitch</h2><p>二分答案，然后求 <code>ln</code> 后用spfa判正环即可。</p>
<h2 id="E-Falfa-with-Substring"><a href="#E-Falfa-with-Substring" class="headerlink" title="E. Falfa with Substring"></a>E. Falfa with Substring</h2><p>设 $g_m$ 表示选 $m$ 个位置，其他地方任选的方案数。$f_m$ 表示恰好选 $m$ 个位置的方案数。</p>
<p>显然有：$g_m=\binom{n-2m}{m}26^{n-3m}$。</p>
<p>然后二项式反演一下就可以了。</p>
<h2 id="F-NIO-with-String-Game"><a href="#F-NIO-with-String-Game" class="headerlink" title="F. NIO with String Game"></a>F. NIO with String Game</h2><p>离线，将Trie树建出来，然后将 <code>s</code> 在Trie上跑，需要记录当前 $s$ 在哪个位置，延伸出去多少个字母，延伸出去的第一个字母是什么。需要在Trie中快速查找从某个点出发往下 $k$ 步后到达的位置。可以使用 $26$ 次树剖或倍增解决。</p>
<p>之后用数据结构维护一下 <code>dfs</code> 序中的一些东西即可。</p>
<p>很坑的地方是 $k$ 是 <code>long long</code>，然而题意说只有 $10^9$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line"><span class="type">int</span> sum[M&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum[u]+=x;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=mid) <span class="built_in">add</span>(ls,p,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">add</span>(rs,p,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> sum[u];</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) ans+=<span class="built_in">ask</span>(ls,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R) ans+=<span class="built_in">ask</span>(rs,L,R);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">	<span class="type">int</span> opt; ll x; <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; as[M];</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hap[M];</span><br><span class="line"><span class="keyword">namespace</span> Trie&#123;</span><br><span class="line">	<span class="type">int</span> ne[M][S],siz[M],cnt=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> x,<span class="type">int</span> len,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,len)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ne[u][c]) ne[u][c]=++cnt;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;x) hap[v[i-x<span class="number">-1</span>]]=&#123;u,ne[u][c]&#125;;</span><br><span class="line">			u=ne[u][c];</span><br><span class="line">			<span class="keyword">if</span>(i==x) siz[u]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> dd[S][M],_dd[S][M],dw[S][M],tim,now;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dd[now][u]=++tim;_dd[now][tim]=u;</span><br><span class="line">		<span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">if</span>(v=ne[u][now]) <span class="built_in">cal</span>(v),dw[now][u]=dw[now][v]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> dw[now][u]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S<span class="number">-1</span>) <span class="keyword">if</span>(i!=now&amp;&amp;(v=ne[u][i])) <span class="built_in">cal</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> pos; ll k; <span class="type">int</span> c;</span><br><span class="line">		<span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">		<span class="built_in">node</span>(<span class="type">int</span> _p,ll _k,<span class="type">int</span> _c)&#123;pos=_p; k=_k; c=_c;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node2</span>&#123;</span><br><span class="line">		ll k; <span class="type">int</span> c;</span><br><span class="line">	&#125;;</span><br><span class="line">	node f[M];</span><br><span class="line">	node2 st[M];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">	<span class="function">node <span class="title">get</span><span class="params">(node x,node2 t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x.k!=<span class="number">0ll</span>) <span class="keyword">return</span> <span class="built_in">node</span>(x.pos,x.k+t.k,x.c);</span><br><span class="line">		ll len=dw[t.c][x.pos];</span><br><span class="line">		<span class="keyword">if</span>(len&gt;=t.k) <span class="keyword">return</span> <span class="built_in">node</span>(_dd[t.c][dd[t.c][x.pos]+t.k],<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">node</span>(_dd[t.c][dd[t.c][x.pos]+len],t.k-len,t.c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">const</span> string &amp;t,vector&lt;query&gt; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S<span class="number">-1</span>) now=i,tim=<span class="number">0</span>,<span class="built_in">cal</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> m=p.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="type">int</span> n=t.<span class="built_in">length</span>();</span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		f[top=<span class="number">0</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			c=t[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!top||st[top].c!=c) st[++top]=&#123;<span class="number">1ll</span>,c&#125;;</span><br><span class="line">			<span class="keyword">else</span> st[top].k++;</span><br><span class="line">			f[top]=<span class="built_in">get</span>(f[top<span class="number">-1</span>],st[top]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[i].opt==<span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(;p[i].x;)</span><br><span class="line">				&#123;</span><br><span class="line">					ll d=<span class="built_in">min</span>(st[top].k,p[i].x);</span><br><span class="line">					st[top].k-=d; p[i].x-=d;</span><br><span class="line">					<span class="keyword">if</span>(!st[top].k) top--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(top) f[top]=<span class="built_in">get</span>(f[top<span class="number">-1</span>],st[top]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i].opt==<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				c=p[i].c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">				<span class="keyword">if</span>(!top||st[top].c!=c) st[++top]=&#123;p[i].x,c&#125;;</span><br><span class="line">				<span class="keyword">else</span> st[top].k+=p[i].x;</span><br><span class="line">				f[top]=<span class="built_in">get</span>(f[top<span class="number">-1</span>],st[top]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(p[i].opt==<span class="number">4</span>)</span><br><span class="line">				as[i]=&#123;f[top].pos,f[top].c&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> dfn[M],ppos[M][S];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfn[u]=++tim;</span><br><span class="line">		<span class="type">int</span> v;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ppos[u][i]=tim;</span><br><span class="line">			<span class="keyword">if</span>(v=ne[u][i]) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Trie::ins;</span><br><span class="line"><span class="keyword">using</span> Trie::dfs;</span><br><span class="line"><span class="keyword">using</span> Trie::work;</span><br><span class="line"><span class="keyword">using</span> Trie::dfn;</span><br><span class="line"><span class="keyword">using</span> Trie::ppos;</span><br><span class="line"><span class="keyword">using</span> Trie::cnt;</span><br><span class="line">string s[N],t;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"></span><br><span class="line">vector&lt;query&gt; p;</span><br><span class="line"><span class="type">int</span> l[N],len[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q&gt;&gt;t;</span><br><span class="line">	p.<span class="built_in">resize</span>(q+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">		l[i]=len[i]=s[i].<span class="built_in">length</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt; ll x; string ch;</span><br><span class="line">		cin&gt;&gt;opt;</span><br><span class="line">		<span class="keyword">if</span>(opt!=<span class="number">4</span>) cin&gt;&gt;x; <span class="keyword">else</span> x=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>||opt==<span class="number">3</span>) cin&gt;&gt;ch;</span><br><span class="line">		<span class="keyword">else</span> ch=<span class="string">&quot;-&quot;</span>;</span><br><span class="line">		p[i]=&#123;opt,x,ch[<span class="number">0</span>]&#125;;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s[x]+=ch;</span><br><span class="line">			v[x].<span class="built_in">pb</span>(i);</span><br><span class="line">			len[x]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">ins</span>(s[i],l[i],len[i],v[i]);</span><br><span class="line">	Trie::<span class="built_in">work</span>(t,p);</span><br><span class="line">	Trie::tim=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,dfn[i],Trie::siz[i]);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt=p[i].opt;</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,dfn[hap[i].fi],<span class="number">-1</span>),<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,dfn[hap[i].se],<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,<span class="number">1</span>,as[i].se==<span class="number">-1</span>?dfn[as[i].fi]<span class="number">-1</span>:Trie::ppos[as[i].fi][as[i].se]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-Link-with-Monotonic-Subsequence"><a href="#G-Link-with-Monotonic-Subsequence" class="headerlink" title="G. Link with Monotonic Subsequence"></a>G. Link with Monotonic Subsequence</h2><p>由 Dilworth 定理，将最长上升子序列长度转换为最长不上升子序列的最大划分个数，由于是排列，不上升=下降。</p>
<p>那么答案为 $\lceil \sqrt{n} \rceil$。</p>
<p>随便构造。</p>
<h2 id="H-Take-the-Elevator"><a href="#H-Take-the-Elevator" class="headerlink" title="H. Take the Elevator"></a>H. Take the Elevator</h2><p>对于上升的情况，设有 $a_i$ 个区间跨过了 $[i,i+1]$，那么至少需要 $\lceil \frac{a_i}{m} \rceil$ 次。下降的情况同理。</p>
<p>然后来个后缀最大值统计一下就好了。</p>
<p>需要离散化，离散化需要<code>push_back</code>一个 $1$ 进去。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,fuck;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> f[N],g[N];</span><br><span class="line">VI vec;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m,fuck);</span><br><span class="line">	vec.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(a[i],b[i]);</span><br><span class="line">		c[i]=(a[i]&lt;b[i]);</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;b[i]) b[i]--;</span><br><span class="line">		<span class="keyword">else</span> a[i]--;</span><br><span class="line">		vec.<span class="built_in">pb</span>(a[i]),vec.<span class="built_in">pb</span>(b[i]);</span><br><span class="line">		vec.<span class="built_in">pb</span>(a[i]+<span class="number">1</span>); vec.<span class="built_in">pb</span>(b[i]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">	vec.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vec))-vec.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(vec),a[i])-vec.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(vec),b[i])-vec.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(c[i])</span><br><span class="line">			f[a[i]]++,f[b[i]+<span class="number">1</span>]--;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			g[b[i]]++,g[a[i]+<span class="number">1</span>]--;</span><br><span class="line">	<span class="type">int</span> cnt=vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) f[i]+=f[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) g[i]+=g[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) g[i]=<span class="built_in">max</span>((g[i]+m<span class="number">-1</span>)/m,(f[i]+m<span class="number">-1</span>)/m);</span><br><span class="line">	<span class="built_in">fd</span>(i,cnt,<span class="number">1</span>) g[i]=<span class="built_in">max</span>(g[i],g[i+<span class="number">1</span>]);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt<span class="number">-1</span>) ans+=<span class="number">1ll</span>*g[i]*(vec[i]-vec[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-let-fat-tension"><a href="#I-let-fat-tension" class="headerlink" title="I. let fat tension"></a>I. let fat tension</h2><p>矩阵乘法结合律模板题。</p>
<h2 id="J-Link-with-Arithmetic-Progression"><a href="#J-Link-with-Arithmetic-Progression" class="headerlink" title="J. Link with Arithmetic Progression"></a>J. Link with Arithmetic Progression</h2><p>最小二乘法模板题。</p>
<h2 id="K-Link-with-Bracket-Sequence-I"><a href="#K-Link-with-Bracket-Sequence-I" class="headerlink" title="K. Link with Bracket Sequence I"></a>K. Link with Bracket Sequence I</h2><p>设 $f_{i,j,k}$ 表示考虑到第 $i$ 个，匹配到 $j$，左括号-右括号为 $k$ 的方案数。</p>
<p>随便DP。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N][N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y; <span class="keyword">if</span>(x&gt;=mod) x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(n,m);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) <span class="built_in">fo</span>(j,<span class="number">0</span>,n) <span class="built_in">fo</span>(k,<span class="number">0</span>,m) f[i][j][k]=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> ne;</span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,n)</span><br><span class="line">				<span class="built_in">fo</span>(k,<span class="number">0</span>,m)</span><br><span class="line">					<span class="keyword">if</span>(f[i<span class="number">-1</span>][j][k])</span><br><span class="line">					&#123;</span><br><span class="line">						ne=(j==n)?n:(s[j+<span class="number">1</span>]==<span class="string">&#x27;(&#x27;</span>?j+<span class="number">1</span>:j);</span><br><span class="line">						<span class="keyword">if</span>(k!=m) <span class="built_in">add</span>(f[i][ne][k+<span class="number">1</span>],f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">						ne=(j==n)?n:(s[j+<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>?j+<span class="number">1</span>:j);</span><br><span class="line">						<span class="keyword">if</span>(k) <span class="built_in">add</span>(f[i][ne][k<span class="number">-1</span>],f[i<span class="number">-1</span>][j][k]);</span><br><span class="line">					&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m][n][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="L-Link-with-Level-Editor-I"><a href="#L-Link-with-Level-Editor-I" class="headerlink" title="L. Link with Level Editor I"></a>L. Link with Level Editor I</h2><p>直接从前往后推就好了。。。</p>
<p>用个滚动数组优化一下即可。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Byte Camp 2022 Day4</title>
    <url>/2022/07/13/Byte-Camp-2022-Day4/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="dd2d0e157c5fb2567823e06ec18e94d1c2f13d9ab9b34f0faa07512c9b6495e0">99251fdceb9fe96a1f47814acd3007f00b778d863aad3e0abfc36d48fdfacd95e1a035507033a1a6d1b6109aca7a29530d8ecd72cf71fa112e78fc13229d0622f5c942e1386a48680e7c7b635061aa051f6269ef1305f832fd21dc6bac54acc83713fec2ad8b687f58c643988c01a9935b9b6489d00d7bacc7f56a3665d3255602c0d33e806d25a1f232d2e132b52b4708a1f099c15dda7022373d417d31a3cd981cae5cd179538b0a2788fe235fc4b5bc4abd9feb9a5ccfa19eab0dc39a43dd9dac0c7823ca2b71503477f9e6ec19c14bf1056b3e8cf14676d1dbbbc9aa5eee090797c1fe6d5d4f09160006322b66ebb934362a1b1ef7b3c37988e894a176672ed0073484242ae95ea22bd27cdaffa535efdd23bb94d24aa0ed45d21049e3251cad7124f8cebd8ead1b676245a03c7e6aa60cd4b55be16b55cefd35f657b32c3fe800ba235aa56fa6fa41edf8101c2d5d749c6d3d1a5afc20ff4e9cd6599a4992efedc44b403ebf379932ac3fd2ac4e1498915790125dca2d34d2678b67c364de21fc370c89b5a41575a6dc91583d9aeb76a60d50284b96c6ae4df1eeefb5f27cbd76bde7f12e0cefdd88454427cc9cb78bf04cb8f21edb25cf1fbca2594e2635c7592cfb96ddaf55b0d3f0adfdb2296e7c1da28b836c03c55877752524614c42215028dc8c53484918e1d69eda058b7a1cd5c39c7f36e87736c0f892b9a8c68e41320b4e43040d053b959cce993537017887d4c7a62089eca0534349b012347db950b1173b563a4e90cfa1fb6e5e824973be92cb10318193cfd9d1f3b31d3228d7912a5c8d870aa2f9fd0a61eb6fa126869a4127818dd0907dac78c95ee1832c77744b1a4cb44a00077bcc1045c721f4ccbfcecce752ea1187767e2d277baafa252140e00a7d941224b5a899fb259626c312ea8ff9b9b7a93d909f43a35df594ba12c4d554548b9aeddb474d6da3dbf0066fa41c79f64e451ac08f99e800b29b7106f00193e29ea30c6fc2e4102ba5d7f219b1a5f1a48f8034ce318116890e5c7db1adc41250772846e923832827676e96dda4cd464f90cbaf82ca49cfaf8f207854fa9ab17679bc34542c5fd5a3a21859211dcaa4a407413f0cedca096dc8360a94d953338eb808f79f72b49e6f3e53ee44fdc70ff8d3756342f28de16a0c3cdefb4572a470c7fb3eb03a3bdc4fcce5e03c8a7cafca9340d4f9b6ab91d3d6225bf5181dde36880e96da7ba9e81e9c59e8954213df1d5f5d4c39b41f94a44183230dcca72b921efe49ee276651be7a5c3d10e0e7e347d619c83c799cde3f30246df041454a4a3532025326d8bf0b031ec293ad88730c2f64eed6f0091289e71836e05ef949751542a025369c4bcaf11e6b5dc4a89319fb13b3510857f5d9d083a0a4fc85b7decf52431eb429cfd22b780598fcc0b1a50cad3da6a4fdee992c2b15f5560d8e54157edebe201430709bad710b661d1533cc12489efb77e9be39fdb44137af789ca438d416176807bc36d91303ab3212099fb3c17e54ead7a1413e64ba0654591e631456e4be63816f2ba350cd13d7f66736a95b76c9ca5dbc50806ea2a56b65b6c41a1e40afbaf0bdf16940557f0be33df8e48b7aea6e0650cc7fa0c38f9b1f7f45de084b8c7d48fc3b55ce60814a7d4ff6104f69c5a42f28e23eed24a23cbf23ddf6e8a3f1c429bd9c1d95a4c6c8a4f70fa3537dc2817ca47a8a80c9a7e4f0026703704a339f9a9b8ef5bb4e2de9b6aa614504c6a385f9c2ae58921e0e9680212779d847f5e5a3c4d6623e0769257ac5164bf947c0a86bcdc14b4d30a7595997f612a42c9a4b2ff04d9c1949f339af42013b39a412ceca7d2bff33f683101c90fee1e890dc03f37f5c2c575693eca91f02756655f6208ab885b93ac0fafa4309f90f2fb3d70fa0fdaefbe32be9208876cd258d27ae300e12d95d6c0e8aaeb46576fc21035d51e67412b33bae018ae9de836dc51f910f5d57682f3834df700ad0c9a60eb10fbd0b3d3776fabee598d4dd84ce92b8d29e6c6799455b6fc46a704e123138568dd7893e9a025805484cf2488a2cd162521c906d1904392ba7dc64e470cf976d02dc5b60ab1c1dee09f38dd6985eeca7b086434b569fbdf57153774906c5167c452a0f8b0b686a9cd096d04a6160db7eb80ae666387a5f78e35cd80525af9a51ad870eaa7d898abfb4ec2442475db2436a28b704ea5f3d4137f77e3a6117b4f88d3642a956c3edc7b93055e82632ef7b36f6c47b0498b8a1814f50ecfd6513a7552f97b9e15d5d27d95d8f785cf58e35bf1b7380f32e1c9527f5d4a5670a6cf02259dfa16057631dab645479fdb7f2716fb9fccd493d8763c6fd76278f075fe447942c3f9fa8ca75ba95068926e11ab2376a6a051d042e9e52537a67b2c20dc60c9596e99177d8655f6c306fa05b4dd9b14dab005edabb44500f0210698b08b36bf57860b5d700343d821ba1209f4bc28e957d7e8901a3f832bac20cae3f00225f55fc5865e4b9dd457362dcf1e5abec9e00b87d530fa0082fcefc0239264656fbb0b1836c0f03c26052305364d669a0d75c8bfd57eb29b6b0be15b69503f0db1889f4a89577b3b08e3ac0b1093fce3e2ab966bdac36e1415be114cdf02eeb2488ba2a7c3fbfe31c2fb3900be29c5a3acd73544bc2a24b43e6f1ea83a5aca3e8703b6b92059e8781d018dfce44532027d6019e38a6627d17395e8d0ea7e5f8d7c245526d5ad8d1bf1f96489381a95a83618332be4462b8e1c59c81fa920c28eaded6f5b3bf85415deda3e36d29b01ef454412cdaf12156ae4ce018e24dc5345860c9757c4f74b08bcaf8bd78f0e712228d71b9bf9e827da05540cdf7f068273aeb6d9cb6800f110f5e8a9ce271518f04fca4773b76063ec10eff1483a5faab7aa41b32f3553648aa1933bac8728d78b4176d5d6dd69d94f1dd05d31fa60d9e9b9b5b05fa4fe867a89e44ae6833db3a302be019147f918f9c07c06b1c8da1b12ed5cdd3eeccaa00f5d3d8d0935b0884fef2c34c88b192406fe8104c96c1c1263625a618c2197d72255c26292fe6bd188d63adf40a1848ca0517b0c8b1abb1234c6ecafe4754610a55938981707ed728477cbc369c614399a44489f82ba643be1e8f80e916443a08d007ade267a54c77647a2b5c10ef1743c1f71753144d5d129bb0bbbfcddbd867e9d9f439d49a1caf3ebc20d85ebfe69fd4e1e38fad3f5a041fea8782285e5397dcaae0a94fc5975a9df882e9d071e8bcdb77180c98844fd452ece1895893962c8567fdfcc2dac44f9f4dadb65e32b90bb816d0e43442191e1b22c4a5bca524202616b0ff51d4c2818f3ca816ca33d83ee7e72cf0e3b39e49141ca66b03b09acbd88b74918d5017749cdc614e88abfbc52467d0fb66e24e7e8c9ff4a4b03457b06e94ae83fb40f8db1b28ae39e49987fde765e1f89aa6816803e6c22dd36ab820a601b89e087a90aa23db01696da487106723ce9969539511d33687bd2965453a33dbb03a3662fd6ac93725f4bafa68cd326050af3fc1ead9418bbe6980dac24fb2f5a80bc1d8dfa7b30c75233453ded8004ec7a496635747d6fc57c4371bbc27e779c7b9ea1c7f697ea2b63e36d8749a06e02807fc1791b61c43e4dfcc69c1665a727580269a9492e2b1fbb518e533c488c4b10950a643ea078091e409214e058226e7460742ef6147c87bcb4c253344aa1c547ef338ef7b2edc41015ca40be133f594658256f8ef607d1051b40d4a264e7bdcd72e036491fcf8719db41dffb0c0c3fbcbb8f6a3b18d6fe00fc61fb7af7d6972140acdcfd77c0f17486f8895de3cb0018fc10e771097484da5e52acab3e090412fc1dcb29781911e041de948526617df28d4ddee683aa2f91153b6f2b45ada8b2b8dcf76e5fff3ea7bd16428312cfc0135514c3226951b89274ff632af022c293341933fd3dff393bb0508f35ec9e5c78bfe3b078525aff284368f34e289f039c572a91b94ac12885f13c366a9d5813eb9c13e73ebdf636861349c02540530b97112d1a93f56d4bb31f7fd016d24dffbf790d0866aee0fc919e27211ad3796937d228bd18edf2f78f7993d7f9ea6e65b6350d600e8a773337998f95def4513b4e7d4f667da759eb05e54aece09a4d4da5beb2477553ffac99b96798645c51cef39a66eb0da182b37c997171deff65dc9a2dcdc656fc34e642e7edffc267e86a2b18c6f69e432a55e05d6f7fc1eebcc6b68f040c45f2acd4e6b0ff1f5c2c8151a6d4ad5885259f8ec1e047aacd050d30f4ceba3a88643b5ed66d515050aaf79af3fa06475da4d148c7dc21efbafe0286c250f498b1be283f098d7547b49e15d02ddda05fea32f638de7ddfba4b06f6ca1b0b4ca6c8486e397ab93aa5ce4bccc8b479cbe99927c596ee180cd18e29fbb514cdf0e101ed945718565d5357538dde92c41ff6b9fcae569f14608ce6831ef4f48711d4d8c10fbd0d57aa899061a76fd17a17aa291fd32220a9342c1836c36b389f12a085208d253b4a6f0f1554a855e924e69a7ed6a1aebc2df8a10fada40451427f9ace705ec03bb3170dcbb13d80b39c11edc68d96d8adaae54d2e86e0ff3789c69c4d7de3ab22b743123c5abe5221e2806679ba80ec19cb7bade6aa0d52ce617bb4f0062d211b77df4828639c87a63dccd8d56d2d228aaf6244ff030c4f918c4ca4450936555e5bf925a05a47fd7802b6544be1c2bd31c60844e462312039f7ef50d8274ba04c0dcc9594f0400ed8b7dc439fc74f4e0222ff15fbbead69f78d986d4d26cc6facbeba42161f3957ef794ee10476b9753eb264ced9c27a4dbb05cda7f4ad7b9a4b41e14a91f2a162fa5c0b4bef37e168c87e7730acbeb050b91e61858dfcbf27109d1a717c5f7db7e3cbf29a9262d32892353a1f17ee90c46f9c6bf655c1f43c3d765fe7f1cbbe0803b74ff68c2918706174913a2ccd69f077f2232482e897f878adea9067d28ec6b20c1a35d9209ce74689e03946ac1a5fd8326aeaa070bddc6b2e93684037eff00d71f7014b004be2fe8a9183e86a250faef857ce4b522074226ffbd8e85645aaf63393e382720502bf4e4fcd9d69a97e468e0055f7392f71ef3328e7702b13134ba68d2d767f456264f630c2278c6241fe47020902ff196eee5e4c253920efc59644f4bba163466bfb4644e793f00380c95353f17dbb238ab9728ebb791c45d0e5a5e4441a2d7ec176d53b2ed93c4e76c9c00625aa722ddfaf84322d0134a48b026838de6cf5ba4155fa94534a28b1f22bdee78e7638d42b9c1b97124f44bd62eede5f4c9b4fa822b7d48b23fbfcde9be398f71aa2c794c18666c75a35881f144409bffd65e1b2744cc43d3cd035d0c3d0583ba360ff2298348555e54f79798d7cf5f25c687348d08b3077bd2975ad409bbdfea499fbbc65dc079a2adfdff1baa061101fddd970ee685a3d3e2385d6897e4f58f3c7fef7fcb198916b4732fba83e4fa1f2605713f8585052ccd6fcc7d40a1ccf984df086835d8dd6be78b60e3e2e798677b5cbd3e5ae9e15d5d82dc079908044b06c7113897b3659e22a5da7923669ca3a4493a18b926faa0402fd47e82a9a8fabf21ac7f703944d65dc71157701edeb5d2402cccf8deee0eff92294a390bf5e3488e9f8111afb5fc19ab533f1693826e01dc063d299bce74ede3251250146cac848a116fe87eccf84a284f31640ff638a2f20db82145a6b07c4e2501d3976b750d852dc2e3a1c7c1f1bd3670b3026deceeedc01f60e1ccf901463bb7850560ca26fd3a249bf9f5ee3dfbb54e0b62002d0a3584e0eb362287196a2d43ef27922f5be609f333c778b08cfe36556a0c3a14b359c6fb0da7755d0c2a085bfe76785f943c9a9874b8d8473d31896b469cc64c60ccd358ab47297006183b2917e17870fd1ac8f9f36a07d271e57f6f4ad5eb106d5cc6f1fdfd826db4181126c2e23f101c129f3d99098c7bdbd276d3471fb42ecfc03f943e26c681a2f12c37714f7a59108776f570e463e53583d0d5e1c324401253844235aff26cc5bbbd25e1022d268544d9de7f557de023e69fe7afbe69c382eb44747667b5949b788d834c7bbec8b1ad94cf434159d48da6819d79933494c8dc7b55ffda21e0cf6fc4e1ec8b91c809cc95a6e858dc4f5ba6a7d8e03bcc945bab7a4aeed4071b0032b864ab5e8096d4f6bc39be5862474ca1e184ba9ee9326417d7ec942a262549c4d026b2f5ec664dd7836269be5665c6bf658ce69e8de466c831ab1a7e28081633113c823696c165f73c37dc25bb2e890c45d7a478e3bdf0561bb9786a140e8a4ebb443eb0ada3f201f9a6f4b7476bd4777f88e5f2cbd740347a1a206c1a60a498fa0f93214e424965d97eb99858d75c367268ebff8ba4c451e280be121d7e05e800ef2d96f6d6813dd1caf661b7c8280c9ddefc173c2f031b4cc2e85377a774772cf17b9a9bd01587dd08d7cc0a692bbdb442486467afb75beb5149819d73c11404f96efa32d6d0483eeba522203ca438862450766d363fdee370efc4d37354e64ca7838a173013a6505a438afba9ef4314e677b2b9f44591cdb61f2e1710e68e00ef0072ab2c329a8f17a4375f240a8a51b81f67838f88c68c238be1a4af5ad714747bc7f1419aa10ca94911a248a7c67f9b951a365f73094e014ff0d5b9b9afa2e06cbecd19c963911419744b620493c09379d238680e482e071d8fac53789eaae29b37dc9eb1c96bb87c5cfc24e584ef4178964ef6766fa48c1b1ad5f95f170348a0fb858cdf0abd08037af9364082ec2553ef64fb3e46879910ef25fada4783c68d78340fc223166e15e66c065bf6f5da4509614c340d90984852481a913892d9b9a87f73e251ee8983ca468a199ba7e5e3f7c50a22c100e0d3e8e6e407b55c57228c7adbb0a5b1b27bdbb87399a087dc1b86078f2b69f91c8b43403973807c6522c4c50923a2a8fe52f58897e57ae7a5c2d34f36b5ebf9435fe9e9e16d6c78ccc8c9f9752252f9ce81ea7c87510334e180188418e88631270f25d412d2d2a0ede686dc75a670c551daf6df1de53ffd318f13333f8b707791b900a7d2797e9636337bdccfae5c9b008f39fd5de0c154137ea77753bdc7cff4c3a094753aac97961eabf462ae322dccf3c5659d875ee2c977ed5511c71d9611a2705b93857b125f28da823bf6652942246e84d8b2df8ab1d547fbaab0f083eb0d9594aef5077eba5b90987cf9673504b5396d8f4ae18129a6d5ca21d8867e86b7069956d33e3ca70985cc96e59bd32417535ac9e71d47a6343199314498c4c875d0df88f04084138f5483b88b059db1b5d0f4d54630963c1aa769d0cd7d64ff790d6616e533be2a44c2590f0747f6557bc5a7f9aaf06823bcad76e95fdfb0461d963291b70da0d032f5c5aed14607f04ed3000536588de92f28ab774f850b3098736b845133a77dc9823bb11c06f274e33d2e29b2e346cd8fdd449c4674701ffeed2848def28bc7c7d37bed9b5bfbcfb7f299b75162d27d13b309360c10d1ab1e328b293231c9168471c207e434c331d7e9615fc0abf7f6aaa481880966c9e7a622e216d2ffa148e5020e5f0f7335f3141665485045c61a42f1ea88466039eef18e007af822593500984e7fec074bf83ad8355d6b24ae6b9ec3b3c6b6524d4444968b11d8f33bdf1d5d891ac208015494fab3fd0f9489f12759d776957de8f63fde1bf14658e07dea5104b624c0a1ed2f733172e3663292a443eb9e6d2d57446552e5a7fefb92760a0e06f9573076d6bce3bfd93a51f0f46f57b1b1810689f1fe9885984da5970e2819deefe3738243705c6b68237961af3a659786c00111be9db98f5e833ecc17f5288add1bf2719cb377938e530562b8698d21fa31f1d64f33c3d40722459762dfbcf1c945d5be82e10f73f17efbefaabd23bb49ca07880d1807bdacd5f731d668f68ee9f0365da6815022f5e1766ad718c8eba10fef6a5578b8d1669f5e72215041351f5cc8f0c0c67725d4744df30384b3147f8b8d1ba131b671b8eef3c843162877c7868302bd0a7f526cb4ba8d4ad087723723c413c0c0920692c234e1e889d84925e07b42580a4c8236aa77ea6527e60ed6e70f6cd8b93f8b702b713b5074b88d1ba5274badb3c1dd549a8450bbcbdfd754d27fb20ec48a52edd93f00fc6438ab26f56bae154347284fbfb5b1def4952cf3a64988db905654df87aa0980424b219bd1554891797808638be63a910fb0d82dee68582928a44b4a189f6017631c00f01b0fe837980f643441bb3201e2f52ed510725904c24c832c04fd373d13d2cdc2b322fdce72479a7ae3683d8141cf60c1ded5617ca82d4f8095243500caf57b17568f64364345167e9614c01211e425ea0ab6be540a90ca3ee6736060cf44ba504beec0418f3a23a959f35770f5d11f20ee17a2c7e2b0a381ffcbd92a4741bfface250c48f4fa1507249f27a6ed9a1ac32850fdd9ecfce58dfb59bda6ebf772285748034e5647c2cb2aa454e137c47cb53c2d0f02e505693cb07253dd620e57fcc8873a59ac1b7b428ec732fb7e666559178617ea7d94913f99a9ef5ffccb0d377751dde92e77090d77a5b18555ccdc26dc9efe9890e777550c58123c478cc9ee1a05f2c9fa7639ef0181ea2870cdb9e1b36504830e2b6ce1e5a592b01de0df987892c94a7c1915bdb464e5b35e2db966db329f532d773b6c6e078f9a505da5c14fa60a9bceca346bbec6cc9db5783ee0084e4d68e229e19575e9050dfff260a13f223ace0dd97738becf83fe4bec28e69dcfe3702b8f46faa45926ffb0658c4d5fea8f989b511f51e9c12384eddd63c929437f7de0fb05ea2f0e5c7e89a9affda5d9cf2cd1c53d69686bf0ebc0e7ab40ec1b6f9f7b0e50369a45113d0347d7f95b40da82d64fd987b32fb78e6f7eb8b9d5f2b11b725f88867b9a1e5a0a8b1c2b24fa648c8b3bea07efc099087b75718d9e64a4855170f31484ff83dfd8946a7cb19c633a8575c04eb66f2ecd46a72920617a615b6f696b41631f1e7e3e8bb56d59cff6153377b5df317104dd2370b4ee29f3961a63e6f009d8a0448fd3ae6d13d87de9d73e8b6d25ed86c7778fb7f7e49cc122f914a4877c9d45138cf3bc38765c5b8a328e2bc4329836055fb744d373d9ea7aeebacf1b09eb7a2f269f3b64fdcc76e06fe988c5fc75a4ab3ed3652e05cd4c5c86bde0af020dc57a8da25c36307fc79b1f44ed964e9ac17c1093fa73fc159cb7c5c7eb4d25d300c3649dbeec72dac7c3afe89086fa29a1eae45daa5b6b81c07a402472a7ef5173f565f309f321a4481afaf567fa9ef91df93f5d03945c3a3ee0b31891e8fe524d47af0c4b4bbeb9b0b9939836c7620ddb85faa8867a2c76fc1a73205becf45f84cc4fe49acfee2d1eb2d87548dd021b5e3455ff016271680ee9f2f8ac6e50e58222579b3ae512f5776c0a70fa9012c27f503a3a39d6d709694a05a14db40f82100062b4d94fd90c0f0d4a13f6999ee9fe4bfcf7ebe6e95f151fd8825d68a1f5f19613ae5558e9a8b9ee06105ea756d9075b070b18ddd36190182a30342ec9ea65b3b4625b9ee46becddb9d9d0e636cca5bb7a5d73f149ccb2cc4e832498e4ed0c609515b4f307694e77609e724e32b43f24f41e3b5d7871434c3534bdb68bbb233ea4c06537137f396b47560d19cb1c24964127f21bfa2e5df16d9f3d96e59600386e70926832f3c522d7bd45571ae0d24d217f1af4f3b191587cb790c3bf5e6e3d99fd6f38c25175ce300f0c33d6eb509918c496a2afa38bd09136f30a52318636bc6dba9c168e495052a263dc73530837ea0f73226452c8fb4bf3d59a9af242b541e1ceec4ce6da2d5065af18c57ff3e15fb3ab3f13665c9d4e04aa6fa0ded1e09dd65b3952cb54f1d7f415b679028c24f0f79cd2645750dc9367a94b9852f1c6c9904707a9f491815aee1e9747939f4dd922e24204fd2280b310aa1b5b7100ae8fcbdb7debe8bb03e198bd0267b9d508a90adf6ae3e2a5f7c5c6a3da261071d17cbc27edc127f583078a86b7cd3881eab806ff574eda8d1a87799bc9cae28e39e3293eee01d747d5e51d080d3bd90920d4ab8a28bd3e5d2f0577bba883356013f708446d39730fc0332430ef771b52848ba49b4f38254850fbc578b52e141029fcbdf6e48c8f9b89892c6fcb873832eeae4b65a6c59874d0c4d66fae0f039f0c8d9bb30c3537a782cf1b12b38f4201566c9fba1835b2b1c3fbe0f326a3e51d562bb368adf3263da032e1020a01e643e12e9b021889eae85887d4a8c5764d931e03ed3e2b80e773c2477f55fa90b328aa46a467a2263ff6368ceb23f9583fbbddf950c6c70457fc332f79dabaf26c707d8a2c2096990f198dc835bc6329746d82406286d9794ede5abf9a0e395150a1d8ed24d724106485632661fb0a1e1e47577e79469a71bf8f1fa315eaab8f926860c20507069bb1efad8b21d1cd58befd378a8d9fcd0fee9e5aab432b3e6d7bf5a767ad42d679a296b6d73c76f7726d589ad4955a26b42332942a5960cba54fa61615004d6c8e0e06e6d032a7697de08d436a34d393c72561119e045a7a3831ec1aeac7d5bd57b1a3be07918f48b4117c72abdcc5918047258af39826303067f5c4515032216a8aaa1794a9e5ccdce2256298de326bf9e3ebe8235409ea163dcc524a22eb742aca14580c078144e2e002667dd49c14a5a638065b83cf9ba5fbe4c705160ad2576c3d317d7cf6035726eaf598d29fd333004af22335dfb5cd2dfeed26a2fb8a37080901c42a31a0f6a77bcbd08291744f3a5213e86060856098412f5e2a86ce5620e38ec81adb174f9e4538ea3fda0dedf678727adae227cbcb91ef82cb4177923f0b85579e6110b3f413cd5b8876d53237dd0d4607a31825122e643864ee01c0554949de93c0596cc3fa4b6fb86f74074c0d71e37ad53eb314c31895238ab2b9dc7f7a840a872feab89cd42ec1135620d0e55a4252d929dfb675786c60f13cb1bb0f7b583d381581cbeaa095830816df9c8f43b3dbc1de39d5dd000657ab0041e04791786b5bae163bfb872dccf9f6337ed7facd29a561a5329e1cd2f9c9b5ef58958849a545344436cdabcd306be8cff373e95927a14ec35e4e460ad969059c13a6824ee001ed3e18241e0960fc78f013829c7d3027052410478ad1322b142ec3c25b848eee0f0a372d1a8280cbe69a36720ffe61b6fcade0bcd775c4114da7edb8cf139c044f9f581f3247060dfc41c5e998cd8576877617cd54c92388f5c2b72eb09ec80cc739b33d99b5ca853e61078e28be8549ce25024f798f6963f0f4351c98a7acc33bd413bc9ffb5afbbab2d9132b75d7f7c495a9b2e0e939e012d589c4392b1282da5541ae9b0a4cedeedc07706fdadc10d1e3c76569d5322d0569dc34cd3bd19a67fa6a650dc1ecf126d94afdea706e88d10c6e5b79cb460f174e8173942b2df0405df7d1f6190bbcb3f9d78ea2dd5f4832fede02f220e826b67dbc6e49df739735ab18851494673d25062f7a021091d827639fe6fb9a880c3f0e9c5f2e315b7081768f061631764a92fd02a785f4e6a59982d6ffe12acf727e4141221779f80249c2eb68f19c94ad9e898c5965208b595a07ad643f2e7d229d915027ebf2efceb91126a8b2535f989734b6da33b202c3126f8caf07a8b1132b5a50d4fd5b1e9de7d661876cb8de961352b6b0eb642717e5889157b4d68d194bb2815eb3835d74fac25604e6cce9787b6c091c1297994e1f2722d791a13fe52c7078dff624c6009fa7f00588c3ad76fdf5f75622b77026fca2ac1c60dc4745ef96ed4f35a0d52449783db41623fc0301137be35cb283bc7002c24c364cdee7db59ecec3268410f5ebba14fd7d51872d7e1420b03a56ee383c4bac767b33d6d0e4535121c988132f1753668b522dfdfc02008df24fad43331d64d437cf105d6719ebba4be0a44bf5f9e31b4e5b380e60c0e307550845bb7f33958ff438a5019803a9253326bad48c53981dfc6abf162992286a7d3db781d6f7c9f2dbd45e02cab92cd0e9809484d8406dd515b9ee00db47e52ee390e15e4e5d843824cb829566d4e457ae9678c94859cc3e047de1ba389696c72b76bb2912a0be4662f031bbe02beb157aafd3473c11b582ac7f51d5e6ac7d3c43a4f7e1d3eaec8dac5fd3d6a80cc160c8d43677fb6c6daa1b2bc9b16e6bf25c4363ed40a358123f434c510333c0c41bb4ec52467b4c4abed52680bdc567616a2e29da04d6ef0483c7a8a90360c7cc23f05850701249e6063002fc15fc87b69fd4b1a2969247e4d5c848af931179de8e6c41e922490f21e2ebb01e80e08c45b39825b91f9a98c1687a52c2a758cf75bc3aa1ee0ad237aadca0bfd21c6ca5abbb0a21b3fa587ca84bf95aae9245c3b22e94d02efbc504585902addb337d4db4c82a7ecced01bbe21916c26aeb7a90a56229c410e64f35e5074d09f822eb7b0608a038c98f020846df8545dce08d204f2b30f86294ceab87487e7395c63361f4f6b612295c81167547936d323c94081db6cd2dbb28ae7dbeeacb7ace901461a98ed1e4247fd3cec9da6723635f2e3978e9f9a31f60d09600ab61e879bb69578b2e65ada4a9cc77470f9fa79dcf12a2d015a36064c3a49908e9e8d1654e3c9331ad3b6aaa9db2f40c956b0f9d1775e79ccb3e4fb0da5439f68dfd950de3b3d0b7701c5073e485c5ff22b779b7bbe4a53d75f367f6c4f05aa651461bb103019d8ec1ca5d7693c09341c7cb0753e4a4a1c38890eefde6346f957f83953b91047a600c785fca4bf5af692ac6355b649428ac97197470fbc3e671016cb770f29a1e4cc52f58509c092bd9244e1de0fd65331aae11de4b33cc1ed43bf2f3984485e25271c0e0581c374f0e2a6e3653259cd56aa0c1d44be2ac01749091eb4d646ff45cb988129567bbddd18c5043ddf8b8982e03c7350e05d00b6b85d678165f53c65b37a70c6eaf2a816bb01e743bc1dbeaf059fd7ddf2807133a93903a7a5a19ea31eef7b65e4070bc3bc5f5a9a0c65d6728e10285e9add4d46ba0ffc275c0bd353b54ec1768c315bd72cbfd28cd2bc613c221bdbf647b6c1de93da2884cc025122537b2480214564ccd54b3333ee84da4acf9c01b76936e4756a14792ef670db734a83d6609658e5d7a771d8c08ba8d5c65b536aa0f452c9860793a1aea5c2067b2bb3c5de454909fab1114b6d2e232632ba789833ba0a94513e4e9663928e3ecc18632bed7a511c2a2b71dba9dd26da233408c57e216d286a033bd87c4f4160fceb26fa282f901d9802a38ba9d47bae29244ce27dedeab50c7e7347e575627c025c7249c96b74950cd64073db82f71015fa076013126d6a60e5aff206325a7bf20dedfa80b5df3363b22adaebd8e9ecbcccfefc88a8cf26e991975639b8366aacd3fec2e04f267dd933a80d55003ae3c5524c3a66fb3bd4599170da874b94e8dc951b7b987c9cd3916e5dc9e0f33551fc34a0e709c3e802bab25b43d774a30a17fb282946d476c2a6236f7b9ef71074f2bd6c26f74b59cdb3aeba72790dc2b98af1ad2a6c59697231e941c8feabb4ea4c2eb4602759767947ed20949403906b905cbc56cfa8569613586be856d405b8a2cd41fe58d940dbc5c3467f24889e427bd34531f27590a2a6aad1566531f58b19692eb4397d157d5fd665b43eb672afedd9fe8c093516083ddf25ec645183c4cfd2970ddfaa8b3097f8887983768f12b70e27c7d81f474913672299ae2b023bb9e472b68d5dde751be0042fdb0dd12a2fcd56529f544e668724114bfdf1df5d20a3419147967ebf230b3a7bedcf377891063a12e929c47a2407ad02cfd17b640a3d89d9a254b96ec305740dde70e617a7fb6b5aa14e847b2fff5aaf96822d0705b740dd8b0d0498cc88cbc5b5be3869cf2d53b606fe31ec5fbbd56b60d299d76819f26ac045e949018f5c55aaa7702918635bb12639439bf58297df6d5601311c630c5d9453e8b543fb8b88bfa7f16fa5dd9263362344f4975bb2585571d83961364892067a4f57c58f8adfb224c2105d7d784a1e22f2776cdac0f3450f3a6be356d837f3b91779a2780ff6a73d982af61b13098b91227d58e934dc91768e7b4fae0fe18e6081134e9cc7669497d82b52deaec35ec66d031140514263cd34caf558f8b4d238e29628c7b3782423d72e13036c7c3a458f796607d3b175ae1415fffaeaabc3185b647efd4364711d157e96cc210f8221c1ee82e378f7e5c0930eab800035337e4a64618952cb71051683108a3c85f03cc54d537ce471724054067da804f986c943d54397cea8c5944ab1f4adb51bb8e161141c6e0e29837424432de3874c1906aae5491fcd119334206dc3a2de7da358fe474d8b9126b4d26f3326025ffc2c5f4865b23cde6ae230321bdc40c71dbbd7e959572789c1348f027383af4f481de9277e50afd6af252443940913ac629a372348361bba0cc9bcfe1bf27337708c1bac07b57efa7eebfae9537dda7b0a20a3d82110f01ccc9432fe64f04434d29e335f151e255d39d799eb4b86de8116bb760580cb0d022743505183f14914fed988dfa23ea280763382def590d8cd21df849fd1f0224999c1fa3c4b10ab34d8eb6c851b09db14cc41da0fcee6f120652560ec200e572c25c84d8637523b5b16dc34af069aa98daeba42d4c9ac0e098de99ec999e356dac2cbf2ff1f618ffd4b68675ca39f0f843be16e1cb20f783efbcbd70e3da1e8d07a94c0a408711d4503f82ef4cbe03645d5d69c8cd4c4b03bb6b6f8095d522cb4eadb7d5967df712762c7e2105a528c4e96b3d37c1b46daf5c14a9bf7a9cd5ec73a0ddcbdea3b103fb68ffe4bcfdb65ffc6386cdc59ca4bd6a409a92ed66963b66bc1f5ab10648667c41812f00564a33b4a10c9d0568eab88420e92cf3b2a51ae7e487b6bd6fd0b5811b92a94157482177a08ebe9041e020bc9fa7e18ad7c28d919df72aa21c98abe5c0cd33d62ecf8beb87b034b0eba9d346c9b073396f7467d9f61041e8fafbe401fb1895e07ce8133d61fdd4664e37c5e53855a32508ad626d32a430ccbcc8fdd286152ea9447a720ff99217c8fef124c1b42df159e57b10130e1a4f9163bdaea33facffaaf4e648e4f73214d6033fe75b75906df2eb79b34db596c04ffa39f189eba1c3385b9718b7dd837f4136a3dfdfd7f7169a359346103eb04f911dedb96c2ad2ecde985365ded09a6b1aa64d5a27bda42e2485ca9dc1897fbd077149e323d69268570f70797c4fbef6db84ca8cabbe5ebae31b662e201927cf2ad1929a889400a96fd6e5c39d9d03c0587b6b1c155cb3adcf4f8f09b71ad4d8ab4d352f13f51e58518ecede7b64fe328f28a60e64264ff1966445670ad0558b0df65f88fe0226be2b1c0080b65089038d9eaa92f38a7a06d10d175090b1d0a29da87b1776fcafb018b986300934e708e5ff61996f436bd17958e15d181079a247a8e5795a2c8a4afdac5a229cf6b7361fcbb891d10620109d912fb6291cde850992029a860b12483e4565afc0c12f28e4f9cca5fbc50217675864ffd86630f42bd335b8185118e83a06f1b2d7e09a8be8b093d9c2ade4bd2ff0ce15908d48d4dd4fa0af6d72297ee9fc1b9798622c6a53a377876dbf3e74082a839c35924ee324a22e991a380e89b1ffcbd861449ec8899da84819cd25c439091278b5d5b946f050fbcbadc614ddc4c748f903b6c03dc15f3de06a6e3e508c4c3803eb704cce4ebcc6fab339b3e8c306b36e05a4e727b92fd245a1bfa9015a4611d81049c9d7491e6c6399443080370c4954e7aeaf85360c78716b084b3b6eb531a1f0975416189a11ae28514451dbea208b73b9049204bf8e8e6150062327b8cde332a09235595aefb710b351b8a91555018b9c11aef8f85511417d64e5523a307878b818d4872aafa665dadbdc465262e4e4b213f2a80d3fef5bcb75e723c59d44f083b8693f7a1164d730a7b7657cf461ba51f3ad419cb0437a57e81241407d0b321d7f45d69c1ce04157b634fdbc9555a7c8b0d75453b47e8ab06aa4357fe7c15620c7db59242123e91ae13599913018a4b6e5a085bbc174e3b3dec0045f8b36138f19eef62ad2b7ca672f8486b886f3e2601fd86617f1eb94e00da7bbb10f03cebb48c298446cb633f3775ddb8c4bcda8404124d995c0bb03123c478e56c53118559317d4d8a5158f192ded67fa70ea7306a27bb7250910d2c1e20eebaf55da2056dc867b562e9c8ebf648b6f9147aaa6e43e7d442c9d611d533b13816b82e41bd78e5918eba4eb2b1b7665c444e8c776ae25e1b712b8bbf5e7615d3ce98021a24492721225d7143be72097c3517e981a49ca0c1f63755e419541509c3bcf062f90319400e57db7db9560ed2282e2fa803f191f9ddeab995683e39c5296f4222393c2a701077f0f4abf7ad6f530c8c02e70ba8718c96409b8d0a4d269ecce053c2c0f625c58e104760ae70a394f01c56b367170ee7c92b708da2f4ab112211e75c6e15e2fae3f7fb987debc07d13c39c9365729eb1165731ebaa3ea3668b2c8453dc7f5e1eb15c79ced8f59422eb813817d04514f217deea7319694a5a33fb930a79bb36363dc590ce69a3dc47beccba81e4d0d1e6ff6a9fc047477ec3f81582b182d6d4bb2732540b3529140f19a0b11b456272a9f49b528618788bda995f20226e48b1d678ca96d7c8f535b5d06a6700d84635947ec2e32ccbe7c163202674b8e675b8a80682da5de1ba6756f66ecc03dc1e7e5dd70662203b6e3ca4b07e1e91322d04dd63fc2f07250ff3eb5347329e8cc3b086177a7808faa04ec3d7a544096514c96d6337efc708a8a0dc17c2c4e83f08b096a40a70e4d8e493343e0688b14acb83be071cd8ad2b17dc5c3106b726fb92b6b2591e2018336e6841e07c3fa88a33d7da48edf72c28ee3b9741d09580a2d7ee2af85194aecaca2ef4b7ad4168fe781cb6b68e7e88716569735a9bf5bc3df6125bad4ea47c6fa6df37b4c1756d95070be62f5c5f4903659f5bfd443fb7141a5a40f593fa4d15485ac25b02e7a2b361a4f5a35b4b509e4bc105069582a67d20b98ebb6796b60b02a4cb0d5fba37c9af0f9ea45a29f8c5712b5000802762eb7ee44127ea0a27361e39001ab4173107b478dcf5ed5433e376f561cdcfa402cb0fe812ab0ecdf3bf08cf5b198d208df5d3047fe080cbaacda73fbb8941202e798c27508204821edc809cb1e271e156239df794356ee5466d939f32ba6fd46f7a8ba98233012d15443dd716fb59567f868c1f4048d7a0d0b461f43e2a406d59289c5b857bc0a39fe04f4aa97f6b7e09fc599f6fb316fc02479cb1ef5e47e5e9a0c61606b34f31571fa457ecedbda9c7ba6c9b477d5dfcbb0b2314c1a1a918612de0ff0c01cf68ffc8e12dc16cce7e0e2def7dec830f7cf8d46a7af39dc6bec2e9e0ae7806500c1bfe29bea7bb6486d1ec5250fcf64cb33b0da58ddd22cb34b49dbb4fc7b478e6e5123eaeb3c5ccf7a8dbd8cded2256f7c894055b3beeb4c2dc60b2b051cbd1e821316ec86e20f983762f20a47f4f21d61cabc466efae34270d9c269d9a7761b3e806709e570b5ff4c41e010c70c07ed4088c75d6f61954d7dd08eb760cd6ac9dbfddad12c99e20222c9c299e6f5b32196042596c5213553cb17b2c35e9c061cc08dd09f2c4684440c0d56fdca4eeddf420686587aca210f1683a89021b16e9a4c97a8bdabe1bbb6bfd9392caae2808e214c6f4e68c3cdd14804200060b0f58bdaf156e91abe2edaa06fe73da8d672e6f7b3e2549c3f3aa829bce69fe73ea162989ce45c14ac4e08fe6c9e33622f3f7ab34b3f23df472fe44063c15fdbf8475edca8c0921da352f2836a2fa24af3a62d30c1f79647789f1e54228c36d40cef4610c68aebfad3c1bd68a831503e7a0ee7ec43e2aab949138ac11fd0ab4687968365c733c047792bb5845e257df8cccee3fc1ff697642dd6207df35606475526adbd5743b440fc98db199571bb2c9b053cee67b60e9bec1f012929c7832b506a408a1b0e11ce150211c0b1faf596aea630fe517f37fa3efaa022ec62a19aa01f0c57875ebb6cd2e17594391d1558b5e897360ec81bd1f224e7b781883ae016f7a1af77ccba9042a3e100409869db21237d3cd38f06090a00d6db72e488003e424f745d3b6913f6b3c3fd4211be74f34370f7001ad63447e3b15ac4d515644c059b0789e83978e0034be43d94adf283859570b6798fb9c2b41ebf1478bc60aa53bd552ed3a820627967e997131d0ddee7f317734a1b0158923823f73a121dd8d8e51b9a3275c234fb9dbd3e363777342cfe5fe58fa19b19cc46705fcb2fdd7d8887a0bb80500c47fe125d36fd6b348bff5c4cbcf70c9618c7c1e5254a8ef7873bf3e9c842f6974250baa9c77a107fa001eb99850764ddbc768efda5d457b6a183bc1174c56096b5ceab04275e2179db36a47c1fef35cee34218109d5a000b915bb36aed93d9ba8507bed8896e058d8da13644bc5960de5ef1169f565d5479e3189bd10adebf29eefbee9bf83744e9ab46b93a4671829369ef6a852ab7b69b9c1ccc3177fc01b1366f8b80430683fb648f61b3abf4c18e6f65c6861fc0ff5e65edaa1691115a1c0892b2a57ef6a3c7b5299b35f992a2fa25fa8450d66908afb7df83fdf4b677c4eed71a74bb9ba7155f4160438a21fea602a8306be3fcdc61e2e7c46b25c8ac4731c77f84d0a0536d7b0165ce220276e970fb53baa4fd11505320550e9e331abb1307f7954047062b319f97c218c7472bd810fc2c2e84ff835a25e85febdf7fb8d2015eccda71a554c6b4e949ea6116ce8f58e9d464d0991e0652b7bb68330487f29b4fef127c8128115dafe618313fbd46d8dd4fafa7cd14c481e78006477b44d09dcd3dce3e5d89ef1c09ccb7521b0dd66f21e7a6412b47da919efebfb488ae40b826851bd815403749f97ebf842c8bf88b48802467b71d55fccafc8cdbeec64f7dd672a2a126f794b144cb6cf49564b8eb66866ee9221cf2cb3bc7f009131bab47abfeb68a3a5069021f9a7dced905fda6f49cb826ff8dea644a7aa8bf800e181ec17e23dfe107c838c5d26c9ea0393737841680d58a463a13fbd745ae9583e59006cb075ccd643ca49d008ff4bbc9439670e657dbbfdd04a1d5f2aad20d9d3dd38981592c744e2995e53e89b605be127fd7a20ecab0cc271c9c44d4ba85d4845dd1af71aab8854f91b983f561a0f56f5288c153b6143cce5469864f554584eedcbced4966276e2c54dfb8412aaef3b339660ac1265f0c5f679c53ca42636f47c9573271300b9ff134318c0bcf1f53fe5d7b0c992bc144661cdd3317fd76340851b61633bbfa0cebd7855cdf1c1da2f43992ad98048c255fc121e61466fc290ffe371c588ce682295d7f3f0e3a81553364d16b89359cd395a481e09b0de14b8cb121e56426e6b58780a333f19a260b479e0e579f97d7d7a9f3a91c68c9819a7c72bd82882bdf9fdad36894f71a4bf4da8f690ce794e4a7ad40f9183a89445de6f270c453f843c8ad31e88289bf0223108a6373db860924bdaf62da5ffa1826e1bad8e8fc398b18a0bea7029796e7fa062b5a3949886ed85daaae2ba9935758cba50a5e73186cde372d7902d0b0b0d8c9bc57f74ded0f2c69dd543139cab406de64631a54f46dd617ae082d04e14bb0d552c629c6bc30209385380fcf8d11bdbbb310024307eeca5e4771a5cd6db3df0baedf60da6e23f4ed25bdafd870c4101f54fb1e46906ed01c5d503af4005315b30f05759d1cd4da43b72db2d5fa286c266818b7d7cc3b62fe5f68022a0993e6eeac8120933918419d87cdf5780d81ccf9030d4df9e07c56759a3314b20f93d598a15823aef34c9432890e4fb83550c76fc375890a1e6a5c667173bc42a7e9f37fd6137505c4e8d7811f4d8d9acf08bf8f0fbe5fd591f8dfdf3794487d3a966b7693d63f5d58ceea469f92f30f7ebf5f8c2fdfa26f3b9463fc087be0d97efb3bd0215fe98d69f596344e0b23e3a1dac5a42060ef24011531be1aac718ae6c80cd2c3318c49f666651b254f58a23f5833b0f1e4c2ecf01c2a73b339188eac8c8b7877641b39b1c2bbbaf067ed9cb55d3772512497139a14b46039aca93eb7d2a652905662de41a4c48c46407d9bb39b97620ab8bfe5b88ea8ad23823061b7cc8fd73508fb4dd057d444bf7d90b6a59ebe3c1225baefc3380fa8d372a5ca4e5de77db44ac7734433097c348146e5729c7498108e8968d6c82f3dd4ad8b9aed4af296588888018361d28cd0a1e8173fdf29a4e06d7c18c0f2c1b861368ea1a8804865fe05a94e725056e17fa9c01481abab820f7d53d1ee563eb3fbb8de15b843e7cee8124cc74935c05c38714d1abfa7d3d702645e32ea19f6496a3bc384060b2dee9c2eb26094fa2495d08df51bb3b01c7c160b4ade6e78889419979cd85f340968bbae15316644a1fb7e5caa15d131f7aa505559024d237898145454a6c7afde94e939d124cf4411922e50010118bab0ddf53fd4e061dbee3209ca24d38e04ae363545fd350c99b97bc210f1d805edb4b6526dc150822486f600126402914627508bed09490be4b7cccaced5e02a3a11446ea89b2d260f634120ecf5a48d0111bdcd9255eee9f8aabf472be2de1a116f65a89c4ffebfa304f3acac3a289537c4a7641150bbc86cef6cd604ebb1a38839e1fc903ff96641c1fbbb13232baeba5455c479daa3cf32d8550504d9620e95b38892d1d36a47ec1dae07e4e62a5591982432e7c0cbee32c0272edff0f69314fe51ba5bf14750bd3a9151b8b0ff5ba95c49c074377d25679c0a2c9a421c6fee1dcc9acc39002da43bff592712d850e46ac0183e1608dc81e34b1073e225f1da3050374d63cdf41266cb2822643e840eea0733e1b4c482d3b5da38533c766f5aa4dddaeca3dd37b9846e41962ed52284fd32bab5ccdfff09e12174fc9acbd62db0a8fc687ca9f04dedff95f2dad4289c7c9755cbdb94e191a06b4db2c7352ee52c0506a2f08d1080d2c32025767545caae322e8e132cbb350d4bc16ac996335c20448990f95bdacf34aa39f76259065259f2bd7d9c8f490709453ffb8f89d4b92f079872c2cec528ee0e4c0c7af906ef98cab526cc43229e7f7e4ff75e222bd620bb0d6ced91f1a115f09f0cfec6f6ecee0fa48464ebd6ef0de6fbac5416a863fc8ecbffca894fa3b0f720559a33f5df22b61df880766903c1c114f36af9158791fe985fba055bbc9c0e983ea561dd2b5816dce3f33d409b468c6ca36f427bb37b18ea39851eca331a4763eb1ff2afececbc35ea43e67826a96de66ba36a32b43bb6dba15907dd1e53ade592a41e1d5a5622911bad05e793d2b5c9e6dbfabd0d7b8adcf1944cc80d098da9d2cbbc9875ff4aac0ea012a930e4712c577fdfe34eaf607c8a5c4481ae6c7ef2431edd86ac2ba52e3a3491c03525b95787b5527815a26ff545c47ad2e9f7ba72b3a54d13cbba23ab0eacc9d956d289ee3cd3050ae60ebbd0b7a3206b74ec68251f2d2c9b2e94461eda676336e1a3d6d6895e66ad08c17867b0af17fc174e2202d56a127b4ebf1cd3177aabedb9694de16993b87acead68b789a2d558a8bcb172bc8cab539c6eb11d0209d63c6e4e64069820e668698e4ea5800eb7293ebb6f4f6496b194d074312c68ac86e300b1d70afdf363175cea6d8322d23938ed86049bd2d3000fb6ee5cb3f56f2dbc47ba01d6672c74078dae90645b2ef7ebc3d33654682ecdb710df11eca5e70114413ade9474b1c390a8509b24a1388235e665ac5f2ec194133c2347806971f8f9616f7936e6c0a7557a6d44b45adc182a0738767bef41d4c6c3afa894dafcd5758322743360232ea49ad7c81810ce19c0623da852a3e85c5b50c57c3ca57f4e4bf8e7da9674d13d85080193b50fc33aebad19402d5b1523bb73b4cef146e0b17de70f0b51de1950e58403e5304625f131ac69f18358009ec7849b652e820e45c29a3644de74d37d0448feb7bb091393ee18719d8227a54b5b2ff4c87e24565067b00f46fedd9d034c070cff80a232ee2de8dcf72dc3ad94a05338e9575cdd389bc8dd6627083c4aeb1168fe1702daf894012f79b3cbb2e90b6e8221097cba5c155d2d94f0c27d6b558e1ed34edb6c93c382eb7595551ad9a65ae2c3b8b934c8b1edc2c8e95eecec044f92c6500f92182d635001a347dddd2cf81428ab922727409cbd80e07544b4adc92a79a64007fa22afa952cdb5661e0f8214d9f581592f7c5cd156645764865cdbaccd8c5003ca0d99dd4dabff1708d01656d3e37cd2acb052e47dbf540ca18eefc1db0cab46a724c56379e2c23c23545cf160cd8aa88f34cdc371499aa67fb176719810dad3128c03a45ae5935a010b1af386332114f486a670efc75766676059c36637cfef76c6785803d51f8f6ac0da19d394602cc2689f35dac22a1c325acc8c9fd10655f5632f0ee84a468f10d4c1b537afb26946c9a5169797dcc444c1c85560fc95ef1f4822edd23eca649b03606d5857fc1423a52f1403c2839e1785ed00024eef23a42aa083dcb9eef39d91fb85a8f975c48cf2a78ce139176d5502dfc8f7b71ac9d895e0bb46fdfef02e66457126ccf8db36da7c256a424e9ae8a1e39715343f1a54c02ad17e9f64184d8d765f938dadf2323caf86e41933dcb4e21efc77b9142545c5a4a9edf3ad7c6bc8abd34ee8b398596e4970503a1253f755be57d06c4b3eb9c1d16b93ecd6f5447b0645e388b725c304d86562dc15381513f98355031e9050b4ca21e5d3be42c8ffa0eb08013d3593e6451a50fd39f69ba9f247b5679dcdef4626632e5674ad3dce7fe4e9c9a827d8ed816e234a1b1fee52400085d60273a057bebbbc854c50580686c52177f0604374c557deba1917f964548d4cedaa4a4819030d2a0cec08183b077203723a408afc27e7b471a5cba0432e6957782faedfff08395761924ba13f044b13dbb03a00f080a51632c57b39ebdae12657e9183feea4513b6284c1b64d9e14b1811801d09e0e96c4155fce3c5751290fe2be6246f891803a51ea4c0695d8ec13bae5a34203a2f7477c12a914166231f38d2e1e7acf7bfda4c1ada338690c3ef626edad767b190b0232e0b82fdce2cc080929d5f6125bcaea30b4ae8b8b81c48b489e05b34b0b836b1397a45fc5eb71c1ed40d1ae998091592492a3067fe9b42cabe8399ac2e409c4fa192f0f7084f6ae9685e495adb63f920448e9ff3328ae9eb8c81d8871b88869d124316a9565707e6222fdec5fbd796b6572bcd33e6ac26d00eb3528d1ea22599be8a733384c87675a8bfd7ae43a09811f03b0b2e4961b537d468d667ffee2585cc84fd34b296be097a763ffce64eb2e91fbed7317d44ad6600440f307cc20718e12d32e96ee61da0d2d3ab5352ede1f8f39c8942b47f0706722930c0f170bd8f4ea691020f93fd2bd1bbd3bd49b56499396781b4d79915b85b5fca7d4d3818af3040d95f75c86c0e47bbf78d8dc68ecfc0fe94cd7a5f0c01d04f9a1d7ff545507e97cffc3a633caf8df94f12afaa8cb4ad278aa024bcbdbdba2e53e5d34aeb4bba9be06957de3be5776dc1f162cba3ea970ac9df9fdd12e67100210335725989194a2bf484d64dc34a06c7abca229d59dcb059171b04b645983214090ae184915316c55ca9213eb642262b70e44fa117e9e709afe4af6f9a86b29f576e05830c3b0afda807c444500968231b415d2f11f6107c625b5ac1ca1b5d7cbd5a68a999986c3436c7abfb958483f29b9359b96ce3dc8874c06bc92c1cc99a1125eb6d45947065aa746eaf5f134aa3b6af1dc2b27a1b40f40a1ba47e8ce0c622663965d6dacff14b7a62ce0cacad82d587f9dccf8f1d35c1a563e068917e8c15d75a8a05dafaeae156be14c56695ac17101e8d98595f00a83af4bd626dac0fc04390d20d8047be0271f94f977d9dfdf6a4fc229d24329c91d3bec4844284775d3506729ad9ea34795df73cc196c2eb24661774aa8b00fde23e3da76caccbeca70d5c79cb11b637469e95972e72d5d5497a39585f590ce1fd85bc3bd4464afd0c4bd28e3dcdca344223a75328e79f089c7ea3bc67a887b743a507d6a1fcd766939985f900d8baa5d037713ebc80d65951abd803fda503aaf5e010cb509a32c4cdfc7d91da17fdcad3105259db81c736d810a7f6abfc8a04f476284d053461369cfc5c1703485330ad3c82a5629a6c39cd0d827619c55ff8fd6fea735c65746de9d3ae9e754375c5641198da53ac477877494ccb2053e946f01ca6064722fdb61352debddeca05c4aa9ca2f0b076e829a67333e626361e7b01765838f01fa32ba3e4a75ce6b7ac5e98fcb9538345bf4a4aee5da68f05233a3bfa85326cae6e8ce2124cbcbf6e5b2727f27da188c71856f9c9bfa56302c8abf760397bd7f15fdb360a664eacc57cfeba251df7967aec531103ecfb1e2220b305848ac6244c6027b0a797d3aa8f2f004752cacc7e536f059de85babd8da1fd80d4e80369fa3af9ca5044b40e42dac75425f9671aaed11ad357cf863165fa6c80386c46a4b7f41be36e5d6c3e62fa36e82ae8f4df0e6bdc9d1520293a7d8013b8ed18cfbf00dea7d4130cae958d3717f4c485dee8311c90b2d978a256c80fd37c21ab2c5fbfdd8d17b644def33b78ceb21f0d175898fac83dd099123a28123f92f9e813e79de25b4a747d3024df222e844e1fcaa972ec21745fc2a13f3ec9d74d5756b9e0f990fceb0fd9e657656b82420938d97f4e8906883be337f0ff62578db8429288977e3cad9c261b9ace0d0fdc434b0d1f57e6d21ad620a8392dd5792fc23ec3dfb5701b1cae0d141a690424d939f31a15aeb96099349c0f7f976ceac498c061e61c55cda08313690b291917238d000a327b0ad2b58c4bdd416cd900dadd86c827bab7cbb2bb69869953e241645a5aaea7860a0b0a7e4514ad68ab871d0ce4f463497d28c1a558d41f34efea1fc85e31c94bee7548feba2c63cc9ca7a4f3fd9fb65f79ead98094833ff8a1e6d5de5ac926d34f126f76a414bf89698b4b76a19fc0c2435667cbf9841c775af4d9c516ed3bdbfd7a4eaa35f09287692200f840fa42c3ba4785c7dceb72b1d34e25b17ffff714f285f6c8cd5522914281a279e6f4611aaf6559c02378482dda5e5016138d4a78c4dbee129db5d74e8194494d491ad47bce1bb958d9c3c9276c9b3c73b14df5bbace27931b5a7cd0fee64155b89ebd182b79a5a0146af78cfe0ba15e3fc3aba09612244ce354120f57fb4182cd34e9709dc7c96adb2ff138d58e0f1638337410335e9b82a4f9ecb277a30abc3d35e93a368df4a17391310f6ffbd55be88ddb5a954dae05ebb6d697d79a353adf515fae41e2c7dbf03df8681d183893f26fccf9619684614c7fc1b1614c61b9257ad0ea69b68b069b3cb9247beab2ddd2e307216cbe1c71680ee6efa85dc43e0f063fb07c964fe20261d25c7286a31251eef813602eabb884e4a53edba9e51e1c444ae579e065a19f8b9f833eec14c76473e987919f0c783853c2894216604603344802981d9d22a3fce6173f8fe81066784d926f49f18de5558399814c08443a056749fcaed9441785fc8747388c17c8df14831f5a0c8de788ed2cc9f9c49c7c4c29f841e524ac4bc2344397e5cb52846b84e6c2caad438b1cb304ce875e4611687f67a0caa5fd4d43a0cac1e4e733a280c592d899ab267352c8fe122a1c07680d33c13f0fc041888fc072c3a38e182dbeb3221e044e7cc12c1c4ab18d96e60fe1aa743200fa2f350f430b213afe4b234a2ad83ec4a26a4740d893865cd42385a2f08b076f393fd655515c35fb012966d780a3115e555eb50fdbb9c3598cf74455439ee9b01c7ebf12e93e86b013e979704eed19d245f8e61e2be59ce6646e6185c47d3f5578b102d95d41149d1fd2a9f897ef4a3bc2ae0f2b814a142983dc21177d294ee347ac544cf62592a5e68456c790cb1a352409eeec11671c19434789219f68cabb9bbb817869bc59db351f49b14d452d89a05ea9bfda73fde7f0066a568e5c2e9e43d3387a3ff89c2838d98ad4d3b337e54abc516f660b34d4c870e2e2b74457ddbe219ac68adf0ae1028825c9609aa159864ddbbce6bd266093002b02878e300a310fa0404d6b399695755eafc39bab72bec95f4ae29fa448297e57319a69e5a428f048abfbdd2ff5de833a3dcfb76aa6575dfc6686dd2c5b2e82672b7af3ef217df2dc99fe23d10b129b2c98dd236eb2c40ab13e4e67eb427dab9059f47ed1810735db8e4b967667014b5787822a9430bb7a5a0251adaee10d6e4f720e63146bfbc6cb3257411e6aaa1c7773563a6fc1599d9cac8f3771fbc87f5f15686ea40a2bc508e9052d6ae990203e7383f27858e579662ed932c703761e08bcf78a06f7ab268d76b7f06766d968f5538f6ecb648eebb250680dd46b17226a1b213156af04c407a13faa47b7d178a23e1749147b3f565a8e1a4615f58bffab9d4e93ffe0830c220624e00466a93f89ffb4709826e997a9201ad865fc6855e8e1c53ac86b7825ea48f7c3e4e64ae14a62eaab46aa661b8d8697bd9d7c6f014d6eea1df05ced1199663865a69d627e4855d3c849e5460e77fce58218693ae2fd9e8199cb92d67b9b09583b8f5b24575d81538fcb6d4c763380f2130f39e6f5f5a8e683786f1ece55c6ed76ff49d88cd1b7b7472d633b8d26f5e3199989bfb239cf2de12b8f35119a6b179e02803cb7e432c37f5f2c49c9fea440f79ba98d87efaca0e785cbb659c24daf1636bc0d37c175812a17b016d491abb1b1e20fc55d2a79cc57823ca2ac4b66710e79995d48bd76179a807951c73d4425ce3ab53dfdce89ee8a95351f41f9370ec11bcd307413535fbd3604ce16d3a3fe8cbbbfa20bd879fb539ef2360fd4a58883ffd72e9b39e8d7ff018138be9c40cb154720df2c1e5b01762590d9f3f7bb63e5316ec14dabe50be5e3e645fcb23dafd9955af5c184d9332ec1cb7a3c0c03dc804272bcc36e6e5fa0b5f5d4836131cba4e9a146e3d198998c9c21efc299279241085376fe34213b8ddf758d480930c8aedff0cc1332c0639921aa2f8758b9cab4423f518dd692f2c3ac8333b87e0fd2b7fdd633b3c73dc30ff5443776d7e06a258e6c10fa8d05ceaf964e3aee91088ccc16a7878bec4a7ffc2cc43b8f8f0f5069842221f9bd3fdd03d577d83041bf8d65ac9df974081afb624be7613a13b8022aed817d6677b14bd8db81fdf3adaf8252410fbdc41bef91f31b7f67291e6e9e74540f012faa161331ed02c0fd178a739962ba8dceec79871ffaeb9a93661169fd5fbc2c793bb331e722538cfc82628ffb75a07a1f0a0bc73bce8a12d8b9ac5df1a2149866486249b8ba691806c35eb071f4d5186b1777e3e312bfce2e28c898a62a74249913e466d3772aa97b0de11b090e90f1a6348ed31c50d9d2c5fc57609cfc52a6de6d5a574c896dade003479597388f298f0117dc8d181d22dd950d0fccb1dfa874f0031d7f7f9cbca8224d227a2f519fd39c5472f9c34c0072494a61f79bbe99a86de521fc20f957522c2d12b495d07e15b2a62b1db49be2642b64a1d7b18963a20e65210b631d23108fe2942493d2d20eeea0bc51375ed700863ad82462d7d7b19a2049550391b97821affa35a1cb8730cc008da407068fbdc0028904706d898212d9f26b841c931c721b279f41746582f9e61a05e023c160bd7a0195f9ad7b233c3d2b1cf4ca3af4446e6f3fdd960fc23fae446c507bd1f8652811e08bb00b01b9da92e200a8442133eb7d6d6876798c0ee1af5ecbc1426ba117f690837024be268d0fd323ea6106ae2fc70e9dceda02dac1d71516788fff47a3d98e0b53fb642bbaa82191fc463b4028b9c2aaabda97ed143706530da75600b066695a994e5befa634bea7f4bcf5ae656b86bf8f54a0aed205e25c6ed5062bba7ac79ba720f92821e44766b8f24a5e7d508c4a040d74d25e625f60ef720f2b9757aa6ef774dc7830e9064cbc03bb528311bb05a7ebb85c70efd3ef1357d2159c4270785bf5d5e2674844f7b7493758aa366acf5faa425515c861d1ed051e2c47651cee9f23fb9df12c2d9b42c61821d79ca7fb25851ebad41813b110b4a49314c968375df50a62ba282e6fcd40ad77eb38cc33961290fcdd2f8038ca6f92a1d8b4660e68900e0a5a20e27229e04a267dc1a0efa281e5ac637f8c10c113a4ba27f418df7a05f3508b8f756829bde7f73de91b847ad4e761b7a4006b44411c7841699d34e40204bbfb8f81fe6aa5368f61847a1c65c48a0c15b4bcc69c3ca478b53a1c2cc64ad790b9f31e4cfde07e7698c081578dc4c05eeac7157f7434e90ad86bcd41a1a47836ad81719d99ddb8e7a0f03efc701ac56af0ec28dea31f6e4e4a12ab103c6dd960957900e5039e0eeeb2876928666673ae769c34b19c14c1584c95b33dadb59502555a201e48d9a472f4edccde0069738c02d606e10640b226d0484166fcbe2fee33dab332a59dab53be132b1595d2dc7e33ed70a896beec0b9e56ec8f73be5b7db10d8625fffa5633523ec25a8182bcd348b19e727a04063ecac9e4264c1aaa7341da58d74fc22d6848c5c4dc23ba8117d70109adfc1c378cd0f64dc174004fe90f81d10a7726767ad6cdf1d62320efd474c1e749e36108192741001ae84f18c87bfde23b5eebb9c619edd1ac4d128f6672d77eaaea454030f35ad5bf5182b25cfa82bcf85ab3a93fe59cdb59e49035804ed4f330a03e7985e09c47fdb182daf77f1cba079f1741468f9adf29bc27a0da5b03ce378ca7f6ff7fee94f44c896e9d1683b153f5c5c191207372523141d04d122a25d65d870d9b31435da30f3657fbd9942e9d0ae83c746c97676b11eae2ac2d22a3afb266d7e0000c681134ba5f10d0b386ee4da4b033efbd81cf6f2611b33467660064bfea64745633fc925513330357d6e09fbc580d360672502da2ace3b7b2a3dcd4ff512cf1ac264425d48c160612192326c9f0a9c6280c1ca071885d7dfc1d77934ba411888d46a5dc53bf917e52cae2c5a957a99090abed9afb9a66f50da34d0520e0136c0a12fb50141d836a108d2b6b6ee1cb6ba93edecb17b8bd014db7507471ab440d1d29705a5e2dca59d9eaaa958525a1172e8cb593a301ce1fdfa897f9ef16cc144ecee0ddc663ddaf8da94e7425a33058ffaf2b2de0d5e28c1570ddf44772b3ac5166fdbaea172aa294cf5554a69779ccb01e0975468d30835a2de385b6023177ff459d87c98e9fc0e39993cf1b05b9dc8ee66786c3e75644d1d302ae2e36301641b4977558912c3fbadb39973233991e595f1cddcf520de1a5a9bf87c4852e969bba756fe5555393e7a3904eb22a2404c4a0d7801f754d0c95d0a04675fa3b10606010d73ce0da27e77bb62b95c515053731430b3156092b4d0503962921db5a413735e0216a2af96d8f57642527ca749e384f3219bc17ed3c3add6ac7516967a97e5db35464baa863466d5df3397f91c910461932ef2575516f49bfce7fb676a146467d2b422c9f919d6a4d789014264072c3b4a7c9f85b13b71c0f13c5b59d473f784e276334489ef2ee41a00f692f4c50e9600a4968ee841bf52ff7b4db6b003edb0dfaf1d9ec351a72cee7575cc30d0a0ec7e5bddddbed6e48b1195890dad3a9002b7bd01189e6084e4f598adc724f24eb2ad6d95fc2b958c79adb779085d3df6141df27b9064849473f68b22dbf64ee251281a2bcad907831929f2c8ad02934b994ba70f4893cce145e1caa358881b77168e7b197373290cbb176e9aff326344c73566f385a392314e7a1388740eab1486848877b825c79c2e865b5b7bd5ff3b9f6e4464c3769b8689e51ba1f4876da1a4e5156886e10c9b4fa3e47d183e16202dc86c042dfef7a1cb2e56cd742bc01ffe1596755e6be6c553dcb529afca543c8aaddd0d8fe7968bc2fea25ce84d220e5ee9789a2e4108647923eacc9f220782ac0de2fb00c5be5bc7b5e7adf81ad2ee848596c4537268c3ded0f47f9263515014f78374f82fc6f4a29412c7c4e13712c409de3c9dfadcb41fd0aa5c0a7234b021b007d5bdd73bd306a7af97c54733bd4963b171d6740ed5f059708be638f9d3ca44895b6bdb8bdfe6a834adeca74778ed085bdd56fe0554977168d0a78dce469eeb08bb56f4df354771145275109c622e953a00755a42c71ced08854c08886aa24e518baca59d0b48a60d45d13d4c342152b9625ab247966838fa2645d2ae044b5e1fd65c3d6ab5c44a83062eb03b9e39f60c06d837828d265b2d5a674c655152ef7b7b3c398782d3fdd5ae06fef6250c6fc7b9ab02ddcd6bcf5d002448ca4afdb36db4f4975eecc340b50bee1a9d41846d5b72d9aa1a7872668d4d0502403e274725b3dfd6eb77f59fe340b288cf2956f50889c125f089923f16ef4d49ad0a48dbe7d61431adcc56c96804e8a7b31de0d44581ae843351106cd96250d98f6a7248fc00dbed63e5f23267a30a0b97cb56dc070eed39b2383b0ab90d15ab8e4610fffc68f9c77dafcab30d71e38b0d152acb56a94fc74061e3c105bd2eed9300ae377cb6d0466b89dc8bb09c0db64bcd64e431756c929e93f05b95cec8eb39f91cc92cad5039e412039f18a926cb6dd4bec0f2e728106225379449cd078dc2a2e160b59ecef85e2c9a82791b342c93b19c8000c845eebc59e2e19c96e6a59495a86b4fd448327b251c1c3eef1307b89e828029adf2e139f0496a63f132f01c9de4eaedaa938817b78bb662e23e4d8deb38251001a795474d782bb850de823f000190ed52b570157536b82a3bd1faac18386bb212f8cf3e540a72a96c03f81ff858875ac0f3a81b45fcc0035d21c235681a46afe3ee79acfc28fe085320db39a323062b01bd87832a7340538c54891e42a6d19cf37251624359debbee36617bbe4e9fb2269c7932f2ba836ca24a5cea3b70ac54f1735436a7c2956ae5087468fb71346cc364e6afdcf203c673bbb6ce83315ef708d925359cc2f42e8eed80c1319dbf21f8835b7c2f21ffefef332acac11096d7440f01817c55ae7df8d5a4ba927a3c2e1c11925a245e0d38a0aa111116bac4fd5207f5efa8e15e810815140aa5f5379c8c0ac72d8635c25c2e9005bd0679bdb9330c4d25b3485ee7a9e8083cfe231ce673fc43610619ff56c867c2a5b4659d01ffdebf86627422b369a5b3c03ca1e5cf17691f826197e9b6c8a9087bde5b514e79a07b2fc221b3524953cd8d100471c90c41817a65d59328a76c5f8aaa6dc810ba943576b12db6927341efd18de930340b1bc8851da86df01cbcf9908bedf63a5ba80b4519ee7385cce44d3c2d49ee8bfd85745d82708fdf626dbffe929dd24492d3f58d77fb47edc21ffb1f9659c9e410a3ab2674386002bd01dc8245cc76f96a1c67e6f34d2e14aa8fef54dfb62b73208fee60c1c2b370073ece0ecae035cf2f3bccc4193742604a79c5f833208cdffa2881d0d7356cb42ff561680071a74fe004d3378d27a0be1ceaeb9d9632ef05529ab5d47c5f98650b0be92405df5f967b66819e6d5d3dc15b524e3ad4bcedb9912a863e9564a7c09f65cc84e7435ba0cc409dc2432d9930f55a97774812bbfbe4cca7d4219b0019946dd1336f24d912776fabf6a19db462c25f2dc46c98bc6fe5902bb3f94c8f66b001eadaa5038139dfc436b6f31c41eafe2908647b65796050ac9c957b06546a492764730f284d92ac81667de881d4317e134ab255182962b9fe65630464c9b2d865836e55bd469c7628c33cc5ac2d2a7bbe20643397bff3b0deb94a756105b4629f394b9e6c92b54a66ea130c59dd7756abafd64b492f11e239bcd47f65af0dc232457102744eec810a8fda5ca2d78dc54747518fbe965c7c63ae450d7e1c73246793a3465d78657f188a4abc8e8e14f958a33957f0532f6a9c389ddee9a8facd1d8dd05b2ca715b6086017410a3ebcafaa59a6785dbf10df13d9d85a5ee2d1a333f55a9b5130743e5b3beafbc919b19212b45a2700756f3a9e2989153dc74069ce2796012a4653b472505bad266c48f616e66b139674872607b58107c777cfdd77020dca4d90d910c13b597aee9e02d9c8544cc0462b68e1a530fa9edc70d8e0bd65e2f8aecdee21392cffa509b5d09e86a305be97b9b02877a2b9f2a151181b44f4ba37b694672dba97a4e168dfcffb6bb444d80ce3a2c0a7f36b63e6539e74bf4d015f58bc266ca79faabc04af70eff84edc44c306630ac1925866d007a37f1959ec68a5d970e58a73bd4c41ab2ab5026527185e2711797eabe964330b245a77ae7b00af45ee0bb271e0fe17206687a332a1553f50d5ecaf4942d73d383f24c0b82c8738fc29ee19db13ad82ceae2077411712eece992a97fd2f745b621641440f8368dc7942930f3b7e38183b96df4af8920703e718d4f3064a4c0dc44a595a729e31ffabe1ce635de4a5c55c6b989aca56184eba5b901f6b4e6892fda56419e90f4e18b50bfead84451a738efa4d91c48d06dd658993055772b1e71bb47edd884178d11ec63889cc6b443142f07fcd833f79090b320790d898d99ad94889c18cf68e498cb9431ddacfb626f2c681ce08fc13c03172a010fc50a8d994eb6a1c7065a7aaa7d27ba5af61fe81ad9b074c236ea5b0a45340e46105a1fc8708a1ba92c32fbf2c5acb73771d46ed305677152e27fd598cbbe69fe1b9a0aaaa47c63bb9b4f72eceefd99f3f3aa8ff4d7d779aa8350014ff794578ac6e6791691a3e690c62bf88377f4343042f66e56825afb6ff22eb0dc7b9adf475e1ab69a39814ac0316044df5cc8e18e8fdce66d4f8c2a09abc6eb3492aa988b32f289f2c993d216f9876a831967fdc19e27452828455133a2a2b37deb8b29dbe09797bdc3b62224ab79ffa5d768f99655563f1e61d10e90655a13831917222d857e02f4d2b2e4b87e1edf3159163976ba5de39443996f584918d673364b69865d0e7c3aea8db0bba4225b9df89c26ff7a41591085741182959ac0b0839a2a3a984fb1d47e50d58675312b047cc38ca8b229e01644b5c9d057cdb7a0ddc73dd599c6a1502fe7a1bafed418cf1e02d5d63dbc2125d38e10449d46098e2d574e7a91f70e405fa546734fbbd28b02d3af53675c1ac21769c5e7221af9f54f466933bb8d3564beed792b581ced6b4b0cdf6fcd9bf0d808571caed55f157ccbc65164c2eeca3ed0a7e1df9c74364b2a0e2778eade27226f0186e9aabc798696f1e7e24b274915eb867e9376edf14768feca24cf243e3959ba6666117976b2a3837f56704bacdb6535d7fbe61bb06a01c6b9cbedddbba5450e5f7e6d84a8db6b4bd2cc9badc93ce054ade46c7944852e024f8356181ab17e93a7c5518e4f122101811bf36bd19114a1f381e2e6b3dd58dc8c6ecbe05dfa63e0a8a0f447e2235b8ed9af509a647d4945dbdc39dc87899696e4eda7d050236f9f007f22034be769df26dc92c3a933447eac946fde92fa7f64fd56135e2ce1d9616d47abe732a0cbdf758abd7ac96dfeb52ca08a79a173531120d8a18357814b722f004c0172b0df23838b2b700353ce823c8665dd87352b1a8c24ce49c95532ed7b334399a4fe16b673324dadd64f9954bfc903055bc130fc9066e35565779cf70aaf10ea622c7c4da2ccff6391a56f67c31c93fbb13ca218512761d2206bd45b9092f72350ecd1ec6643b1e5cb41f35c271c8ee0bb3a01191c2bd6afe89e51312ad223569077cc75f5cdfc3a94872a49e59938d1559c73cc12410ef4c7408b1fbbb88b9422b451de00328c42a855b2169db1efa9bda6f3c40da6650430a222b681a43b4895638a8a1c011139f89dbd54cf6f535a52262d6ff9f325385db36d8e0e60f35a0637b241fda6ca21330e2fd9d40ed53aaa9ecee4184e138bda2c6d22f9d441dbc151e1e6d0b6eff05eefc8364228d69182db0090045c38ad22a5189d7377834bb6f72ac3852d735e880908984ea5047016e6e32ee59d738472fe12d74051577e4f150c666e677caa2c3f26f22576b9705c1e290a1fddd79b51733343eebda5a482bd780368e81355bc38417adcb4334901d9a810ab824cc5c038b2c89692e5ad50da4093ff12fc82a7ef3fafc7b17b9059499e87ce2c9cf181182a88309a9e9cbdd1e48ae99508cad0ab24691ad9b3a650f509829f1975f56014edab646a9329b64da0d159010e2569c1b2d7ed1990e3825d4fd852ecced2415b3d43363da3339c207ac7c57cb2b7686dfda17c6b5f298d83e3e38a67c64d9bb934cfc62b6222bdb8b73bdf0e4c0848ac72419d24b1890188dc3f1560b5d1ec8ff70c18116109b94588a8b2474c46078c756054d290c92c35f38938b709afd6fccee994bf94f17583f0e1b8bf78bdaa55df083d9912887e4c534a694dac4f59bb5230e508be8182922e24a0967ebf4df2c7ec34c2c3b86ae0a08a29287bf2e055fde071a89f3b7378172d746a8e55df111b0a5a5ac4ad3f3795d5f21649bb3b904eab7bb6b41e11f1b089bafb74fd80c05b014793f742792c19839224c72b22b1a95a3dd5a24f20d6dc31397d0970ad0868ab4ea7fb32aefe53b89850beaa9948da0d552adbf96452e8f2881c43bbdb0f5da5c0033d4435a2b447a169b4c73b00f50530874367482d98e4f94e0496a85ce526f5fe4adb65004d2399ed74a68cfb015081d831192902b348201e5b6ce5d862b0d7dde750557a5270128f648f013c489092cd5ffaa9a246175eee6cfb1766c32aa6dc51b2b256fe34447a46edbaf63ed29813d8ce48e1ac4344da23435999e71038112b625b1069c9cb4e71a179b7d7515bc5e238bcc60107efbb0911568a345356fdd999999d47109389fdefee2192a9b3dd4a8ff570d37bbf6d6b8d978e9fe2bd5811431af18571d9d715d561d40bbe60d20be96546cfb5c6f641a2229c73141e0273d3a84a90f3ad41e7d0ae64c4d3368b5cab9a6fe51d34a8e9dadba5c62b08313da7b042ad08b96caab4588874a062643f24cb37f55999e00af630f1d618cf2f94e25a439146f314d683b5012c76bc4a5321f5ba5b36dc7bf47f5f5aa86091655d15511db8d1a0de2a1ede64797dc9fdd8071efc2ba17d265a12574c95b9323a8031bc8dc4006e7cf118f0073e5c2dc7edfcc0d0cbf6e8120f81cc0cde1b8a268b5a4a44bb1c6a75c088c8a74626abf343c04966d0b47a3c9f3ea91221a09cb480a038959d3208d5e6b5596737a6f99592b25916d7d1f3d7f389d84b64ded1a17ac26916079c9f5ad7dc4b1aac897586143b331126438da38c2b8407b93fa1ac61f8f56b7a1c2ff2513b066d4d8a05f5223467cec1267d22a3e02e3efaf989284b5dd5bd880bd8847289549eb7c0318773cf7a4268ceb4907c3e290892673d75bb676bd53d5f645dd7a7c75e81957e6e9bd22ed1bc8343aa07d4b914d0010bacb99912b11d2a9175b1c0e331eedfa5abcc8019826f45500574316191d217b01195f766c60a92bee4d1e1842ec1f417e54a5c7a116f7eeb8459fd99ddd8021fcd06895e2acf01b43e037620bfe8550bf70003ec3a730e07bf63c79780a509ce5839b8ebacf062ece13b1f7e1046fa93f20f966a966d96ee2e5648747f539cf86fd03b79d005c07b593c15a1e9ab27d486abcee0b3905f473493e06acf908376c9a07e68b8c2e04ed872e92137663127f1e360647d68b0d7d278fd59c4b634bfe45e922bb3c07c6cfa041684f033c9105c6fe8d6169bc5e6682ca0e1909a8e31092f5bb73f2838a475eee7ded94b6b4fee9bfb3c0083e7c9ef2332f7da7d0b62dc0b628c20065b24d1aa07608ed630d6c44a61830db5d8e8493e59bcdbc7ef1d8cf5e59750376f975a534eb333d0e4023e9cce3dfc0d766b4ba629ad9920ced9686abcd6edae326553b35e78ef567233737771ad0493f5c66dab91da5966b8e312575d7b61517e04375c43a3a1b3901ff29290cee0a799c0dd5fdcd5a79b1027f7ae6feafa1829bbeb8a5a6751121251ae200f797cf9ec890183ed2f0af3193507f38261d247221fbc3cbcc91fe867bd4280c0f392c15d042da99ddf409ce6ebe738cfcd34ce1f0e6d6302de0b2018b001907b4e7f7e734cdda387c41ec59e909e210050f9fed6e0c5b308955e434bdca6ac25e601a2922290abdc9abedc1377a157c4e5a39f2a4eb020b422d32abf844ae2a954a5e499dcf55d5721fecbc148dda3104f9e26901890a1a0e662566c54cb7676371db3e6f3a454036d885883915a4742df3245ff7b2abfc22c280871057c4ab41d6bd372eecc92b77c8784b7d62a66dcf297c895813b2e61c7bb794bfedf105a234ac5c45d59d421b496a78d73d75e5cb653bf8d2906f6bb4c58d51650907c00162340e0fa6e4a689e69dd526cee0dc801a80d0964dffea44e8c3511ea1fb68f8c677edff1de380a8aff3136c4eb931afcec69ebd377426dc12ac23ee7827f9f2ad25a166b372eabc299d9441405255a10e2fa90293bb70d7de48750678e17b1e7843755e7e7e6a409abc81e809bd7a1a5df2a941e067fb444a595852172efc876199e5b00e5348a3fa0ecf9117c5f986f6f9c8490376df0bede4028ddd486bcefce4b8a8895e7ceb23b9a3129f810189fd02fb2361495931e0c6b9056158b5e381f580449828cf8eae691f48105ea14a963089dde3a8e6119b736aa775e2293108279d60b987be3f1a7f10512f909de8d9192d83c63a8311f1b87bc6b9970e12e1160fdb248ab1e7eedc2fb9b6d7b7b02c7c115bd6fe62745f352bbd4fd7f05299e8e5fed97458a487d7cd5afbf4d506d4ef6104e8e22ee7c4b8d356cc3f8df0a4b140895666981f895b88f4987c1adb457beb91f7cd1c9905e92f9e58c1e86630e1c7985b3f73603574dc0806476f267f8781f3d17e3fd6f19a77aa5cf7151262edae081da70bcd751bd2862d618c5067a6f4cb76aabf8082656f34fb5b9279a7ca6b872307feafaafcfee3e3b0bcb9eeae689282e73a7463d6b148e659188baba4c9b73c45a2ebb415d60d7e23a41499bb483b49e8cf14f958d2cc155c8665c982954412231ae583ce4a3ca678132c328f3bd64049855110aaa6b9f79d4026a8a4277a28949ec34abaf87165c18f5734052b29b99df86b10c21d76a28ca17c6c017c919747424e21b4edf938971ea634ebb24f83605fe2289b28bc1b8c19cc752bd5ec0df89b2fda07e95acdd8955849d257d48a1e20e0a0fe37b721c93260ddea90f3fcda153d984c91de21961bcc89dd3d5287146d46d4749f0c71de7693e5f7ac520b54b0eb1fe0d46b2887615a3fb455b1decbd44c84b5265e502ed9257452bd3008cb230127776ddc7bc376906d85b5704c98358c54d9a9dec96432241918f343588300f010e54a3ddf2ca916424418b8769868a6755c65a35a58f1ed7a94530701208ce4e01f886b5f3b206c2caa26d8f13e44aba85224ea0afc8db1ba77d1035f3d6e67b80705fef3be766f84696f4e1bc5eb661f842e7c37edc721d6cba0cde8e0651bfde0d756831ca549bbe725e205a1a73a509ad58070ed7d38d1238a34508b11b8f708f1b2843fbcd7467478758814d0c4cd584a1867d1e213dca60c79dffa1b73ed72c3bfd9877691bc48a8f1ee7148d14a03da51a43246e6c44e48d84ae7d3af61ce94af3d0e287e67d292c55c8bbd64cf344606b1160173fe92f9f6c4a3a1de971c4882cb6da95ef28103d87938bdf5a8b023ecc285f6b5b888a387629e6eb3ff5083a4026b9e130665ec85c704c60e9cb34a72c79d4023cfa4b29e23172a3158d2eafbaf04646d92f1f61efe8fbebf6953b8b27847775304fa37fb0a25c5c494806dbbb9600ed9ed752d62eef8d3f85fc6d967a1d51d270ef4051159c401ea54edecd8832bddd884593936abb4a757aec8ec58c2d9754479dff463194a11e22757849dcb258cb6d46961b9868eb132953222600e712296941ec646009d5a3cba9cfa63cd4c822dc65111e81dd506e4b89bd081e6a9030450ee5b91ac5c0ff819d290cb72f397e959488cfec987cf6fc4f580706a9c19da9ccefbeebe89e6778f7f3dbf9cc6dbde02e395c059c9b08d305ff7bdc87a5b02b34d11e8b8bbb9d74b9c289e56f65c5ec5163a73447b000298419deea77021ce29211457b3127a8cc2cfe2642f00cbe50b9d090f14c29b34c89574081fef1f35087ab1780b0587b97a4f2bf320be65683be391b871001b5d06e46066422a6bd851ee59ee3915b322fbf078608898cd3d80e2bac9c16f11a5731dc48ebf08bdcc10f55bc8893f5daedc2c97be3ca64bdbe2a10e144bcdd1d9e12299aa17b31b3010265e43c029eb3aa24fd129d9bf7ea3d493bdeba7b1bdea935106d34a7ee7732fd290f8e76725e5e6a025fab48ca79f361026fc6f3e79b0c739c16177cb64c061fb6bc55f3150297d4e95770aa1354e634b0b666f34c8c1f3c9785b56689a4d9116a611902375ee48731ff6761616d75f9af6a05303bd7e97069398842bde0467242b176b330b4ff629ed5b10787ffaf7b9ef46e5167af7e13cc8a6b793904ff1152eac355436c3e6c8394f0a062117583916a5ccf2945fe47696cb858c1a37d4264e8f18f23c50b670c3e8977d86c4889e8a4bbb1bc6377c7c3a8778f2ae991e9611a461cf485e66b7bea0e68bb864b8c5dcfb6e3efa963a894e44e4f5ca24546856ce7afc4d4dfc745e4446160de74636c3feeb241a1336b4ab0da2e0f8fd2f4a15758c959e8fa2ca45beb5612becb8be65c7ec4065e2185b450f8ad5687af2781b8c59dda15b89a314177991ddb956c9b1468eb053e56a347096835c47d757bc801a610b700b6df5a45c856c162d1b344dceaba21eef29f18fc73cf1845721514721506351affe9fdd11594ece9a6dacbc59490a389cf7cae930699b9c4c003fff20257e1ea208a7d23bbbf64e607043912c09911c9717a2d62289cd769e8eb2cc26770db3a2d491589e0d082b62d2fa54c5020c794d726abcafba03e6ac60a97901a6bd9885375454eecff712cf9c96e7ae208a3c351e01a6f5b92cf57f1d950fd01cdda11ccdfbeb8f6e2a6ab2aa2434c3f173a03d985db21de3d969401dc3f7d787ee264f417df0d5b98677e19bfdaa3671d2ec532eae777de1ed931e718e74a9fc1810c34ca831bf9c45166efd236cdd68c98175aa18d944864616dae016cb5eb824f4e0420cf6ab20b0be04f3d4d3e954b9e9507c729e08d112145525a9ecc169655db62f7dcd776c1335cce7f92c6581a6497455647b25b1224df86fed3b08b4c38e28a282399ad90c19906316f6b6ca0eba0fb09af9c39226e7fc6b4b57136803fe8f4aaf06feccd3c118dab1cf14db0430814768131d09d0e39bb58c7d0e91a0a99c65315a968dd82c632a62f2c228b9fba61cc1a24d64faed27e7e395134992a05edd04944d30c832f85cab6121ca605a0fe5b8074cdb4232cc3f646e9c26d8293d57294611b415fe9d55fbce4dd918ee9220f3122014a9d4fa06d5d8c0d8d15421d09f4d908e9b1b967821c189ad178b49e0ed0d50bd2bd8992e2298a47ce9ab5345384e1deb7d81d45625cebf2c61c725026565268c0f135e8c61a693e3f255604eb9212ba22aefe0286b6985f866c0eb8bd19812c529de04b2498d09c4ce242a4bb1f8d15a733bad379ada9112db8e93a33527cdb46ae2b8272aa2ec5b5bc00d83da6ef97b6f360a93307d9bf6ed4e6ea99e88db4ed27f9830c9727b2ce490c428269924cb1a3503e1934621b1aa3c7c0520c16ced310f7d01a8ba6f9280ffb1f4c89849f9cb64ef65c477f503c5908e791d186ca22fb4589acde72a2f235ded7207efca011f49e94db81393bac7b73c59aeede8649365d69f5da8326df78514b2f19a9dbfcae32ec4ebb171333d405a91c6ebc8a5e5de692141f25dc5c72de4c393ca4ff145d734ab2ed81ae349de09227bb5ef5b2c84609b04d1d0dd1549822270640d97cbc79fcdea758fe98e9567c0924aa90de8a895f4fb620ca2a6387de7016404370cd6295efd13b04f7c571e49fb5e14c9e50638df09c1ee8549bbda7035459efad20c5b16db93ac52342f3fc8899f0fe27a27ccd1e474ebcbd27ba85b8d3e511d17e7bbf9e0f846aabe4d88b102d2566ab28203f6a83d9e6ded88fa08d27bb648f37a64c674ad73935b30647f71c35186f14d977f6fda3d1e9ea7c84761da33cbd798c291ded7db61df9de52d3ea414b34ec592df2028f984850893359414cb1c2d0f7b38316f5e66cebdfacef20e4f64a08cc654afc6927e5ff46cf6b07814b9443a55d4423707ef85b44a0e14525700939eb0df654ed4fba0a26aeb6884083e949b76b98342af0bf54d3ff1a9a9316aea4b084c41308e9edee2ac3478f90a8481230d767820bbc2c1698aa12936e48791b5a7145bfe34b12b4d0664204be7f9acf4f198e38a5157d4242b08b05a81b96df3eadc96ffc21151320a298040600609d5149b3ee9373f83d85838ac6bc1c25311746593600bfb57778bbab54b99d55bb520ca133e77eacbe825a53ace922247ac33bb4e6b4da3d18c1f09ba0d02bc3e7471902021adc4231bc0e3cf9c0eb38c61edaa73485a39c72adc02a274684e162608d3e6bdcca3d9191def06dac07622f5e43f6e0d91d7d6b6eb95346b4453961581443e9b4bd018e5b144b7d23097959017f733d72462e692970177a77682efc2d6b488b1015a2b00c55f37b2d30cf48098d930a0c8c3adb76bc6e5632360e9015b12c08aeb1390b65a56bcd6e6299ad00a7f5f790e7e0cf3cb9a53981cf8e50c33c699c3ec78abc95990a7ae93255ef30a49d070976b3a110378b09878ac54f74f6532c8cb0c8d163b9f4d2b163c6b5d70e47161b1ffd4aab7539367ac08904eda781caf4af82302072e97734f83e836edc7214f818608140d2b5052557c06cb12c1e0c2c094ce5cb52754591ab0dc4b47c8a5ca6005f5077e27eae9f675179dc674006354af908360d47bcc5b13862be182b69fd23fea8be9e456a03c5e9cdcaa6f11910ebceedc09e8ecd6e81a1ab8fd000c60ecc57dfb78f52b95d461a5f7e5725348b3535c633679153c8b5125fa0825ca6cc46678d013a51eed7c53639e0cb49433925840610123529d8169c152f298d9a7e2254915c76f95c0a9bd1bc645ddc4d35db20d00dda2cffc130b69486ffe27fcb1ddea619b4be7bc1f0e84aa65c612234129a8a99a81f1b5a300064ff27efa5d86ee3f946fd03c5cde46c2a2a1d3c690d7bd670a393976b80f66905427c669e485ddf5e9d93a460e43e16ab99ce34309e3495c9551ecc683b59af97d15cffcec296d381a523f17039586b90368a38c4c0f722d67f5418ba8f1450db73b08a94694757e9a256e469e257a967d342ce9b1f318ff526d6eb5332cbd430c180255a92ef951a6ba25d825b52bff6aa8149a17b1240513aa7095d66cb518fc6b242941bc324a28b9c47004da15e3239983e98be384db9f30e12902ea9a495f8589e858da3086cd510ae2c9fa994151429b4657215d0e011cd943bb7a3c40316930be5c2439601c1d16e05efb27d35294b68b9bd25539f9d95e38510c20424f9968717a2696eac969cc723a642e508583eb615687786514b3121488a1b7eefa7d17cb9a96cfb5ad94a7dad854a353eea3c816150e964141865d6987f09f37585bcd854399854e9ee1b9cdfc0c2afe881a19ac9a37fddb4ea272a30cf122376bc80914967cf9ce9af12a86c362a02c65ab1026ac4323ddd18931a4bbd855567eaf8e3f194556dc42a31380ea10404f84a6c034f470bcf4a9ce55c5448dfb9b0476bbeb3e4ce9e35afd75194f1de12cecdffbf1b24606fd873306a3a1b3d3fccd78de95aa16e6d0955a61e669c9b0286fd5a77757667681d54b824a5d05947baebbc1cb66df77022f4278842927f4d3cb74bfbe6c6525a1a887939cd024880fde969e357384aa8e36c9c55184e62f6e0bda24eafaa7e1084892f5f438b642192fb9bd84a7843e709b67543371c88e4fdd1fe68d4f2babf1f44fe17d3bd97343873b40c1685d0cbb6aba2afbc97457aef1bb2fe428fd545a2278132f94be20c3722be9f5fe9d7732e95619211d9bcbb8841afc837514aabdc5b5b20d6d78097e9987bff7446ccef0eadcc69828375ca03ce61c96a9015736b69a00606b9b8d2bbb2c162d63165c43cc09f54fc9679c868198f3b2fe79e2c6a1b83020cc1b0f95ff183200fa87d229723e7023d50274866c77e73ebc2172b915306d97b34e572732cc34716b2b326ed6b0fed45f7430e8039849295863add1f2849753fee83b38890417bce6edaa649c2c48b3ba44a22d518fb524dc766a69728c08a3e2cdf6430e98ed53658b2acab8c0d7bb5a2556fcf5c98583a5df0deac0301f108798eeeaac1fbc2a5f35a2592b1584c17444f1c4e6dea0a8b465e1fa42b46799b16e484a062fe62569bd0681da2a59f8ee8ce72786f7de10ddc48a7c4ec2c19a18d66d9f9bc6fca6de995623f4917752c04a38cd688b1575f0695b56013389de28756caf5809125f68859e5dbe2c5d2e1471a0136577e359c4c936cfb74023f5389862724b817210255727f287c8ca3cc342cc4aa880a0d67310fda0bc163e7aada3280e170cdbde357cb89ee1d17950bcfd732966a3c5afb619958306c1d3a617121212db8930566e1cdf4dad08b58a8b4e13f33421646c0a2374442a51955fc747981d0b27377fd50e39ad4866e144174a428ccf1953093aac52ef07cbd13a6f33478eb8c0f4e2f4f01e8763154db84d34098a6ce3a5503143d2629cb3d5972fb88d945761d680eed985343ed41f8908aece3c575e3cd650c82bbaa480acdf97a79d09a905383993423b7e0a31bc529c5691a813f85a36c7ffd4c5df0c7c8e38abc1a4fe2bf1409c313b1e3513d6b3bcb841caf02b11d60bfd873c5effc0cc27864896f0ddd951f45e0e761ba5c356dad08eadac7377d48e313110a76cd78d13d7c3ac8c014b8ce8a0db6603a5cb4b2ced02074cd051e6ef7129d7c935277f986c4032f66c36a490c22769745af610564d69a0f9321286969f38ade129e6b6ae213b9e5ba363d3420d4fc0f7fbc8ed812c30294f610871fb66ae8bde28876e1af694b249a6e29a7dd9c970dd733538616a8d4ac03dd25adc4aef8b3cf911be2725f60127b1d2f640ab10d4c9fed4c853632553afe085ae43e81252e32d35cd332edb0780150afbd263857219db305da3b209f159503c47146d18304ad164fa256c46ebcea500dcf8e4c212bf823385ec09324f70d33a7bdd817407530dd20a9287d25e94335b77a6a25800f528f3f6216eec8296754e0bef3bdad0a1a96231aaac45dc952a43a66dc616fd32160efe61a62f049ced0c725b2bfe98c567c3bee885d4bd1743cf8cc0ff1113103a9aa8477b37ee99a7c8362c60305fa35d8fe937ace4257e5ab710b82a572f4671fa185d03cc7095209685d015e13b29d9a0441747af9ba9da891a7e287487804e8cb1e4a437f0d0973103f06127bf2a0af5f8d57ad10f29497bf8cff9219d35d5530317cd131b62e831ee9e27b4afded1d8c2a75b17848d53b0e6333bf3ac8d6366ee58c0ef130675a839b0c1379ff0686067abab2e3652638ab492cb2b2dd1a153fa84f6ec2d467106f5e321f1fc6cd3afab89df1f7afc4595da2486dcb675ae567b5c1794346baf6ee0de43b79761ded155a311a7f2657d1142a36d9c088977b07948af3d3084f99600f0c50b18a440c09a52f7753ba0c92036790b44b3797b501f3a5b1652915ba94ba5927d8cbf815b46ffc7d21280381efbb29c1fb6fd3b5ceea0e294739d10bb9f5959b36037ddb315c0a6b71d65a7f8ac3dde325895d6f4cebe4ccc23f7bfcd6fa1d8a8ab1ebf2780b9f581baa84be9e632bfb5dc219cda5d32a36efee96aca750020b77864f79af83279aaba72f4bb2a090eef0c78c1a6081afd64e2819b4770d4a84cab0e177c5c81e7e7b5285eea8ca773f38cd823d38b96916e91a221a0400e50e42572eefffcc78eec42d7fabb09117657a5708496d82743a78bfc41504bb16fe2e0a39a5af592dcaddf33a9ef9a8471363f8af8633f017a472a8de1d9b451e03fb8dd91a3e4e9cef2a5ce9217fc228083351da6191716087a2cc5e7427c716a86738ea426be8bc31c6cc1609bcad32845ed4e9cbebdc164cdfdbc6e64b8a35c1b6b88b42166d5efe43259e4bee1062ff186bbb0fbf3542a3747aed44360bf9801fad51564a04f08c4c40edd509cc6500bec56a1d1e898ee5505eff6e0fbdcc4cf06cbf09d7c04e856d42a395770970fc7ae423edaf46201f8c493231fc42c0fb9d2d85b4935d76ac99855b1d006a2a410d552c3353bfe2867c346acfad9b9fa4f37f82c44a1869b50b075ed9f98901590f55b6e5aec13b65e9e4f77b870a68b8992f1a1fb0fdd6e0b595eabce79deb4206baf329e21abbc33e88b17bc1e2d0c150a44df1da87a15ac0596d9b667c64a5515d1a6fe67e0decab2c6c923145af01304565dec438b9df1ab2e15315d537836e34c73e0e2235ece91bc2d59d6d1058ae6440f619ca684f3ed68fe6ba814a321420002de12e42514f7f50a2bf6a8793672e8fb5b562c43191d3e12401917888196321a178bf0788cc442e78e92999c4d85bb808556582fa8e8db8ffb3869e8518418862378d76ca635bfc808bed6c8b5b7e21cfaa87a4d9f991f13610e3487c852de5f93d4a606489f1b8ad578bd103da0f86f89318a19cf692d06c7082543a67640d89ef8652978705abd5eebfed046676487de58ad4e37730a0a8e21ab68974cc7782943a56106a21de7f369065b83ea497d440ec054272e4ddd01b3e5d6724aa96844c01d3418a357ab3d21ef3007698b56b72e659eeeb00b465f17649a6bd86e5e208af26115dd56f46ffda8905bd2f5d2beb339dce77f02d3578da4dbe15007ef64b7ed7c5ea3464e143a9ab050046c89df86d7f58331c8a1b22b5c65398d4e0803ce0f25239d2c30b5a07d41e291699e1d4c4446791b86858a4054594616ab7133bc295702815e5673a601d9996c4242e06af305cd54290bc76812bba6f3415cba9f8d8948114c83618bbb12da2be8a24bce8479639ef16c746bced6f237fb05b70d0a06add8c6cd88840ad2cfd0a6c2c3f019527a439e4e7f75b554b6ddc8e716833300f8e9434fcd50a2f43a88a395b5375a7b61bff1cc7587fa41dcfe1831003dad6fc389bb5f2f1bbd57051b6d932b5188e0dcb448d2178d3ddfd238d5f49e7cde06ff68d512a93f9b5af9cd3d653f28e77b7115c881c8a59dd53835db350f4595a230427e7fd35ce642ccc28a7e0a6169b1bd043156681f604f27dc4e3c82be1fe61c9bca5d9b1d6c2469b0ee69cbac4212efb765ea3f9c3094620140ec84b7d4ab6f10409d9a315db542bf2608721868ef2af73311fe37196bdb0996c446ed2e63c79bee7361fb01057c0c68d256f88af573db6144ee58e4af7fd20bfc56cca8818f68d041a345638fa0fe5ce59b48078d8582e79033f1236b0485c3231df72783a5ecf7871d7cf3378c385129ef8f582e6a7d4d698f45a1a551b33fab32d3b24fcf84c6687d35c18e3f48dbcdf8e03488d681040925f9ea7a51a29fa34ef107cb02792ce2ff671a2b0b23429cfcc1fe5d03aaa3cdaea588588303c49e87ae74792b04a14c52addb20003ad544abf72e7dc977b6081300b6777931dba74072b25e14ac734cf5c316d6a976e10462b1ea63d5bd59a1324f7f069de330645a003e5e174b5cbac790527835449fe0d55303f878169054e4788a671977888b83790a641d8bab607ccd24e5cb49b311d4b8c1e5f7ec02e903bb9f6dc172a90145f8464be25781901a2fceb845082493f48111975b88d682aec917b082b93c903ecc274083bd7ded302d59aed3c6e6a645d170e6ffd65d91746a0b3806d2bc9d4f162bf580e30f0a03119b74274c1c4a1d5b948ab86d124a7af68d3a4042cfbb811284810962263ed59c2824465a4beffb2caa89a38f5af9d15d28026b6f8910fb0e49009cada654951e4c7978b5442acb27f0e74cd3670a49817cfa4a32e5ed78c4eac0d08096c49526101d56c32819416df50524655b0e55dd85825c02cf4b9fa816bdf6ecb2d70d42c82481d1f33b989e1c5a4bb6bab65d459b3cf6f6169dfa02ad932b101d633a63f4e6810b6a0721a533d395b9362c590a872cb0095fdd3aaaf95540732e2d99333bf1b0012ed4c12db180eb08bb60d8b19ed45700efae2dd0892e639dde16fb569db1bfabe2cdcedabcfcf5f9d5cd12a35d930a20829c73a654a1e65debaf99cb19ecb423d2d75b7797ba9d95dcd800f64e6ca5b8bdbdc2f25a4aa555e8d2f0e248f383233b135892c633759cc13c5f59929779623ae72353e99a5d999b0b2bcab261f2d8d72494ff0eeebbb940c096e8c395140efdb184bc8cf58c9016b3357765f9021dede2fd418298500c30294dfaa044dc6407ea8c118c1b9d10fce1b33b67788c9879fa6ca632557ca23dde0e8f475c79f1aee00b5957e5c2d5a4f9408d6138f793bcc3d97f996f7b80528ab92d9b5643b4be5f412b72b9dad51b9577ad7cb4fa921716ad3fffc1dda92e3ac846bbd3dfd9c2b5d8f69105af106524a6331f45c9295b2f38a9d464dab9833834d546e85af113459ce5bd9b95627da8a2e23a42fb732b7beed98eaaa73016c5d41b5c9d68d3db941c54cbd378d9c6617004d610e925672509c6a54257c5e5c94e988be4886af57159b8be4380902f115248c06cc137a329e4cb929d34c7218119961e92f9145a1b7e4505b7f48aa19adb46f675176c8e4665996643e0cc25160d65af8985a50ffb5fde4becc4401613b32caf57cc562209a350e157231df6703d22a41b5622884a3d76457d41e359e9a6d694bcebea545df02cc2a05b58876c0931d61b57cb3114e2af6b12a7aa21c93b797d8b39aee710d9371f4699fd2bb4b2f3f7606744611c3e52f85c656e759d22e4113ef45ff6e54ecd22d688d8e7528183aac6b5dcf0d0f2b2aa975f598e45ac8834e7338808a1b54a21ede63c2a60c15b1638e3c64bc487ead95cd6dfcc26bfcd7a9e16e614e6e75a3b93660af829a688633a48253fca0955ba0e2fc542d5355f2d18ddb278e0509e083f3b3e061d14330661f230a99d0f65b92f22baabf6ac49625af70d0f06d9ea8dbe4ffa0b76cad2c8fa2396870ef42dc082a7d26e970011b30df6dde675d8951876b15de7efc970d6c8a4cba1bec704d9882c34716e1650fe50b94e57a23a5b975bb6509766e3a68d41cc44faada42c6765f46c3e24ac27e2a2c090b557645435b0e2b9d6326eb30ec8180318491dbb4bbd48a59f7599b158c9f812e484dbbdad242016d713313cfbe4dd38029e938a025c5b5e6034e5368557ae862e78127a21300a9658d145e58875a77456546ebfe5cfad09809da86810493deef386dc7254935d33892cb0ef4c2300de5285cadc8bed907ca03d3e39fa5913da5da499c1c79a74bde3c43355844dd774dbb8b89e894f0dcbb8b76a1c37aa19d47affacb3954ac79c600e1e5ceebd8713c91321af00abcdd45370a50cf4b27562a0eb3d3a571251d81fa75a10672d1dcbb37156962e55900979b15fd4df41d68614d1d33605b5817157ba94df514fe58eca19bcc0e28514a0cd4e4782f6fe7f312e0ceeab9a04a4c6d5e51e2db1296060cadc105ba4111e1485b59b6fbffcfdc672709d2b5d3ada67f1ee8aa05c541e0d823cd87ca0edf96cef27fed67d0f4b0dca06826fcef4f94c941afa840ff4b3b266a3a04f2046807e67950e00d09ea7a9ea095b6b4a5e2c7e15550ed641072a7ab67a6f3e09ed2f49dff420780128fad786282f906daa4f1f9b96a7b9891ad15457f2ce66846cef9c42f1ae75101cd768ee899949f52146e3f034a187783cb2570a686c1b8b6c85991bd96c976658c8e8d9c06845695c6b98c538ac1259850f960f2d8927f85f3e8ae433aaec98c64804e449a0880e6d0a0aa7bb17c52208e9b4fa469ca41e64dcd5a1251aed42174202df9e643fe7ca9c5ec9583312df67ae28976da78ee38c9579ef98f8e3bfa4d86486617e5ec1066b11ecb2abde79d0ad9694581f122383fd1a786abfa8a6a238d4b600722c8b9005f0bf6bedc40302d2e721eff4ccf4e1e775c756deac5d45a0811eb709bc3ef4beebf5d77724f1521da10d29fac769467ba79f8f57183fa2a64516c6923aed1fdd7e50ffdc402cf005fb90973b68737ee3a71e4e7714dc356cde536dc5dbc7ce284d5805f69c268b3c3b46a2537ead4f061008ece7d85fbaf8ea9025e163bad902db6acac4a14a6f74dab3156a2147a2922c4c29556305c47dc690c717addadca96c13216121d878752dfb2509cee7ea8b9ba647c3033075882b55571ec2f1996e7bf3c6d1ed1cf57d6070718ee10bc0363de22ffe4aa5f1c2c0312b1dc36c18406841930a793ef4fb389572dfee898608b85b0f461bad312001dbe7afc256e320e1828ed8cc203bb127db0ce777cd3d551f2c40c3ba472bbbf4d0068c2c7c3699af97ed041866877d1384eacf8cd197332ac507da0743da21fccc8dfc7c2eb65f971dfd07d2f1df9f2f565c06bf7f2d6aa00f716abd09472a1c5c0c03f4997a164b13de5e0c9a7068d38272e10f56ecd60d2acaae711c2e9704725bd0a021969f9f9b14b6b861e21e1c1a04938ca3b819771c7a877c2f43f2017bfdfef894c6d565a842c32e7a0eba130713718658f4b811c3c021117f03ea29c606fdf1d49044516b01ba319b2cb151eaeb429acc3c8d366f4a60ac9584b5f915bdd8b807694374ae3ddaeac18f98ccc43a33bdf4ff2b912c7d8bf93623ae197a238431b4ede2c3fe3e1745669923839a99c230f9e55ec0dfa9e321c3d1f9abfe88622222a61aedfd86f3661ecbdac77b2888e1da7aee61d2a1cbeceaabb9d7ef14d5b5e0a8d4f65571f2c90d522e8106f6ee40166a0f4fe329bfe12bf0277b80a77997d0a2691ad7e0b749072ab03ed20e5d660dd895ecbbf6518934bc7b9e47c936dd25532e9362d73b68806213687aea574d4754d2ecce6ec2fdd114aeefaca9715b5e9ccf512be91611966437bccfc5c0c0d7beeb8bb1ba7a22c8b79404e6f8931f52d21e5f00aa907a850d4b9834d5c1c157b0d86139aaab9534985067bf4a7059ff9edab1c17a472f83a7db65abd16aa74af779d90317dd4f325ccc222b9929a0185856c51a7234e5de0dc4b5c45e105b68251d65e5587e2a4c7e0c4b78a28b9323c44f07601e27c38d6643d2f2d966d4487453aedc605c093e3ecd89d798cd25a3101170689231e6bdb75d09be5ea70463ebd18ae45754ed26334869fa318d334659e136b5fb3f57546dd94ac887960b2a5f8269fa2f4f400f7e2c3e4733138f068b9bae0075c0e2211caa7d924a590d9882eb8d879697d02ba3b760e686aa541fc7423de955361bfe1f0c9b385767292d0cb18a09e75f1e067abac581c7cf75768ed8c88ed4521594105b051905130ca6f4655ee0c930d92a41b3806c7244c716c2a8c7da046df914e8fb47b2a07471e46b0e6773ea30f6e8687d5cd438859255f766f19fb2580da3c88941c18a42535fb623b915e431908206297ae17a884605dc16563bc40b627c7e1cc2d4b7602e72d7f5cd85660e315b0adfa95af1564a18d4801a460ac022c4f991fdd4abf16c90097920a534a2f6462c955f5310dbeede7e034ca9363420c0fe3638cd312c1318d4e3dc5727d47b426dbb93fa457e2f83795b5cc3524afee5cf0969bdd443d8d2a1c7a1d955b2720bf85f0b0f5ddd0b32f2d88b2101e6983563d81ff604c308f569ed07c7600539650e6c6d89448193b3159b6866aef7e93719a05437ad22764302c3c7a0fcb4c61c4d412af571677886a19cdf45410ba187d82a0c129538f3781d21dd416a68e8bca583b73769563bff9f408b39ebffa95a5e2da8c492e61ea697c39be2c45775e77a84974d1ee8b1b87212fa6afb455417847b8ccf9bea0f8b98e2cacd75e096c9a853d91a420cebee4ab3f8307c07040e24918cd01d483a91ff64ffde348d246ce733ba23f9603b24aba5285ad6de1ad5bfcb6a6073f0611595b9c8419fc3ab33ad851cea0677caa6d74c491a50d7c7126bdfdd1d2ef52bc8f3c690a4c4b13c0ae937475f61d07de37f0608e25fe910f3fc99b787feab13c4759fd6c3957a39a015b86d8e03df791453676f67e228e8345e71b773836eec3725b054523608a71e6d66996cff3fe1748bd248222f3c9787471337116c96b710ab1d184366c488a83b83ba4fe9180fc81de84acc6d6ba4599cf79a8ba37cfc918ba160376718c39a59a27b665d7e0b946915ed084957e4484396290496780ba8d9a97e4dbe3289be6036ff2b2cf0fb5fb1cb7cb9401a29521ba9f5289dc4de0b6d2d02f323791bda1a27a745cfe82e47a4edc08144c50f415849af6e0da5fdb76db513a349d4d04fa8590106e4ab9166dc2d716994df8ebdff113c0685d66131fe297e812e94cbd12c6e23879c5bbecb91611a439ddd21093fc0c582bfafbb8437e51a1cc54824dfef9c44f3f40c18cd458db5c80d7598e8d9cfcc9960aa76c7d4f0a38ccec29cb23e2915ab531dfceb44a9f715df07577767e12fb55598e745353fb19d9d2c7c2f10a4380d6043c5af09c38009bbfb45eb55034761f3eaa73e24e063a1ba41fb00f1eded44bb4a8563012872e626895f6123e2399665922180d7ec566db8cd01e710c55562393c3a28146f32df9746a465035cebbe75323367aad4aff4ae10a9867a641a28573d294b988933795c8001bf199dc17490c1ce0b9f396deeba17c9589bfdb65798e9d8f52be85d5cfa8b00ec59265373e1ad496188d92e0013c0400088ef93522bbf13768200c7dd89138972494c90082b533cbf9733c50284ad218568496664ce1b0be05739febbe8a73ccf247e91c41043f142c8567ccad868a8bea3915b35c6418fe6e88b84969e32bddb6707f8015d7049d9cad907ffb4952684c63e369af44c09a9b39f647f1217333e9030b0b87f1bb036ade6f129c4b6254851fed2c5148be1e235083679e073732ff5e1fe9e7c4c9806bcda30ced8106cc789add52ffb28a17ed401973848f52c6aa17c64fe5f884ce9284e8fa465626984a80bbb1672c66ef0052c749de95b48842b11d1ea4fc0c40697da0286aae967669c7d74ba9c2e80f83510f908422b8a398e7572b668f234009d8017fbb224fd4ab54dfbd8620f17de298b447cc09bf0b8e1d726b386dc0dce22bf330f998fea4c05d862aa6f21eba0a16f177c82bda495b9bb85a7509bc577ec832a21fd922ff9995b9a6a3b72d1a37c26962acb9bd1ee2f12cf992b0796970a0510451d91dc2f1a73b3e924577ba647fd9288a0cf3e79c4489b6e3cb895b6bcf72f539b55d721aae8d2d369c1a2dc0d3f936a67156b8ba8d05b52f7a80a8ac98e950d9499e4fa52b300459fb9195d2b2123c88a9e02415e23abe6320586e9476adbd3bf4f675f0d3f3141de2945fa5a9574fc528f2bb5f0f538e1c10b08c2a2a967c51d723d367ae043ae19f422e76f770a90838db1e2df3efa905aaf3f54b9cc3a0544095bd7870aa747f42161186b220645c65053ffcbbc6a4a90b7bc0a7f33d6aad9859c77a4594ceef3294d991c48457a7beb02689ef8c07762f26cc7725eeeb41d862b06ecedf268488e9d59345ffee39a9fcc15b9a1827207ef58642591a5f83fec4bbad7740e687567284da626b38d4bff8d0bb5bd23135f8a4d8e76583ac4ca87bb284cd8c8683c2373c1757f2dc3472c6f8c164440c12911c66ec388b45301bd82ba42f5d11a86b82201a110c7ddd4e86eb5a998db347ff48a1e882e84b5cb023a19b12dc66b57dae18584887126c81af7b4f989a768ca88051f56e0027f19ea410b192d92f4ecefcb100a0d1a3413a2129a159a6bb7197f15c4e48485aec44603fee594f4932579425851ee38f34bf11e033dab612984064c22a2b595319ac5fd6dd912f4e57bed71b315fd1f931ed97428473dd61a8df58f6821a5eb146ce73a6a6654a9b4f0002551dcccb72b63e017815c4b9bc3da0af97b0c328e755a405c7146e5c85e0a756a80693d64897b403d750d0ecffd2e8970b04e2cc679c5b13bf372546e8137944ad5724d7ff27da5f8273546e372f95731ddc25761ecb14a952a70eee65795c8ef64290b217f45ae104e75008e5503b29bf78c3c42c791cdd6b985ddae261a52de4b02a37b90142a0b43cbbf5a852261d3fe2292d6607c6f81ad2addd7596688d2979aca8811e28864e1d1b737a36e7d0c60cf858df7de58b4b15de6fe5ef1a4adbc081f01fb19ca3e1331297f17a489ae5d80c2504694b433dd90eb3b1399060c4a934765e430dc839409663ac7d503c636bbbae131a267c52e0186a5ccb57f63247ffdd083b18a2f6ae16b2289a6ef41c9f381282300a02f5345467689c5e8e2b804b35b51400790b33281951482947fabaf347a7d6760d73bcd056433503fe3e205c399b4c4f85167f9b8f72d608b98ae64db67164d0dee8867060d6011ba77474043d8ec050cee092af1cfabc6c765517ef83eb604fc8392a37acbb59fbda3af3077f357133c7ed3c21439c5ce63aac99fc48c9fc19f4ca31d264ba54466db82d8cbd37204410c6a0f94953e1b94da4be800c8b9460a54679a808c2149dc3a0bc056c43693495fafa57cd32b1d7f0ac797c59034e28b505f134296563a61b2edc204aca3775fc96b4e07ae29a9dda940460482d16ef04b7da87536ad1a6e68ac609392d04c7d9aa9096987dd1482ec0a0bad999da675cc5c30df8e4e7b8c9852d3f0517bca90d5c34addf83ba729fe3d01a58464feb04c1f1675cb79571d983504a7172299d3d0d37edb874fb185a56c0fcf9fdee10eb1347663851e50d72b6320c24e5663ab3711d22541a4b0c0465b4df2f3836d06c5873a6f8a4a89f87d1236d542c98f362c573741000f38565c57dd0acba3db35bd4f3240e0a309f9200dfe52d878fc3ce8f10843b278f86cdbd47c7289ce6dc385bd0bd5632a2433814fb41e73f68a0c6b8fd5cd78e9018a1197ca00cfc7f625659be0c5d7c0187ab6635dadadfe13fff03445214e59e09d159534d574718d022ec72888340641afd4f934a2885644db55e0df4ded20cc71980b30d88a80df4879e74d81cca0ecfe038a3e4b4719edbee726e6554f0fd248a5ab52ea1bac499330cde6cb8930094ebeef0ca1d6105bae581e3d60fac3a91d280162541a7b9a41ee55f2ff97b7380f1137f64b45159b7daefd4bfa886c7d89fb65bffc2a480c2e6c59106528e87f0a3e6712c41ba85f471c3fdd3a408ef416eab1fa78978722ebba197ce747cfaffc19596a554b814cced6f4b08bc173fbbd91e582484b09f402aad5758f67d5e1bd1fa883c2555e5e93f035a7b453ca583f77bec6262282abc10930b7b1b3da00c721b2472e1fe5eff822b480fab8820f49093623519be3b1bdb24a29b0b43e8a53fc40b0a75b9a1fd413f72fe1f177d3b18f80b8122f6b75c0c5a5d972b31b25ff0f935f7276758d6008fb28547209381f6554ee3e0d124792488b9019bfb23f1f7c2ece998518e96d2ee4002f36e3731241aecfba727cac21cd9b56616d2bd087d09fb34a2bcf2b00095e632d3f377d9a7fa0545024095ded0cb59373ff6a9799a3f7dbbc417ed79dff4ed23ce7324b752886ab85d20ff4e34761efe61d1403f3a1b7ad29303019d8cc58de1c74b78ae8ace888a2391ceadbc5e194c0e7f4f8d5b4564f7ec031fe8a2c4f8c2e9cef1037152b2d55fe578d2cb6543de211a0f1d888da1cf9dc955f02536d798e7255b7079cf3d86e8c6b570cd615d91a3b509b52d6d8a3491cb6c1e3cb76cfcc008e16a1f8954176461d3d998b1b973f0bbe7ca30f33dc44839746f69fcb6f3f7ea7acf8772cc9be8d3f9f4ac72563e38220679cd436f45671653d15fefb65b5ebc2ad9682bc296e7bffbb6f71809dad00345bc831c78cade6ef1304834ef7a4015a2c4b22b75af18829e38134e85cae20cffc35ed7bf2e368a8e2f21e6f2445bf4b961c16b172b51e5faa0171b685dc530ae49d306cca0ae15c7b600057043fd8981beb4c269903e3cbced5120f546dedf8366ef32e54784a7307aeaaeb3a88e801a81a5019ac0c8b97371238fb95496db5f3f008434e3affd1ca12cc7437b49d43a6b85be984239b6f8f5ad23f4ee0bae8325572848916ed789e62c49f8524754e12113a44a805b4120f43017d2ccdb0913498637194ac7a701e34f735cb39031b4df03cf2ffbadbe463dc46f1d34386f850a394dcc32e95c74365d4844b912770ada1ef0feca72eb62d2e1b450bea66b7db03b82124ae725cafa3e700b70d5d7e66151098d09699d55f34efd6ae5f9856580cd221da7032de5caf9e97671c6262f32b703746d07ca1bda618311724c9b942986a7426d09740bc0c6fa80e87b96fdafe14ecc8c57d0ca0b6a75b765749a970db8b7642779acb16ddb08df64c5ef929027dca35751f3735fbbb4bec1492a27d6751f0b7b8c9878269a2e3446c2a12229ef4324f8bbaa1e05bfc0c96dca19b59fea229f51b7c8559281d05484438120d0e8a695f8bb6a2869154832ad8eeace3149588110fedfd9ad47ff0340161212a07fa8b470a8d24538a38cf49169b5bdc12428a0c43df7c04bb998ee3c509a1606408ecc51ba60fa3f261f9b4b55beb16edae57d186fbc5e99c61f3bfd92637ddbff025c173b0467bf86692746122a467aae5d489badbeebd1315bc87d54172ef59ac3a702bf29a5121e8cc734c2ff1eff01258cd78f84daeddd7cc5beeaa0f8df5d1f95ac699807025abf3fc71462ee45b32d064ca61a0edf4e48fb60e6aac0656e914c93120e6575aeb4d842158897f2094451d2b572b13b9b09fbc8a553d2af5e3ff77973df2d95c9ad695d72013df6de8d6abdf1ac25c7b69295be8bf9b6062e235dfbe9212d1fa287c9b1ca9cc9bf74f02a45bd908d7b803924c806bb6bbb772f2aab63fa8f8b67667fad1180722b8b6308860279c933a762c7e62b6af138f1c7d4c43dede20e0c1191400ffc4a7e29419f87a3d8daf788742f7e20a6faab82a4b2b088f04b0e6cb1bb72acb192bedaecca1d7a84604fe9de3e251b26d7e5a39d5ce1deb71ec16166de6d272781f5aa1ee72ccbd09032b358020a56c46704645ebcc038ca315aafba8987f8a20228e2cb7c7f4088b600787869c2cfb8ccfab32aed5daa2348b1c1903e2c13ce9f3c44d343b6e7a0985ff938c9fd741bc6841695b19f5f4804b989f215d0bbc3f5b1850651881b3ba691134f4c4130ab6c9d62124720edb18654463dbac03237823041d5a6a5954c8d36338a7d0d82ac43b3a4113f12285d4f0ce2e5c0bba99d7b1d5994b4efa3ad87e2e0a0310a38ea6f55473ef85afb3d37a62fb51d49871fc12d2b8e2d5430bf00738dd69a7235b2d68cab28bf8758e85ea7e1ada4849ec64ed3b51e10aec67115e2383a5bd38e9ed3f97cc8ee69981157c58327b4475ed8f5c3c72dfbeef942fdf171bc2a8eac28061cede389b130da8e09dbb5feeed923780935cce28fe9227aa817d40e43f3c3b3295267926b2988019738486f588d5164b7c72613ecfa190c0088c8f8a38ee05e42716d4dff83736d4ddfbb066eebef3a9e9a67ef2e0269358cd4b222fa88828d8aa7741f08bc60e39c52b7735acc0d1863495ac81c43a7fa4e318ec7ad808d82ee4b133e91706b1fad794f70b11bff0c87b42b8980c8743704114d387be7b5b712e180b0e1925b06c71020aa165744b0a194e74b5482e72b427c85799518adb17985ecde11d23e522064d0c13cc39538a2427122ccfbe223a64b22869953bb573621e74f687d8f0dfc5cadba6193113581e30e372378a9c753498b1322914cee7ebf78261226b11ad037ad2c61ee153ed2861b64a99f2558a3bcdb978e89180f0a5ccfb2c96c85ed07591b798f189323a3afb0dfe215876a567fe2708a3b957b1b75fc4656a0a6e71d1b8f78aa6b98657a97a0e81358f8aff4abebaf67b38155dfd0642a9632f7d975377c16b4dc0a7e7d46f44c3100486c5f21f8e67390bf62fd338f6ca89194d192a91d60ccb680b06fe3f05c3bbe16527fda6d61f97612270ced102114ac0361df6e3bd0ac3ba3740ba0c251725806bd0b753353f2f011000701ee1fc769e445d65ad26b2981ba6a55aeae1572568d1789260dfc18399bd832fa99a777458e876a91acde4fdb350e371f5a5a14849962e8559b8061cd8fcd34a2677c056a93f0f5cb57acec4dd84356d94823e186fd890acab967d8fad7f3ad7a9e2667d1c65ba97766e5c0fd7ed9d6ef558989e6df9c790eac7abf5e8450929a7a628d0163521b026f0a2771dbbc8d89cb64d7bb894f4bcb666a73bc95a6a2f0bcd52df97c2e3452dedf4462f4a8d19bb81b1e36af4449fd7f4098e2f1f997b0375d10d34caaa5b4625567488e71d9f5ad674b8abc5ce39bb85116538039dc010d90d31a27a34989f3d009b75b675cd7c106a4a25853545adf4504af104da12a28861f85f24423eb6e8ee44e6a51ac33107b251fb896d7a800d34c4a103c42d93c0b3c39557aeb3318fcfee8ae67b6432755b970d3cc5a7d901401ebd04577df0e3937627c49d89d72701e7f18875d066b1b9356fa13851d4a866f80c84ebe307d7c9ef38c123be88dbd29fa6c9e25c9c242acfdee0c51c630769c0b97d14fe018ef7dd98c57f75b833eb251f5821c5d02255a696841adc7bf4743e06471e03495346a20196d35d422e369edbdef71e706748e9a4eef114574d510fb001e2ac17fa6a1e51fdec33639bca77368a55d9ff1c653461e4c1c04fca60612e018e0c00fd2610a141f60287fd173717ef40bc317d15770806cab56a91347cb217dbb42515eb5fd973ff712351e25affcb6be9c3ccf87c68e44c32b919fbf42696634c25c5109577acd46947ece007e6c6133eb22445b7fe19596d81aa80c89f74b8acbba06c47fab89db7e51088bc93ccec1f96e4ff41f95019c9196232689de47c4d55b41b5d66d6a07f9193f15e237fb2dd4d34f9048b298b61237bac24e6241d0055549d3d856598a07d09bb8f7ff83710b57fd777329f4e3ceb7190e835f4fa6be49675cd1a37c14d2dfcd27177cc34be6e6df74e9d307abc4d3d1b37f5b95ad163dc0efab6ca66fa8977d2bb7037f8d3b666206f3077d3e8123699928f0c429d7cc697d29b46e6658caba3d573c2e246d5cec702de698b6a42710afdbd03837c424c18dff4e1716a5731bca5b9a98a937571683d6ff0455144ff5fc0a2afcdfde928dab8dee9faf78fde49f31521e36964d3a1421f414a7c538d249af997ea981ba5db44860e4f72edb8f5a7e84cf2726fd0dbd8378ff3dd3c14d3ca00538c1385231108100ab292cae93a8c4b5bf5cfb2a2eeaef8866cc594dbdfaf7df5491f51b2da9f8e7a7d30792d98388bd3ed88faa23f6e00cec79657394fd8e61050b417ce986ec6665bfe7fcea3e06968662494a666e033e570ee7efcd7601f14c49957559c0ef94e82cedf98605930cdd0908d5e589173a049a2691a8b44582ef5819a5d6a29b74403495858d4e3331e704eefdcb2c5fc3bd7101f9a2e45886d8896047fe10a251a0df4a1c42658c72a4d21f4e5397ebe701aa5b33654051a5891433010a2d587cdf62aba21a1ca1cf2a849d984cc642072af101653b29016105dd8fbdffc21a0a09c7d2e415f5d6ba6344c9e152189d5da485192fca5e0560af1de3a67eb6e01e90d05764a39ff1bb4da69e17255e30bca7925fafb267862d92e44eba4a7aef372069294b13756a8f255402a6699b021c1d12f100d7dfb45a6002d740f17de1f14192b738cca466e7d654d2c70e88d81ade60657cb8199cf204ee11a46e8f9d38ada69b56fdc7632e7a75377126bdec8dd1c6d18836b95eff223c4b55d9d4205385cc88d498633581ad1df83c3d36a843fb50f6dcfbd7d6941c38cdddf0dbd42ec81a682ac143bacc29fd8575a7c0eeb69ac020dcbe764816efe3884201b950480c23578fc10f140d8c54efecaebdfb1c49243d13bfacbd5f2026c842757c2395225e723eb7bc3af9d3a243e4e676edbe52e7948a6ad8d0e9f4ec1b7486e0f32e105a2b5e199953fb7b2ec3c02e2d49792a8655944f287a07761d7953bde17e0c513eeaea8e92c816cf33ff3cf0d7b235a87532ece2afec136c06b8209b4c25588187adc3f46a352dbeada28d9b70325fbac6dfcb94c8b4e566bdf38babb51ab0be2aa9b6dd37ccbfbdf6b146de24fa1e1d26a96c1312528963c1991642c819f913abb0759bb1e3f0d9b0d5595a0e9ed03b77b8e63e0095ef552e20bc1c9ff18df61f37e037cc086aed675d311020a1bba7a83516141ec927c32972c8b0b899db09a1334bc762e0b987fda8ea55e38094b2bb61ea5e0ae5636741c5c126c7b66416d36767cbe380116bc612e0d8ab4bbed8d0356eaca337581e9ed5dafac788cca176b41f69b32d7a86822894ab3e8fe76bddcf4eb554900bde9cf811319c426b45df7a3931fcfbd52ebf5a27832a41ea13d79dc883bcf398b163cd3116f351fc80700a2df528eb9d13a4a606b9d7dcc32c728d11e84fcc4aa1e9ebe3bb078ffdd5ce25581a964f6ea67b10e4c826cf65bfddfed3f92f7f74e29a6117c0e9e909123dd477ca576218df5d710d6fe8bf3ec1781ce500a37382013b8d254d7a12467672ec3770eed632499397a8c0651108aba5e03021c17bf8242fe72b148749f06404f1321fd891afdeaed37a81468afbbf1745a4955b52916330e3a58c2fa04296a3bc72e01131369714954c38d970fca1cadc4267bff66254e7a118cb77f189b422d26c5e7f7964811cd73e65068b2187a592990682fb61e1655051b836aa2c5b9ff3abf9dd4b7a0b24c9a68fd767ca4162858b3f256df7273425152f9e6366a97105b08cf780c294b7a761b639f8673c57df026cfb346a3ec9bf56766b0008085ffe455ff7919abbbd55a4d2e3381d0c49b86f814081f6bac6b7cc2d544f2e5a6121663f11f8bd6edcc0012188d8364e33cfd27a4c13e469e5c140ebdcca38d1df60cf11f84b3966f1e0dcaa27944d33967e5bb4c9ddfc28e9e73524c39996e43cdbc9257f01eb475b82f14319a59eec3a89367de4fc7321bcb9fa34112c8e46c128f4580054991ddbdbf937c8f18d0c56964b5dfda1a205f66cd6d2b0e47f143fee33d2284eaca69f61e9d59a906cc12155dd1c532ee1d7dd44d5bd786910318bf7b2d9c7d3e018ab622b75c4d04d9612fddf6f132741434126983d5f40d82f491dfdc738d9843dd25d9cc832930fa54433bb1388a075aef891c70d144631ac723f40ed495dc47abf58111a928f927bef05720a889d5a7d0ebbb9ea188f58e30b28995ffd1dba7bdc845b08f1b6859d084ab0ee65cb54be9325507bd458f45aa6d381f243ae5aa5119493c5f91db7c30a71653f35d11712e990fdd9ac473120625fb30bc8d7c4ce89a29c3dd5df5eb126a1a10f3edc856e0191b31f6f18059a3924b137095f3ae16b22f5f79f5f384d14b4814a780b62ab45e9bf31cc9f5d354a9d43a97b09e8d5f6a77b2e0a647f79fd5ac7ad617c54c5e49dcb46faf130bcb5d3c0e3eacf0cec6e5d487635d33f4ef8e46d50448d8a83a91bfe28359eb43ff1c162d16ae57d614e82d38ef6624abff60f89f59f055c628fa4b8a07ebb94d0cab50705647ee25b07f136251771671699a44dbcdf747f38a518472455f5ad6697f7e543a1b0f3cb33335e6da9aeade8101642115d05afe5c9efd4dc50c579259e3dc9c7a3a4328f89cd80f00832013b186cddc4b9887a279331c261504efedfd18c139b11826023c1f0ee5d1d51514a0058ac3fdbe6308211fb5c5ca61589f879f885e85951298e99cb05b888964fc8c6f45bcff07d4c446de1ef8dc8e7dc6127ede145be74731510d4f6781a60eac0c5de7d4f34379d02cb3fba639fd27650bae4f6de64d4a01df8e712fcb2c57604d5592f5970cea7ee0bd44cec4ef173a76fa6baad0280b0bd8af1f29deff8803299aa02c79ecc16a18bf83f0b9e5f037e5f7a1fa72bdd949f10cb017f1d925409dd563e674096d7af68a77d39b01f801c86a63d537ce479a00afca258e7fafab94c812ad066178ba3ed4d648505f094be46ad55ff883a65ae2aa9f4741dfd31a84fe09f48818ffff6f49a6d59eadfe61fb0ee0bfebb47fe0c929286632fca5658c11d3fb0c136f78e62e327004dc21237f0f6c6af82e573a9a163b2aedef1f919a5844119fe7c7e05d1e4d92641b5551d6a01b04c569693fe2fc0c0054c7a956eda248f98284125482f7d7afc777b33772f540b72bbb137da16e843b4e599bb6e8cf3b6ed644d8585649aef6667a7fec31eeec6cd5406b6e7ec31c60e70bb6c106ecedd67cedf2849e74073cf601c14b184ccfea332119131ca801d7aa2ae3d7775a49809f4bcf54908496fe6a99d69da8ef3129800cd8f40f3b6bce9a090e46827c238c70d6cb62ec9a120ecd2c98d89f7e99e0357a544e3b370c7b67192dde160d6d8a25d2ff6a8e6fc695eb5c5d52827f0ac6c879f7ca54cd1f606649fd80206dcd02de144014d33cd29a9c7786e918f623e4fda02a90667844a9fe5aed582d9d6ae32b79b8b1b2deaa2082e1b6405defece2d96c893f5e0f1914bf52824ac56f46845c934be5ad7075031359a4928302916d00143cddba1a9546dd1a364d8e15c08ab66a2a90144eb8c762fd7395ccd980debafb07fe5499baa89ab7d1ed90b29b037d340a1a73de2843f2e67a2d3c2c90bdf96b49488f1203bca07536006a106bdeea60a58f0bf92392ec598ae9193e5aa5d59540efaa75b6d5e50351e2ee917660ef001a118e8d375ec915c6f9de2cea577381ed8aaffc799dcb6ae6a8e63b4cac3f943e1557664c1343f6af12c981076e788eb7720ef93e2f3517d8a66d99d2b0bddfcd0b31b727f4cc9d10e4a46b415ff0cab77c419ffed291757fbf3b9d90ad9dc69208497946942f78b738919f05a0bf5514aa5517a2f821a7087096f12c718b95a6f1f2e388b1303b6309c4633ce7b137b3c9e44a4f4830ff7aa45b3f2303838212180ebd8f0d6f35a6ba96cf365dc03d2f8d82b2e53047178820fab8d51a767dcecc2b031c7883cda123e1166599461160f7997661f685c0643f5fcbe004905a4b883278b20299a0f4fe8ed852937d4ac5c834f889925005e4636367a4f0c4efec9e8acd06227f86b98999c65b744034b52fd7ba11c0702e4c38b4442d3299ac1e7717452255578aa9c2841f5b99384cb67ed49a8a71cf27daa3fd4a8c88fb87ccee3e8c08e4da3edbcaa3a528b01bada835f6df6dd5e2941103dfe0325abbbf0e200c512e2c560d42ebb7f9106140e65e46839c556f7f7be046876f982368344d2d7799fc8a7e2676ec1177a7560fd1a800d92dd39b6be584586125541be6b65e2af9b672134bcc13b40c58b45c2b41723746f18f9112157936f6702f31f00eb017f62d4026d6e5c9b23634891a3cf5478c5db6aa9c4c952a74c09c9c3f17d4364d72bdfe311a9e933f2ae7b174f7fd0745cbb6cb275e29d092afc145e4e3b96b28de5dcc6d267754ad0592d399e0a9b578ebf5c55677a60e0019be21f028128ccee60b28defa2505e5ed8d9b5b168c9bc7c99eda1b257fefc46628e64f57eaa9f831b1a6261fa35241afa3da53f1955e6b4195ced2ad00f34cc909390bf4920f4ef0d67ec8e6eabce549700a9d66a5ba9401753f3141a4ed2d0b63ec7bba8a7986d2aa4839f75d1a3e6173261466cb00c48f8f7fd8cc90de053d57fbd8dc3b51ed094d389179429cd46c587cff8135f9a0fc6d2ffd59a37f2a495e8941ff6dfca9602ecf7656518e7efb57640f7da34b45d375ec16814d5d0b0dd65cd1902adce792fd9823f7a99a46a59ec17af442eef79e46fc6401d7d80124ebfd4227eb7f19a34d1b9d070acc92a656d8382edef00519b14fd73ebf4dd99ad35dcab258b0accdfa4705a2e80c583626d848d21904c5e8271971197eb76593b3b795f5be53a47f2058a3454a90faaac8b923ecd66c7de8ab25964812f74718e743e891a95b91c02dc9e9beedec44de66ea248963fa74abd234bf05bedce80ae1749cd155058f5d37dd5417179dd8f67204e9cd0d981e2944916eeff0efc9c066dc4b75cbbd8d79d26e89376b62a1da6a630c89df3e3fb3141eb2d020b6b7a4753efb769a11dfa818d6cb66cf139d52f3f7c61929cd9940ee6d311ba3fa246afa93ce86dd712ad4de1d5bf0d36eb44c89fd5e7932d2bf9e0e3958e29cd510526043e32689df30431d2b312dea7077bc7999f7130a505a3927a80375d3727535abd73d4f5f7e737953de48ec23e38160b6b0b0ad1cbb53520a503db47ec3ecab8a02eb94824ccff434e6a89347e0fd834396e23cfc9aafcfd07c8301d1722d997eb792a6b997f2bebb45ba35652cefdf53102452f4570dcd69a637a416e28253131c5b9cf54772e10ff6abe1aac142194abad0f2acfa2a2390c9112bb9d3cfd139025306206d5bcc00858f9380c6fc7d91b518686eaf877289a821b624b21129eb24e581245193ca550f3e802fd407a8a11f6735bdbfbc7ed560cb9c4b602296b7d80f49db6d85a513ebb12aef4cfb06c69f6eb11867bf9c877949e3bf83882edb63fa1788245dbdc09070776e3ffd5ac2d153368ac0c9c1a241d11f7c40bfedc401c416f8da8456fc92c5c88bcdb0f35c1d6724a8c9b782259188dca13815ae45c1150a661423bb3a90c3ede96e5d67b72e47b43893060ac1e44c38d41a1c8a8b61c6e7185d143f9529ca6177706cc017e20659871a9982ffa20748f86d903ab49dd47bd067eff6f04564a9d597a9bf18f1743854ee35ad3e4aaafcc9e85f52d9615591172077c1b320f1c7cc9abf8aef8e9ffb059a9f797286e0849dc2f865c429e5ca514854a6a627f2f208b216951d69e8c476e55deda6dfb2cb851d2da46ed73721c9449d89c8f02aac8126fa7338c89129b428db42cf55c1b8a2971e163565b1093b3f032277d8c2b6f25a5fa6e0a1953114631297956ff8cbd2d5eff55e05c5c79af35fcb69a23d591d515319727f6a28bbea80c7fdc50b70bd0bdc983677b2a75b0594309950f66bf5c97721cd863b2effbc9f2fd0af22415d22e17191de3d502697e3edcaf566b644cc64357ea78edc1dc74d65c7b222b431a716a7005673092d06d149e9c7d91ea917ee345e7c223dc799a7736a22a7d3f7e42f65464e88cb21737cb9a69d56f3b8cfc27fb53d2e167c11b57b34299bdce4b3137fa621594929c32c5a70fe6a737a0c2198f321bb73f91f9bc05278093263a541dc197491b62806442e8cdb8ec48e0197b5ba5e5ce92cf3628f6b298092136ece577ac2b6350f57223ba317c82cd5e60d21ad50e7b44ca6d9fb9944eae2aa9b0ead23fe85a5c10cc7f0fc6a3a142ca4d9d828bd74a323682ba85c2ec35187dee56f834a59aadd2577bd3715949d53a104ba87f6edfc33e93e77163017fa90b8e09b1f67f48ec5014a0f2a9a5e348549d2966d8d7580390abd16b4314876f90bbebe2c1d6a7403f772b2153488b6ac0c590c8d1c3003bba6fb7d7fd091fda254f10555e7f4c63e6aca33e297eeb61dd3fb2cca1ee18248b020ac49647acd139c510ea513b5f2adbc6c47158a49203bbad573377350f1450cba5b02d32cd92d78b6627246c1b4a74eb138d1288c6dbdd09f36be9baa88f7d1485cd15993a75d0d4b84bc1f5ec9bd35f10d6fd14cf6184d7544e56117818d00767057c5002480db2966b0e1fe58f48aa64f7966d0df1a2ef0f110db12b7b86d0cd76fbaf2e1f5dd2131284b06b3d357aee0decbb0d47bab1298f4158aa1afd335e535e937a47e0677609b9a719ffd01b3d8f9f594517ea723ca44b7ed811b33f182b5812c414c5bd25f665b315371b10079a2a4ab15efc1031e35ed11e5417d4467b8072a2dca92a891643eadeedae6fc0bf53c153562a0ed8f7866e5825e1169fa7ce3ed305a19687b7f1c70ed3e9516840a063338337652bef955a0b495f19f5809ad3817b7a1af7f4d90c61360645cb0f7ff91a8ab02b0c718b8dbe30fc24556c3f4361c9f16ef005912b87a1feab883606e5c07685e710e0084fc9a39e8c90af8f99d4d3354eec64e1795895f0ca3bee7d953fbe6c4e68b8cc5dd041bcaba837fcde527435d28ea8bd3cc8cc992c08d5a7ef652c3e6ff969b2e4dfeac6eec93d9f9b5709dd5f95eed315a67d6339300179794cebe7aa7bad1e1be0e1c425f82354e167ac0e47ac42416517d3589ebbc6b8d0617a2c106bf8073df79e23b4a66f12b0a93dcae9fdecc3edc1fad01fdd079a9dcf48bcb2a7ba7a95d1bac5bfd45c22a37ad2ab9403cb8ba77a0bcea625969b083a6527e650741eae3b8fe341e23786154cca7ac4d7e5c4edbda6f43a86c177bf27d3faf74c1fe673ca6a90b9c3b78690ef59ecf351d5bf28fa522ffe331615c2a6e751bc2b76bae880d656c97a4dc3485ae9860bcd2916f2e2796c67a9d106fc81000d59d0caa2573a16b01ae21266c98a06ca7bb3a29429c3746f99a3609fb378522d3d205aae48433d18088d6f39c2cb7069c6805c67d75a0f90ed18199329fd98de6a08ce3ea1a18b1690a8839a104b5d7f3be2809674767f1b62ee320be3c1e973921cc10a1344e5932b456474362db7c688d9e6ef9ba8787d2e523000184c3b99c03b98c21880e35549f356b9edc382cb67f5083ea28b1cc9b46aeb1c5b6533700c94fd108387abba71cb71d5b2b828b6fd8f503c2943427fdaef2edf7c01adbcd7f7620c5213ddff90843da5b9027453e275fdc0e872bb62807457868dac604d31ba9b1b1fc8af1bed3ce1a181a3408698822b75f7f1bb1c035ff10591681b11af92e54dcb0b48aeab8cd656c5209ad1d5aaaf81bc743a1207eac9d4906460a1592ff3462191281369d6994d2f3e1762bc4efe0e14e5e10514ceca411e737fc385c129b0ae64245c5d953e2e012e3f2055e7a802ae5402521f7dbf0075f85752b736430a3fb7daab173ec1d283a9551f3e41858835fee17321272918ff062b706a23cdbc74c077bc8d786ea4e2e6e44fd4ddc9a56f1657daf741d242c3cd75983846bc9e73666cbd8af0353c72244d316d7ac8b52653cd85a517c51e2c1637a7fc8fb1f367a3b3132c1b97efedf0f0bf641d77210e29de748e6f8fe2a04175c1ef5b0a2c627450cc605bd3c233cb893ef63019bfbd9129b1db78b6492506a47d9653f56e45fb4e9f29260f489b4fca8c81151313fc9338b6d342f5314ddaeb7a03c50db833c7c20f8868c375ad2ec8a3bcede7b635488e3571646c083c3256ab878b6129a60ebd0ee6475ebb750a3bb8cb50ddc6cb31f5b778611e6ac3f778bca7f1019ce9ad66c8289127041fb7f9dc26a137bb02d91a1a5297edde42733776f760783ccafeac485942c79500f95eb8117b3bcf172975cdddfb90341e14efae1b81c58b25189cd841b80b685ce218b95a1c069ac20237e615731d27b39bd7e580a278a5eeb19a6f94881826349736971f4b0896c9233f43427d54620903709e4d31e2d18b463411e61ecdd1fcee70686b3975911bbdf078fe1cfa02ffb5bd7d5cd5051a33330b4a2f7f0f2959b6224a2d91ae77e838615c6977e6074069541ab2e2ef83fc5df042c77f6086d5fa65996ceb6bb2bcd63dda1a8929e3156be252cd0637e5a340f916fb23262ecd56940e7a8f3d11802da1e4a6551264a439ec3bd648bcd63afe463df771770deedfd57b952c1a7a1900cd73d79f950fa629988c68c6a7c5ce9e14620774081426b0120d7bf0e0a00bb754c0bdbe2619617c9782f7c8b995921fe2a1007a3840113188423eb04fb9ff81c1e8d19f9d48459a9b9580a8c56caefd1864b5a80dd94e9bdc0b9a21c9a8cf52386442442126d7ad967a1ae50f6cc06ad27288ddf90444ee138b42ca793e40c50e883a7fbd03a153c78a68ccc1e118853ea2ce6771076301cc7d72db189d9e91e41edd5e3bfce7386d86117c3d4d97d8e8a2e0ca3ddab9d501852abe71405fef255ce431c17a706d4d3efc2ef52e7454f93ab16d693ab24bb8f31be16f6b0ade4b06c7215000fba4840de1ab8cfa370da8206b881fcdc30d27d6e4eded36dfd29651fab6b099b772af3b875729afda1e11271bd469fda7161f3805ebe3d479d39b73fd46ab3cb35b560b84ca317e9fe3b16f3284941131d403c5bf83ab314f45f11b0bda5160551bffcec68f024424441d9ac0192a0913a4c33ffdd25b0124f1cc21360cc7e2f7cefdade8ef26443904decc9a2eeb631573edf09eec0cd34bd7f443b5b3ffae864c3fe9589cd87cb90aa04fbd1eb034c1ad01a30e9dfc1287250c8f6e4ca75c78b2c4659023a0c5efcdf1cc7c133f5db05599c74131449d6ecac0449be60d23b0b850cf3f79bdb2ecd23c4aea8dc0f198f48c6d502447660377c60b5d5013f4b049eee37b8390a8c8a419ba660d53902544741d32e52fafef4eb71f6e90033d765f2e5574767ba04e71f9d98d4ca951a57173875f0676a6fbba71f9299405c44bd2e44a2baf4bc3d8c9d35f06fec5391300c5fe422f9b3dbf71c976e53568ac22626c164a19e2979c0780c73d56f4750f8ac9d8e4d0401d33ff4e912d32e3e311f572a4456cddd426e4b348f7031455f224a0653727d24390b3cdf73bb8cba285da78bd9a66b0e55be8640ac84c3d50bf27c89cc2ffe0faddc1d1e38d6e2d59ca065321caef7ba9f9885f2a8dd8a92352df1f2c3f8acc10a06845d05ea4f30c9e9de281a798c6cec734cd933395c81a3d0f30165f3a1d347c8c9e52c0ae3b9a758085304dbf91d68e85aa344cec0a6c61c1eef017f086869744bb828395bcce2ade8035cc4012504193eeb4b9982ba823b84afbda0e79f09ac2a83bea567f177861ea2fd4464054a0195a56e5604ca1f554bd7b852eaee0b8b010128f4b1f03c55de1438328353b37f39a76cd86a4a346ecd78608f8a21c039a44e30a5e8781968b98ab2972629a5c66fa6ea7553f01a4d96a888aed8d6fc0f47db4488bf08a905fcdfbfbd243ea91b4e11169e3776c34441d7108240c1134d967ad617bdadc15a7944c7ec7d4c5caceed649066adf0735d264f31dac7a46fc1172fe2795e4734500575817e62a87968653697d6c952497e665228203ff2cb0ff507f75d63aeda3a417118eb41b30411063bb3c9d0c25d41be8e7f29b6acd1dad0f2ce5a0ed83f27bd98e19d8371670f15a772026a420d36486670b8a04e3cd9435f249b0bb39511db3dfba7a10a14ceaf021b64121982047f1e9eb8740f28aab9e155444338818856eec4540be5956cc51f1734edb145eca085c2c5c93587bfce8a59d23db53c35f37d8a5f6526319665cfe1e1d839323f33c17dd39930692fbf197b5aefd768c52d9b4f76ed20ea72db3abb255f05ff12e7a42fff16f3025b612b47b0fbbb79623ca39a5607607ca0c6760d9ddc993a413f7f76035a5fed7af488c59190817289038615d647330c34d30bd34fd1108fd38dbdc7c7536f597931728a1343cc415889345d451370d4f8382aa0ab3e87f4847adff8982ab80cf36b711cf4d29613c05e1c34363b3e78bcaaeb218bbd9e565976cdb84ac897c97b62b6a738f66e9f25e9d47c45969787ef7b52068d4407e38bacb0f10e535816d6ea1541333bbd39e4bc200af2c146c0928770c6a3bd8d1551d7b3574b4cbf33a5682b37c1e515b3e3fef7ca99220eea5027d78e90e82dc4168e52242d6779968d6314fe9863490f471b7f6a9adaf1a85f574c06148d1c6c62c196bff7443fd5303e3ded2d7ec77ef0de0a0b9f71d9b6002b54205edffd86b929b4d0c21bb8d2fb7ca8f4a600170bf0dff8f903ab2920a7c0b4b22c8c196edff0e279fa57837a1ca3401d944dd4d85e2450f17c5f0909d4707bd5a58ad7cc8c947c89efeb5ba39eb09e26bea2b097f8000e9bb137bd1a35d3785701cc34afdb03a172d9c93618e2e511baeac1d06c90ee73a69bdf14b05e446f6c2ba256e8a0017a3f6938a2c6b64c7948a620959a7b56b971a56301808c1aa74010d0271d0c9ea9b80925373d5d525d889ac13a08a674a195be3156c34a080c7f90d2d01100e8005e7a1da5128c17eb59b1bebaa4df7eed44e9d0607582e297c2ad0d5f8f4cd222c487a7d0a81880aeba7eeeb3f9e62cbe26b3947a8b3d1d56d2b10d22015152be1f6fb44585d3a21532c3d9e2c4d4d87df9d648120d496fe7d2ce4b6d9ad35baadf89877d931c671f6d6c03cfa3ff95375976d60eff025ec822de633d43fab99727d0fbff5f99ac6dc220a781ff4eeb0c24d891100c148bf23c5ac3f6b96832af32f58cb2d85b203847686dd687482522bbbd0da165e6b86428d6d6f99d6b58abcf1d945a6dd438905404057c28c8762517f3e5a1618f8c586bf2e33c802dbfb29172f54da14e7eb8bba6cbd9301d45a2b465beed5b0d550941b6d3cf452911622e48bff7ae595a6103625177eed5ef457a4690fd3f3cb578d831b68b5a6e0f8f1fd93ddc803c8f2f4064a3fb97c7a61fc69c0e27a42da6abfad886bdb4715f540f38ae291bd8618b1a58407c6e24e67b703386135c8a5a80f85a4efe42827ea114aafe95e30c3e6c1365781e1784c07561eeae41e5f85b4d2427ffd1f24e974865ca4175e203e7993fe241c093b4b650df7820cf08dbf35bec105f1ba304dc9e912f7116087c7ad6dccb5596810001254d2d5829fee12d560d66a437ab10ad66e790b23dae92a294df099f69bbc7eece03e9531e88343b51e9f9b865770f9b39cdb4522a409a8ed1810e0184f066dc4977ee93c183e3870e54e9825327a438937e13b3b2036594134d204e5c7ed6ae0e598ee6f2153f3f17c041fcd244401c01fb285e4b6be71c68dd991dcac4ab12437a196bb9f3fe4bb1452b46e7635279cd95a8e404076aaf689a23b7f5ad50b68f25eda5817762bd7ff24ce4586673bebf293f9abe39eb70cea5da26b6474e5e3a17e55d90601ddd513810eeed85c49da8258a66b9175cc459404293c247a46212fdbd09b2185067c0b9689b99ae8919459e74b0ff218db58f2f3be66977d91bbc6ae414a4c880a1cb556a58b2171cd1b6f65c9410d80e5c55bc57116df293b0d3c785e39ce2ec6f002cde2baf0aec48ee98baff942325a07dde7e0f86ca3b5523420fb7bbd2d0db0c08d73e9c7f756753b51edeffca1c096c52a0bbd046e670548b28647c655e7642542e15189e322461836c1ca068988164175ca853e6d50ec147386901fb8b427adb9a563a12d7cf82fc494bd996d942c40c010cf904390578ad50754ab3d9b5f46354b86ce85ef210029eeffb5205c5d72890b05de07a1dee67b56f7d83f50ddb7791fa2e62d3976ae70fb30a068895df8c5b94b0ec327ff83735506045f5bea38d262a65d7739974e8c9d2a8c5e3b56a3d5d0b5a01bba74923e8e50cc4332a1b375429de2b1ee994ef86b7cbad84dbce94d4c8b14eac4487a52a9b51fb2125c62c42ea01facabf2d749a83fdc6963a97c6f68f6f2df89cae110626d9a3bac7a68702c69e964e7aaffb54c087a9c126c5989cf4690faaf2394e42f8bed6d1d5e7ad8a181f9a2893d402f886e414505054a55ca8ebb373a7179a1246cd2a643aa47a307cf6b89cae698e8d2e85d58821a1b4a14bb5e9099f1a8a967e5239bd73215f6a9f24689bdd9e6be9aa5b3b49fc33a5286d5dd97e653b27c984565717e121196ef5d5af95754955f4689ab1f2f5f68fe9f7cfde958d02ee5ff626def3afb86b3cae1fd8dc4d67ebf114712cd1d23a4b603d76bd9912d92a49b47f0bd9211fbdd8b21a6b58c43bc18880f375f130997594cca70193a51d948922ea084ee335ed392cbb9d3195c4f6c6d2c9e4d898889b448557cd2c14c8379308834cb1b108b93c1055ae0477d2e6bd65287c54bac77100d1433c4b533b40ff6a96c73f5d27f41e1fa2b39e93c428e0417f408204aa6174938665244b5a7f9b4baa37a33f5dc439d3aa9d8e27b2fa8dfe047e9242a3f83fbbeb6c58f21460b9f1a5930b6c1a59f8658487f27bd7801bfa186c5bba40d38ff663aab169e39fb9fb2d6af8590a3edbc992f10046276d5808cc5837f906d8b575005f7c320fde87e9ad302d33ca90a009d4c0f92e0039ba14ae31e239c7f83aec7f50b0daa4aacd7dc468306cbc48c0b389ad339a50d76b361f3c8c2298089ae2560df15b5e8f15e63c1170f3bfb781a0441719673705cb6936fbe7f0e2c79eb5e52aa77859ef1a4d90e886b84a8763699d7dd2d62d0c9e04e5e0e2d5cfdec5d107ce50f3a0adaf58e0e82ababfc16fe98e535536d71af56889b999c7f1ca908ca28c6073d1458665c22d046d0259bb435d49ba01f26cf46b20446c1c405d24f1137c6d468e6bd083849a9353921c34872d8ca1ce80959d651df11b93b0624d17351c0905d7c5ebcf356818740cdec7ed424a6a13fa1d2d874aab18673bd2a151b58dfd67010a0ee51153f45c3a58da5b16bb16d2275fc3b7a0758a63644afcda786b4c8a00c037fd9df6194dc28b3a5746e8110fe41e12efb3e6cf6118ff3a88a6c3f18ee1f2c8890a2080393ee364067490ffaf8c3773878ed331af2b838a1bf694f93616d319538c11884612b679a5d7b52e881785b96f3597354ee541e5f18a40583792edca0066e66b723ddbf2ecfb1945115904766312957669d5ff16338534787dc9c43081f82698b7b60f58d04395aab430624ebf5508f37d0fa5350e78a96948ea3e2e814a02068a94d4bd3fc72d3e7780617a1682c80c2b3d0fe3b6c6eab98555b267ed64afd7a02fb663f773bab5159fc00c5d39767b5470129542918da2b1994e06660bed43dbca4496f58de0420e2da7aeb6c8c9079ce0628af08a2cdb52acc98e169a899851c2f09643da2e8d82e20661f33700ee5fb5e90f7b3e3a6370fbb1404204af772a425cb8ac663035da1e79cf8344f22ddfdbcbd6b6b49247431d4d30fb265282db6ad578868b59ae5a1d85acb4154594804ff9c9aa2795e31a4248aa1440a29409067b066d446c537dc2ffe96e299ccd10ece87a6f7fb5e225ae2741aecd6a3b1f9a3f275aaf81cac6dd6916a39b74864bd7f64885994216f244f3e08b8730d6f517ba0979601324044b2f06e6e196eee28d7918a26a4ea7dbea354830ef2b445656dcc35f2849f23315a2520cd6529a57b1eb73a84284ec898d5139b257da9741d1468424f359ee40f2a408d6cb7c78d508ecbf922bf96a999a4a6228947fa11e20bf6edbb9dc3da6565d58d7a32556c39bdd130f61ae03c4349d7d959dd7626c9ef21d34fe9ec57bff59bd11b6ca0a2161e0016071f67e888b3a6759b7b276d751f9313201decf7a63f97ff52a8e9c4fb162600155030d8adaa3fe64b5b4284459aed2844e36f5a9deaae7e34076d8a9b5668621d40984c4cd752d9cf13de4724a3eeeba36c905c17d0f6b70048e131fdaf52f0807a1421154f38abd5721861ba3a962b7ccfa65e450b579ffc345c7cea1a6dd6f5f4056e5abf4f4c075a5c7043d62b6952970e42f70a273b10c7cd2e751cc2d101cd6cb3ceb8b4ec016665652ce7c1b9c59c76149d3a53dce2f7e6d29595752872cb0533f5a91dbfc8da6eecbb44b13a16328edaff6f5cf7d6a61ec1190bb8628e24a1a126d875fbb73a94db4ec585edd9652e32fbb846f9325c6751be5bf30e5dd403d86ac4456d3a707052486db4bcec367715a99e9e49a016db794e188e71b24be54d5e9f6caebf9cd64b9f08dba6ac5ddb3698de964b0d76bf7884cd445cc497daadd01c997b4d17ae2915d7bbcc19ee3f0be38c4ac35e8bbbb952c3faf674b01c47a0f9acc1124032967af389ced50ac9a99afef769c58c82f18f10e238bcd3a36498da950b0ffa5d7fe289a3513d71df7191983eb88a3f473ec8f4b012ae80c8015f1bf9b174afed420c37b09f7d0ffaaf333406a6eff1cee652c193a30f4d5bd544fbc3de34741e095dba8055b1bd224ceab035f89f0f5b42faf080a662283aebde9166f97674f424cfa253abf2ccf60e845ce6ee1951eebb19f34b30b83c1d4dec30a5a76d956c8245007450f625a62fe50816fabb8d030afcdf7f7545cea49263b9296043551f3f8e79958ccfe9c0988550cd51dda32f5805c8b928353c7a716f7284bd5982c9260e050554c49cfba222ee424c5fe7cfd4d806f9f2605fd3afb43a6cf270782803d96c02aa8b4b27fded5e0b9de97014fd6b8c90eb9bd776e92e8c06eb27d56cbb176c73a83688aea48842c53f450adba7a77f378692cc09dbf307306e665e23cba2426e382c91e07c79f4ebe3cf9d0a7f138ea4c32afbf6b2254b6dd10beb3c37fb635c8efac8f1649272f7e785d48cc4d8630629a51c228e08467567d0f8856682df337fa3ab39ea0664804ba7102fb0b77bbb5d9c212b441ce8dcd3c8c1251239669cc24c2dbf71655ea9a443446e7ef78f4cf678b5267099a8ee27676e68e54e443bbc376761eddb4768674c1a923f133219349ae637d71807f7ac8471218f0198ea4c83a817ad172e5f1196bc89cb85fe1cfbf3baf5e2c229e688c6acc261bf9da1f2503190345d05eef93d0a7c4b0e9a4600eb753269287dfbf0c819d892c2ee85c58d5dfe27838ef1590b2565aaf4be4abe4b4b4cd9ddafd257d5bf4ef46214d5fbe64c465e19cf2e705c28ae0d995019b98ffc657f5386fd729502abd233917d12f55d07182bea6d65cf8b4f7657e819a0979a1f7ce6baad53e619bcb0b7827c03a6f7f14238459e019843179737ad276f94e50efcb4b4a6decd5068e3b50b927639c2ceb5701b5d71eaa795d08405d87a618cfcc8a97006ae8cb56c97d9f184dd520bc1636aeac5c4e3897fd66d75cc3389508d927cf3e1f1e426a113656dbf7e81f62372bbcc8c9d60ba117f4ab550aae4db5e065383da024a40f04f9e8ee688859c541004c43d351804c7fa8ef20abd7aefd45edc6fce3371439ce3fb2f5a1fd14d149e442e44e601a5098752dea0599478470d261df64670053140241cf1681f9f9b7ce267570a0ebc5ec60f4ae826b393fc7f6068274e1aa7549f6ea3c02079c3f5a9b68431b55a83c052d3422c71bcd7d0b4fb68ee177fdea2d84ca712e6d270055272a1a01e63e83bb62df556eaa71a025ab91dc8140a08c900b25683fae3ca18844b3746dc704bdc4be32ca07a78b00f24a2f1653bc8f46c48b42d67affa71e29f11c623f139f56e189ef992efc23eecc173fc345420126bb4b569efc146a31f93edfe06bef877367054c7acd119b1f4833060be4c9ba109ba2fab9cc34763943e8731244174f3397e9535410b60e2a8b561e7e97d0ea6dacb6b6ccc96e7e0023c285dc300582a3e29bb03f1f5136ee4e8fb882c7790cb97595c2c1927c6d913673d51427fca8385ae5bf5d7ba2b696dc8595c75b50ab259c65bceb851d16e7817c2ec42b715064de02bd9815545927d2de862ad6f4217d5e76323b458b290f5c1bb6781f81a6d15be14dea0f40fcf1177f063d8632ce5f60addf1c5f38ce8bba4670cbd9a4128aba18fc31ebb7b81a6562042d7b1d7af396bd80d3758d96080cd82140f41941a5ff190ff118bd3993b1d9474930b221706ba35f09a1c0f93b98493a5061eb8f888e39ab3cc2620926c0ff4189331425301918471b3d7ef5f5076ca4095e4c3ed2adcba8147cce7f8ec57d10f3cd1a5abddd62ae53132afbcb941d06ca686af2a5aa822fbd1f37e8fbac759245da131826e7d69a494738786b7b22a6beb3093c60b87f1c08a41e5d786d5d5999978829d957656cdf4d8713dd6b6351493c236cd5a98200e111f4c830f1f2b373b609a84ca16360830c2bbe4421ddc80c5d7dcad92b23148f088300788ce2985527fcf6f247b58ae5a57609bbc8ec528ff7a892391b1a0831ecfbc1c2f44ef06070f2e9372c7cb9509a4f857bd687af101cb7b705f7cc190a5f0647ad3226fb3c561d837f9fa68d9e6cddb3d30c2675581dbfff4dee31f2f3ed41985389bfc44c26a9f391080c4b200b753197a03ea5acd1a343c939e73861ecc9628146a3351b8da5d4dbd963f7f2eade5773478256f05d88880363c09f8d2c92b21f483bcc7cc8c7869b5967aa196afe99cc47c129a1549a4135904ed60f07521b86593bd2812102a58fbda9d3bfad2df80e29d093ec04959d3c13db5b49d63e2c33156ac7126c098e760d811cc15f8574e50507145bc2a259b5080e90698ba7fbc4f04f452edde63fdc60386bbe6d56e904706bb947e8452150e7d4e3ab318f9f77c980c9e1ab1d9e7e28f2e19ee15d547ac43aa2ffa476a8cdcabce1207b3c9b770035761f155737503e53f438a2b1a8b8ced6f54f7519d654bc4bd8299caa984e61ab86ad21b8e0a72c2d5c8bb920b140997f87070a3cbef0d17584a68390d1ca3b0728bb7f42f7c0b7e7a93d3fb360d5e3c705166dae9398846354f8ec0a28b45d870680b918d60f89c4b82190271523969a1b43bc813595b070225cfe4d1b2b3ac011d8a4d6aef7838096878cd65fe24f10a9ac89c2271b5b3c674a46b530db3304e7e613e14f02f8d35a8b04b3a1b5fa3d7ae32ece2015f02d2dabcfef678f809f007a76248f92f4156e82a6bf4a1d001bc7b325e5a2b41f49c928cd47d47acc6e330431b50303253cfb0b736a86e00324eb5ada56e0e29dab21667c5159550cf5e75783dde6d0edfc3bffd19a0b76659144c95aaacab18a5a940bd83806b9b41975f466dee8c999d12e16adacad8b8674f63d505af617d177b67eee37759683865a4aadd2fe32bf65474da5b99dfbf04108a586418d689be2b604a9d3b97c9f37a00483ec9b6d9b3eb84a6642a33f6d3af9d0c2344f2e327aa76df7974a5e2b091aeed1faeedc7e78f651c0128b89872db67a81c56d127bd2bbd30e57a2368df3d096974198ea22166b0b2dde3ba4258224282c90afc8e3761275268026286c1ebb22139a4cfa24aa1b8b5401c43ecafb3f4632a468a47363e861757e52c5fef0b29f24b0b466e063855ed0401d65f495740e163aef4182c0a5bf89a5f447fb9bb9cbeb019a5cccb011bb38923dc28bf3546a87090f0d6ba1598761afcdec8ab6ec6c8bf7ca4d6622a856b4562bee350af75fb14eba3cf6dcc3805c80c0156b58a8f90d886b76516f67bc1f03c51546cfd6b6004c1337663cdda17ee5bd7afbb12034f91d0be44e57e9be746f779933e0222a0b33da384eb3570edd21555c680fc40f6694a89f67bf432bf53efda31eca59c16fd9d92677576f5f630a1d1653cbf12f25f1b6866ddf641a811e56d42d13d882c3e1f672a768430fcf7fba8a2a0bfd9f1b79b50a1201a85824b634279cbebe87c4065f4d3ad6369862b70e260d1a71e88d24a1efa1e0cb7b150615f8b6964b95ab2cce4bac3c8f0cae1b08958bb4457bbc56beef96c5348eec5cb808078d636dd0262876c72853bcb8ca4b993fc34c8537a12d30038b22fce6b2490946f4dba6fdf179f4cbd5f0b71f66ec128af6beec36ee05cf6231b5728544ca808aace5202d395f313ea54e3e3b1773907de3f400ca19d1b09e13a856089f0a82d4cd5541380e0b6c5070d7332ac4e4354dfeeb4175b7afcea97057c1ddf79d2b8f52a3d5e3a288ced5a239394dc0971b54a93b0830cbd34cf1450be89e1457f1db553b7ca7e2974a70a26071334ace558dc451451450e2ba77db3fe94cd3cb0c517df292d32bd86e919005b9e56f77cbb6d38c628bc8733df08921e2d7a6e1486beb0a623b98299152b522206851bd13239cc37e1406d7d957d9d8126bc6d421cd4cfe73889643e9f48f44b7ac54a87784120dc067fee39d29260abb62a8d701962324c81965b49d257b7b0e9938a6f9791d469983071b7bf5b39f9ccd6e66b4e0f57597ae0010484136ef794756858a124a21e772efff346113c9de57c6cc764b430c8e3a1f878dd0a6a71b17a4901df9b54a21bfa6317718bd215cc6f553b777a1ff8b5bc3bfe1c0548df258bed224a68fd3d10f344521ef69c2c4c7a42073ee72178092c822907796e3c430969b739393b2ae9193a93dc52e7cde31526b265cf1efe465a528a0847f75b4d3f6f6d324d1a1d5fbcc06298515ffdede21adcd88fa9f8a9e03e33c4b8a56425d81d92190841c7f5efd0dc31a76e2fc9f94f111ad02cd81c21374e6d243591ca128f057e242d17d2e7cf8e1d613720c633fcf8359db2bea641de820710074d142f1cce1d713ddc52d6a2344706962063a27c4fa152154363df1d278228e3025c4802abb1a511712d08c738c92c74edaaaba182fd3f1e39004b37804d3e7141ac92194d99340f5fde81369d17c499117df38b5e30639d3bb763ffdc45216d65f44817268a5581ee8aefe98d84657ca5ebce9d2e68ffdc4f1e9878d99756e1dc4f54500c8f6248825194f94c39c7e94ada77cfaf8d4e696e4b92281ef0c23bb0378a928633eb6009e8ea9964f8f6409292f658169cedf94d5b7901c291b5aa319cee0e62d559c524ebf8ebf163d977322d02d12a8ffb61d87e7384b67d902ad941cd20c94dc63a0927cec46e8cbce7007278ac548b92c1237cad1341b2056a312f265d3e208c076b322558e725ae427ef3390f5e6010445d15614b426d652570648bff3e68ad1fd394cd9f95dda9e52c5202b4ce09d60e243ebd0c554de3ba97f3e3b8cc07eaca900df1c55c3605f935cf2d364ca93018bec6a627bbb02fe997a052a0e121fbc8e1f29768c71b3af0b3a290fca5f0c8f5c184ab108885692e799feb3e22380851b0e9d2a499618b5b78db9970c50ca9107eddb070e68b3283d62ef2471ca503e69476734f66c04a82fe8925c1d1a2feeb406dcc7195c699f43ebb801e2903bc923f95df2771fff276b6fffe1be93451e3806d617d2ac23385a1eb5d66cb1b69324a84f4c65ea5bcf5c61aa8a2f582451d3dfabba1a3461100fa49906d54fd704468caec09b83502b34ce1de5951c49174b30f27e3c761747039ab44fb11662ec1cb30b5747f50ae15c166609e92eb4b20eb6d2e7738660ea0f723c925bc8a83da9348ae9c8661c695120cbe2a9f5d8329ab8e646707718d546bde810165d6ff50bf3e4ff7551b9102762c6c7e2dde2f65c169a1a7c3228ee1c192ee6c8213a594971ca37847ecbae9b2be1cea3addfb8bbe390d4762c35f9394092ae8ad69620b41731927e5e102a9d4a25d69f10aa6ee6e9e1bca352969211f68ef0f81918e0a51cd7327c8d987669009b52e8e107c84e655de8d6312e485e37f254707f80b87fec92851a16e40a5e7af60f63d403de94601e16946029f44c1a884632d8c4e23b0919e81e91b46cf36f4384c8e4fe4f6e18d0b4a76b7d146f031d22fc76252c5cc65aa50011a99defb9801d4569aa514725a2b951973f4aab2378df2d09ddbf4af8096eb33e4c2138e2f4ed62e6d853e91e9685d153f780a0455d7d90d550813cd2984b217c0fa980e6445906813603034ee2101f49876bd1c206e8b39de377902d1dd6b747bfa93c77b7ef2ece6881654cfaef4b99bd6631af030a33330d9ae01ce1901b6dc6336aea2769cbbf59980b38aa1d9e37505ea7714561b02a475312817abb21e6a1b0736d0e3ba6b3bf6fc94a7cc599adb36b9b25f3122be28fa8f6e2a808393c7e66aad9a42f049a4b7fc89f610bab6f8ec5348c54aa6d6d52502176709dffc65a55746309003c56138183819070062eda107f9121208f57d61d33a7fd01b8e4951dcaa5792ed83a37a06a21b23b081f1978329b1748e8c77eda134f33ee9b989bfd0c67e090ce2e40aefc8fedee3ec14ef90ab1047d8498b03f9fffedf81edb995c3b0718ce15e65e2ccd3fb1d0652b738e69826a700810ad6f7cc3972b70f12eb370824a144e5679cf1753ddca73f515288239efc25ee36ba577dd96ab7468c69f6a9fd90b76854b8c757f90e04070ddea887b4a75e915673483e9f959b4be5ceb1a373a2c49352d9c408d52da75f2f95cc73bbad1120be5c071b0d7a229088169da080517b4813de895083001021c2f4d77414ee170117af35dc03b261c4824a29129ebc9b091dbdd1f7868a681c62991ddf17f19538ec3a5a061d9d8c03d820747b662e3626afe966d12cdd6bb2490fca00e14ee3222a37b0f95726c700a09788d5c804eb037912ecf764ce12357746955a0d6ac488b9be5884c46f1c7ca7fb5938b22973c5f7c5dc14e5a19b57a0e51656b64adb5813fb8134a4dd929536dc7cdd5e998b69688231d6eb8e692514d5190e0123188d67e59d4c907a7e7cfe0b6c46c9d2ec3aa913dab6447db5e2cb83fc8ca837041c87a0d2b2060795823d6ffb5a56dc1a63efd53f68b73bb517e2a74b8bd3b1eb647207e9740daa7c324593040e6c481bed02c883d770cd94416bb780e0b2212f0db2667a2a95b20e16af8e334a104a236c0cef937892f591f5c1d459ab134bc17565fa7eee8c389f2b2dab0362e602e53663d1ae7326da7085e12fcf5279e8a31bbaebf2a0e6148536fedc76305e3654b88ab3e71476cadce9e0676f1b82410bad8ca3d7ada770d3c44ada9b9f017f11e30e494404d96808331c1b51a276ad8148f98120ab43ff1960537ad94023e47ba2143c837d96a16b5013498c8728939a6b7dcde9fc73cdda87c4ff03ca0f0390c6fc0764384e21d9c57af85136b550b0541ef53b07741bb5d62ab8ec1ebdfe3f90065d46ba2d7037b26f7dc245ebe0c2bad72afddd3b73e48cae79da710bf4d9ed79111a970355a747ecdf1f8a95d5aff521afb4a0a845c1a2742c80e2a428aa3b6d2c827dd08bc14a2d67f4c5117991b2180e6640db677f4443e75c83a6f17dba9561430ab84590afc79cf6b2829ccd1294a94c7a90e91c2ec5353362391202b6e7bd312b4f2eaafc5060aa7e87706d52cf55ec99d600cd27e7ea9513b088f60e291d6f6780b4e390f585167e1110cd77412215c61a19fef057c38794c5eb05f53abb9cd30cbdc77f04cf3eb2ebc52bed6cead8168ccb86015af9d5a7b6693b9b2b173196d9162196c805618f4943d8eccd4c25217c4bea5d69b8e1f9e596d9ab1abe38776b563d478d4204769e4258573dae7c473f2f67fd7174ad908886b112d0bc8d54fd2e4e89b891adf15d2ce35300c1cd6944a2e954f006453cc72c50a39de040af7c8e639f53fcdcc60e8706fa37034d7b564beee41211ce6d567ed2673db548140d5fb3f826ad846af366f9f77e282555c678e694b4cf18a262482a316bccb919c814f2be20f76e21b05bce9440de58be2e04893ebc795ce4c16fa669a5c495052385dc88139c7750a44251d792d91928271b34fa38358888b1eaf559eabd3ec8e0d36e811929313de17cbbf0cf73e3ab380b5a669dea54fcfa2c401014d693ee71b45b041df931e6e2d7cd402e071d55d5a64705e6102ef4e1f5f19ceaf5a17446b5de68b5b457606f038d6aa71dbbb01b54b236262f87f980374d20c9b73b890e4558a609afac15dbd40c04732b041a0520445603436fc457233dd38bfdbeb356db4d5f5bd2e5f0d3a00800aa9047a85f316077180004dfd5d739b7142f1a60104946567b87d71c6a3174044f67739f9485da0708f3c732e0d9489f16a25fd3ad70264b580046dcdc4f5aab6b9b4d743a4fa6b15fd20abfd22f14724afa79eb5dab1d9fcce85726b893522ede8e0484e0434ebd7daadf50da6f4909d58361caf933d3feb1f15360f285b89ef6ded3e2a59181d9644c88ef1ee0965f87d5c1b73942aadaba8469cac126c179cc81447f1e781cb547fa4622ccdd61b08f1ad07e2654ddefcd94db84617925b227be54faadb356e105020579a5fd66d351fb0b41ec9289adb213aa3d602a6d9f21d8db6278bbd8e8c08c38197964d436b77774233a6828457cae981a2e438d5372dff6e58e519383199cfe566b1ae9729ba555b3fe316a96540c3a8b155cf3d3d97939277b3f19b9204d75da31a048ecd9941608d0c419a0c562d27c24aaa7f1f3e320062c5584b226591cd90f66a0ee395b63a4488c0b1d59ab1a396ab1f9e84ce2dae41a6bd42a39da4df6362e041049472fb907085e979655f7d00ccb240ec4614d2de56376c050f33868af953a20beff3f570e8b1d4c34a1d8de5c8a8c8145e11d632720cb73de35b29112a02dd9ee4f19413325afa17d24c4679836ed5390ad71706a64f838d068dec4a5ea7e311afc9a46469e831d7a90e06ff8d2223359ef29b722037a8e282618ffd3fe0f3aefe0b98958887b083a4f0a35e616c2f323c54b6d64e7db4417b477e62d9e2c413b9a26411c0b5ca06229ddcf8f980a3b4d651a57df33c2cbf6c203a830d242829b521644aa33638799a34d3cfdeb9d50bb1fa4991cbc90b2321bdf6632b4dcb8df20de649a84f99e644388fb99f085ad2bbb88fd4ae0d67b6ce9ba2f0d9dca83a5a4905cd3e6b9eb3e01ad9af57a862fbf814ef0256b4891ce695c4946e1f680c7fc22159d483b5b97b2f4d53a3fb6148834abac9e3b42c43786e44379a0a94173c323b48fe215dd6bbf62ae627b18c96495391aa945451331a4e890340f9716fcb6d9d071db3f345a23d0b1e11ef883c43d7e5c31c7b92e86209fc15224b3eab65fdbfafb1f1b84e1c85755c6421be0494e86f97b3e2e672e60c39f54130723ddb8fa891a0e88aaf3d1749543a9f94ead80be76c9db40a3daabc333c516fdb41399ab126c7787723909819211d25d40d2ec3d3ddc42915ec26461aa8f8f25080e992497d934b1a4511d62a73e01185ea3f208ccc24bc04c7121305a772bf87cff1202f9e940b2fa318e2bcd290b329bfd78cc4df34bd207d00b78628c46665cd37b0667d9b04e5db7f710afa654da0d3a8ab650a5340e9641442e97055a80d3c3225cdc6eef7d89768a8241bed75d68ea415cdbec00279d54985e81a461a3e3300b296fce8a8346eb931d61deae40e923b8013bcecc4709e45952c169d667bac13d80c0bdf458b282f506abc6a7586da9f7ce5c80d50d6d45d9073e8d81936bfdcc8b9f7fdfdf9c04f8bafe16b5ab0c9cf230afecfccc7b0d749ceee288593ab4d5d7c9ccfc7c5f1d8e171e6c13aa832ad3c1c0eebbdde5e0e3369caecf2f3d6e455377c5f02a9af4e972fab2134e32dcc5cad5db05848c1771710c1315742e9df8d870ce76327a75e3cf2d836046e1fd33de3c960ee90b96a59aff16a2a6c827988fe9313f27733d8ce7854828c425b37144feb4f8d1c3874301774234be13275ad0c5fe406b9c3188f20f34a2d8e68de2e817a321220b1bcbc56edf364a0cf28903fc6cc73a7204444466db79dc4a188dbf413763d93e72b9d52f3f80b07a9ce7c18838ebf213ac31322af60b9f1c508e7ab95c9dd66ba0a77296777c7361d8aca70a033080ad9bdcc67e73d4b0f31e31ee0b153205c57f4580cd6c13ac17016d245ba5ed73fc46a311cadc744e5bd4145f628a389831ecd73ba5a17a3e1bfa245aa970b330d2e560cbf1387b6b16fb8b499553ea78e365771a2c75c61c27a9bc9889fa23fd6793b40c625d6d6cf29197a22ddffa332cf2b4f8de2e95bc549134308e7f24c14ad64d31fb04123a9900ebdb0308da1ec0e98d3810ed39c92d73d73d605d826679751d70895e29b878de841a53277d05a30ee01331238d5f409d3edfd7b1409c9b64d886c397200ecad64f874d63044f8fc1f6b6d20df73094beb2960844e2f24da51f5d91c5ae15ab25fc20f7c4a2da6e3e51b153983195bfd29732c78248134018cf2f5c0fe387f4b97c92048ea625fbc3a3422b124a1754ffd8704e1bea53198dc2ff234985548b9780e66bf0bafa74de894bccaa39ba241d9fc73a11019df8ad4d5e0ad57c3b4e07b70f72e2d17bb4c56abe2f4a99dceca2c428e0d0ad42ebe88e7131a6fa0e6f7f2f2cb3e77ebc7d6b8c50c18f6d10036542717b98b6432a5aaaaf33856ab363c6865fe870dd771a6e071ba431c688f04fa3dc6697473bcc6cc3422b79223c38f4a1860d7ae7ed30c5955b5f81ecc6b21948b066669c7de32427f8ad5536d6d7bc2a3b713e679df79924f590ea4eb088b680f1d917ddaa68f1cbb65c3b0078c6b3b7a20eaae5e2e03941012729da6f96151594fe9f76c4e409217ddc6103bfc6fda4c3300ff3d0ff481018e95eb6d95b158b12b67773d709cb8b39862f98ff5d82267f725f2b19c7b0d333f1ba3f86dab9a1affe35a3c168b1e2cd5d521b3ebdb200dce43c58e462054e39a678c1353e7ba4383c083a34c4e89d39fe789a6a0d2de111bb97c16ff61bc6390d2da9ec3500c62984bf68a2471a100c51c83ae2e9646b2d49b937f7fce52a753318df2dd5cb17e9a82a123f8c31acc945a56ee95e7e70511f1217fcc5aa5e0fb27df42bb3a0243e7bb15e42b75ccce041d0848ea8d779aafcebf823aff3fa70c7525ad59c5a9cdce94a211cfe9bf53c168ab1e028ddf51e0b3b81d088f42ee94c243ce461971b8a7613c9805849bcf4c2f78121b6e3a230b0e0403b7864c87cd4102519d90052ca39a684ff6cea2c679a6f596ca2bc01fa44eb5b83917615b5200a60c72da3626c312b9948df2c902740c42e551dce7e55f8cfc47d301b8c4e64902a5a3959fa7be873479ec2a85f2994bf9b416a213f6cfa327ec435dcab7919192830f5394ad8937d358f2a52d4e843d0aa0e747ba2b8e1a33363a5093e558cf48c7217d4c9280a0a5e71abcebc54565ebf5e1e9d982b6a42258bb18d22085fa5d6aec03e5abd549c8de4e8ad16b88add733c44fa108ad85f5de19c675b2fbd7347fccfc86386ba036a59e32a29162f5e73679a5135402b9b4a65a3082e6d14abb3e4892f804a39e5184dc61afe8689daed361532c7944a65b15c0a03894e3657583f77561c54c1dcd6448e6de67bf762c0f2e5c3ea440f4d83f8c8c99ad6b206a6de44b43a9d2adccd312f530031fcdc7db01ed0fcbb03b42f096e84e0afe0dd68b88a7356d06d1699fe3fc57b16d00a082ecfccfdacc6b5bd003536db77d56fa66561465c39113902093c815418ca8f78d419baa7a20dcf38683360368698f555225bca9fc1980f6ee81056452f67b4755fc5e25fd8ef0df5e5055aedaae5046ab13221a24e130c19effc1e9e1560e724ca18544ce846d3a35e5b629a6ac79cc5619ad3c978084326bf31893423b5dd1dd8b73690cdd3b3a30a8f8d7f14aef4fe9ea4ac857b0a4a6b12c0866cc89be39ebe016308a9dcdb818dad630d0b95afdb71bd74f5ffa652f2a1e097ab31b07d69f69ddd62d9ea03f745336d4214530f7049ca4be4bc2f6999fa14523a3f17416ac5e7c958619e7994b86ef72e1a86c50abba0363647506928f7449112ce9be5ab7f26d89a0b444e3b8e0331a4848215c9d997aee2d61ddf593a6ea6f0bf5ad26824e22bbcc07832a5612d99196ee039c8648fafba562505a769787690d5cd8866e4e8130099c7fdd16cfc0f6132edd80fa1f979eef4c114917e5efccc077b417a3664532ceb0ddbc870246b6e4fd5a8db82ec7e1280f6a45dd360e0257f354148190112b835aaa112349a790310765374bbe42a098fa856bbb6cc1695b127864af8c9dcbd1aa174d2122000758928892304168e3d6b56778c470e9b3c8b2aae9b4c255f2fcf625797f516c45fbf6291d88c5349143504a52acd83a855116ce7770166c17dac8527aa7bf4a7d8475188dede423c8d468a666adce718b6b0ccb2580bbb60c5f16d28c6f022c2e22d7fafdd9066a3d0489ca2ed7caab72f7d72db085b3a3a5c7f3311165732597a1b52e1951169ec17cb4e314b34a0176cb8a5ecec0b9b3e1302c206a94df27dfe99563018d3fa8334d74de33b053913bec64646f67350bdec3aa4119a3dfd3ba54c3aa69ae0d3e13cb30f577765a8b73df6f9d0d4081fa3a5f61c5de905014746f4a31d133e8fecd2044c9916ada3e173b7c298c1516ee9f4c754773ac21f2833aecbea2ac39fcaf5591e1598f148fb9481a8259023fb844301c207a5fb113a911c58e63a389e46eb9d4d1a71d6b8e59413a2e23528f8dc04846b5204c2d5d9863c9b860fdfdd70b3c4159a418a5615ceb369570e49d87d0d1b74515481a94fad63f4f3a4166ae323ec79e122e285278d97e707fce13a1e9414e95f570d635d8fe9e8abb04f1441625bdbfc7444f3065d8de12d313747e57742a247a066182d646717bc5b95e31faadc1a6152095e5b2b6efeb2d2c6a98390cc69bb4bb15354c6849447d1b9363f9e22935e0684dfe3300d8e4b4aba43bc406fda64d561882c17a8dcf1008b3c30f0048f344a5cd2b6d9b1457d7dcf563152dce5f3de99b6ed0d3425d65a104c13457ac0547c8a8c2f5247d001c7c21f2815513c19a98bb10eaa0199eac5cac704363cfaf59e81ffaa67993efc9b0e18ff764d5cc4d94e71cd530dd3c62afce8f7136f79b56ca41f457e646de824fd1c55829e37f4847fce2c5e4c528c02303b0de00819830b3deb7d967710bfd5b8bc6311d72cf5ee4074a3bfd3aa009a0111794881ffc6a6bf57646bbd125014117d118a3a68af43df655c520b53ef8527160262e3882b375adbac7c0e19a0f654db79088faa33440d246d09fcebc38a44fcced673c69f0905091f25a2fb87e54b7ca18e90121e8161071f2fe3137c194426887232eaa01f6ee5b7f0f9f1870fc518f403f9ea7318a84d6624a5bf55dfda8d0fd02caeb7aec796e199c7c7804a8d2ecfcbf13b84af6b8c5669a2a5508e4960108310a84e0b9e315e2dcb039798571c2cecd77e5e889e75eb914eb8b5ebf2838ea7b6a0c601847d00dccff1ee8b335b632b37701bfe34dac45e69632fe0d79c9d6cfebcf87b543cf582c19f930eb3cde4dcf426fb384a4caf850b4ff821883d70b250e0d53dee364117f2e8bf726b79d58227b8ade5e49992e4385fdc8ec63920fff00c7558bc803981e880e11f17772410dfd341a465b6f85d42fb1adf2bd475290656be5eee3ef116bc1e4e44959b2a9c062e9033eb7eaf765421179c5fc54356bcbce3b429ea86b8ef7b27036ff9c1acb38547aea8220d1e759043d376df29e5731239bfb966d18677c8f00f80f01cccfb15c3264e96e17f2e65e5ec9e9297ff91d915ef7cdcbea88a5dbd5497f565c12c4048e191d43303656d95ea873370ce918526336168107e74cbb39f729535334591c4778d9f9044cd899b8ac3c2d2dd2424a6949c025f6f7d84de85fbaa937a3bde685e4b8b9b0e09c7ab2f6928c0834a75fb33fc131775659df3819a7710a456c1b51d25a3ba5e18d455c990f2ddd7f7fba3bdbf185fa378414a0014adfbe0d4583fa18f74ae431c094af5198136702155227eae8c94cfc8ef980e687cc727adb203c3ccc4a256aab3985ff6638cfc5fc04fdc780663671e12467183b739d462833509940fd06174cd6fc6e88a6c2687d09cd2fa5c0a89b8dea37dfe96f68c0d9fd4e19259756880f423fc7ac290cf952c10181938b1187f6524fd52b7104a2cb27c7fb8074a6437f513ed94cce6cddc9d93b55fabd34e407080906e51255904ebaa7c1aa3768df2e4bb4806f35d803a9e4d6a5661981aec71b0a5d3dda156344e9e8f7371e3ad391b96099ecb6bcb50370d1e3ecac1b890669f580269f53a0cc16cda34dc5f44a011eaf201f2616f25eeb45ac33f8ca3871ec8cbb864ff4ce31318061df4aaf604938ac76f68ea4fd4819b2817b15f6580c2b4fd0d41f511b838b665a5d31f09407565ad07e4fe3a41fee3383a5d3fa28c424f036553504a0a8009adf02efea16e0add558781ef78a0e0519f572bb4b41fc39dbe52f5ffa04880b03633d267ac98d63ef2f0bf84941c59cfe82dd42fa8b8f292350b9b553122014df20b5f0df2d444c43825fe496a964b72a3cd6ec8b9776f0d32f73be8def4ca9690effbb174aca8e4b3f77333c78f95b1d7ae4d25e850b001fd7f58c31a1f029156098c4617834771cc83302586a2336178418c6390965c28db9d44cb0f775e1525ae9a3bbc5b3c2e3d818b969836b8d27a76032792061d9d1841d01958b2c67a188a6ea9b3bd6db7395131eded43480631f0aa167e74f152dca767564054582c092f63aff57fc0ef964b38119b9f07fb52617bb305feaf848e04c07b604bdc6490c69f16f65a483ba1d354bb8422810f29c75f57d58b4f8bedee707d227235677c96c79b9cea4463cfc540fd8cd777c716529b527baa6f80d55fdc8def68f8ebfe400a8880c910064aa40ebe09569dc45b6085557c9e75092355615d7728ce2be9ce3640eee79d40c7fd846cbdaa884273c96f6febe3827d3472db918c1636d2d72875f177c2f44139c04bbe1ecaa7f79ebf08478e8e0a293f46e815dc9ea11dc88e947b82abc2ba9fc090ea857c7515477aa7f72424c63927e89a5a6ec38c7e26bd6590fbefae6aff67b8df8281da6bbb62f73ffaa748b41a1c937571a712d451a163be683e899e2b5d110b3d30d81d01635cd0670cf36777abd951383ff99793a4e6cec543d1cd2e4d9b30f0ba6aa4f87d81a3ddee1e1faabac702670182f0ee2bbd0d0cb7a4d20112f0e268504473a87034ad6f3cacb719dbe4c3a38d09f544587eb833cb0967ed03473505f02704bafd15fc37e7420fd64c6cb1ab7d2a31c653cb5ea28f4a90b92d0e46d225412ec718e97087c5a31cf7186d4ff58f674d902a52396ee1ed3e585e75a7dbd9e207f67508578015dd22a63d0eb51c48bf2ae7d6e2e37d3d53a507258f59a5e95f2240b8b0b9ad79a774d02af07a8d33acdbaa83a995b94e31658fe13a37fbcf813b9936ccf30dfe4f9ad5a99d3d2dfa5d682bcf71cd7fb13991b6a5f34d0d9fab6f601ccc0233c8b84ac39d135ebf6115da6149b57ccc572c976d55765cdea829f7de6437e7335728ef9b2e3ba898ff1bef12bd75cfe0f47a3734d09d1b2b32e9433c671a610ca793839d0b366ddb3d62abeb51e71521e6f66f8063701b817c69eaeac2ca610b0075524e56fd4432cbb768ef5b92c8f2faf93e3fed4e0034bf3bdb0ed44a20b711196c43fa9b38d5a83c22040a6c258f994c1187abb0027a9f13601cfd110cab4d69892facb1ce856a8a78e0608d31e1b25f86c7466138d19bfd05693c92e7a72040f2636082cbe57f1765361b47e70f65dd2c8fea11b87ef3024a9c9ac164d386fa08283a0822f0c740ced6e9bb431d2a0a08dbbf07d9a0a123c155f3257afbbb6e3c84105b08c5bda28ec9ea8be6bd645e4e0d2904cec3309f9edde547feef823c4fb857f32f84285b48955079ea8264960f1fd630bbfff12643cd4829b31419285dd7587c3a38e5198ede8e0977da4e3b2abf457dc315cf00f69b63efe9d9d5143036b3c59c83b12a390ca31fdb8c1fabc91b02ef1b9c46c47c47a8647e4a302dff9fd8b71b2bd1e44c94ead7fbeb579d668ed229d0854f4edcd01ad54e421c9d9ff9eeaf992e4feb5c467356e81fe96095d23dad01fdd0c3fee313b92beb8e619ff6f8db93b0d343ec776b9866302027c55691b7c7f02785c8b44ee209890f7ad8173c37ea0e5327d05ab426e99783aba7100a28405237d09fee686edfa19b86ff585ccb31d60fa7499f0ec0eaf1baba36d7fa281bbb4a135322995fc9d848a77427a5d4d2028cdf2967980355ded1f5ba77233f411d33c012d973a537db9f1697a311bd9e044053aee35240f6ffdaf74fe554d143f1f49bfc371ed2be2d869fbc28c1d4274976ae620de6bbaabd1d4ba2583a8b447d0286f20b671edb987aed74cf7e274aa89d3f1dd9817bac7f0bfa178a04b55fb072402e7fef03defdb1a78edab77645d8c194305d752dee6b22b012c21c3045957addadc0d9462bfb8da0cd6033fa6021c232d88109c122c71409f696ac7c3bdd4ec7b1618ce2eb8f7b05aeb03f7a4e782bcfd9e561cd248077c07765100e1c1cda5649bb6e32e7dbc8e687d741d00b7e19da6c7b30318dde3953ab1547e261cc0a232269ce0cfbe60cb41c3e400449ce769fe2aace58c4b04c87b93371a26b137c38bf1d9850685af50c1890f16d010cac158b1e97798839a4dc36258ce65c68cb7d2bd9021d50057f5332c01c36d6745ac4572e7946d9924ed0ee56bce261c090b1b89ce663874fbc1ba7f180aff61f8a30af03da4982eb7c90a9cde90dab6d1cb1a567c215d7a6b1512bea4e280c98102059771768c9970d78975ac6bc94bf5063daeaf4ce02b9d2c5c1ae48f403dba6d29d9a7cfda625a3d4032a42f45cc8043295fed21273ef3091184f3a5fc4edef2c5594d10fcb93666a46954d360f37120902c1b95ff9be7fb8736fbcf394fdeb26c6bc177a37a1986440012ff61b4f0d6cfd1d7949578efc86db89369a7e4360f06e75362a058d41fa1625da40692d1392d0889abf618bbdef93ddae13ff6544ceebcef51e58b4d01afd6b0f32e836e450f4a77e73752743087020ef6a8186e32630a740e91dd5ca2ca93e09abe795fdc8537417a28ca172ae03987ead3d5b9f4df6678e8f3271b9c00f949c50f97486f791b7dd55e8926b4dc2e839895058bdbf83de9e51996388217a2c4441a0ae91c411619457f06bd1f110214d6f309a7755809a9d38802ab9235a788aeb0711fe5ed15815aab3eaaf504c0a2cdd9d2c14184e936c34e8580bea4a2868d286b27e02ed841c3002067d0405114e63650eb4b44b77efc7f8d798cb471a4434414f26b0e84b393730307ecf8b590f3b22ac2dca6047f626861c2f98e7212616832490ffb39c7a7ee9354c2f93e891dc0bfe2bb67e7cfadf111513c688467f42887d58c9ef2545d70a87ef2677c61ab8b5d93f3fe91853b437766b2545e7c18b0bd01c652e92b7754f766f0f1c766755c4f71daee79fa55d7008fc4f5fded70486b5f64ac6b706b5eb71f2c71dcc482775f4c6ca9759ba40093d18486838b5c1f47d4d8cc09a73b09e13ef3b446e1c138b824bb6e4d0a449ecd592fbd4fde316ea1de902cfdbaceeaad6e90f8e52508e276f303c2bb67d6d2d65c509b56e207b8f975bfdee3a8abb2287338d62f4f5eee4d8a76a398136e39b49b92deaf5ea05cf107afdb552ee896a5578793ba94473e529eac7515a595aa43bc9742bf337805c36c56ba05c05d35f296c5e967ea4d865c82277565a1fac917544c703a8fc376c0b9e6079e103726c9bfae71d903a7565ff6af6b8af8821c89b7bee4c9754833b6cfda36dbd5db32399dce387cfb4ac7f7d1e32e4191d09c97065d5051b8ee3ed5f46a3dc9c9c787035282bebf795e420337d7adfecbb7d314fd9b1e1752e23d816aadd92797fd5bd9ae32bde425058c07aa8b658bc2a5d82eb4bab9d676ef50c8642a8b8e838beeab0d725bf786d4259c0e72ca1f2ff3f956b329ca362fb75802b6cc304636b58d7bcf6c9644cb81b7183749fc85a4abaa5ea254698f31b9e25a1bbb46a801954d4bc6d6525d68bcbc8e48fbe467f3eda388126335458cce853cfb368d77faa34f85a22e27879c1ddab29690dcbbb120fc7c58ec94d281dcc5738e1cc79fce43601942cc167852a229b8fadcd515df51789a5055d4005d5d756cd7ebf06f24f21438f2c7a1a15f00599addcbbfe60e8d150efdd56a7c4bdfa3dae6351101d9c9f13f3852dd511b0b76450959ff0cca2ebb0a1380501236089dc270c18884d3a82f4c439a2227f0f22523cc824a6a85bb22d4ef92c5ebb0822e1cad2fcf9fbbb34821fec54faa1fc3b9182bffd29aa247b2fa181870c4630d3456d1b728b4e2c21be8bb3d756140846c9d6a3491e7f6eaed55913a4f9463f60e781feb9e9df64eed5177e9e9e18cc42e10cdea717990b22dc58805b2479c874230faaf73849af64171cb8db2feacb56b16fab1a9bfaec8174332c6153a1540cf2e8c2ba003887037a64b67821c6836afb5ae461a4acbff725ca0a094513f964fd32b7fea8a4ab0222177787ac9beaac850428a37c6e807b22538da3e6af50e602347a26bf30d9b13dbeb6499680694983e53414354116e2b222087a35a845d8ff0f064f8b4905310fbeea934ad010f0ff405419839c9eaa504ace1dc86ead353a94b2f85c50b6cf933a88624ed2564a0d0c6a12133a4769213f5567173c7bf46c4c429c8e913130d640ce43dadc27291ebfa4fc840fb1bec27edd247895da452b70bf5689ab03188e42d7ff7a03707f724fa32182d0e91a80a8f01765ca60f109f1e1f7100b9c9c2cd3e77f7e7efbf17bde88aca2e296fd70b1c276193bc65a16341f51a9a5b6356ea493cb2e5dd3874b13bd925749fb824c8c9feb6950e702661e0ea369e09cb22cc903138c611e969dc393f46e82ceb8e0e62ced651eeca72807014b2d15785dc5be726d69320ae72d6474de0704ed1213da885cd42b0d47c8ffc61eec9fee2833f20e3acc2b2816850990c17e2786a084ccdec047195536e395fccd47c102b5ffa8d32ff98f4e5a31c62325cb45d6a3594baa7a0911c6f525c42c43f4a8e26c5bc62a7a729ed0e3ec02e8a6a8f3d556993832e1dcd9fc933d7d2180e52c9d9f4c7003d6b670767fb7fa329c52b7e644e5d0f2a85e33922e3dae8bbe14d6806bf21ad367f32326ac915f39879b8fbaf2c96c66007df0dde9ffe328960ae9cecdc7966977ece4bcf8f6098ca88beec67528c9368481d3f88d2440a9b50143a2a186426c03d4aafcd32cc74fb251865292946194dc761679e5be5bf6ce85d9c9980303fb63f7e907119d1f8ca791ba32c430cc16145fce7b5916da39ac5fd4ec2235495ddc456bbb3b1b5bb95e068ff96420aee656cc59f7a64db7ddfc8783abac6415372a84b4640f486c0ab3b0f909e5f8103ea712c279f7f95044b5dba4a16f4310c1621e581732bbf80a14b5bf7d29d7e4965d15ea0ed2a3feaea71ba253f99b95d79d593b497fc5e40a347f16647a37c3d02cb95773a24e81f298530aa60cbef009b19a33bb970fc2ee8890bc2ecda63f0c9826d9365278a3410fa6f637977799c918a78b214502b4acc2d8c3c3a91469398dc704fd03aac8836a82ca88e235d21600c5cc9623645f1fb3812d9d9f9d12dc03641fcaf148cf3d8944e0ce0b59ed4f776a4e8b387398f86be3341753c2792119a4ebb9a23bb8eec39c40a8e2002002737f539e6327eadbc75aafcdf914e922f737ad18f752ec8f07f44d95670612d5e6900338548cd7176dd6fdfeec040a84c9ce076bc61176c024624fdffaefd74d36e467f39592715cf38f4967398dc4dd1af4946d09a2c88abb9c4452057dc5d753ee1e3098fb9a8ac6e316550342d7fe28d4253749bc06489eca03f9274e25c1e19b975d0b3a6450b8ab657247cd07fb66c97ff1f455fa029f318a77485137e34de5a523ebbdf4d25dde61ea35eefc8d8f0727b8d2406f7a8f06e332184d5950b8011b3d9f84a34ab02905dbee6ea55892251869c84fd17a8c36b3f36153775aa0d59ad365c5317124aa8e11c82e48a6fe7d7e56a288c6987eccea80299e2fcbdf6678fdf02a7359e60339296a22e29da1a1d26ff7f159a8e81f2c96421d9c8fcfbb20294c554c44d871b3cc5ec2140c7c1cacece97eefe5fda85f85187df8b08263419f215ca30e0bf9e933cd2fb8e945ed3c1d315514fb1a8e4f7278cbc85c454f2b662d5649fbf757b8c2c33390307c67445a41bfc2e54e5e5160302aee7ed2ee5f85ff63ef4a2987a5bf795d825735d6b08c7411523a059101b17a75e724f2c4d4129e0e89ef3769fa1bde546a06acea266b83c60199b0c49acfa6d99a7a543ae21f91819e35f3d9c9cad91d3b09b3dd9378e6a2274c3a5adcdd9b849e87b203441b174a704b9b37b553b7ec1a5102cacdad31f5b552b164dab6dad87d6857b9d309a89b94e5f29cfb5461bda2fc08c7aef8c96babf998cb1a9c70f5163f7629a6366f13c842e3a55d89d6d538d8e2679d68fb6677c0fc5894dcfad2513f25e4a596f12e3344cd44ee34edda1ee59ada9145805351bde818e5e1b8561a2cff034a078d033857fd626ea3aee4f68507d5c4b537e8af0159282ce56aa8f6fc5af49bc3c6a16ef0f223c41c8a4acf0085209f3ceb927ddb4625197c6e7777e288681c2b405a94afc8afc7ccd48a88ee6b71f2a4d2eb3e98acec82333b44d1f455d012505d23d761445b65ddc04f3a114c2fc8dceb6d07c8af61b8e6bd62837edff1a84cbb5dd99b5cece8ddb8a8d8ac7b097ff1d6578771d7055da121354a8e45b5b3f8ec2b5f9922ef644a4ca0d55515d4591b175ab652747abe965af49884c2649f5ec3146ffc0f9fdf6a5abce3810fbe07e22f3e18666ff4d7a05c0bf021fa6cdce8be28ef29215ac9d8c03243aa9d4511e2f7adeae8dc7cba114567cdcf4cdde8150ecd95d191e4e6482c112c6422f06b285ecfd94affa13cd75ffa225292066fe13fd9ec384f0ba611b4f4d8fc42d2a3509d67ff6982fa95dc5aed658f6ad76e51fef38a9f695efcdb207b55a5918988e98a80b63fc45abc144d31a4cfc96c536ff9ab0af7b1a14a1fb8276449073373bd9dc8cdcf3a4982dbadc2e7e8b03ac5c527f0eef9b374e2811073fc8d3319351c7e5c0b2fb8920b811bdf88479654969b4a561c0db4568723096690f0c7e61751f8e0ba5d9b7a0f61fb929605d7337f647cc31a7ab11691970d6edadb506b6989030ebd82566a2e4ac0bc4006aa8b60773888316870856b4dd3bb1c35f3b9d7631834a97d8b350c1d5398682ec13af9a65f9f681da94171a83bc54a80a4420f43fcf79e00c0afa05cb14d926044e671ac9bc21c774caca7509de5c259a3e15750b2e4ddd8dbc0cd6c79c89ea6a1095adc18d6fb550a9f7f41e60bea9c72e4c5c177919816fe860c1aaa4cd525ba6b90019008a4afcb155a974d3958865d3e8715976e9200141ca518faaafd9910ddf8920d2623e348693c6c21d2d80bb7319522303b4da7cecb95cd92cc5f7c8080347376f21c77113838339dda4b638db70bcbbe3a2e38b0b96d0a112964c5b6d6c1c161b13b66be0d00e7881e496d4b2788bda0f7bc83d45c767b685cdedeed6c66f29df4271efbd0311c85fb1dc4c6513829f3c59b57a13c4982225c2053388294a203bb5419b474b45758549f4340eaf4a96193c9bc60a30b830081e02f2c6fec10f5f8ee9dcbd12eb730fb8fc783a8064e10cacccbea52eae7be107476aca2065a61c04218b6e1662d55d9f1afe6e7e73d6dd6b1648a7b8deb805299f4dcceeae86ca5feb0e8620287e270863c579ab7a4364c8178324b2350f56a81307deb2a7ea0e91bd1ae7f2393d15c2762ffad9e66184e2993141d899b33bab27f1637e07f208a95cce9483bf39ac50c6bfd3fdfea84cc0bd02c2e0731475d0b9a469bc09c02858c0c0a529000f647eabb497784ec5b97bd48c3f175904495f6e2d4f5d4195c8911749ec7bda8466aaa441fbc673c7feb08e7f5467cfe586d30a486f4e4a519e3e2e94bb4b4c533397ebddc927ef60ed2fd71f1777fc52700b9dc136e42f2ad886719817cd79874784a23be0f35054eff5521265471c3b5408252a1a617f0464fa860b1047c424a5965e781544a1adb7fe66300cc25f71aebaf77706c19990915f4dcac196717204bda02023a0a7283fdea07563c96f2ce5d409117c56c9d8ab749a920ede5815d3310a1691fba696da5b1a8152ba23769d1550448508d0b1bc378c65711758c610cdc193edf71b5401fbf5c7565680dfb3af28fa98bda9e7e01fc6275b42521164229204d143df78e8f3598666e7d0e8ac093ad4672b86e2a2ef4799b905d8fd6fc61424e986fda2be552352a138df53491ea70007830bba1bdd192614d5cc08b35b3722a4ba32c3f46edebb4127fa539fef0cbcdbcff4722449fcf430f6de87d77dcee09b54528dbdf6b01c4338a926c88cde8bba9f20282f0e7dd214b9ffc0e7366e67a4813461604275921a3f4215d63c13592e61e5ff266354d6a8eaa7e5eeb26239afc9f28caeb7c9ab7730a01a0be43c822906db42356f0c40f3f50800c60584206f76eb2bfbdcf4e93631db83fe63438f086dfb2416c3b26218166a6288557b4c7b7d92af9091cc8ac7310385257e6265c452ed0b63f9d27fa52147023cb5661a0db75b8ec50ace37ab92ac163c8731e04116f596874b3f81561b5507b18abb93462194d8705f627f0f617e073058e2ae72265f227000ad29d7c9bc5526d338067fc710a3d2c1334820fb96e7df9f2a71afd2003ed0952939e05480ff4b38ba7f799b6c5e1451e20513d94a780f440743e5f823b905daa8dfa5127c85022b950e19383e43f465ab5cd337195553a8c048afc270d7773f6ede7ead3fde6c0a391a06d65fa2d16b9f47e92af9d3c4f7c07e9f56e1be36417113316a85635f377d05538755598659723e227c36439f64249accb234d5205b7d486ba2e9e6b8f2e8927b01f00c5037c1ff656375ac3520395e230f3d75d769b7059ad2bb6afdcba73fccfefff974031335276c512c40f6062fa62b82b1b27a6f6d19495ae079f82802da4978d2c083d366bf47a99f5fda55277c8ae0e273dc330e1b19fa704b5a0660e568f1d5095d10dc5a825d29a04a210e596e9e063b93c54a916856b7e6699332d834e817fb062a7c36771cd87fe3281b7c692fbfb42f21945dd15053fa087e3e95e1891f45a01d11edb9ee9a7b007ff3068629edddc90b371722d400598a745fca2bf34d6dee6778b24793c9b693b0550ae2b1005828f6d8eddc30836f75391f0622489399b1ec0219a34e2789d5e4fc116cbcc7088ddc6799b241c7024d01b9830aaf7be6df0f7e678d183f6798f3ad7ece3d37ba9af6a4fdf97fa1708c0a7c42e54e62c1981f4c7c883b49af290e72193124c130ea16dcf41fabf9d80011ca997e875e6af10d75b6ad09559acdfb8b74deb2f6f90a00b0d44a53b7a8ac8d34ded0fcd8bdfb8f49d8a3e1989c059894d7715ca90d0ee6923ed135512d5e52a135ec2b48fa6823005d2e9ca0f01953fc820af02ecaca9cb3b20708038e0be4b180db1116f9c7a7d13c74587e1cf68c83c5ca7d35c67ecf82dea7daf2996622075e46e60f871cef042e2ecde15f8e4b803e714540e1e9e689fc051a61de77a4b23ef79ec5c12c85ff1aef26f73ce5d92d09491ee872a3c06a5bd94ae15afa9bcf092a9d301176787cde8d1638799a229d07bef2d929d1192cbc56c1e102cf0587edfa6d2ca799b249715c7ce2851d6949cf4332cbfc350f0cafb652a9f8c67eded4d474331d2ce581ec1ea63284c44f4ea7fe957c3c61d0b90a222e196883c4fde2d40582d8bffe9f963a09b03385d54f8df2abb339464c8fbc4d9bb7245a2dbbc5fd6e8bebbb6a95ba1597f355db9ab0158d2d59b660bf94fffb87d17d0c2c3b4a6f10a02cc233699a48ab66daf92d109bdf5951608daaf7a17b3ad85f7f22d809bc7a411c2921f212b90106d72f93ef287f86d1b4e1118051582d7966ea53527d5a0a949b722c2080fb11648c3a657b7964b8a6b726243b8498ea88cd892c0d88093122554191d7bbd9ba7e5fbb616d3a6175dab23dc89a8076321e92b6586fa9452b0fd853717c7daff934b8f4f03a621b190e968d5f1bb58bd0a4028e4ec727d34afa339158b88f14e3eafc99a5ce691420bb25bc07c161c18b31a1999bcc8e9bc9e96221e91f6aa0eed5a49e28e38237c8db3e11242498f9e4804bc6e332109bfc875960050d9ee199934e8827c10e99bee0ad3695ebc60869ed741c7633477e0ca87ccde6e9a3168b320bc1d45fa9f1df3b62c787fc1666065c82dc9f10ed8f086448069a374922a4e576b91b5fb650658ded8ed9598dfb358870764a9c5dc0c19b3f16d63f740364b4f6dd9fb3e11dfcf6e569de51d9aabf7adf1ac5606ac017e7750e69adfa4b1a48c6411f34341d56f707e57b86eb3319a59be8b0f97ce1c6cf5960e507a9d7ffb501bf4b1d1692f065d3e3901f453a766b7b0f51073d5ed004eeca135d5f167fa477e320f1b6f1c362ae2adf4be9dda7360c1628dcf005c96c83a41e7cb4238f2ff988ea55232e9c4935ac1c7d7574ebe13365a4cc14d269a6121b695081c32df90ae47c0802830d0b445ce7b3ae9e7dc1c644c4934f4ae7e7ef44e05cca5d20fecc28c227588b371499854cadd6d53948c7dcf477ffa0ba16249e435e04d67f30e5951494d5dc586510f98869b9983c3b17d3911dadb567ade6cb3d2c9628ed81bf69c41887820aedaddf68f22d185a50b94f0580fecca4d452438c85748c45f65f5ca436f5381efc2c30b28a2395f5e183e324f6bf7d6824203189e784ec98dc40f6df2a6ccddbf4a73d7261bcff5252f06da6f69210ebe60149784e6719f50f2b675f4f00cc0c9fe711fdc6bbd4d3a65e31ecb13a2dd763fb924be4c2fc27687227360c525f382f4003d8959085cef99e283ceddbbc9c6d85194084ae454ee3802e8dd712114166b7d1cd10900881866629ccc260f722033f1c5ddd8df3c23cdfe5ae0d8cc29fcf6b8543025645c9ac2a10084f3e844b2a252ad270fbede1678df1171c9f9a22d8e5e1fbc9d51f1300d5bc9b89cc35a38110f78b2f1c8ec8ffec347f8ad4f28cd2f44e46ff85bd12b022c3644826b3ebf3ff102f9c9d8969280f51a525b18784cd7ca3698b7b24fbd099a4ffdba428a8c7815f2397fc3cd484f574b23c94515699d1f5684d4f9374fd8beff888c3eec7faabb7e3b3d58ea0c5f9d21ce7421d057b90138817fe2095625d926787b3e35f93597db1b972cdc48a1d82c1de431d1be0808eee29ba12ec8f30102f38dbdcf0661c9ad3c1089161d07aa5980ecf12e97f0aedd29901414b3de5f231f8cb9c6442e757d6e125521bd5697d8d50d9dfaf4aeebf438ec1117ea602aeaa72f6e89861a3d947fbcab21da4220008192a7b54f672cd7c0d3ae11d6d00ccdc0079f4e916ea28527d78bd3902b7f2b9b0693ef3e3d78d0ea8607f39ef370d26c22b321dd26005fb80112cda13aeca5ede433cea6c715f5303d80e4c2a60589b9d8c5d2db491f8151ae1049b492135a9d47af15040a28ac0792ace36efbc8847e17863775745f839dd2146bb51944b0c09ac5a8b227a82f6dc2ea9b2fc399cf8849d78da39986269a9d6444d310ebe4e37e36d743edeba4ed5214555cc56e1f37a2f7220e7d773dfd279146bd966ba4b300e55f170d2a5d540150c12351bb5dd9feed8971a75babf434629f575cde52b1e72dbee1198de0df95c0f646ccde7ad0d4e9dea37147cd690aa6d618b6f7a84e8b42687394ce392d21f3f77ae1feb2acb6e10c0585fd7dbe0311ae5cf71271942c83adbd899967958a06aebbdb2693ac7b221045df96469df61136e99a9c6e19124fd4293313429cbf09b8138e549a2ef1357eba8014266c80f8d33a028eae461ef213a0665d2f7efdf22fe647fc9970e799df4465024e2d2b6b9a320803254dd1157dbd014792e992dfe460807c304b6493e6b9468b6be3f5b44bad616bb2f242505a41b167933ce834401847723c4dbe45de62e1ab4884f899c9f7e7cca5ccdd9e96d8c448266575b1ce7468b2b7f6d7413f0f2146c8888f63d31df4841f5b0bce00fc7a6c0893d3e8693c61f0964d825559b8b160f3c186e4d98f1cc3d75ccf14155633a88beb16a0da7089bd16bd3def1f08f8a6a7d896b35c1a009345cb5e32e5805ce6fda26b6e074d65d80c4bebc624bb43adf61046680095475048f4e9d9902593fe0b7d711236638c7bb512cefb6c5862aedcf2e647b9416e9f8a75c95833a8722df5f13a2ae81c914bcfa613c98f2c322825b7e365bad4b2fc2710d6d995d44fc71161e61767cacb7fd2f301faea65ce09c6c93b8af3afa3a46c992cd804e21d7873a5df991e6f9815d70a89591e8da6c964917ab9664af17eb89e7b0c51243665046614e02eb4d935cdab4fee4272438420637f1f31188eefd1ea31ec91242953107ce7b15b759e0aceeab3dac7e25ecd664d79878bf87c0879a7fdf7e5f79d1e8db2a73ab69c524a0c2042b9facc91af7c313cf57c3fccd0e5489530a29b84db9f0319f75299b7edddd2bae182afe50ddfed49cac63316a178ea06c7276340a3895ec964dc934f25bc97106f16ce2b401a06bc66748b1947099e409a347bd6182622fc84cfa4ba71f0850d739777b906fda4b4ae9fe7f6c24cb01fcdcdcb774170b4ecab6e748c903b1f82466d6a90bcddc82827be4a16b4ee86f437d431f32fb6388b0296ecea38726143b499c25b27ec57d3d29ea5d4864b1b9a3de245d2a5ae12451c52db2839451d28a83a961402baf954c3bbed7779e7233701f6df44cd7e170656e986a90a224cca6da5b90ca938fec95904d3c454ffd6d5e8e8926c36b38679c2e8d0647f2005663ca585cadfab2bf14d8a83c033f27a01d8ad6a59c1f662bf30b5f28e7ec88e7719b8bc32e93d5b4a2a51533865b2fd64791f48ecd51a1fabaec3da8cebedd80069e2ed8b5e9388742fe045c1effb2cf5ae074b0768fdcf62ec3a8551d2ae4c49b87d90fdebc9239e7612f6ea3663816579eec7c49df49b695d88117b6c596396db6f65fc99cd69097995dd689040a2a680bd44546fa877edb53a1e360cbf8f403991eb2dda5b8be6d9c3f694793a685d4ad1013ff89022525be568dee06bdbf61cdd433932049301161e84fd68e24c632abb9d685dc1a31245703f81bbd325f93c14ba61f8d495b617598dd3da9d0ed19e7c2dcc8fe4a2bf5586b8d2a208ba5329cfd7a27741d8a885098ef05515612d5ea6809be75f6fbeefbab2120b69af5087c487d58b54c40c22ffb87ecad802714f183758dcdaff13ac7394bec07afd41be87ce124f36cf845295ed083f8c64d46f2caae60d5b8bc1ad16ed493b52bd7150ad77505b25e3ec911ec9f12b34c88d3b98414ac31d4a2aef7b262a2995ba752145408ee7978aa4d345fdd4d2c644730009adc32d70ede76431cffa2615622d7b9f905b0418926e3e217c91b456f8bae3d874b84bbc72f1d8ff9e62c6e84950a2383df583df24d33bff89259f906ec11d32779ec533e38185c61afaf6352f0bd61117a2df0f47f78dfcdb798605c0e2fd2f30691a433a3d28a373f7d529b6e06fb953e35be10dac3a90d4c8ad578f471902a678485f92f917ac383987c85ed5390ca8005c08e549bca42d56e4016beefa3b143fc87a47aadbe05429ff07c85d92acf5ee9387fb72103f9076129d53fca0a4da62a3b63068fec5dc01675ed51ba9e04e4ebe6c9ca8e38542bac16201f785aaa20aa695bd2eb9b04b9d3fac96b7d83cba14eeb416230939523692d61ba4a54ee89f601e8f60e80095626ab7e2c4dc258ae86d046ef093796d24c0725354f10bfd4897371cbbdb13dfee42581519b19b2c0dbf0646f406aef4544394ce3dfc4620512319b8a0f538962d0e984507a5b318d493cb01d07a75657ed934aa1098aa2a15f2751af65d0031860ae0c00b50be234e67acbcd9f37d6c90a0dc8740279fe21c20bdd8ca2b673cf9594394b2561b3e27a814b006cb326bf66f56de78b68a379b6bed68a615379e8410862c7754995c88035eb2efb8d6a48f78485fa0bde7925dd405c362503d8791e3a50ef29dbce0632dd5290e1403ff511cc421e3450f74466e78c46cb9e6ee3d7979e24893a1d920ad7ced801a64b6128a05a3149795b1ca30460f51553cfec1a48471e0aacbefd57aac4e751d9972a8179867fb824302dd348fbb617a892598f0ea8324a9100cee67f579ae05d9c263289e2c362ca84e1441c3bb85fae6f3d63794b84b065b25120a8a1dde51a97c584c37f2045ba591b55ab96c3ad841e9163df82dacb6e11d5dfa57651296c023cc988defd60d6c9856d9a85f24a8af837b5552a4ae3ab8786a2c9c0e97079485687505349d3a01e87d485d492043c2fb7a8dbc14f1e4ea197cf8a16db797262ca13637d18bbf29ad51ad20b65cf102e121b295d0d8d80</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Byte Camp 2022 Day3</title>
    <url>/2022/07/13/Byte-Camp-2022-Day3/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="86a5fc73129b21abd36805a79d26d03b90e1ed6400a2d2e67e3f5eb808b9edec">99251fdceb9fe96a1f47814acd3007f00b778d863aad3e0abfc36d48fdfacd95122e113c83609d12ecf472ef04b05614ca06d783adff1a794c57a9b73e6c9f9cc6b662321e6a4375d179476985ba732800d306afccec01c40c33ac933e7d82c721d55c9e887f82801612783cb3ede8e80ca170dd934920f0d8eb7e17734334e0c353ddea0860c7b2b4b9440505729381489eaf2bf99571b996ea9d53a4a9ea54c4513e940c20848104193c2588b7df3bcb920e65eb12a1c51bc3d831f8bc969d13a76de4e34fe95cd8bee2bae655dc0dd7cf9883b5ae8f0434172806239b6ffd57abd8f9aa8bab331ff7f527652dfd77ea131c026fe240a237fd4ccf0dbc10bde500a4ff50f00f07c89db82bd7a66095eb3df3a75af215b8b4071400ce14b3d8d7c61a843e154713e4113e8d9c562eb603de522e88b5886ece2e435a4759a88952b01be9872f77d713d6ebeb451e7b9934e919b9e14fe2b54a1ef0cda1b81d6537bc5decfdad2968a1f120ade2cace42169c3da240ac100b4df3c4db062c039bedb379cd2ddfd5d0431300ddc216c4e1bf67b4ef929c525876647babbce21c9798aad56d0faa83cc84bbc3e0188f15125efda02f699f9b9bb48d971fa8412cb2455df908f505da774524a0d9df3c7b96fa46a5c4e6d3e9ab1653c80a4abddd3f2f3c3879c7e5be7bb304f516c431fc897c9b3a099095fed775444f6b6270908d06d59346d64c67bbcb4258fb40631ea6df4546e443a64c4723a18e29b8d38e2ef77913283f1a0923987da4e301c501303a87cbf451b8419d22c223f4ef9337491791b34d377ad8b59a8a7faf9ae6fc5294e30f8fa1deffba2ed0d16208bbd40b3048ebdf0e0683b9b80c1706e45edc013fb15da89eb8a7adeecdd9b4cfee022df3ce2d0083178de36ba656f50c5c2be5a2a3c285b95eda2a97be052c7cb442ab1a74c3e6a08e2e84c3c7cb655a9af0857cc60995970feab70b10a07ae1274eda00d0ba6123e97f48fac0b3fe0a1c792c8802b453c2f240055b7ec6fa8dbc522ba8b08cd0b6336d948d3cbe0eb26ed6dc5b163ef1a336416b7b5550acc18e9ac7c96520ed2c89c6a2b374b22404435e886dd812068d99697655ce3a0f464d68c31583c45720761eb820bff47b961243e06793e095004f0e06ce388a17588826e2b88cc8cdfe7da4538166e0417a65c212f7e08e69d857b05fd4c8d9c0dead1b393c6cc419a83d7c69e119e806c198f82570c539ea7b8e157808fe38b3b7f77c017758180e65d8d5834311fe8a6bc613c8b1a01a3a639b39efd181d5a228786ae7ca7db9488a34e138d565e1d2cec1bf6a7f6549a9e1faf0d5d24cd20cdef55a83a0585cc8e19326e139be7d8cc07dd55783c4ed3341cfebb36f808c0d8a36a88cdbad6eba7953a45804fe800371acb891fca1291b599c940a1759e76dc06c7d724a13546c5ae54820d9b0eb87dd7667ddea68841a03ae6072f3b576a502ca13c302aebc676a7e1c066e9a39bebf34d9576694baeb48fdfe16df2058f6267f5391b286c8c8ab49ec67ae742ae469c1e1ee25e0e7635422f89b736c532765a3d234b19cc0801b65ed5856dfdfcc5402272f73c0e2a1c45f5576f3a38363072eb477a337481622af15620e2057946aa56f47395bbf721e9b59d1a863710b60bd9cbf0869838834b4c054c22cc9c1ad7b4584f28d401d2df86a57be94ce16a847abd9f9acbc69768e2b6f782cb61eb2975babfc2d2ccb3deac49ad4cf79542e16bf9b5ec8e3852443d5b235b5dfc8214a8f1ec7f7cc51e6c3ca129c69be77e5565ef2d419693856ac212774115a9fc1280cf55f15e8c9c26e3121145c392230b683efa411ee341e8c24fbf144717f9067add900e7a9fccd6a25bc5fad785c51f5f5568d1e687f8e334625cb92c845d7425c2722d76bc3fede600a4d9d5720d243de18f69288a395012569709479f2bd434c08510e114b90e778d316e1fd276ea5b3e4668577c8ec85df1915d780a729d3900faf39b36dbd5746a8ea6ec2c5ee371394fec4c6a5b14105f1b191273e8e6f9f282e5998b639e16f76e9c5dcfc52be17a6a4138b49059947ba68c5ad7b66b199757373c87193fe220cbc3f8546cf2f64da576d043d9d570856777745e6528f40bea05bd13838acacb968a957d60f55441bdee3aec1584b9c00013569cacdcc6ee94a4a82af147fcfe39a50bf320a9762c75bf7f3883273f39e5fe5430597f5aa0baf6483f9758e8686f45b02bad5414c36d3a5cb4133c9e19e8d38bae19cf0fe438430a18cb4956893b976dcbdaa4854a179948f6197533efc0845afd71423692cdc380973726c294daa2c0d91c8a7a3155e19e5eb13f5ba7cc54654ef19ca74e0d12a40f90c6774191fd9a516113ff0eaa2fe6dc4c74f2da3e17eb554de7587677db270c0c4b7b54675181316f27a9328fbc10de9d3bedc94a67028d9833ac0a8aab7065967417a94868a660539ea6edd225341fd622d3d3efaf1ea93bfd394255034b1dea4ae4fe43745361287fc988c423107d9eacef989f4eb956864804a03524882c8155f8db6d7f17b844b30fea03e1524aff41c1552e9c76f73f4a55ab4838f21eb26dd811d1a1f67a1f77f8268d71bf4bde7738e38a41da366db89a6c03200b6238de27d0dee0c0dedab80c885f40ebb754c56c1a56339fdf0912d560a583640d28cbaf1381a81395da2c4b2d4231a64934a72cd57e26282b8c4b59707cff29228ac9ec5d5b249cf069901529a7b9d74dd036769131bac4e4f92c728b4a75d6b3efcae45bb2fb325d9a134ff82dccc83ad4fbf8c734da6dbf348ca9026008e61d8797289c7a892803874e257e039eb8f6bc167fcae623d3fe8d992fcff8094788a55e3301ebe80f509963b75defc9990607d9a69bbd35b3ccc75ef2a43edd30496120ce41561372c37f3ac41d1f014b0298d435e4255d7257be6a2e8dc70249094c306f29581f4d545fa0d5cbd8d41971081e197ed41bd34f2f86460db9da3046f6983c2af11c49791124b9edf29f27c4d9cef7c05b42aa838d862a0ac8a8ed1d2ae4d3beea83fdd97e7169f79b1ce761bd54d3db872f2ff3861785646ac6d4e83dedf51bc64aaa3fdeac149142a055f6ec3f54fbafd9e3f1645b482fb73ae00e3ed194b887fcdaf43653d8c1543728195d21c46277dc9a56b61b1c96e17b6ad8390c4bf2ce37d7d7452f7899959de69dce4ed4e70d0b57657e2186c74ae23dc11e6524ec0f91e6066a717ab484cd16edb2342418405f022ad09fc9a12535545757a8f1b7083cf6ff2395ac47e4ac974e84e8cedcbda3b2dc176d79002f84d96d3c2ce5a7ba40f2dc219f6461f64168ecec1fd36ef1b80213f59d0bdb64cb8936d005a10fc60ec636ec87dfb68bfb1c327fc5460d386ee2cdecee881cfcb41bf707eeff18181694806a500d2d2ee23efcf64a574913b838669560e04421463cd4b5ac53152b7638332848c2d97d862aec4983573cc66b604ad013f35f31ac2c56ab8adf1a5dd74edcc4fa9d0c0c7de9aa7a748cd449a5c2b071f440b7d38509227c4ba387b5e947ff899e2282dec44349c272caf6b5102ccb4d6ab7b603aec105d4859263cdd756a6be54f0a2c9db4d09a18baf8bbb5628ab0d93cba5a4bbeb771ad246f58fc7e641455285f57f0ddc2cb07ce6e5393e6328e6b1fc7bb73117768f07b06cdf1a16dde62e2b3e93b0c6ea927e8636a73583e2c2673948c7b871ecee54ad2c846b38ddf0b070f6905d8811c6759e31a16957d717a070aae482949ffab6d936c6d1ca032c4715a4767b7d77dd2034c7cb319686338c129a4811eb2a7d8274e6495abf3b922cb3b5c530a8d9797998d7bb0efbe6bc096ab0652c847287c0f9ebe73fe389b318591385d203abbc9e457b8fd6ee9d76fec3485cd0ccc4d824e69a894d9a12a020d53a7c1a8d72662e8381ce44709ce9d123e80cff2031448b6b95b06e8bde0f4a44a6e4a49121243787c211b27237b68b2b6fd1eb357ef9e23b5d7ab033a6d9dc30c1b4f9d9b225935fece4c771e152ff2a3c5dd0d44d70c7879218c63260e42527b08a8c72a2e5ea5fe9ad3008d4da295993cb3f52ed29f88d859d5238589d76985b46fd53f2f5ca5af2c2e38bee0d5392b20bf19b6d6bb6d68fa33db14f9672006330b8adf2f3b3e5cc8e046701b1f81c294c7b72e43db3cf57b107b7f845bd44cbebd7f1b9aa90a729fb8b2361457536e1cd41e530d5ce3510c02720f79f492da813ae062baf2202528fbdf3ea91ba6796204f557360b8ec3b9ca15881390ac20880895baedd49767cd10e62ca9c1230442beec2c1a00690c1a33229e526e1e2e6613f47351123a5d8348bfac8b1df1fdc7da5b3f31c5ecaabebed8769a386d44124bc20c3d981e0f99b77b7c50cea5814a128fdbf84c89bb113f67fb4a04474eac461c7e28cf9703146ffaa6d073c683a39e096c761971df7b1b03f750d86095a763764dd3707a39657a0a064a5ab76bf34d5e41296b5cd62c5d370cf6312424ff7b42ac0027a8671513476ed0f20d1e7fd3fd572f5986a5633e24a5406dde4a7a28b07a5b107bfc6a35352241cb5c6f615f4f73676df3f80083417d422d10b4803b96d8037146b71befaaa1618b9bb9dbcc872da2d57b7d44a12cd437b9c3cfe6e9b962fa5a09e21174ae3845eea17c01d27ee0482a4597ed7aa5ee9c5762f92b34882a24337348db198601f679574a29561355569efe211b3a6e79b6396b6863ade39b4de21f0857faa1fd389fd2358b4f06ae79cd48428feef5fbfeda1a9ff9df6f40cdde782b4d51084692beb4dee0bc0b601c432b0e7b6871a7e86c8db58a0e8866e652c89621c831ba68c27a7a70b49bc1c3a75cef49c0d90b9aa893d55fddf9337f07c05489f3e8146166a91b311e97fe6fa1268e1c37dd7fe83e4ae8ebd5b5fc03dded7bb4a6c568e227252e6d5edb5e6ac5c8ef5ab5758d4c7f4b001191cab194673b60735910d854ccaae3a59a6fbe1e176dd8984cc07fdadd2f52b438f2cbd0b5895916c545966ee9bdb63e832fa9d0293898d5620a094cd20dfd9b62cab06b03a24c763d9b032668ce2c90ad6a3004fb205c7a2c7cae487fec21f7977688df83e2dd64f6afe09c0ef00b872465a639a8118fe0e28c8d1a5d2ebf7c19b9f5ca9a1922f4950c1769c252f89b98817f7cbc2151ab5a44b67a250343a14db5651094608572a3fcaca94b65ccf392864ce3db6fe62f7aa921142e1a04248d7249d001188868228ffc32169a9ea18f57b769b09f82b45760574d9add9fdf7645340630cc5497426c96d1698351d072149bf3f37baee1e6d4660fddb2b1cf1ffc988484493a289c4c17553f533e0af095720584c608b0541693dbc8c1c76fda08519a6960e859fd01818e5c41b5b6a7b9b9b23819798573a1b4cb9a26e520940c2653142a2801851cf64a18daf960d27bf3c229b4e35dad4c087e3ae359a33cce9854b4972a7836ddd38717b94578510fe0f6ce978d92611ecbcd4c2170417ab8d1311485e6656de31df09bbdbe8d7adc3c9a6c621948bac54e2608d00248da240df5fa1e545a853e716791951ad949ee44f2e419577a17f6ccb175ce971f178e060d3aa99f9f5e0df0dabacd5a0438e9e7e78932b4749c4259a1a041f0dc0e2b8e8e994224db35dc98cad8b1c84bf65e48c6fcca4aa275ecdaa46a957c27634a50d4766203499f0aefdd77715f5187b58cfbadd224aa0d77a43edb1f42fc5e6ee9881a10923b0a9df70d006a20fad9685ba2320058502abb8351a6af3c0b893fa078c1f9f3522839808bd6b646376bd8138ef6baaaff83b7224db3a59b3a3f636f47c8e6e84ab2a3e0ad49cb396c34587cad88e637c07000bddbccc4db75f3a12aa7ce985cca8eaccc9ae60a2ba7559f280357eddf9b5737b7dde9f9ac56a7c3ec8beeb4ac77a55b7e570e0e8f17ffb76f9a03da8ef7721f86ad94cad9b4c0f95942f6e1c1cbf16f00e2230751bcd7216957f623d755cea554e9eb87c82a5288a8c3ba449466b1c29acb6195ab7bb5d3dc217f2cf825a08759fc1022f631b302f57f9e40bd204a1d0124f190713c56cef9b64ad3f5e7764ed33c5a645a18345e8ddd83a9f5731b2fed3468dc8aa4a94c64c5e65fd8f5d9b966ff2b00a069c50894393456d7907718308bbc75b919d42a96ad812ed35028383c2963f9d84092baf4b117b55af9250b9304a0984f312b36285e29616e738ada145c3e541f22e799f97ff9dcb0b86c0f502f8537610d0aaea90272b5b7e51ba29484dcdc9748726bbc0f99ce746cbe4ea3b6c4e98f5321b6ca96468f61ec79538638bcf6669d869634368be2c28dacd6ee94604c6a67148436aeb30b6c862b5e9f15bc9f6e6f71fbeb61c2740d04fad4ad2986743036b429a6815c4346d2b66f9b5615a76c181743552406230fbc470cbaaafa9e0d09ffd6e829336e5a3da398280527181d8e7f6f1e29a08a46650169f7de43aa61855d85c7bd71e8a7dd119cb7fcc503b1abc5b70b9efe79e22e89fb651f616e72db3acd4b283692db792dab48631927fe7aa05a51d81623808fc96d492d63191c62e299b55b1ef372857d879f6a573d3b92735c8b49f9eae6b3da263ae55aefbe1c8f92e8a90b4937204e1cb4ed7e61d0b737eea07c1a97052564393ee3b80bd4d75168cfb602112f4d09a565b52c5d7fee22efd57d4621f403af6980dade3d0e39df16115c2607921f65cdd2f9134c4e6f6988e78f75cb4e2ee816f13808e4581df81637933a4f1d2779b054284fe62e6878f575438539b7d1dbead36a14e62f9eee728557cd4377fa844036f4d978252a2fd987512cb77d30df5b4327516d99382ed07489c55006950b6ac6252df86aeac1263f90c21e4262c0723395846da602d1a6180d415eeb201ea76876608162d61dd00ce246f34d1737911c20aae18db592cdab818d169d7fdbbe8547ff12ba0f51c00e23a7fe3d7706a92466d10856e7252bba64eee9f949242c692482ee0d8ecbabd6bc387909fd859183e00734437581a65bc466026753a29b041e1e1d2a81ed44854e06d423104e13ba3c9ace731f32aa64b0880e7737dc4898176d2017d8b9b1234ca544f8e63c3c44ebf00187ed55334725ffc1a6de53db6f9dfcf0d44b10ed7431c4404b1018ad37491042a35ece596181ebb1333d8a2d030a903b95445b2686cc4ae9968599cc99cdf48f723abf88d885db39f7e264382888263634839d0d98b50d16bd36cf01c0a1f3cb2d7e9726c24acff9a89be3c0eb3a75b57efa5dac313a76ceb360466a9faa8996a2f6bd38410e63a61c02fb8311473e3e2ae1833b6c8066e8b0f78c4687cc19d92586e3b67b56d1a1a9a82c2025f6a344c34ba2e2e6054ba20c1e12304266c7eead38b60ad6f427e10f3beab9525b5e94cd958ed7020ff47a29a4c579673f0e1276aa4a3bfd5a23a020a771b0b714e511e78bb47b11e862200246cac645c1b9633c52c88e5c584f8459d8a518ee0c861aae0a39e4765fb69d9d3b928edf124ba8c769d2c4a56f9bd11a66ab85d981d39913a893cfa0cb893d5c8c1e5d0162f07ade7a8c0955994f3e5a386a81828d413253f41bb260f34395e3ef6904d43ea6bc94bcacaa213ffae6d73450914330c3cbb14c64834624f36fd4a5e1861eb309650f092762feab75f668b7550e14ad7f6711f0bc6b84708e87f6415e30f11939edfc4efd6e4af499ca964111a1550b926932d7f95f3aa9b68cb01b333042439ed7071f0863b39f46bc4b34d83341431cc0c6c06e489eafb4eaf0957d80fdce6af8a69b34934c78a053810f7d2d5b90bff4176b5eb2ad72958c758eddeadce25a560f4b886bef076481eb5a8be449908a1413e6674a1d76939c14ced90be7aca7cc6602b18cb1f2c93574b14d00fdf0e15b956701866038ba25a35dc7c5c8a0453cfceb163ea2f3c772dc4f084aad9816bff6cd7409ecf2cb28a999b65dcebbb567285736839255c81018d350509709666684107eddd5280c4efff582ca8dfee6ed8322b24f321e189463e65fc6c4ccd6bc3b2d49127190c16989134203cc19f775abe6a39c144a2134b6f48c961d0c7f4bb723336349f15c50195778946d104d6171df9cf292915769c1d70de5e11f59e782ff42f89d0cafb28c9204db98a4b12df89899c6cd446056d2676ce161fb1657d28fb43ce23d24f1aab3456284efeec60145d7de3cd0b386651548b0cc983b0cb800c824cf38e30ae78bc6af55d8719c720d81e87e168d153f9f449be0277a2a56ee958f6edd4529819798a43dee6a07381d24549f615871da8e80d30b369eb2260d4447724485603dd905a09663dd975c4b993448e9a3fcf1db299d5551bf7140cf5bc6c03d1de9d734c9e247645550e9c11d92528de7f4b5552a521099633ba928c44cc695ed1ebee1a7f8feb9ae64bb49d416b66774dd9043451551d8fa53494c6699e17c6556acbbeaf0517d5041ffa02e7d6b26366bafa160c314574cd2c4c12ab6608e6e0b0437cdd447c450bb76a8c6817504273337d9def95d2b7f4997b27c9c4e443316fe13ac2afe3df04675dbc0f2d2e4a69a5418eac1ba2db67397d1fcd4bfa297a38f8c16c32f06e90dd0ac9c660d0b03b6fdba70b313dd8802ef0c626dfae714ba2ebf8f2965f692dd495c87e934348b1b86f17e381ae7b0dd213ecd69f55c4dbd0eba19351d6f0da9da207a7efea9e978d9422d641b800bab1597d2e1522e6e4df3dd56fe04149c8dc2e7651aacd98b2bf471df39ced6588020ab3d718dc8cafb0ef889ebc5780a9263d616919cd8d87e74f51ff2a570533f542ce243d18850c41a84f12d0f2fda259d7469967da5583b476381383c22cff84ea7469f28c2a8d81fdaed0509bbb6197d644e7573e41cc09b0a81e80ffc5adfea8e3540fc87616143568212a34a9d8d4284e2f00f617ce9de0f312b6387963f2d49a4c29bd90797fa639536046f41743a3b00c5985a3419a767e7f75f32527980eebad6f0095871263c4b2d1f8ba8b0ee2696eda009be4c2f5e9038959010f476b59aa7ce47a6b2b59b75fe1fe1be1c11d62e3f795063f9115914b78cf6b66cee7abb9fee14bdc2ec1ed24c39a238a1fb42eba64b84b9f948c7b595125219f44f46587b8e5cf287c082c67733380c68986d4261b802bb97b2fc7e73bb7126857572f491a748efc3961966f9f9bae3a8cd393ecd7c2d7e510ac2409ac40ab88c251347811bb1dc6d8d2f3325219a507171d93649890eabe24fa5df08495e4bd7f1dbd56aa84dfc4d136aa7f3cdb9820b50264db7fd299c765bbbf5e693d5fe3e116a37f3a4499e386f834fbf8bb28abf1ceade6b912ad9304c6aaa3313ae79cafdf44f6b8d3a62af9b600dbf2969351c5b921ee64eb57d73fa07b0b17e3f81fb196925ad5bfce72d366aa47653f84f2be77240f24082432e47966c45c1669054aa56241d0dca89539fa25f4bbc08f528a9bb2d5f7d03fe361737d485c4ecaa8796ccaf06ae30fc73dbe5f314f807b5f2e7a2ec45980e3d899450f0269b96ff6e6e9f673bfe3a76bae559170d284de44adf9ec488d2e46e4b7cef71bf0c7448362f6fab191c66d02f6710f1e8076cb07cb75ee2c7290725139a87d3bbad9b21a65644196a793002b49762d16a92d1a93c1760a3c45061c0d9a62cd1bfab70bbc20c799078e5fe0f9cd106cca180329c744411c1a97d292b98dbeee99b5dc9b7fa3fd1f5a3db4660c748dfe2e00213b5dc536b3bd590ffe88bdd93c0f2a472eb17238c77d95e5bf317c26a14db6f3077a11b3235f81a93a1b528516f92142509a83bd5f19d8bc458f8ce79dc26e0f7bfaa6e249b90637a3c37f20aed114a80dc56017c401915a876483c10709179b104bbe9a6ea01ba267fc844f8bca8f9540ee9496d9652e0ca1305e7bfead16e87552522f7f752a07ca23d0b221c27a45ec671ce0259053001b95483a1395741c913e9ea721553e397b3456dc40c62b8bcf7fd39a779261bc356dce2c6e3aaf2934caba05082f7a09a7a0a14647fab0593624156425bdd3ad72c21f30f4d2b8bb0e0e69d209a0ef9da763f289e12f7351977d1980adfc48c4d1cb0f4d661ce2325ac9e00bbc6ecac84a2172ff9692fa8925e780fe146c6081c5bca4b7f6a9321b96cf3836d77332abb7addd7955fee544e18f557e3951b4887c8b1bf3553704841535a19b25a3885b865f21af3cfcedfeb517a99886b3aed7d55a730e7bbe79547828a60785eb1fe7b5098bda129a3249c333b803b457158a8bb9f253d25bfcad4e6fdcc7aad44a606edb4ec4208770549043736327a11697f638b13a3cf2b05774096ff4eb72699c01811bc5e9676f9b52bcfc43e6cea96df789bb3d748096b8df6285308d6a16bee7e6df51424809b322ebc897b794e79354eff25b6d4b20ac4dc0f95d8d932192a2089b8460bb5794dc5b69c8b84de2dce9e3db26c0afe3ac7734c717baa7dbab61c338a315a879ddbd32f2379c65b1a6095c8c1878f1ad0275dbd91c38ea06c1935e5959b51e001ed0fbd39f0b504cf67dec1680edd2e8bf6bcbb7f0f1495c3e3a6d0123f531a872080b50e3cf54304170eb6e31c09cf2fb3774448bee9f4d1584a592b2f1073b54c9b81199451fed6fcd55204ff0803ba87736b40a54f54e0c52a1c6c21c02b52fa8f3ddb3fd1ef6194fadd040e5a62a3afe005b0395e18862f151eb2faa876f46d851ad07500d66a518dd77d965cccb897afe9c4e9d5995fb4daecf0aba36ae7084d057f2ca8c39b5ebeb8be8f7d5e585a7936604ec84cd8df98c002b2610ee587871494a5075a0a7cc67503c0524f6ded8005ec47de83325955ce9a452229053b6de33a5f23f306935e0b388df932e4d16b4193ff7d725a263fe7b2c90a2277dbe6260aa320ff26ee6640d586042a4fd0d7d6b193d64dd77ae9917da0d4b05296c31bfb83d230feeea970339ae05b652666a7a4261c94717a744d9b080e1e3b3a58529cd134c2cc4d7e1781dd167f6bccb59239bdb8445cff4d74bd8fe8d622e0b2641a93a0013a5492a1354784756161fc4050e065b31e0b55f433689eda38066a4c51f6316f873c93ab0f7306460aae32ca156c9b3fdcb2b576f41e75c339dc1317e6380c6774cb556f83e15750b242b598d093b67317a5d86af48214b1c80534202349b3eaf85b02a89b005ab2093f455c30ad05ace0422c7157d4d24ce432c10ea37f040df24dc3b1c81090da008db8098d54cb291ad123506e5f8683aed74cadb4f39b03c989dcb91f34835098d90ca43e6fb40faa0af085ff8526f2e793f28d224686bb01828779cdf42a16a5c4da67fac14405fe0868e59a572aa33d8433356d9f3f9604420a5591afadfdc67f3e1571bd13fda4cf080a4e74ae577a831bbff4ff6697005e6ef6be1e0732756f1cae129be6e378bd3b2cae2d4d0b575a8c0ff8d6dce05d3663e290dfb0ffd0ed91aafcae6ac3bd83345c30531de5ae9680d5e1914cafde25dc275469be458ef45d6d5c5e26327589f3bb69e09ce7167e24cdc440e9f8da8bbda51cfbc564378035797baec245b776820d30bdf11932478378cef7d85a6f07750010b7eb99d26569a52f04078d98f6efe3595a8eece656340e67f0f627d7ab3cdcb20fd470169b99e61d112e207f4fed96c0b2c6d3915591d94b100eb082d29e62f06da8ad5d87c5303adb3596919e0b6a3eed1c5487bf42ad2e988980d56ea6c53a5bc66cf2c028117a7d1769dc283c05b9d7a4109294c4f2994be22ea27e4c64cd7dde2949a1999dd7e9d5182967db2bfb5e2c1d7450acfb09254542a87b20a10713bc12cb1d0e2c0855845a1e1becb19fb0f19e4e786b71d32e5ae0062b9376285f62a4b090ac7f86bf5bd5810f889e21fa4ec13a6e3e499a26be777672e85ce2df07b593eb3de63a7c36f3a852ee43a1411c4187012551ab2f3b133884a2a2fd3a1b85008a531197f940ea62960457c2fd769f3ff7f287612b631647184c081f929146d7d12e56f48c4c55c365bc3df671eb9bcd817845954c77b7f5f513bf8252f2c78918d0d200bd93561bc8495669a8f2830de54626b1c6c7d27a2f4be18e6641442e0edf2b87b89bf20fdf085bdd4317fd2f2cc21d07908b4a57b05f41497f23b6a9603484afd8ff72862e78fd6876d3c14177262fd6a1062b6fd07ad81bb6e282bcd7e40a98869044dfc2766af34da9299a8bd3f35288d26e08f9d6825eee627e8313b1c918334a8936ba2a033a3f2110cf59c1ece33b3d857e2127868b3fde84f94c2d080decc150ec2edd7f075bd726555215a6917ed69c8f298b72d7c8f0de6e71c8c97720436f0f5e58afae6f63bdbad2d0c5131d7bce4ce7c59a1545c7fdefd084df75dc434402934f8feaae143c0f59ce18e536912dee62878c225279e524cc84c7b576a8c994c2991b58c0ff9ed0eba48ea93a2c92e6eca10e439b6151b32c82d36a3f29ff5d810c4e9146b146e3755545ad3f69c2410ae7f0c4e1fa1ab3ef88bf7689b894e50d56b27265fbf36517a0ecc282d286dfd52c05e8238f34b57d5d9956e89bb12d2b23aa1eaeb8987cd031dd603ee1459b2655d6b2fe3d868e9723335f39d7f39f7037be5e31df3a7ae19794ff344dbaea431b5f01e19a51bec62b78b4afeff1af840fc8662ab07f7dbd784ebe4d7e36cd1c75d5d3bd6ec5b99922d486e239d027f9f60e5d86751d68edbd97167e2cbf957c36cc639fa7f6702b58ffa3b56264d2b83ff6e67049db67ceefb19727443279eb43c9bcb4ae667af842c13c5a101ea77d57f7fd10c8a2b63f7ba54c46c2b97f32e7606262b3dbff09e6f33f0356f9c17c4cc8e9292981f59e9f4289d7d965982a8f7dde49781687fbc60baa4d6f70a62a3b24e43e38e15837d7881257919b0a95e84fb680fd988181b91ee4e49261441604a2801acd9d7703ea5db780e8289b4746fc54aff7c7d13d4e1600e251f520cbf8872706d9ecbd7ea5ac3abff8945cd927a2baae50e6c91cc2f64075fb45fe5a52dc0f7c1435ef342d83dd7f5c2845f49d31a52493039fbc45d8f18c7fd65d6e1b16fc4ec96a261b8cda92bf46ef7abf71240de6bf65d859efefff6b9fc052a1410d6b87741ce50e31f701b0b0b50061299b764a504877f743aef4c4c6171e20e99d834df9660287a4714d6cdb5db39ca42fad1a390ceff777edcb1d5accc6eb73376d21577c40c4327fcae608581417f1e8c07963fb20dd1e9bf9aa177c85828e421d2361ec1a44f0c252aadf6456cbf164a2ccc25791f0f07fc0b655e0d91c0156627da5ebebfd0235f18bf551e6f7ed3105c3b8a02fb67b892784a8d1c57a2d62d998a8d437c210a2db29cad488933cd8c2f5b3514f0b062bb3e984f6d1b05deedc8ef8b1b35882ccbb601d9a758cdc80b621d97249c3e13d9a65129ffdc73fd63e52691e9123785889060ea848d09745c3f2763a5b2e33f8bafbed05f6690a68286ee9224fe4f3f4f147c9cd99ed7c5fd7454ddb71668f2f0f125469825fe68e6d0e4a5f78ee7c6f580ca4ac15f59760258f7d99f45d199f07d1efa848647905809d14394670570a6c0aae3a6f9ed331b1cd119f019c60e88c2f779de9f301d4455ec4a72568ae9407337b8f2883239b0a1cbbe35c1f4044da55856ec1e5a1b695d58b73ba17c4073595e59a911dee245314c3f033b2009461e4cfc9b1b42ed60c3af6509a5cb304cd4b5bcd2c3227714fae8326d8c274d14cdde22bc7ae034801586fa46a147af5339fc2302012aa567f1761edd22dddfc55415233fd89535ab1148fd9fbc12e36da72231b93078858b2b9fbabf52b14523f912434fc6c71a5733ec7077d4b321ed4b7fc529c7b3f81055ce05fa082bfd7d44e02185059c2b5765880ae8b7813e548b01e9f05e6573806730dab03144ee6da1dfb73df8b9db578b088b2a0a0675da702da05338e565ac8101d239835c59ec006f37fed18c150ad80cdd52a5e0243c7100e1d25721b250c1d5c472ab14b3bfaf1d3358654b5a5cc7a967017d6f7185d596ac4ad644a1fcaf359f712b262594e08e4c20711abd6b1a73ea083790bd47f2e2669a669b63f9fdb8aad9de2d32007e4112684bb49b52d66ac38cef053719f727d728a3560c69135db6eabf54593090df88bf2f7bbc887ff8c9e0cfb53cc99a7d1fef2033b6e97822a76473b4df831917f255414ce342aecd7cb1415ffc98c8ec5cdd76ad79b7a699f928edca029c86a9b5d2e60bf97614261789e6e7d2246095311b8b4415e29fdde7fc9531fef0a8375d148be8a01d5c29634c34f3da7c33bb0da1a02aba93f37407b34ed15c0f529dc12d4b5b6a587aa5624cd7f64d451d968700f00fa9730342ea8cf2a29865aa5d16feacf79a17288bde03ae7057de561dc19af3ddddf24e9e4a3801f5063b5e35db74e3904b38f138170618b8b03b6a51267aceb51b8d521184ef7f5a40089345895e17532fdd3a6d76cf6645617619ba29a58eceaf7f9ab1f93964caf665dcd34c58c9c752f64c6a886272f6cbdbf5940b6069fe9ebd4de02879487b2d8b491a684052c52eb2513f482cc3aefd12664ed4fb31b497dee01fa1b54c3a8ac84a0bc4eed6f4a4b3fbee2d956820e3a024cf7162065003456fb80af37df603f8997e7d7190c420916fdff546368a31127391af47b99a5c97d0d609cb792b924581662148c76dc84ca813c44686fd5fbb36fea0ffb9d41377c2643df9604e42860f3d26d97fa64208851e88a33fff54288b8cf04b39ba3b7dcf879d1abe7a406c842037bdcf0e119b505ee3fbb96fcd7d10f36d3512cc7a21d989d2fb37ac4fcf6eebd2d5826d186adb2754446b94085fc1a35d0e907676debc0a8789124cadb50a2cd2817d1c3e6242f0b250b7299fc3da7ccd79c8beb0aaac7c519777cbce97276f266dfc76b50468b3eb206b80b921a7711f4afcd2b2deefdd91d57f9b3e490d7aa398dfe4addb116ebfc351483bdeac4f97d4327c740f62c8c85258344981222ebfd622b581e7bc270c55c5d0fd9018a3f5f58bae9bc0ba9fb2ebf600fb1bfcdad40bd4e1c0b98fda99a0e27bed7ce8a890badaeb4966dceffc770ba487ad49a70c01124cacff7423cf79d5b274127dc118cf178b71b23e9a89d9a918c833742a6076c6a5e64b6ebb624fd837e210556d335042c17426ee8e415cc89c728eee95636874b7a89a238219a5e3817eb48f0a6f621e0a8be2dbd5d40f2d5556e91aa2f7c89606b3c714da16079f68e3a9d798d9edfe2b27d1b2fe6e38676b5e48ca8708bdc9011e1c58ad66d603a1255ddad1371acb2a1f3e7436cd05f9ffabf4237837870c10a21a0d1b0a6d66b0cd6f18778eb405d8775f13ae87e6f5e179ac69c33d13145603b2087c2e1bceca2ee018131391bda4de5871ae7a03076c4bc3c5769a9d1250caeab49a75cd911d46186120aecb8c38ce579cfe12532218fc4941fbde2c7ef284ea40f862665f56159f34f0590139cfcd1ab725ae18eb54db9fed6a6b8192c39261daa702473d8aa7dcc5b99d41a78e60349c5c9e4e16f391cecd7ca18dc893bfc417bcf8f4bacbca17a9a3149e8b3287447be564f2ab2b22b4352bf28e7c56cf51262190b992d72a14fa176d18710f8529af101b7b33bda08188b9f59480e9d04e6b85a0dea50ea46e1ceb58c4d1392428fe5f96035a234c798da71843b27eb930f131025c7facdab5da9dfc2515accd005998c4f72ed488e6369997479863048d7054cbec7f6fe84d2845409d07a1ffdb91f14283872a4c8ed5e5acbfbb0e742b7e757345ab3bfbf906c50360304a762d57d4aa2e718731a252d6aaee87637618e165fff309e5da541057247293603c24cd987d2f75b4fc349f2f97903f0891e730bd82b4f755dae92105b712910f953492528783d566e6028d0d71a643966af787fb1bb9fb61c39a96fe7c3478d9494379c4c8b82471333abb91dbacc8444542fced5765b92c6b03215dafbd152b7989edb63d77f6d41b03769ad519ab00e3c2b5c19deb10d20acff194e55c24cba2b6cae8910ad068d2742d81b34d5343a9ffa3f2d5042ddc2d48ee508d637ad49627777241fb85abe75278a2b65d0f98f39720e9df0815b0641365404d60b2d7d1e5b49cf6f3db0afee20cb7937a83e9e3c7cc134ed3da3d558220a3a5e4fa77aa24fb66c388be20a112a8ac0d8ad63ab5948a2bb7abcde80108b363e5fc5f4c7fa6c5afe439bb83517c39707a42b82b24640c79d927beefcbd0e73ea8c254ad814f4cf349995591ce503df1564d049ee5b99e7d808c2c81d31873a08fc01b3ce91d58b7683a9f16388b95a4421930bf2865fdb788dfed1fce5effe5042495358388c7bbe7dcfa82c1e75e80414d04d2babee1fc37336887a7d8cdbf5b5fd2798f034f29d9bb51e989365742ad64485b91f949b56949570c69657de58165e27700bc8b17c1b93108c9c77082452f52ba84dc3f66d962c781df57de1c730d501b01c71ad8473f390f7d19c5db8de593b2433a16c64703c017d36d156d6aa8ba2697abbfc88af507254d9910575a2029fddbc2733996cbb6fe4384bf77d5350169e39c601607a176cb8f6ef3ae2011bfa2ca829f890148c04d28e09a06d5d0a07656f0539b46446f59c5e11bb0cf72994b8ed5ef2e21d434ae28b042d70ec753fef4337be65416019e0631db06455889d097d0c9e6fd0555319d016d2f9a196f127de874d126c78b308245bd842dea3d93561b430aacd3c8654799ffb8a0775ab6048914fbd7d03a568137223c4c49506045e3e9410e997432892995096d41523c98e65f5a43af6732ed4d039a6f1f6fd73758d79eb517647ab730a908ec741e24d6c068b1b4764b742f4504c715b91545a827e41e45993efcea7e8d17a55d5754354aa9654fa268ad570e5464c90284a2dc2f873223a5f370d199f6d6c0ff8c65a25fb891441cff8ea7e770bbc1b43e23f128f653f3a543cf3330371fd55f2f2e7e84b57c7743d432476f5d55c5e88de59d72ef222e2f3a7b5741fe139cb47f68f072cc99923268fbdf00f6185802b6d46441ef0fa26e879d1183c6da410e8719772ab9e7d9afc940e4586e6a3d8cc1add7920644eb0bbcfcd9fbd5c4b3717a902fccc98655816a1daef89427c07aa5866057a0b2d19e8e2f81d216593a95a26b20e70bdc8b28dd07c88f13a421113ae14aaaf7e88aabbe77483e91057ba263dd7c09116da98644abb28898a9030e7324d5c00750870707af5ba132ef6107649fdd8e988ba3b1f53b92cb651b46fd8a2ac1b77692a3cd540edd2b0ce20a7caaa4a7e508bc9aaa6e05d5f2e7bd8a9bb7d6bcb4906f371da02b236f0ae3783e56bcbaa3275a17721af4e34943d0f410eecf4d226e49915a8e8d561969eef7e22cbb9f1a511475f8fecdb81f90636e33cb3077e3456cb23785a8fcc05db0da3fddd93c85a4285393431a3654b56d1b76320a7854f7c22fa5591fe9b6ce4e58fb4341bc4ffd4a691d225057ac42f03b1779f5a9a88006fc24310ec3102f3b7ad1d06e8907dda0e7f567bec36cb6688d1e3938316bc6173d86c85a6106ea19215d128b218b341965aaa3917b1d7ee0b897dd80d4ae21f72bd68d3be063b9d0e38783e638befa84a3c33cd5653c19183e2ceb0e629be5e919ce4ae1c26ce4bedbc1202791929ba9ba4e7e2ecda34a6011a89e3ca17c5676c2e636f61d49b4b00fd3602d8ebfa1ad8e97544649670e7d839b96aa88297770940eff5bc16ce474b711d0ab50b6c55880567cf273331e5e33c8bf1d67858d848ba08bdabf5195b3db09eb731fd43bb7ab19da16ad771b5465bf226f6eb87b5a8b118e68f0d7614222e47b20b69100b6d97e9056936d0d1d8beeb785a1e02a414c9d2ef9017279307609f6e979c00682521dcf5482ed4149fee0a6a58f2344afe7f86a47136ac0f0179db07553eda642a4e956cefc88353a39d9fd52971dcaf91e9b0204d552eff5de1e2c02ceeb8771397d55730c1ec22b683900136cb88ea5277fbb14f651f21fa57d1298abe6ce667657828b639c844832fde7c1a7a4dc015ad64180de1c9fc51235bb4111122cab9b5ae7dd60303b0f47117cf199cef0340287aac539dcbeb4a60ec42a045bda36ab16a0df8c3b5a17272c0c4a7c968f58c66c6db7f11bde420600869ea84b4c1af5257cb93f2c05628b9f54d2507a0b798b5c35210e7803dff8fd3724b4a1867875f6bfb391c765c37d93291cf89115601531b234d428ae1abd40f466d601cb2df0b5d5379729df96d54e1ab971efe934aa6ea93d11f4335f087460bc220065e0da7f3778ffa4be3f1a8bc195b8fd2d5157555d60c0fb90c166a2fa0c8d9861e9eef70179514a56a7c4b09402aac43cbac670e1b303add9f6610db8da5f019d6222b11d98a357397f68d8fa61329343ef42650af684313d628f964d910f58564dc3d635888272342d2bf1ab68a8c3891ea7874ae34c7f5f61063668dc8642affc03f883c42cc3ef0225ede4dccc332f9a1ad785fc80fa353fb8ba8fe7bd82598dfbb97465d1255013519526f60df783d6205287b00d43625b1ed03435c87b0cb2a6099ff89a0ef77e063b4f5bbf06ebdf5591792b890fe667756f939de2fb69f5826e213591ae181226e05928e8c7e3267a88114a7a83a5137cb29f60c6beba2d7839478a9815fb63c083b99f757eb6f06b97cb18e4864b78855dd7557267f91d78801e2e88a612bbb0037235a7ca16c45fbd246ed978233cebe00bd2dbd50c639a1c5114183cba677e9b711b408cb4933c48e156013d251727764baad4678a630af1e160bc9aa4bb79a50ed79b1d42e203db3064ebb3530eeb5ca155aef75933cea0428dd76a69d8d8ce4ca0738a7a92bbf3b173118a63b5e25c079052b606a9d32a50ef7f903990fe2a016f226c88590de1666ef07248e5c654580a164cfd18beaec52ad2b48a0e5cb794585f074f8296ab68e67c0b9e504bb914631eb7d0aadea075f2206b01821ddf08037bf39e2550df68e15299441f89dd55e3edce65a84999f042a2b48c1f4b9387b4567d69ce9f929bb78e21a7a9cc560070213a77b313414c97b46c8d41b19c5728a8706a40db045924d127dae948024caa3238196fbd5a3cbac69bf3a2add7d60235cb92901ef2a251fa8bf05849f7abd8fdd93939c7f3eb65753c54b8a6e545749c0b6153c608ec9421898be7e4beb6a4fbc6cf8f21bb85cfd665aed4ad7acffc966440af36e3e8656b742dfaab13298e8cb9d4e063c7f4e1c808da6ff8b428644bf124a5a6f8fa6a31b8a2004393d40ea35e12d6efa6b3694742f81c16aa00fe934ef6e5b603b26257f1045bb0bb81afe7f688d4bc75c9202071c0002ae6aa0644b5280317232cde7d31f63b11ea366d97b3ffd19f414cf3eede191075aad8ef20c641827f0586f355b0cd27e191e469b46520cb37df3ee1e295bed36e39e3cd21d5842afe0d17f2c337aedbf80e2300ba119e186a46d5d92d1157c0ebb7df022939f7f04cb0f44940a1087fe1486c19d6cfc3d5054f8f3643ba5386147a1fb1f49ab9757aa5ee85fd89bc5fe981d17f947bb047cda5afec4d37f0347ab34a77b81320e4a6a6b45c4768400b5ccf0e48a41ac6d962775997d144f7da1e7e4983b6e0b7c0b4ac77f3812f4781144ff7f6825f42b03ebf94bb6c81d0827d8a5694cc9cd3697799abf138127c02bae5c73ebc8f31443dc50931bd12894d79b3e3c9fc05f835956dc6ff6f2ed56fe61deef0e45a938ffc1e8505bc16ac9d35990e01d937cce454e8a8c398bde65ffb735f3a0ce81d4dcf8cfc9d037ad4eb96cd1f3e2f61ab0851bc24bd45d8093610fe020347b8477c07ab783fe9e586aa72343e420bce37389e57ce29e5bbce8e9a099a26acf8b881b34c4d3e263ffb70c3c5e201b2bf244dedd47e505b8200ba2fe27d54b047ead23bdedb38a8a53a797841cc00a4bea919c415f654cff378cf60679d822cbc226ffd0fc8ae09d8976ac90120080bd75340f9686d8bc1dece08cfd93c56e05e298bada0c4a99c82a7140ca20bef6a2ac2aa592137e9744019bce1781f2ab567ee1140dcf3dcf0c21622fd9d95ffc9c65ee0252ec3e24c59abf8613dca60d977212616f2d27abd0f9f42fb8515a92f40bed11599fdac2ab42b73f8b768c97ace5a45f0d674a5cb68e38289f51fb596f18a95cd85b0b09c262a468ee60ad3a33ce5db1639338e84992fa4c30605db3463445e3f44bb8b17dc83c467e19d8085ffb8953317860ae97e877a5198515bc91d3d6894bbf4e832bbbce7783c2ae6db1858c7e067b1054481f0d5bc18d3d70b0f83dd7351c7df6cdcbf8be29b5c3caf58fd47936ada9c65b90046c96746b3b9578bc69e5176bb3e4d0cc03f3e2c7f1e7b7ff21b389677cdd9f1323f451c484d904e5c999d001ebdeba0ed660341c180e1311a74b426f53a73a025cb675b1050bb86d5a75e68877c8d6c0ce6ffc600662376453083a83bec89eb8030f7b0b5209f56dbcbf0ea1c78ba0ffba9b9dd368bbc0dd95fcecfa02bf004a824892def6503b0f36e36b88e129e87307710cc24556359b1b062e0ebe330ef5ded791211d7e7fe561f3fdc0e0253bc9e83944efef7d815aaa2fe2aea204c2b4aae7ae4f2e2291b93098adb633f9857a2aa00a62a58da1264659d943690bd68bf8afb342793dbaac1a9310897df64709411d5fcd733d5b182a3682978656ad1da54ecfe77e8599691458b082535a6c3ce36ba61bdd68540f2ad2201cb483ebdbbd9c4fca6526ed2a692c47cedd7a8a5a1ef9e5c8ca96a38e031b12a36f8305f0972beb6fc8251f64125a231014b46016ca81c83ddbfc6b0dcc87b632d485cc1ffaca7bb66cfc2b13cb5da81a546dc7c49b8e12ff5ad3ca5b9aef9ea319a9afc521c308c3518ae98b2f7898f0f9d03b3000ead7102fecacb1cc7ea1ffa612dd4df2af21e4aa4a172d786f29bef5733c9c943f86733958991236d5a80cf723818720a79699c3fa5f8b29c82ebe42f802ad42f20c0cb64f245069094d8451d3bc7257d0a80a28f65c3ef509cabab27a3d3a96cc3490477bb7f85e1c3d58322c7b60fda32cbd5fa1ff8d6f807ece143b90e1289d4d6ee53c07b3ce8a615ec5fb43d2e3dfbc8aeea43c58af5cbafedd0b92bba157cb20c92a16d88ea995edbeb5a9cec5c9b79cd079488be83f7123a6ad92becdfcffe6de03ddec187122ba9a78e793a2ab8227476b1f06cdd33ffe43666f08042b3b17bf51b6e383e3740d83e32aef55cd6dae8c9b2ba364ea46c7092ee5d8c0dce25e78544b4f87869c1f284265d74532e92621374c550fc6ba522c5625ae816f9bcb3eede8de18592dd5f81b005883d94e7e5b88d856b166d8c27ce7cbe33d1fb211997c0b7dcf5fc679b68506104f7c3b0f42ccb5c41eceeb0975abb7ca5481246129f54b32cf90dad6f66ef9304fafd32c29f313b6f9e6baf8ea0b6a8d7b36feef3c26ca02de1dece2cefeca16078be83cb6ace8770e788ea4df4e6d176dc478b62a07a37c290b4b97147d21667a398384d48d7827c9407e6975756d00fd8c860f5fcad507dad5d2e940cf708a1782132a33af710381de0486f935d20bd42ae0fbcaa8f48d638b92d4520577b2be5ac2f451abd05c0ee350f7dd949f37fc87c2bdd569a59bf871eaa0f19909b06b9979a3acca3d3132f8c68c2d63b65be2fc6d96d6f698a9565c6663037428c1861394fe94a78af5a3b3e4e4261da1f9ce327f08789ebb6eb9f6c4665b3f4f3dea22f12ebee8a03ae873bfe029ef1b48de7ea81e55400bf1fbc43fcbd7ce52c158c3a5479cd1ca28d2fa14eb57797ca078405f3c4393bfca89c0a6c67568fca8b6e29fff6982779c6ce96949517c128acc29695a957ab21833696aed55994873fbb453e5effeadb83478517a3970318d674ed2bf5d545c3181e0c388e24782989dc451eb2c41284ad79298a25296bdf9c916efd78956cd2fefe30893a7e0a4aff8f1949a61849bb441aac2664cd7932846288c5eae932219b76dc8d167851eef0ba45cab97eb1074977097e1e40355c73ad49d49dbf13ce9c520aaa93c6adab90cf0b19fa5c8e292b0267aeeabfad892d17138237ef13e024917f02921f72638666663812294896a8020745bace7fbd4eacbe980fba883816c23d8d2acf06dcacff80e9e26f1ca68812c67778a6c9b8c5d921ad4ffc5c26dea5c88e61c5bcd337758bb8c1ca72a120fe58f5c617257106535905fabcd097208f0742976f72b7980e6ec8e4af0a0cb85aa42c08db74cb6bb29ac4fa35f13193409fdcdd3af444040c3dff073217fbc1d703ae625329fecfe81b51268ebfa7e712e5b2a77daa5f7f9c5d5031832d4e7f7cbe362f35b400e9420cff38bbb2afafb02fa6874f1093706710a0b96f3f829ecba2326d854868f6e564dd1fd43355a138df50a42e0bea4fd7468c24fdfe2c24535406b05d1c4c3268c993a81940a3b1d0582a380eae3363be0ad023e499f693fe821fe50ba9e7c953e7f2440765979a5d08a97b8869993c3bc4defeb7e3ab51abb64dac054df181862f9582da2a80d9d6638e6f7a4ec28876776bc3c81314b17fe6bf3712bd3531ec59209ba04059e30f07b235f601e0e8e1c8163798db4cff8398bdabfad361ffa971207095ee9aa63ef68f07d6aa3612dde680041e1efb25e92dcc9d978d7bf8c66d39002ba3d627cfad2556901476b71e8539632277c542034f70676557ecfdc16a0b327c04118710132c37407685d71080191456d20f2d577a3636781738202cb8e6c3b8cf442ce33a0dd96721abfa5a4f898c9de0cff62af4fb533d35e2722040e07a2b7edd8d77dadbb3478d66904c87550f21edeeabe263138042bbcf44507bec3752e66ff4f6bb22f0a2dc66332dd58637efeae75a4dab69cf99862d279d5735b6e3d40663b55e376e3b2cd5d73856c69d34a1f8cf9eb27296da5017a11cacadc41200cb57bef7d3ab4d6343cc3703bd073b0f03e3b48a21fdf19f99ae0095e85cfa14908bc44214b82553e354b8c108b606cb7b13b5a7cf34631b3f82474d05d1bcb6acaaea06a16042caa1ddcbdabb656e1cb1e2fcff90fd4da0c0d276d205b666a9723a3f3cc728e639ab0454c797e7b731838c449bce7e709e6d71f5e5cf096a3f79bc68fb37e33a961f2be2ed572bdfd298589c5be044e2322a0eeb09e083282105a684fc0b73f1dd97da1b75e8a6412afe7f27b526bbe1bc62f4408baa711595aaebc2561b4464cbf5a4cd6aa9ea1739b046214b813801fe8689d7df97b244974ccc71040fd9dcee3f409ed1a8a23f0c6441b58d812b477236bfb88ecf920b216ba5570286d7d8fba18e72dc1a2148e661498e48b68eece33d8a093a4698ced588503031ab59a0c0532d702ba779654547cfb999d1b1ac39166c6c5cea321682b0fbf9519ff4fc218cd04704314bfe590608399cb622dcfe871401d9ce72c68294a35ca32ce5338f6fa5f546b84bf63b44ecd93c4216225c4c1394b481f35f533de8cd5e892823e0ed64b071d51009e1411b3acc3d2e740c4c28c95a77ac07444081a19e6dd12f567d7eb2a8f64efe2cd7929e67c22419d4781121823fa8d1f932db9c4cc98067b691f327db3edc1b987c20d79912c61b8c3d0031d9e5201447ca09c80c795a8e02a76985cc6a6871d309c8c5689e5568550581c8b4932fe274ff691cf30090b7296549510646e5341a0fde5d197e3f5da93325be7a6b19f31a36c981c14d0ad186587f8a039ff1959849a6346ffc769726521c7208eff0af02a5b46dc6729215b7da227e80ded8d3ca2464936a0d48baf2b97429ebbb07119dc3a6f13754a6e319271809d4a3799a8dacc9f3115b40f791b8dcdca2771723b25bfccf333e07bcc57f3a7ef293ff72f8e76bb6e839e5b32314ae3e3ce7f2a4e8b9ce8371c886a787faa4603da44147e4f370c523e03302bff24b9a11317e974cf76d43428be34a26f37c8d28c65730884c52a7aea3e755d45e698e9795122b3136498d01497c8db50026ca12647563036213889a8f0f86a873e608a0fcc6f4a79990c9fd4aee57e0d1a419d7c09807efec84ba5bb422018ee6a98661f1f479fb80d842646d83a700982cfda785ecaea8ed7dd95df41fa7884517e55d32d4117c9a27e18c353b7622b29e90b98096862fb087b126963dc06c0270fd01eb21a3e2844e4159658f07cf00bb77696e36b8235a4307ec6ec203cf9e6230e7629ca68b480975209dc8d2fda28d57b0e9ff04794e120da7877b2aa9413a554861e7bf6fe4ec40d2e22198d61b5128652261480cdd94b68dca1699f14f6429a0449c33e6f148bdda76a7cd44a943f6dd0ce706b6d9d7d95ddd173b355385ab7e60e7ff1d377d0be53e7e091d3347e53eeec0268ba95d935c3a19bf14c7d9a5f9fda3244b3b277fe66864a88803ba35f1de2dd0b40700f20070210de766333ffb018698517f532461de4e5b24b57ed49ff9f70f16820d8d8c448a0a6a1462e4acde99adef31e8c66077023ac4a8b1f703010c508fb4255bcf41c851d3805736c4529bf0935c4b723d1a83142ea117531747252e94782d9914121e192994030fc70cccd09f4bd9a1bdd005d35ad23058cba5b945fd6cfcca69b08f0ae36fba8011439492b776144aedb2d37bde96ccd2e08223234c7c3e9f8fefa65ca1fa1f2ab2b060e2781aa9d362a8e67cc7e40fd826801b677ab65a6c3b0fad57345505bcc8a8f76a0e45419538d756bc68cba63f7d45450d2cca492816493d48da6cee252154d60c4e731c862a839816f24d79b802d81766f9251d4de570548ad9fe3b60359776ce2bcf6b8825024adc1ef3eff4d305a927009bb3691912cad10844676d87fd47ed8b6296cd1a65d145d898f3f3c1e309ceeb2e477de6b260866bded7c689c2a1af679f35bbeb43c2a6005c5b478f5dfac2ccbc04be350a516f51edfb04482a8dfa818e8ab348255ac1e8bd09bd55017279145d9035441c1ec9405643781ded737451bdd4ca231710457b75f5265d05f4823c3c0a0cc209ef188e021fcc38faf58b19b2e73cd65e8a87a3bf6f773c3fb7e1c1d1f080faa2946f61887e685d2357c07b0d35be811439e7959ce2ad666b26a4a7d373b4512375973c6a5d0deabef7b88515a562808da1e72967a83849e0f20e0a77d45e08803dfdd556d5ca7f68c97996715e2b16e614d7c3dfc37407adfb85bd9ad04664781d2f800a0bc5d98d8814508060230e45da0c41c5cbc9264becbe36135f685970461c1917603665aca26b8a53010bc887e7cd0a5ddd9dcc6d7c1e0ee95a1b7d735881fddf8cab94ce5fc8093c59e3936686b5861ea8383fa37e1d386a18997a593fc6aeffb8eb661e3d20d4f0d19b054d1e71258e38476464f450b20e8dd83ff96e6a7accc07a5144bcc24a0f13e71f674ef04575ec33779a8ff61e8ca8f49ebaf8db1047cf9ee61bdff2f820eca754cac843ab3380c96c1816c5b139e0c38b0143ae5784053d29723af0e83c86cec79e693c8334bd1f1caad1a8205482df4dd69525c90372d69ea2b08f4e288bacde0b4bd0425f4879608456582d34548d155f3599c706cb745828b6a08cbc739fe407688cd43777a32d219df60a7214f538c727e373625eec2e7b926020f8b5a6e9a0ed5d956431959a378034e9a377556e3fe92130d3bf177f60621a7db538aaacf0e30fb8476bddb7452c364fbe578ab27e3a7bc6e5a0470449ce3bbd21bbf08e01a6586b954755d9504601011a94f512913c9011c56740365636b53b9aa5275c316566f36b8de38fa5357339712acbd07d664ef3ed971ee55292d212f83620bc8064cda19cbf157ad635baf097099ec8516e242e643581f1c64434da1fe65471205e887dff959ea97dccd3ca5fa026a025360af17338e8fb19df73328893b933aa83a205dc06ca08c4d28915e6fad701806b5bdaa777c20873dd25e0b328c49c5237218620eb488ae45fed52d85462bfb13b900c136572547011cf256e9c2cd591e123abe8da7916deee3104a0e7ceec3e1966a8125c9318bc52e01ffd40e8ea2408b36ba8d3bca09b33db3f35f47f93266fe28a5784467ddddb72ab03ea108a796830a6b9dc8f5916ee57cf094975425d0f0019c9ddcfc059e4bd256e396558e6955135659161f9bccb259774a5ac75b3033246de2d48fbe5345fc20bccd54bde080e2f69859837af0d5eb9c442ce6e9e4eb2bb64b1c7d213c61e1e1b4e4b064073379ebd550975d76f87654585d0c7b26134ff2c1d22e6b157a346dd2f79a2faad5b153ca77764616c76978193cd2d6a2766b0e734717e56da6afa72a4f4223ccb5e334e2a3debc87577064976bee36b4c9d1ae7768f12f9715c9896fdaac2323a9952b1a3ff06bf2cffcb0ea8675fef4d8094e6b775f529b0f104b59a33959527b36c9f4abf9def3281885620295695017f59dd3383f3082a9d2bfb346acc1ea062d018efdd53d0f2b0cc3deccba1e679779d2e8f2e3a77c9bc4cd19d7a22dc56c1b36f01a88564704aeb82efb32858ad48a740658bece093e6f25d4dc6495c65f7c1a0f0db1915d6b84d08d4219208c7c866c7dd9d0485a019f008b86f963cf57a188c58083843a9dc19ea909d639bbf4756aa791798c555796cbefba5bac9d4d0eb833defda72693af0180bb358a5a5ddb380f96ece447b99ec7fe6a0c1e13ad20eb9cec189cad66c0d14fdeb47e6c25aa8604933bb8612d8710c61f619a2b56f89801bbb8643015f400f7d9808bdf52e61a5265600cfcc8e9d69e90921b936f05d4977cd93d817bbeddeb36e7c9ffcfda8a67ce0a433a5849fa37ea98bff6cb92bade10a70ced7a102e9991c2d25b898174c261a1a82297866108e502a8ac83bf2e19d7d0742486239c8e290f46b99cd365484feaf9b2582f435d0da6acdecbd91e7839173db4531b6781a4784fe20e59d3a92ddef1af172f7b2038c28e05d6328099f18fa62be4a3bfa3e202bfd84e346f48ce504635b399bfb61fb6bab00d9a768483f61188ad5e22569e9f4671bf23e224ebed362ffd0398199c1e2dae1914e1aff7f3cc9d5053abec5df76e2700c4784186640e1d98e1e1ef74488a9d6b5e82d48ac9576d8910ac7ee29aefc9869d4db53c71b9c25bccae488ba0d8cc26bec2211927baba4320fb54246ceabc773a5b007962df89cfb152380fbab966bdbd0604cc46dd4c927888093c2b21ab100c6f5b59a8d2e413733ccd4183d0d1c496dd7b05665a078329cbecb63f40d178e63ee4199353f91440806564d76ba18a8a14b24ee85b255685f4b59de604caf331db88793b1627c224b34b9cc0552b8acedf5da3b9b711258f025d85329ad4543666a71d1971ea4046be6ae7e3f195d2c984abb8999ffc6b12740d322c8ec1a88903512c20198a084186ab6a521b1ba7be1cdfd47f00527295929ac327fc3cb77b2d2f92ec11e12949cfafb2baa1ce75bc70dfa3749d28f6d01e941b539e0e854bc4a9c478c2654cd6ad96c7b0cd725a0c5bfaebd49982e00a98c5347d79b612284b62dc3e93a13a832fb1a9ffb1029da8595120a00ca3a6fce3426dd32cc48ec732e251959497d64accdceb9ccbbf579525a73c4480a42e121bae703de9e326adaf9dcc77b5f2f787f0646fe881d55e1901cdd484911f314da671d8be210ad82c40f7126518793637518d99d10b39a576ca33ddec48f19a9a41dded19d43afc47d3052bd1fd83e468629332568629777f71fa5b1483b214ee41f990da706ce8e1e41bb59dafcb7219fca74f822276660e2025856501f1155c51bfd92c46317dcd3237e99f6c2c260243201de7b0653ce1f322b251478d73b27402b29a9678238f62a5286afad76f3513eea82104027fd97ff88d1428111584cbe0d91aa8f4904f4706b4fda1572485842c9d80a8e1cf12a26c2455736de09f5cf7107167f75b1b8e63d142cae6f22a64fc236afcb194b94b240e57dc2f45e1c480d86820b5edea88d8c0ed7fb875161697ae8b36d7ba023d90f0d5eefac22b667a054d927cd24dbee95d3d7aa5c8876d6bafe9b59ac5237bc6b1990fc17cfd0c46803503ca36ed1a93743ffcf883b9cf2ab74a505cd6b77a4049febc603fdd5d97a80f322552339583dc5690289774df32bb419882032aebbe7f1cf80ea514f2a2dc154a1eeb56a712b611ccf005419dc972b1dc69f7c602df3e322ffd3c25a23fa55b1e35956d6432d61972559ff1ee6efeff5bf4ec70ffb1</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Byte Camp 2022 Day2</title>
    <url>/2022/07/11/Byte-Camp-2022-Day2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b74cfcf92f0415f403bbb04bbca960c7ec586917a66e9a27859f8b5cf841f1fd">99251fdceb9fe96a1f47814acd3007f00b778d863aad3e0abfc36d48fdfacd95cd5c4c8eb417afaa29543fc533323d1ae81a1eadb4d4e1ada407b2ac9976ea3e768fc726c685b43145ca0887032beca3fc6318e24b7db493488525c4e83de168a66dfccd91490fb1975404a9ac8f1515a4a48f3809787cd481b35a3e0c4f00c30040d640e69d19d42c9b75f3f65343569792cc920ef9cd8d107ebfe5ead41d63cf3c96bde6ac82c1f4d16dff88f06ad4b393eebd6279c5d52bfe4a9e967f586f678595d199ff231b82f72ebc4a7e3e521b28699e4197c3fb091ed6e003c080d1ba60ab6cfe5c0533cb431d6b9d903f9da5f879ab5628a3e99464efee7c0566c2e8a60da1d36a80ef8f370a2e00005d43ed6be8a2916ca04c026468e6d67349c37803a15161aeef8ac869b4ae9629878333caa849a8dc142cdda74159fac3f6c4a8363b82b294ad95e98609854958e2ea8a805f349703c3111c6361c17c4305983e53f61bad6d13e759001678047e187f93827e696bbf6c6b722343cee8c2ae5092e142d80a17b691b9b85155112802d7ca1ecff46cf480f88913ff13d332d714e4862f054f1b3ad9d5a330948b2347d1cb5b2694c4167906a82d6562f4056c94331033c882f0e6f26327a62e4e8cfae1570db5320bb4034280f7c7e0143bd321487192e652dd53606facc0d1203cbfe683c647d273fb519e38ad58b8c0eb3648f29845aa2352dea72732a10df8ab7bec4bb10537834767a5ca1c7eb580d41ed64c3977461cd3fbeb2f94892a25472aae11617bbf63c4a24eda3561c0f009a8a0da87f2faddc3ae9e26866a5794febd0eeb54cb7d2811f7f2f14a6117da7b5102e99777b00b7aa87bb098908d3158d38595992c0078c63c1c81c5d73b115d01af628a378623027374575a33dea4e36cab3edeba7f396928552b922a7bdc593115f45e1f1364e06f124557f49d2258d543e50be5ff5281cc55c1213525635ed480389bd39452383a47445ff2d286c5a8d6e3e1375fb10965c16028e2f30f5e16956a058b4b6e5e7ef1899e6f29a67368906f49281d36a331cc9a7c4111f66bc2497306794fba5b21df6f7ca2d350979152b40c22504916f4671c976b81cd69649b963ea817ec9d8b0afb04361abc51980c0f62a741eb9bebc1ba52cd4256aeb66f7f43e3b6bf1a7f1661439deabd50f5c250a0ed8f8764df9a9fe4b70365cd5f36ca363dd292b5c067477c55cd0e66e1d3d1971fda86e479610ac52dc3a8ee08f4b471fd888def17d304f02c8469ba8b2340ae43facab1befe5eb4817c3f204862c693e89abe98a259f1cf3589a77647c252255becd2964f131835ca83e979968f3cc43ff1c163085ab08cc862a74984a1ae929fc588b1ef2ca085da74f9801a18763564671d21c6d708afe2133c77aac3b33a569455ff16cb693a92e3e23e1a0da4d3ca6dd04ff9e7e9aafbd59d8fd78ba6bae633d597ad5ada475d28d316f761a2c4c329f93d22f6dcf10b610e1370d02d581137ff7f5955f539bed0abadc659f4d94a7c846a8ac3cfb453a9ba85bfe757a51317490ce12dac2b57566d3a132f2207dd7daf064ad9bd3a569c45e497956444dae79bde24272a1a6c6cdec1e0455729eb2bfbb9b09515da709345c67a7f6b7d542164b290eae6c81a8599a4e848eb78fa15249ce8da8fe825ae249c1e91b916abafad7c069c95c11235bfa46a596db6360d5dac9cf61b83dbb1f5837d3960d752e338451a01816e1fbaa6cc380e97ab282a139f7ab92cdc91e62c2c42ea78b700cc54c55a2cbb9ada248d102e93a12f3d247a57b67b908d4e9c0c232a53f2c2bd13198b8df9df6cbc28127de8f33948987e04dbb0a03372a1fe8d9f0def30458b89d6118a3a0ad34d2ef9f301724be6654f538df367778e471ffec29c6de3a0aeaa2c36f372d2b9d485d133de3a172b7063e69c6214d9f7d1dfd49481e9807a157709a6010633b89891da8e54ee031b07262e48ff2c211fa0c4ddaee65bfbf17cf52dd6e5a788266d004b983087d4ba0a6b553946eb930a756a4323ab5ea3f686463560bed199e97d576d74b531304225ff64a9d36716eeda5907e45d60e6a38d0588d5f2c0a14c2a532cd93d26ba688995d00ade2e14c1f67fad1a4757e5e807a99966616331f405ab178d857d2a46750cba343b738b6f431802fe5a76b943a1322dd09f94564e9a6e0ebd6f816f25e8194a4212560b0e343a71135c928feca27cff3a9c2f22dcba75d065f0935ff6af8e77e48f8358e11aad03476c3c862dad9aa1f7c65bc713c1c3c09d8a6fb9ebf60d6b4d811eff0672911874b0836c0d221f9c434d3c4e414a436ff432f8448b74ed3e2f4c3c43e3bdd54e91982ba8cacf1879a1e53a5c2ca3ac77da3d8d8b1850fa44e0d2d771459d85a8690b20cfbc4e598201158d199ff82ff25088b099a3fc5ebfb7ad52e80679bfd025c85d1067a7b84f2826d5f3cb82c0873ced535e8c2ce865731609e280ad0c88bc1a6a5edc028343e52cee315ccfb0679803b4322d7747f823f97a65aa49ec24d6f69155d253958a6e8365fa70b3e5c7005f3ece5ada034116e16e09fdd40e881044dbe3b8297f7a49948f2f76f817579e200fa0391a34df59811840d11d37c776709dfcc9c9d3307ab5c46f033a20934db586dc37f40848cdcb8e0442b5a30b6c432a4169949c6a6ab060a0de55efa1bbb2b4f6888c9a12d4ef0d20c1dcf21397087fb32bef52d20d71c4484aea4d815ce7af738fc2a575db5a1da4ec8027db86b0e1d5fe5a788f32577ce0644f5c4210338ab9dcd2e0a14fa1e41d9473cfb3aeefcbb47651e1e43603b05aa09a63de7ee572968e0d1352994cfc3b602169536f26272a14b00dc04be1b02f83f9a2554782a1766cfa52aabe065bd576095bfe9779590ee8cd72ad01531bb67d7f792876c0633ac90ac7f1acc4e6c702b402328452a38622ea401d194637396247ef5d6f5a554302340b82376dd7cf70959c2c19c22886522ed6fb806dd12f00839ad703860abaaf3fd811e19d8e8e407bc4fef71630ddf5a632e682b92b9f47860bc164c28a04b92cc21c4badd0b63f1cd9b8b76d4ed175014bbf6fbf8a996490821063339ca7987064965a56456b722894396916e8a563d99bb0f98f0000b8238bad5698a4eee4807a8cf72bebbe116285b32c20e568927b7b9bd1386896e05b1ec506a32d8d1fe42ccd788625e665ddcd57f85522815efdab4f21e704443b2dac6188b6aff725b3e3f27bdc6df7b2b042870163fceaa3d30feac12cedef98ebc984eb8272b29d9ac82f6154271d9bc5ab960ef2e2a3e5b3ff883459ef6c51435ed02c022d7c27089335750a1ab2bba0b7d3206df5f56ec078711a1621c2224834d95b4f59a54446c6f8806d6031bafcaf6603d74034cbc17076725151d7c9ecf44482b87f1b2d9ae62dd1f765cda9f4e3bcd1f4e407627cc964ce3173f218a13212270b4d6e335c0804d68f56fb9c282e2d8795ad0c2de6d5ec1cdf36a0a67bbad26c3dcbd834e2bf827a5d96be86b4338c9c61400ebd43d0c2d2f80e932f3b77fb17316d331faf65bd3e4f3c0334b744be1e8e4069bb6213bdc8973f3c943cd3dec2a3a88757422bdf66ecb6cd77032742f568674e5b77b4c5b7643ff6906239a67cc6d82358bf6e5475743150164ccf629f779161802d068c63e03d23d78cc614a7ab31c5fad859ba8f0efc157cd819c673d5cc1d684fb09e60cc0ba3c064b5165a5a2416d01f6321d3fada3e771e182498e6b3afa12d5d72a78fe9845cff8ccf1f637e4ca3e5929c6b7d80ce9da7374b7554e6ebe7292e1bb3f313ef8a3d09bfdee232e3b94ca265551debff144feabe4a2039e47021ec4b09f8b7cc623367db541e074baec41641422ee716390f2b31327ead54ad0f826460087ede39456f5f3ffde50e300d1c13f78ed400a8c2204c0754c80e90d47a27ee4e7d979c8e0de46c622924b6b4c9b8e6d92bd354fda9cfb9958944fc5d519782cecf473f14c3b6ca6623adad704a8be7917254c800c339e50ff1d0d202d62893d51bd142f2717b9150d5694b828169221c1573717c1bf08955104d03bcb1f377cbe3a228f0ad588ca8032f3417f9d042e9c0af96f0b01b5a2d8408ae09f8fcc3736d725fc6a23ac4bfe5813b01bf7a5454a471a8efe8ad8dcfc11db045840e5b54d18a3db7ce2cd1cf2e270a62aae7e1b7357885337514be109d685b68e9fb002899fcf5c2887fbd10e57b7d53c646cbd59e5f51983ff86ac5619c04b5e312f6e0f94201ed58ad7e801e39d91375bac987002b4a26c4a6d2226d1de276763e6ffd03a44ffc3810bbd74e85478120f351edac15ae369265cae907d8f626b62a0b39828df90f8aa66c6a3d2d074e311a10a8e03f89386b0179aa82e193336733ac1a875eff829c1f603f646bf7ff476daa4079196276e75569c4e5d7af12c48d8fb8c55da0506ac5c65fce9cf144231eb1a5842b33ac2db391f9cff3ca1b9d43b1b9a132c7cbf062fb486775557e3d8cbb4e8bb20dc34585683923d786c7c77fe1be5378b2ed22bab39e4eda5e0401cbe62512cf3970807c9a4144104029734434474a8ac89e93b623e496567f52659e2df788d367eef76ccfda72eedb8132c777b8d15fde77086d578dd31b008ae1ce03cc42b9e4184467b25cedd850d9349a72ff73ab9559df437dda6b178f3c7e44236bffee223861f2c9bae00ea3f88fbd1f78b3b76fa37a56ed4b82f57f68b71b7a21f60bd7eace9c6e82b31cb0eb8ca0fa43026a7b074a4a3e714d0cdfe670cfb048168c34a667a8917de984a031ec6781e9f86ed4a476e128ad704c39ca4806bacc58ec57e6fc7bdb1cab4ab7fbe5817273f44f87d4a4ff5be91860b3fb8403949a87a54449d6dbc8d46419ee6a79db6b4a1daf5cdb271553c42f56583950ffbd1a1d6e65fd201c5a446fd7de577dd5ea1fe3ded53550ec5861e689dee3dd29f65ce1eb892ac42fb3ac987de93fbc250575cba4f370f0380be9459736f033e4fc2101493a217457791d13c7b8a4c2b510dab317d5846347e1bdbf8983aa3bd463656c421f9f7442913f0be17564e17e2b5696ef80f00d475fdd2647af7e40ae05475652483b8f4c9e632527260db41c2a0d0a414cb7c595da0c327d96baa03df2ae0ccb83ee892a5a1e91c5941aa9e0a7c1ca46ba768b8aedce658175febac385f22620980116498cd197e386dc1d12a39ea12b6c0c885ed4ce1589284eaea349c820203b083101043ee01b7729c09d46418b706b437572c3852bd7386e03b23e7a938d943768b7a9916d0c4d1f7d393843c1175580a1d334fd3af97fc49d569d4a3dfbfddbd838022c30220371723f41782b0c50bdf7a1c6625494780701e977489df0642ebca676e81bf5f3b83e7715e97935d120e275a154770f6e8e96c273e0f94127424d9dcccd4e349bca0910f70e52c58e8decfe383bf273de115bd0b7750c6270a83be7e0e5f613886d323de5abf94bb45e99b08994112f3db691c1eb53b45182a9371c8abca8bf274fea30e1f00778935aff4a63dde42b37141f2549170c7dcf65cca7d0fad278036a7e00fdf1f6a2ca55f8f433175e783f616b9d45bb12d141496822e2c0202212095f3990ba71c64bd8c8c8c8cd94925d5b8c93c5f3e0ab18eed907d677b3fcc4c5f528cd246ec91ccceacc31936c4540562e0a736d918174430a8907cdcfb769558288c49cc78c266860fcc33b1957afcefdacef0447194fa35da9ce3ab7cb289204e0d2c599a49130567a86d95378386a9e13494af84bd0c29b4cd1b1072a82db6aa011a2a5d713d0b7f151337b07af42574b74e7d477cc5252ac221423b9352c8ea5022100145173fad546e48b6e529b7754e67487803eaae331b5a629ea7a3fa8947075addb11f37ebce1cd6c19e7f5ddd798c9ebf0013bb1783224a7d792a836adf76a7ef2ff30dec25ad568f0107f5fd6105b36e54d75550864a9761e9545c153a6b0f6c1966b50efed47bc8eff1dde08f42438a28b051f0b1d0cddfde3f26e9b83516e6ea5a339e37ae22dddaa50b07b0070bdc156f72f11f863d4ebf97fce8f6f409488c9d2231574ae6d2f2622ac082cd66b81020465e418120b7c8d53ea2b151adf37d9e7fd9a1fb38174d2ba9f7e8910108c34274529607b570950d4b442e8697d0b7fb743e04ac9d68686daedcd750c73f29742261755a17ce9e7bcf024a3e191ff5dd71371455266f88a46bdbd11b74eeec8369ab7c65ded5ed6542d9aca7260005e662b06cd0a3773edf3624860b5b000ff5368e8515f4ead10d3863e043643805e4006c4c2208e43bf9eb115bf3cb9e9b438f37e5316615c979efa73c282afcaf5fed41afe139e25b6b1aa404e10e534626ab57b048b2c540eed5c4753def4b56605d159ad3e4266bfebba335c5db8fbcabd64ce92226a8ac4472dd11af0c715c94538252f8e2e1f4217896d487a2c2543e35baf7e171b9ad82a677d3cd6b18b78cc7dc1d453e1ed1326a24615c1ac8eb560627e6fb6b1720954a6200c38b1c45fc59d3d3102e442eeeb55ca47ab0d6e5c0a6ca170db6cd80df3cd6041decc2e70e4da8fedb38773ec33f3d2aa03c3bed42cb2b412d290b98b595352a6368f9e6ce4c4b508c81b5c8b3c81de8dbd702fff8072ecf017225e566c1645681d4065788b1d1099166960045ff2d044c66c8833f15bfdff77b88dbd29ef1267000727949ae27197b052e4e3571b4edbac4e88f1b575ac0d2f46675cdefdbedacbee412fba028c6f58ca7a09aba3b9409889a8ed1eb0b841fbd4447556d447561af68cff21496f0dca128f9757011c98e4393eb7cc11f339872fbbc8c2dfebe24f3b2ed7e499e5b6efabcccf555f93c3caf49c956dc589ddcfa1699f2b0a5c1f8493011c5a332ee578e51f1381bf0a13640481dffa183d660bc819c092085ae666ae9570c1ac8097bf25f461e47d3b50fcae2850a0fc94fdd868a2bb419ab65137717681bd2e0e308a9a30bec64720934a6d1c1ad9bce376507664fff414cd9755084cbe1a7845917e03a8c6dd4bc0e980e8c8bb0e9a75a6669c9e9c830d3a3a34c89ae6a9c86527cf0bad03a8bf6b6ba4d4ccc4e17a393cec2b235391a589a86bd2284bb488232c5fbba5bc4b666fedfd8ec1ff104f1fb4b1a9062921149bb4cbe3f5fa43790800e6f0c29da5f85ad084e1405dac7884f669ad1b5c891876e17466ad5e2111ad83b22db4a95e8509c99675f31ea08caff1fb333ab3565e3df4efa51b6bec8a4f61a3b5aa9ae840c2c1def50f5becba3a0a29fbb6b177b5c48fe30c34366b19b3504f605e7eba8a000d2bfaf2c6094ddd096ced2a7c9ef4da4b9f9843a0be0e944f88040a68f50749aa819c7c3f89870042f53fa7f1fe43b41406deef762118fa28e015a07e4c7062f56b54c9a46b6b71f18da9d3f33cd7a27dc0c46beecfecb64e46c892ab4d961af1445936a57a740f109603f1b80e5ae7a326edeb46500a72f5c36d137742eb6c2cff27fdde3714d7735c3a7703e0bd0c79786f340c9864e815bfcefeab77c000f1a298a21974567e49b25d1b76e136814daf1e54700e1f8eb16d621e30af975ab1016a7d513e03c1d531ebc8e53b7a29e6054e0b78c0db1d73095f5845f1b56ef2ce88eb99049da2259fa1c5e860e25503b2deb1f77ea1a7197de0bc7778082591e429d5210c6e6a797237ac677cac065b06e89f73f467ccb746983bef0c73a232a0ae21c4b2a8e979cf018b8f540347294202d08ad6d4ca4ec0606c2d07824ca774b8d432df429e306c8119ddfbc296472b50b7fb5fe33e19f032e52aec31ba9be273544eecf82c094049233c8bee362e22c415b0ac1624849018986917f21e557953cb415c23705d4e37295c6720865d74c0979b8e0170b474a31001ea5ddf43098c4360dd17f92a2ebfa72142eae00043253577f08ec507afd0283a9b59b362520c03c721e5b14020552d59f8f9dbe03d90943c7472c166e5357fb3bc124740e9fecb103b2ff8ac6d0e986057388039dd689b5ea3203f97d8b1c2aaff60962b9ab226c436a02e5a9612d90cbd095393e36df4cb0b8c6e44f14dae69001a7225e81cc155006ade7a1745608b1204a357c2352153b630318c70e3fbfba7fdbcb1ffa71cd57e8ca87b7a500db741464b1b28177e4a21969c8db9d2362678f3e190d5271a385ce764c4554db0c16628fd6624a654524145d759cd48ea83a8b0ce7f67fb8fa94426da07da4544526fea92f600fc1aa1991d0a78e40f14e4790228aceb880c5b91f2ebef550197969a64fa64463e72f3bfac440ebd1bf16f161c63a94118f39d82245622183f15b29cf3899813ee5b2be9ca4ced12e4fff4ac3a623d710ba4fa767345543b18b683f8c8bffd7b34775da00d3de49a43573234c81c279d6df290be5631beac1741f939d10a0c657b2c11be206f1514699dc00174cf8ff06489122598085275642abf3d9f67e60240b252a22b0cc40a6dc11c4218710a84ce657bbd1e63c69eb71a08392282b318b59e0610dfbb0c0d0b9a7386f4eb1bc7a54cafce16aa05c9624da0e9bfe94ac2427ea15069c6a8eb2e7c5e12c4a7dab8b799e2db071ff42b6e9a402e2a42ea783b8bb87cc5c986af9dc3a4c263f32262a62c55c5c01752fa93bbeb5119493feb99007b101198317551ce5117cae09187422b310f5f474e3e3f3fe10664287d7105230d80b1f5d6be62558ba9bae3a9edb572e05cc7252a9db74e0a749ac1571a6f19732efec4830c04276e6ce8e4ca2274e28ce1dc6506de99a2c35d9df8d5ce0412a6501b38bb21f80de42b3592659e800012eb6f2324bc38925110d921c3277b193f1c0e7a4d8c1650377a0ae1cd884bc115c6391dfebab7ff2454159d48a7be89e24e8c55f91deb1096b63b5e329ef0fd62944b0c105a5aa324fe71e02ed2f74a3780dad2a7225a40abf7310f18436d9e57afded17dc6f0684c7e4344b364a6a928a8acb186757f3a780fcb26f8a3bceb523291ee41281330e394576faf5c6f147327c717b978549f968eef7f399024e5dd7ac4721e27a8e0a47d0b600c3f12cb6084cd61a3ca20f148c235d6c89d0b8817c12218668c777d8bbe0994fa82c737a5a3cd0ba36be22d93cbe64a3915418f736ef1d27b8d11100b560fef51e49416593c5b1b6766d5781b12f04b31afc0a342cab8da16f4a2fc91bb9edb1d9dbea2388079124db5868efacc0a3897569be37d8ecc22d2e20536bb3e8d8ba12a6d858f7740e9f21c33cdb80d0d15e048319f1893e247a20c93b01ac72bd02ee96b4a410f899230b39630018df56fe05afa9cbecbbf6844a987775c5feb7de46a88bbc5514341fe7e9a1f9754c4aa9d5486aad868916e1763c77166b144c55b9b939a27e7bcbcf9e4b97a028249dc9edf3f423876dfabcc79b6f652d7686026cc7ac55cd52d0b7e0fe7030ac6fe9340799bfc1bef7536f6f2775b10451e71b42dfc6b9d68612767b87cc6af0f20379edcc46de9e2c04bc85baaf94a7cfc44d71df8fade663a9d172b93d0f2bb0a0ad4056543c3ac93d4e49dc43c1005a081c30b914d641d1a5c27407ab4716dc5a4bcb8112379f823632328ccbaec6ec3033c90f0bfd27933ab9e8ad3130673df02c12d7536307ebcf12a8894529b78dc8dfcd48c8c71152a87a9bfdfc5247823c521e489f072464d4f0faecdbdbb75c68a7f441179e9b72342cb09a35c9edcb0f285d24d25336a4164b7965bf2eb8933056ed57a17592b15f3ca4b2bf6c0569c1232242f8558411211f4076ea8670040ccc45d9812e63488afbb93f8aa6bb028d7a4b1941b7c58451e56369dd7b20da24629031a03b6d16d7e59e3ffdfffafd46bb24fd0c2eb61a42bfe12b123ea58f091f142be0b77b613d83db305e9121fa8c0271d88477aab509ffe420aa1b94fe867c989e5535bd0da1f97e2ede818713db9a612cb9498f81c417156a19bafc9abc9ba4c89d7824927e19af92c87c791e1eeecbcdc01a317e661d741daac4f11da830c390e47fdc8815e89264d421c2c907b340f5909a51a4e698a1ec4f058e489b06f4894982979ea5816159a3206ab6ce244cc1e4f9d346e54326c97311db99fdfe685952c17c76963e20f3ffedbf4a5f1bbab5167dc8378e38568e4d08304551b4427b6dc2c104a5d25c12b53c92391ac2486156596bb8f5a5865d00fa562d7476c7af42061310dceafc8fb142fa6e40606dbf7de23d35d2286754d30840b849c3c08860ffdf3e0508d3972347dbfd1ce5c8545abb20443bb7367fa8241273272874fa27e8f2158e61d826070599eeebe55e8373efd337a5b069832739a7d5b40b282749bdb8d7378216c5ae55e4f4c79aaf1e9df2c0923999330e4403e77f9f72d4f9baaf331421d7faeebbe6a6ba94e198adcaf241341a39ee7adf631f7f44a472289f3bb2ae9b92ce6f6c7bd95f72b0f89fcaeb49204e654543477b2d09ec956853f2f0d063d16975006beade4e6647858c2cbde0bd1302f53fd569d4e0dac8177ffa6a053c37269ac38ab5cca127f4aed3a56ebe655f28bd8c619e79188d32298e5308f351db3add8ce9ebfcd49476f5ec889109fffc10db58eeb1213ab31ff0ec9b0e98e8a580a16ec225e1ceef89cff00523cc6541bc9b8417a71f8deea071ae453b7cc78ed52ab7254e6fe79d4dc16f4a50540f0b94f9ed686a7580fb054ed9dd234daae56d3b510ec1fbfebe4bc0ed0b6069053a324e39a1091dce3ff1468c06562b7fc373f045588ac92301ccf6eb1d4dbd821eacaea1a7be9768e6d42b24301fd8a3d7c789a57f855a099da9b7597154d6c325383bf45c86a175d745e898a71cfaa7945feb9c31d0c68fb98c76ffd465925a7fb8a7be401ac3d9060b486450de9b4fd3c5331e228b8e5704b60d488b6411334744c7c790aa86116781f72cc6ec2576be37d69a71a77887c91e3cbf4dce35a2afd82bef9bf75bf4d26cb943687eb9bc95fa5f04c3887b52a5ba9624f8d1ff0adddd87092e3fc63bde9bf7807f97ebbc61622687b541d2da46204c799efa148113453d0d836f9628493b477cecaf3cdb7f7a8bc81d9d6e1a2b24ed07c1805117e504e9078ac3751a7eabbf0f66183cb0faa4f47ac68e3214e07157c2202cc6c3a261871c484ec05218218708ba451b9ca5a7f4f61451aaf747b00f54ef69c3a7fb80934d6e3f76ce70bf923bf69d17465bfb83f2967d1851b6d4ac454d621295417604cd8e7d209291d1a73dfc6dd1ed9c8e70399f8f1dc856cffcfad3c1b65778757d2bff6eb307a44688543044a3cc6ed3838ff456e41c84b02e287d5542f8424fbb521f9c4177972e87df38f950c8e4b4e6a4a14b366a4a2a27445010a4c34affbfc0e95ebcb2b1a3020eb5273566802f38cadaca2eead9bc8cf374c426cc86317a23d1f83a91eeb76bdeecf400886c5db7fb08e44ce0668d7594a2577ee559ea38f0ebc5e9435064f9f7490d07711664f1c4fbcf85278ff498b4c468eccd9e5460589f08af1c362c5bfe29c2f7477f3944904c9a7cc15a1c840a119c5d7d9d7c27d2c007f27bade4302121bc897f42e074e145cc9bb43ee5644a837d4d16c60a4169fa3dbaa1040d184305573bd2adbc60d530a3171e3f2057014c6e2577036011bc8d4af67518b0dd01edce2768a6618050e95a06ee24fb040b60b5141e9341182a465436cbab82340c2b5afb1fa0ce3d0997a1c2521816a5e2de8f73b5ed4168a586e2246cda5290209227f1d6ba6aaef639e61ea2bc2c0d6302eae788ec26b528a58770ab5baca51692e7e6b3ea7827714356ed8923247645d04be9b8ea19d3817d8383748b6b92a12a16b9b627079c9a4d45e2887c1efd215343292c988f6388559ca4b4c16427dce5fc1ff89570eba08fbce1b132bd0cc1115718de69265d58242535d7b2d537d4d545e0a2110ca5ec684ce6aa794e77a3711eac5cbf5814d843d32d15706b1ea708a5b5e3069e4b8d7655d2cd4ce3b522d1636479a27e827a4cd9795d581fdec2906099cfa2147eb51d059e63df325c8df40c0230cbf0d02321b738277703df74c19b12cbe167e7614de78f6fbee2fb535328ad79dca46788e3e093153095a4e66a323b1b8e9c16e28f1705bc3fffc1c873130e5445d20ea75df795b701a9d20a75c6c10f83091b32e045052548420d34e10cc4827f9630dd823be8aacf9e5ed686b24e562b611d2e0458a1f3a6adfa5e14f5a030510e62ca7b302b333fbdabffeb6930abead0c143ce1ed537c5bb24861d88286ec10564258c361a94668f9bcddc490f47c1b76cb3f78aa9926644707242e3a7f7b5d37c6106ed20db565061e335e96111fa71a83f4a6bafc843fa5e7b87f51c334e6d08f99f4dc6f80e1da84e577ed7cb01ab11f64bdd811d60588df29587a171edf1a5b4f6d4d934fd11d7b065c4ea1fd677eff13cde1eccaa2c3d0e3b955cee97cfae27d1bb0e9514a2ad754082682ca3c6e94d904afcce1ec05c766fe000d4b9a3d15bb71961933dfa4939c068cfd39b76c1d5bf646ef29ef61884d3028126b5d6567f5cfcf60eea8d47a35a500ae667416a1819e4dcf7822ace26ae98ca0303ce0ce0771dbbb804b5063bd486ca076f5e0af96cd1ac6df029060ffe49a5444d32df8350028afef6960a3dc9a9ecefd04277de389b89fbc5695ba2e381abbb37f79253e5a857b7f3e461485d74832264879bdff248786caea90c3ca6dbed5f7b251e2e71175743049ce73863818633813e06459ede140554bdedd8032f081e257ff0bc43455e43803d81817b91cee3f4b5da357c39a7fdf68b0c45bd59aa5b3f6a4d4b15ade3c9b300d8d1f0de8e9e3df3b8f9e6faf8908a1c491bd9c8436a0b1a803f7dcbe66ce035b6feb5db38026ddf0aaa14b89524299a6ebe5c0a052a24fd420269fbde2bc6558fe74a3ec7a333d705f7a4e7b803f7629391418ec11e45184d58adbeaee4b856108ba450c539b398730de2552dfe84ea04d10a9948c7f9896467d7b0f3451d2b05704d264e17ca02d452c9b1dd4a8764fcc0f9f2780f47a564d29f2bb6bddbdae3268f715b7e361439dc1894d60b6794e71013e848bcfd2cb64b8dbbaa864e9ac7dc583e72544925196c08d4b7d87dd8ba073835e3e50b37349090475d5bf3727b2c277ff09a95593f862b09e8aaaeb24f8ad339f6d16199f03e82588de31c6f080dedad886c63b7af7470c271a89e72c599dc44a6e3841ac1168a2a014340606ebad7e3ff3a3ca91b28fb5e64f92eb6317a8033fa96c7668f35aeb1a249a21833691da2529ed084c2a6ed50fcbc07c18b6fc6fd695d66f194e19f895116cd918294c52968ddcf5c253c4f686f059b1bf330d721e9dcf6e99328c933a3de43ae7a0b80129574e681e94e2e14a6ee8c2f55b7bc1a8c60dc76ba36b1ac9baf203a19539362df707b099b8b6b0c74cb67ff89fd28dc162c092813ff54b6c6dc3860e43abbc84626c9e9fcf7cd4245b8e0386da27cb606c8b740ab387b4bbc6345ffb1e006160b04b2058c15643b0d84455cdf6c4c6400c1667c686b38681093a4e2913d588c7faf3fe3d4f8fe8d3a7f30d541e741553bdde8801bf9902c3490f55a2b79848ee2bcffee951fef06ad75326a6e43a8f06ebdefc1ef77087afd4b3526e768da7367954082042819ca17e61da832d5641eeaca732e1c51f53e27c15accc960ab710afc1c2229b7f6ebb6fa11a7047cc96124876f9e2f1bd6640d1e98f516269b77498d07b6d24ba1f9bea13914ef20e36469316c8d2634e3679f5610a9ebb257351bde740cc430afd5ec2e1eb75e0d6d49371c3ca66b76171e30932a7f6604d7fbbbbc152e52a9171b9331b515d953d7c05961f63e2ba974e5523626a0529af5deef8c96e1ef274b552e031b06620d289a1e1d0e98c3a3cdd5d3e99c0ea2437337f731e0349754ada76d7ea11010e0479535a8d4b2f6eeced5ccf82ebca062f486f5e6bce6ca3c60b05d4717200fe760357a75e50a131e38ae337cea20d1a78d5b2a16b2d168c7a8957e8718a928c193857eb621e0ae3f3519033b2f24efdb089a6ab2bb82b6dcfa4ad06e9c8651893649614d60be87c91c12364822a1dae62dac96368ea5f5672409b9e2220551bffc5395b5fa6a50856a0e7c266618e025b7bd034528d11a9451c1d50d37f425e95c9088c64faa594916b856a228ed26656be8f2047481b4e632279087bdc4abca6930f479cf696ce23167753848b5210335485df09722502882736cd5ead1935fd65dff0b089f71f0abbd828a72739f95270342906989354700959aed0e26311a9eec9b76ade0fbb115bfc6306f85029ceff9565b64daffec6042fa9db9f23c985da679c71cfdab61c8fbd9475d98555e522775ccaba3f141783c01087e8426c2fb8e2355b1c66b65408928a4e73d74b19565d1299683561a4cc0c6f3c0d278a1a4b52c107b6bc257d89823683dd07e41e2bf3279145456e90f062acc35b847282f5f11c8c2ffceb84d9325dd3528a290c511158e12afe5f44056edc1251a7edc909b59d9658ebc2c028d29bfb145974c9a91d5883bfbd5ca36cb2fe6c7cba5e381ffeaf5141c9a8ca9b3fc72235be2fac41f82cdaf8f428dc1db11614aed787c646092b719dee10b714452626266b5a187ce0e5322e95da2730faf61acc4523d7e685bf0902e210d9a287f03add8acb216b582300dac24455431c8e84e3f1d9d87686f15e3f028b11208d4b54f73e680e0d2badd56b27504e95dbf7a28fbddd15da297983c6b6c711a5ee6c65e2c3d44e88a39cd81ab011cc7305b0c462eb2b66952204f4dbb9446f9571c7af36bd047f5e49435e9065c5f7acd48ebd546e7c650534b9cf47a8ca7eb7d40b1aa987707e3fd7ce59aa46fe7147e885c259cf14e1af315c1d2c3ea448c3a66a41fb841904e65934e222fd1692d525bfa903945752160626e52bda986bef354343450f01dabcc26ccee66eaa85af19ccad845ee354effd779ab718882e40d11bc7df2cc9180f600188e2408c86597e37ce574e0df19b1f148e2d3e9be1a6b5179bd7732a93fce411fb15a993d66d2350e346847a8c58b75641d19aaac4619c19d561b878bb9a6293b73a159a9353176d4f3a7a6633d7253c9182e2fcb31087b0ed9f2726d89ae9fa2cf5daf4f4a79ce2e59e82c7d70ea7c9474042c45a2f26a8502a7df254bdc1244b91742158ea33418c6d9e37721a0320ba23bbb8e3f292d2b5dbe9b260f519b872f17195a254ae54d414a424a5cf026fb598026f947bef3e769aa613e52e969640943ac0bd6fafb9324c51bd13b5f81fad51d2afd9b7380c5a6f0766eeb7a8a8150f32059b8416de64f777cd1f20dededb6a7cb1227d4c37e4514412f4b6b83ba120417ef2689f20af83a61f537f71e32e6d501ac1d565695f6113b9bc565438e9e4753ee7bcf68085ff55423cccdfd1beb78bfbc22c5ede22256824e797c98153e3bd8c55eaed5692db07420f11e73cd4ee72f642be2f70f8395db24c97d9eb61818637f28173758c8409d405d33f35de550db5ca073f7ae2759eb3888afb9893dabbf2ba14a27608d15156dd8e69f0a31361d6317e5f7d3d38f38aefcc5871d624eb55cbb337942de842c671d0c81d78bf61c12c558030345127ea11b4d0c471cdd645b1977e1a480aa95708cab320988b6779149eb7476d6c10e589bcdf6e1834a0197fe5e3768a1bbd030475b875d1a4de459d3c55ce15b9c41e7027f92f47ae98551340ee4da6fc00ee6b4da8449ee0cc50b15c5bfbec7401dcbe3aeccbb2440f1d7c09596a3e10a7c14dc41d3938003b8090c9bd32f0c87e93e437f5355c6ae3d6acedee817d52977aeb663ed6e025033779101bd2d33f7a37bfe62c881b19d44b14a2c6a1567e8fabc1f09c43c532b0306c139daa3a04c044e42b1188012197667b72c27e4532a0b798fe8720afec6a130f7c9010455790a936aa8b98fa2534abd00efe0ca992c7e0cbc92e837b7760fac88f2aeb9743ac3e2d143bd888f92390f02a439984be078038f8f9651c4931271d1983b441d66e7a2a2970b0821d18d41f6222ebcc914b3c5435a1783730b7fa66eba0328a464da1241849dd875ed5ee7902b18b15ae33de873bd538e1766775c81f4b6510aeedde0720caca5d11f5e412a241111710c35fd12e12ddb72ef6ac2c292a9365c0bb83f698d62e2b4113662476bc140902109767700643a2137a929de8a45e569cee8e54a9dd176f55907e92e8e8bb2acbaff532f954c17cd71e0085130689eaa3a01699493a2c8ee182a186d5d676c9c3927d3988a095530dc0c923097767415ab21320fee51f7600af81fa2fbab3005be613c056d7111340cdf1818c27a13661b71283525bd72be3e311e8e7322a8aeeeac1ef01886270b7b817451b96804918b55ccffc818b330f82c8c0b8bc710fba25201beca536c2af7de9e55b3fdca227882e3430206bfbe050005c5d678ea83afb907d1e85db1a2ce1f91e98bc0fe1ccdc790e214c7307d7313ce9004821d801abe0f4e4bbda956e04d84efecc86ec060bc60efc15242641f32e8067dda16802a81e58b38af78687a10b1ced8217ee2c9afb3b7e5c5c1d18bf84e95872ea5ecb699dbf9c2660e017b15c56acf68cf221eb5f7fbe555ec3f919774cc332db7f8f0a234af3738c8f7e95f53ac72830c9c09ba35d1d4ad60169e480eee4e735d2c6e4ce68b353ba5b4c46143cecb1ea4c6cffb820e1a48dbe0ee8a2b71a6ce0ee755b2ea0791bdb3e4802c0af2fdff6f5a482d787d381baa5d4f217db85faa4d7614915361e62af45541f91af318dd7b7c13081a17ccf5a293354376da2ebe418dca55f272a8f51dbbdfe641c0f375fc5e589031a57fff6a62ecb31e404d078101171b82c254ce905c1a36b923a85d7b89192f94dd24d012040c11cc92adcf7f76358601f508084a509749cf64390b06e4f09fbb281f6f143b4d0ce6360cf0841e4e96e303c24362dee53976ed60190bff69646e901569cb3b686c563f4fa495cc03a6d49b1d8e65e933b02185aa2b1cc430ae0654cdfcf38a674aef7c8fe85b3eeb5af7b2ba0249c9ecb88c1cf7ece36a29b7a525c8ae26cc95b518c027b2f59af106c60341d5777fdc9b4571fa1dea576e364b5c41ddc338d4dac820d2a4a692aa59c7942574dd54bc86b939e3390ab942070c05591b9a8039af3fdba105f4ba1eb461bf269973b2419d6b52e2b2196311e3784eff1b893ea672fdda61fcacfb9d3c76beae9c3eae4f98a2700d213e572789dd43276eea9a1efe1b797ac8f99fe6770e14b57556e021f071e7e7db18e62af6cae0e608aed75d8cc21050054c588400273051fe4b985a657ee7684e0952d63712e236d627cbc2b74878792dec13bdd23bb6b62a34b357a37b6bc71f0a1d65dc15218913f43005de6b37c8f94687cc70649d6a7495b932b95abaefdf4abc398f2cdb33ad9e56343facd73f2103382d146b49ec601dfecddd48528c43badb43185a8dfd627014ce8efd1e42956994bb1856e7280b0ffd21a156bf20f2f6c1b82c327be933e9064730c282f8dbd4f4d7c4f5928d4ebb4596aacf62308f8659d2b2a36d3c5c69e643202ffec52ad77a57d118ac2f414503ec1f5c1271d23159e5fe55a3832319f5d7baf53fd1959832f6115def2a6e1dbf9505933b5333a6a526e86bf85764e84be3b2508898ed1912503b16b195cb0993a8062619c47344655f3e52070d2a7b9318578f3746cd6e7b6bb0e35a69cbc861a2227cb344f3ae77f0e892093dd74453444954a6fa0f489d09acaabb2842e3e09f0a4a4e36443cb3d4eb7d292b9afe11690355e8e3ebecaad543214f4f0532dc523094fb24aaf8cf4015fc75ca8f8f90bb0af57515c5631c637f7651cbc90d423a9e4026221acbe048f6d8b4b161023671191cf9b2d089ce30f75fe444e3d13814570f7813d2aabf27eec6cd2842a2f439e16c645dfee64510243c5a59d94b50a1f93266405cdd80cd0d0f65a4babd0f66f9c36130cda450a9f814a74f60859533b978507f41ac305caa87c193b3d3f6727780092a185de2eaa2c9e0d2dcb23e44e9bbe056a108f66dba4e5da4eecc1570da8dc0da0fed527a4f797d99b2b41986924fe2f09e53e21d5f15341473e895122d94bba49630b399a85961a3799d5eaa3715a0eb25144557a058e9437984688b513dba57c962e73436cd61178227b9d9e79ef9004a757e05081c7284a46a409976b0003d863b1c0320164a4e4a45320273d3087f0addede67491af3c5fb7f7c4c5253d830520cdf023a8279b0bd2da8e700311b4adfb24623d49bd442775d0a82ebb8e8800100866725dbe1429836eb77be961b4c9e3ca9bed922a0e1c609edcf8d769544e70b0b06d6020f58bf78ca6dafe0a3a7e210000132d9e0f97252151b4e5772f3aa239c71e9b6bb2d51b1dfa73932c73287ae8f133bd27b953fc3a85db8f5cb7efa37cd64bf4c1c57685040f4adde3a8881b7c072bb87061c85eb58e73eca15da9e13acae14a817e2a7945f71ec3cb2e0769f233237d5ba515c7e4f65c4beb55aa367843933da7cf23412da572cce73d56ca2d42b97655ecc0394a542131b353059a260375bc7efd2c059cdbfd79412a98ce5c87f7dc2c1832fb2e126367c131b4614f4c7f9536c603f8eea8c16705926e0b372a0d75cb9361ae64a809e52f5654944ee6a6b29be692c29b8439f9f3913a826da95539186df8c504a4c72d3cfb27d8516d45ea7ec2819e50e501cba7a36d3a10a1ca080c6ae46b0ecec47032887776a65f62ff11937a02093ecd477a53faf308b61ba3ad58d2b565810ddc6c36f7c0eb495cf88d9a27eba4156722d5ece53a4fd196fe50a360f42f4fefc82e79da2004481b3d958dd8f2e962c1a89811bf10f43001623124131fbca9b6589a58fba2cc1c7364865267a77b81b7e8679262ad8cab6c9146a3b53503abb78283daa0b139cb391c729a9eee502452afb7ed4f42ac7bda6eb4b29aec5ae421550315fe2d93e58a594928cda7a121a3b2b4d6fdff19a9d454a7c0f31104d87d4aba4d89f56de7e34b8c128a7df974b3441db0d78488708476874d4a12f5c2e708fe1fdba629e779d2d563e4675ad5f2dd5bf1d793019c2bd8f32af3233d6e4a68a362c4a6b59ab8bafc5c2b6deda38166b6b37daf22279b13220c5afa8ae20884e0b06a7689102397c56b94b78f36236a7dfb5daadaf18819c686788fb233bbf6e383986187488d23139626876fb4f1ef5373a9f64fb665d053f6a905e6511706e813fcbfc50076921d44f30a5d94987d932a6c8fc4f1596345f80bf581c665176acd7a36cd83f4f1c5d3fe61e7582d347f4a1a5bab9cde016c960f3033879bddb2008d69c0029d3b8e07c250c23fafdd8e7466ab9e623b8916609a8b3df821ef5dbeaece1f3e77184f26ac3146594ba0b29e0f15c5779883ce5d70674be9c5f0006a7f790cd2b87008af28c8f22b4774fccd75e7635ca77ebbfdbc5686e83d3a6aae3f0187c039e9bbfe112b6b820cdc5f0b3d4a60ec3866b7b40202cb7251c92662a8f83dfbab4cd3e6edab92247b26f55b266013a79c54895e70d10c254f31360d1cc38468fdfd1c6374b68f8e19a732c1ae8b282ac724a0fd73a5eaba797a4a2e14af3bf394b644483aae1f9475e3dd0edf9582d643c2d1a98f98523d69739a9e613b5e85cca9718d84049ef0298ef1dd2db06ee77c7b727c15a79bb80d77b54029a1f1188d9e85cf612b2dd959360f652ee89418268377d222e228dabfee40029d9d53d51954f32c01bd6fd62d65401ef37292f0026b90dcdef1feafdb1c3028990e337b00023fb4dcddc043c9d98971028cb7f6fb6c28c9b63c67e0e9472abcac68784807e202b300ac4b45157bdb269666be37c5407d52a55f9d0c10e6434cddc8eb7ca962ad657b05724f138bb306f7dc85a02b97155489b914f3b359e09dd0b445ade97b2152074dad497091f9af157d98541bce6953837461f6d3d868a29f7c2e90f94c476932493a9829372987091d6bc58144c245f58b2a4dc3148d9b07299f41216240c6aeddc0fa59284961bad2d171c4e629156e249b3169ad3605654290fdae35d591ef32085358143d80122a9471273683b5c85487e180485fe27af4d55a890dc88d94461c0da623b9606434dfba1d1d375b4d41da5574c2cde5f9f452aa888623eaeddec94e633bdf8c9c2f03cb3ee10dd973c8f59267483ffef0b16dc35c35b39979555db75cf5147316dc335ccfa0d13c06befea95df57b44d446d5886a388aa756907a36eb6cd5c8e4860e6a5ccc8c615fc9a0fcb424cf72f56a15ac8e6a8d337f0ddcfbd76647a220b40698fc4e897308ba08c126fc16ba10399ba9f9a984cb15b96035aa06a1a06f85ee420cee7e7f5d700d06954d1dc155684e01fd3b2d263dd8efdc89fbbb8eaf5ad8c84fb1a4a95b38924224dce6d1a5d3ad19a2d72d4867c5c860c80ab8a87ed8c01b5375cca6191453c4d7f0bb358cd7e915722e522748e21f93cf768e81691b1219a13f3951d71228baf85c917280048d7cba139f1b3010cf25150d862f69a04b5a35d25a449d8ea876e2e95ea3550bb8c7906c6a35de541320b406ee927d78e545f5369cd40e890f94a767cd5f5fef2b7ca979495288a27f9a9e71b21a543fbd0cdc0096f3a149532406830ee82a5ae46e2e3d29196efa2a830876b4c44e4837d4965c526e530e6e45889e01aed2bca1c2e03136cefa7be9d64f0e2223c7e8780595dabbaceb2d0bcfafb9fd4a7f9d2c4917c36bbd451c274e3aecebbfef2c046b9458390723bf66bc18fcb2f643445c328c2f6e4e8b913a6f7c1fa8e1f92797578a547be1f346e1e8625e3ea6531d1b9f1758104a1f3a00fd5ec562ba59eaa5bfaeb5a20619346c90122804da4deb94d5be3c74f3cb9e192c43003985e2cffdeb6fbde1261f56a29de5a2807bb73c8d2f6d6a59a57fe759889fe4f91debcf80ab17f9949d8c95d63af853e395b9dad81a84c8b925c5f0772e997f0654534bcf526f2563f9d5533dfe473aa30e6462a5e83d38154b0e7a5b0c01d2755c5a1d1c5192379794952b6e1e5669df9f9efdca81be86f681f2c62fbe022f172ce51232fd5f45ac64e3f4b044bf1f13c61abb543c29f5de16d6da257e8bf172faeb69d95dafa73b422597a7c25f169ef86cd60c04ae526775d796d9be17e32695c6d404e8f1615e24fefb4731a4eaa436da17309f77e5a38d6d05f6a07792e6f97303dbf84a6097ffaab138dbd8c43c6e62089658c73144b7ca153053af237c392f2db08c5a960c7ed8d07e59a9e239dbffdd16d7a6a92f6a11f80e5d8d2be6bfdd455022fd7f61c7c39b9cb54bd47e5f1a77aaaf1714fdd3959f83393b3406a91d0f0d8c7913fd1445456eb96c3e7f618655a8389f15b421285976b20e696c3fc9948cb1b3352e28c5cead2c3ee28540764b5330cabb3d60dd08d25c48ca99823dfd8ee5902ab09c241ebfec2c54c52a26ae3765dfc56b7bc646ec7dda59abc390146677186364238326cdbf433d3b474ae7aeb1234fecfc925b2780d71a339d7fccc68f524b44dd9d9599a9706f566b8e7b0cfe09bd193dfcf788055b18ef6d319334d8cd8910b9f49bc65dc123c457515fc6f6dc9887b4b2acb96544dcf03ba57117d38d695b1ebce04e2b915de1082242d7656d5ac2339b75decee1dd3bdc71e058c2ba3de0b01202869b46f2259bf80fbc09b3996cca59fe76df8d650e04a3de3a62af9d2ac1f8606b83f03e1bb68858c8958dcc039ef3b930ee97ff3f0ef8360074f2124625b7e4a6f74c3ba6c4baad709a60a8e94df2c4bfb90bd6e373426df26cc086073389ed858b1693f53781e1fa0406ffc108f330a8391ec3524c50684581b465ac71ebb4395f7fc34657558e8b92c6c7007ef36c691acce3c3d37260020cb40b9bfe0b62bb4125ecc1878f62096f9811e54a6c589f0a131fb82117de5321839aa312578102de354f8a3b77ab21a4936eb3ca469f9f8e4772d2337a29f9257f95738b8678e1d355beafe41236c1e326788f31b206c4403ff77e9979a881f2782284cfc7006c4416331a09b77b92024fac6530c00e7872f36da84c5a3116dbd34b5a40460b1210a1db0e2a27d4b40a8184776af7eb8fc7f624036393ab604cc231b1e8187f8272131db8b6887a69d7dafded393f2e8e35fb83cac998c2d85be579ab9fa1f041bd0226046c701d5a71d4d677e22f04edd5692979ce95f58e30f00c92c480c7937767dcf6266da711d7a433a0e346ed8c058e085a7365bde2b8276e8f563e8432bf5d993b9800fc31cab7bea14b88d88086bdf9eff4f5e854b7cfd63c5d5defd5382fa45b2f0488f1d4289ab384b806836b2acc57913130562968c3c5bc0773e8a40105909627902fd9206c66eab29a626b31b6d0f04e2beedb74f8053204ad8bab6359feb74fc373657bd32989f9773af955d1f496b394f214558fa94d9c080ec92d704af9589de963807a496659e35bdbc1d6a6cb2cbb13589b27bec927cebb5bbb5c2ad890a18567b8be3252751db10c2b8fc82d8d37e6d1722e3b6e01ca69b22004915c4c6d460f14a65c13dd794abc91c7d0a4ebf3458d1409584b9dcc3a78781e07489a582eba30ac875edfd8cbeaa1810b37fd76cf942e0b368e1eca400664298e1a67b2d0cc925458c499ef16dad8afcc92e22a27a316a7a39bc2ea980e8d52bbf3e6e4eb76d847da4ea65809ef92433f10ce6ef673ba1f90de2ffae182c30aea78c051183627a0fd6eb64e3b8a55d838f5bcc966e213805b26181e911debe717f7119d6150663a9769c06c3ee26d6f51313c454cb2646b096e832ed3c7433fc4a9fec826cf0555d8ae7eb39f05e43ff30a6560b48f7bb22ed022a5ec7ef09b92b79963156c5a2f7d3cceddcc404ad22044cf4618338b2db76351ac292dccdb3dbb63135157a2bdd00db054d8fc78aa275da20a1dda38c9d6dddc1b6233e38ba544d927e375980e88e9416cd1484f2df5d935f1ae86139631ff5774b4ac7d9b764dda5c1f699140ff1dbe8ff2e9b3f3f0b9caefc5bca69e29f35b5992db4cdd808afd77b8d66860348ebbe79ce42071d9b995e93b2773b11f1e19b166892f1563199cb5d3dda1801b464db6cf0fede57c72b05a212b94dcba3ffae4d4e131c77681c8e44be288f0f1db53c908473d2099519c6a335bf192833bab0b489da294f3388ccd1428273a6b8820127dc326c31c4de38fbb0c5533d55629b6b3a0f4d2855bb3ed81072d8003e659ff7bcf375d70b7984cc70219a83140ca01aa4c234879932a3f9a547361a9c6024352cd404e586c392de891fff60682a6f93fbab2f611ce8ca44c2b90538123ee70fc7db947656ca69b674f688a95ed1bab99cdc1506c439f1a48f2d3199a134a224bf843b44857822bdee1e57e1b4a143deff24d9b35ec135320e611b28ed6ff933790cf812a0e574e6e987e091d0cce46f9b5daad90b062d4bb2b02c5c2dee4ea51fa0a8671231b8f1f2d11cf8da7bfa218b7fc92ed7fe85c55d4a9a90632a6e1823c4cd5f08efe4c1986b29dd3df6ab09f6cdd823ef137bf9b0b804f2c094f76147a46aa999498d45ad12b9b60693bbcd0ba32fa806f2323ecc09f8bf64c7a6ffbfec5b31c58544ae9b7f8784d33d4fa2673d97f1141f671d3660685f90ea4da3ff6735b282e8d949d1e6d9a094878872ef2eface700eaf11875c26d3c6f608cb8f1459f65f5d3f34563e8d4a7ff54b5197f310b6142f387074877496116c8c49dcad72834e21f8dc9d65b2c473d363ce267941e9c1a7adb3fc0d07779f706053d40c1471dd0931f0f9a2a4580a9bf776418e6865733e55780fbfad316de089fee6f176253734926495dc2ef06903ecf285d71b92dc4eb8d446a6e28cd596894d407a5756a48df350e41aa878fa07d54071ed69aac688fd9f59398f717cbf5b607db7e9dc59dfa9921dbc009e65b302bd14ce967383ae9b8d5ae86fb4462bf1809c975d786203675b5fc59cd1bec1c86b0700e7f7621e324b21513bbbb370b63d9aafb57f03ea234691d6b1a8b45ab96d67d4b8bfbb58742360f6f55e6162c5363b9018f3204e83ab4ebce4bcc513b81294529c9478682cceabc6b7d32c2a50e46e352ef97b5aa895db3aa825803599f9bf9ab27af1911b5b5285bbbaf034d35926724fb0b2c59e0d749284213f028f28da5044ba2794f792fdd1fbb6c6c40d096400a5ce0fb3696ee73de2b43a289a5a93499f6a29cf35aecc62e21e233fa2142075a4bdac737c82cc248f334e9b6936006f7ec6e947d96cc7d67afe63347b43367d72e153d3aeedaba261d1b237ff1e1fc52bf14638f48980468214cc3ee12e39052e0760f0954d973328fac2e4eeb5a7767946585a15e3a38fe2cf34b3da829dc95012a12316b9482e94398e7077751bb02ea3788258a7f2dbf14bcd43505fa6c0fbbe9f4448a78542f206439e1bae8aefa72247ab22848bbe026da78b8cc9a57243e7c7fa84048db53512fa22b0afe5eac2f39a2cdf71ed5dbeedf67f31a15dc19f5ec2b0612d1e54fc3174477a62d021554b0438bab44f85453421ba0aa266b6f46353c8cf3bf559c6731c58766788f51eef1a9e198db82b3067566c04cc59ab52f24e0db74281363add3da2f5801b25a9bb7709e1ab388483966eee37bd34c3b4c6fbabb33063520e6140aedf1c6e826c2d614ddc7c31eb0d41da0ed63bf5812a8ab6d935b9db9e5b5c69b4cb7ea01dbf62f6298b376a639ac581b0aacaf55a16eb5a5ebd905e62a3db9a94b2a21299bcd408cad36792858cf6f47a8a0ce70ec7666b53fd3ef072f30b04e7a833723c7d2313dbb70941d89e8317c973bee624a4d5fa4023926e3f4dad107bede340b001ba4adf12ac1192165cc66b4adb043684ae29796cfd8ca75c0c30cbd335e9b0b6317e4925df6a1ab04b1a0581e0d7c93aaee0587f9772786619496003320a084ce258b395565e1d8a708195b13e7ec1efa18c5be98574cf56afad06e8a4dfdf2d2b0066112e4802f465639dc541833cd6ee1c0119f90bb686c5707a58127a2a3a94eaeef959aa5c43776835daeeb9303aeb7e355da1addefea34ec5be91ebc672d6fdfc8eaa29dcacfac033b62097ae7c0cf0c499ede5ca05ecf21d8207aab9ebe6f7fd2afdf70b36d8bd65818ee92c6d7741f8f4dba066a5a6bc5ea6bf256caff39aa955dcee371b2c64e0a6b4e9dfebc7dc3057926d753fc9451d50c46d120a5399227a13de545dfd144f647f1e7547f98fb3862ea22903acabe2de9587b6a1621e6526e352f8dc6037706d972df13f51373b4b8df4e0f3ef193981db93e7d9f657efbf496eb30bb334beedbd22280fa6fc8d896fa61c57c421070ec0fcb0c53502ce484f8d02325217f0887525ed0c75d47632090dcd82211a386b29044d1c3af36604e1a1e922b23276a74718533b37f4ed2a282eb63015029f29feb085d997f3e7e20848799ae2ffe225144e8a209e39574c28b0233db6c02bd203f4c22950233ed550ad1e34a96b0675cf29ac9cf261cdeba99e9d5a525601e16b6c29bae422e64b99f8b57f39b55599f3daf5d24b63fd54609f46791dbb069f68a93b5e0d36af69900ad1ea9141b4c4f25cb7e0fdc8fb5a261c0652ea4dd75dfe871da246188af2c302ef08f040c9be4e168cc07bfcb4fa5492e377c12d05c8061900a71eb822e60ff65c19cc7c78d20b6d9d30e86fe62fb91ddb182792d78224c70004141222c4170eead42f3f2d7782d2144f6727542f4c002bd3cdfd9b70563aa671940573d2f7f420f9dfe5a014f767aa1650d8fef32e691e9236330d7cab1cdfb434a6c3e48b1aa56a76e4b6f1eba2da2effd6169fce88905b7b409d4936df9bd2e5d274be2fd1d55be82e327c6bc76d9424e230ce26c419b56a4c837ff3bf5a4ebf14b1ce6294e9aa9fe32d9461c64652dc7af09acf04c62e32689ea185f172d272667e44a1d9fe35f47869bdb38442ba5ed33be2b6ad4396fdb6a127430a8dbddd8487222e63bd1952ab5bff7daffa7ae8d14f5d1c47e54d5a94b94a46ebbf9bb663355cbb122fbc7118abc8b3477f0b281b23ef21e42865436cbd0b01619443c631acbba66db8834570e1776df913e29078c84ee7d0226d8eefb46c667e21db4bbcdec5336bf026b9baeb555c6664f513864dc272a6d095a9090a9feae4865f72cdb41beed1567c5b5a18fcebf75dc8fe1b514a3cd1a04bad64c93ed9da8d8335db2064c9f183cf42ca971475b810310ae476ae34fdc6ccd7ed8f63dcc5183d8893877b8ed494fb462a835f66b1c3c5dd60e991ff14e940ece20cfcadb915bc1c565889ec0f9c45e3719de03ffc836a40581e7ea962693e7515099a35dd949ff332f40f98e1ff773cd15299a5815adba5f08cef04b331cbec9cd88d6685cecce4be1afe274861a5935c600725db28da855af5aea07b18869b5ce42ad2760775d3eafb8d50706c9ad0a1fddc5bbc85224134010127d137184738c56633b1a0bf8320258a13938caa0733c917d8aaf436aa0d6afd6799aa4146a464a53401748f0d08a82afed91c9c78404024b2701bd6a206fe77eb3365e0b069081e84d63c763d9b4f7edac07d6264a07c31d0c3f247bacf78597ff3ee073362c436e8d69c8ed686c9bb9a98570a9214df259f21a7ec8329bb97f34012ee84214d7222ae6e23e5ad07fce6228b729ba0016455da72d7dcce783fde5d40b3b10698f23b8eb1c7e1fb16b59331dceb7a345810fd5a34830a4fbc74928289e6a86256e176d0a56581cc47d267475b3b9482e63e3193332ab896ed1583919960a6e3a7ed27d0de013f429aad9b335437026c68285a25dc544046e073863330516926fdcbf31353cf1be983c86ea6482ec1127c26c5e04a5fed5c3f80d8584a1c7412a0ff3c11767e7ed54b7595e95b1327a64b0740c5e4ad13437b8dea158ae0387f59757fe381ba584288a6fba78a3b80b48b9473d2f3c04fc603599eaae7efbd72905e233565946bef6e6f038fa50ce41ed863f7910b849a934a79ac7ff0edb6f5463d8e3ac1ec4643a3d7657f5e17dce153b1851f578b664460bfd9bfd7b9608e7647f9b3ddbeaf41f047461a9959278b0b55b379f8bb22c240b2dea2fb9b95b037561e38f2e05686a55898e25ab4167e0541579260e2d0dad6058fa3acb636d5e0678d39db14fb5373f2e7966f034143ceb46799699ab9c09faed0438eb50e87feec4f3271b374e87a73a59bd9f33e12fe812477cdc340b1f55e9bd5a9f53989225d70853c64729c5afaad8e85b9c574ac56e9b26308ca43b9cca78ed91b6c8b577c0614d558ae9d3dd95a5b64bc8e4392295fa59e1cf4161ca414a86cb6b0959916681e56b7ccb8b9aedc5663ff9bb3b4e70030442143c15a1cbcdf5c0e038b7a1f01554f0c1a680b58454797498525e409ced4256eccd11e6f474977f5e20cef511831eaf87273a4d62380a18c31ce7789daaf6e309bad6e03425db509ac126f16225bb1885831184a8aaf11eeb757110f013a42c14dfbe09c3b58f8075262cf9a29c4c7536a91e01983e89a3cfbbc99035e8547845abf8697baa6fe41ae28b1acaff336826232c79d8c0f361e6e339521b63fc149c86f5bb32a035c793212c964328428a4704ec6610af377e27048543b81b1f46fa42dfb40c23468d36664ce2c2fb94c981ac64749f053bebf433cfa167a16924ca53ed48a5f394158c815e4bcde63c9856148b8de503199327678362e917fe655e4a1fdec3b752e7c4eae309b65c283e91ce6ab9e7f453142fe8bba57276958e239a254d5f337288f252589a3f5ea7d28f865ebba29eb79a18eaff75fa53b64529f51b94e59a580ecd83356f76656d69145e125350c0149f524466690e1a38d53722e07bbaf3a42dee9c00e7b1545d74b11be68beb72c1550d49092afd306c24cbab9e4ea66b7d9c615e66ba8852998a3e79da4f98329a1828b8ec3fb170bfd9baa706270fbac0283d0d6a7e06fb97866595e37a2e4e3f4b8a4015f8058ce70e1700a8e128a02418a9a617bff68441d5861d40c2a67422f7d4556c77f12d7f41fe73275a5257667ba9896fc046cd9023bd6f4013592ae2df40f50f31ffb077b8e2c779c727216d6e0323be629815147b501680219d6839eab7f75924983b54e08d0044c8aa3bae9845564f984f1264ecaa7543a25bdd252d603f3869abdb39dac02079452ddf31f35bf2ac5932ab6b1b14245dc401c19275de8750dff475711082dfbc8ee78b67389d2ac322a65b4056f7402bd23d05ea665f745cc026b626b7fa38b2ef03a2aef7c47c746bb991300ab530791558c9862f06148531d1e679c79cd89727bdffac76ec3a14e61d42713d9e94a8e0f54d0fa3f377e55bd7b82366568fd615a74931e1cd7d0f065a606e235b36bf64b2acbecccd6e6a9d2935a8f7b474673e7e54373e6e6d3cf6493c90d5cd0597a20acda458c8014d28832a35361eaa7526eb357378963d88a4c98f14c27908b9fb99384e30f5307c900902f55bf138ca6bd17d01cae032c40dce310257f2f9ce64ede23ab2990b3679d10d0ea7e036f5c7d66de0be1ff06aceab26bd61c7b29a6457d654a12ef170aa4e722de43bdc5e575d186e974f5463876af5cc0fbbd9093b468a49a62fbc403225948ac04e1f31c89609938a18a806ab29cd1b274d8d000f7a96ad45021dfff2fec324f449de0c582407e76f695237d51270cf7bbac5016c533ac35ae6ddda7f25673dd70aa49d330bb3d6d56e4d8571a6238203b303a5c30aab80b1b9ffacc8a8ac26dc1cd37550c5e549d0a7cc69a45252a847da1a058ded4a94cdc9163ecc414cba048c4c141e7f70df5404e4e9d0680af210872acfbf8b0338e7efabeb6a495f6da31fb1a393c28f5cd6a752b97a84081237a65ab4b17e3d0278e70041421731e7f3219d2957a99803af03d9f48988f34a6c47371330f85a1682abbbf4b174315627c362c22862944d1d4806a353781ad5a8761d7fcbb08f422345026397e0a1d74790d766b0cbaa596c9961e01fdcc9e57aa7266d3c1cd28f8add734ab48d53a6c8a19e6d4b3ad5a4ad85bd6330d50c7ff80df38b56083b015886892a3cfc688ef2919a8ca461e76fe42d52a4c04dfaa438fd173e0e6d921723be61d7d14154374fee617a6d2e2ffbbbeda8dc0bfa472dfbb5ad5acf7471e0e796fcbf03b765cedec2a2ec5ec7d4a8175fe2546e0fd353f3535ea75517984b0b4d9de6349a35c21c434ee02646ae09125ded912ef3dfa512942aa5226c555d723a076cab7c76a73db69bffe7ed640230ae6c352089264448cb90039b8eae04d6efcce50070f9c51980945ad1ce3a012545f8fa56d0f1a670c10c5c8bcc42f589d50678cd47874972b61d21685757994d4ef7bceeebe5f202bf4013f8405ac12cdc8e2e672525367119977f6f516fa5fcdd7c0a18b0ae4e34a1ec01309f23a81d89bff7cc83204ae14056395363457f2360551a7bd9b1498dad1a99b0ef7a60d13c85abddd9dcbb5459365a4dccaac9972f72ee39f3006e946a16a2e17b8aba9be51596a0b5184ad8d6089212740be856924d232395df8964eff3b308022922466845b786dceb3dfd3c90f54068a845ae2149adb5e7afa11ad2160511f0f4afcddef5490e36a2e8ef8e3b6fb1e07218f13278c857e05a5f4835bb1040be2e88f7c7cd6f8cee1361223228802a56c588ba2231b8c23fc4ecd87591ed475ba26e958ac9f640d29434474fefc49141b824004c64c70a6c782e9f7e0d30a4ad21f260348570e6d610d9931cda97f64172ec3bcfc51c73a04970cdb08598f0f093dc3e36b102c2438d768727ec2a1f04455c9dfe53303344f69d5fca775d1d6a515495213f984e0eae4e7cd996c6ea689b7fe398238242102a574b7c576f8a55ddcba578aecd53796cb2dea68f2ed27eec9cdc0d9e0febd5cc5dda798c21258b75f57d5fdf9f32ee41a90e38b8d75b2b75eb240ba36e81c4703feed9335c871855ea0f1810da44c56951a02619f6af952bbdef24de7a2ecb09d0e1457000c55a71c41f60b1da71576a72aaf2b167c5deeac98f88dc01fe943f46e3bcdda32e428f34a56a2c0498b71faca248d09daf739df506dcc54e95b41308b6c081978dacbbeaf759ee4796fb5d3b3be5d8256a2724e31064799cc08c8a3094b8eea2e4e059b49e898501e785d207f992504914affe949e8a112590df7177ce7797092b4888a72879fea6e233009cba036ac1798901d437b7c3ddf4b7e1f84efb846dc09d5b547ef52180e5e11b063e873be73c8245bc9fd4c104b180768793943b5deda55dfc2c2cc593e2c82aa4d032c905c10b3d28a257668616feaa39caa91788f3aa4f655be2be8d0bfa592cfa3f8145404429e3b2ac654d6eeec1530f5ea7d0667b186f27b2f5cb622825fcc743c6b3392a64260ec8b74679b2fa420d8c8a1f3f6e43976b81c825f5ff39c8cf257c52015c8dbe62538480ee069bb26bead8b9c59b8bef59766802b1603e5861e102891e5de61f1ed0f6a5c0d0eddccae6d08ddea4606ff3bc70556ab39da756c3d48833b6d0a5fbd054eb638a05e19061b2efbdbc85a1fef2fdab3fe49c533cbfce445c93d876dac111e663313930d472f853c747adc9a3c9989733c42109878aaca3e2d132d5fd94d0e0da713b847340626472e590285344e7509ec084bb00dc8527c664e2b9a78ed520bc0ca9ab06eb2b3d34fa999130caf7d022f33aac11feee33b2b3c55b95f8f04a87f5fe3ea1de75f2b7a68e9495b7606c567c1560891454ea70129bccc3c8eac9c0ee609eb684b40288e06344d511aa3e8804df8e76128cdabd017016a991b459d133a99d4284e4d3289f42dc4b3bece07a1b3282004426b8856b4ac78f8dcedda92fb7e106fc64849812366487481e53a448e7d875e07ef6bdc669ac331d454ba90149c24b4956918e2f0aa6b040a2e5eb1b4e04928997bf171f42609cbeb425334a33353ac7e678a000a8b2c35159214c166abea17ca9baa88e9fa49f5dbd9e474378dd3b44d6d32028d866c7d0755277e3d3439992b988e88e189b4a711a54920864be831c0cbdf0c3244e62b33a804da7b27c24358941ef0d21e469e73dfb95ab04e3c2f68b8cdb342b80f93876d92180dba23b240577a7c561bef0369cce73ca067c985b553aebec9cbad05977f33424ff59cb0e2102becc4eb19912db25ad07bbe743fd9295add133a80977c10a07495cf988b50fd9476f3faf9cb0082dd3d7c5598d7674622d0d66634f4dca01412009b472b6d2e43562846df82e0fbe7446bf063d5aafd7f28cce73d1d1d30a5ab4645799255de068f63315f2134f0b84702fbdf15415f44a17b4e74ebc44f29b3d372c30d0983e1de5173fc7e6d933834d5c391bd0e2b7a2361e560191f947cef25b6aa51e4becf4afbb610e3e1843d236980c7ca6c41264a0d9da5773047a1446e9dd51f8063d3e30dc5536fd45fccff403cd6f4fe4016e1d9386a7b707d1b31463d0d2e1f67bb6bfbe26583ec86cd062699ee2c317e6837fff2e04449154f9fc8b07d9b93b56abc8638711e9777b79a6d437fec5207ac77c8ad722c6efee6729be6cb21f9ee1a4710d5a8bdf167ad36a6d48b636ac5daecd0b972c85ef3450d724425f053d94452325460063206b17bfc7385fbd9f983ea92b63e2f31793e9ebdb8fe0cf25e80aa0bd02124417c3f8f71fd6b4943169eccc587ad9ce4634bd893763dda955d3bf2ffd68a53bf437954b769f79891fda3bf3a76d821a1e057e45a828317ad6bd0014c5c84b1b8e448fd6224e4fa0dc37696e2f379c1925cc00e3b20814e9d9561e31c7768ebfd9976f13d2d8d32030b0de2f9313f8575fac2f4c84ed59fbdf0f0555907e82968b8c563efc9cae02b009f0ad4f4ea5aab31d3aa08d51797523468e0cdde5804ec049dbd6e03aefefec3f31efec24b2ed65148504661d1ab639400a1e899b9b213b41c986149a379af7ac06ca65476b85795942a7593c121bf59dec3bed99717a3cb366184b0634892cc286df590d0ecde3474484bd811a1f4e89c8eac34da76d7c29ed45449c2cd13bad06c9b7a30bea0a08719359a1b4b5aa25d16d7daf7bd0551f92bbdc93a702bd61c2d54a3a4b46f9a572d0e8a03335328b803183f4b9cc99397f623dc9e115a4f28c9a4188bbb265d14de095d15162e296c763aba62a55cb5c48a8f1bf020093f71ded8d6a9c42e4980a30dac9419af9e3fa381ce18dfea9acc50143241cea56f95ab5b17ad4d4ab11bc4f7d7d51dc4ce88304187ad3adfaf27734fc7a7fd32472d9565c0ae69f2b6d7d546b283d43e503a296c93bdf3ba094e1db464c984edb740c2e49c0648c7735f22e0863618a9f1e448cf8d7152929bf0ef029472cec8ab664d860030d9920eb64d0a576977b644c167c71fa820ae81168c6fc16bbee20364bea54980c72eb79ea26812cfbf423ae6e90210761212e69b112b1aa1866de8561d2d76a6be42d5f36035c75b9c2572e6a5ec5015de98ceeb2ba2fe88a2f921ada8c70d9ba13bde8435ff944b7ebff1d7e605b31daa9537d6f29a46c580dee59aebcd55aa2a2940cbc5ed4101eb08737e3b8d1dd129245dfa91661659b9d6c203fc8525ef1100df6cd7e60a8646de6efe94c66b252ef12d4f3d19980235033847f56bf5f9b26386f4186550ccaf29df50c8b095598b6f21ced71423cabbd6190298b379a268bc44f47738c9e964ee8c0834d5201f6f76cb46bea970310d41e96ee9123991cfee0eefd499cb3b6a3382689ffbbb5e4e811e9ba6884b02b0df1bb05098039703f57772b2a60d9a1b9b1aef7b17861ab57e518d7aaa66aa69e6684993f4d986886ba0ecef48126c865bda4347ba88d38abbd58b2f336285ed21f05f47dedfed4acdef415a48f1f80528d3db4704ee31fad0f5fe7fa0a62e83fb2fced6f5e7c1262897932456b14ebd8a8990a0095304a431054059f0b6577a4aa9dc91e4f92ef3c1c18bd900402994e5592a23f6346c368baf77fabc7302efceb93eafaba6dbf2b32aa8c9a2cdbeeae1fab20a135ef1e2b15986a573d41eae115acc46df0cccad7f78fe6e880e062ddf0798cc59e2ffc1e53e1f434105cc6b6be9986fc572752e37d746fa96bc5919786f6841363f976332434f953db18644f68d4f62a9da3efe9952b277c843bab08f130d89ac7a0a8723b2b61b4e792c77d50987405e09a129fa9d3a85d068b8911b3edb7d7300baaf989161dc857e5d6e07670d7c366e13d307cb8293bee61553539d72c235fb67622ab6207a6c6ad83bb098841267c56822e6360cd782b236eb8cb9ea068545bbf04712e305e61376c9d7326ca9764e11e4f3ddecd0433699497626af6c5cd826d9642f4a7703ac9e51e1c757cb07bc2e5cc00af9e892a141c8c2fa20ce6f45e8ef65517a23c14a80cd80bea611e56d82d0d23107b0c3154603aa423b5566424a5439e9a90700a50e788e40fc710837b3a0bd984c4e82fcd35ab3cfb1d91fa0581ab06599c5644cd6ec488d2ded6f94a68f49358556e0dd79457a105a1b2307ebce12b99ed8f878badf50723b5a4ec57412b92e441567a06342bbd4fd084f3d2134b1fe5b6a3b06b5de9fc7e659357a6123a4ba443cf3dac97508ca12f6b23f88e68e0242a2f840578aecf416dce71850b7be10266e072ab48387e6d0ada1562088bc51123d680fa086711873dbad0b4abb9faa00a6db6b121d47ba4f9e9d8109ab2d123146d90d5f18a4be966b62df93584109be7a86a5d155d481a55a3946c47b35052623e5347840e492c4f4afa757a262f237441388e24ea8dc113ddc5b4bd154b4b18beaa9368f8f9be69f404b40ea4618b62768805de049d6f77f479e07d0efe4adc1a482773f682569fe3187c7af7467c9cd6a8303af1d80f163e127c61c82738cadcd2f2ed69d612cf00e47cd56cde099d5e7d5f51ee690c742566750e347e2a2b87f954df3831dce076984a64d4ec4dd46d6908b54e44884d33880ef466f4b7e6b0604098dfc8488a2a6713f9b91f315d8e6877762b38bea71c6017e579bff6ab692ae464087dc9498e5760c5a0ed32a913d1c0ec1723dd4b1e868249060e309da3a24e0a10482213c87b9c13a5380bc7b1d8dbad70616231d8b6de31cd69c6bfefb0f8a2e1ca8ff7bbc71676a2c8b96b3baadb13b60ca97da2a0165186c8054db500602830fa93197850dbf95ca65ff3e904248135c4cb747bc8532f7486ad133c8a36d56e4cc0e5be31d338e356a082300c1373a18cb757272cef64b5038f1828ccc436381150b015ae386e4c712559693420522ab38ba4c213a5086e2f8012c09df938fcb4641e4d5d65e7b7ca735667f9c7961c29b0e71695cdccbd4d5bb9ab35a9d8532da59750e19ee30b778dd6f2e4d89dd83fbf39b206005c12f04a611860cdecf014063bf2a1065f30735f432c99b9a68e56cfa0e25acb3f27b7eadb1c437d2ccf90b4f67c4eefa7fc558022a2d85a234fbed32fb665493701452253739a6447cfd65f3d935785ab1df803f98d0ce931cc0c6c2c972bd0690ee8a02dd7b1c26b7ef2230d30ff9aebcae7186f1202bc8620c8591723658ecccf4490b4ce7d18e9348688b40f54287d534955e0501667f0fa071e14fb1c2171a1ea3f2f3f99a0f61dcdb43bc3c48d04c6c1a003ce5e3fa8edb770b9f558e899d1c3335e8a5480fd17a325664b844c803d8d4d616c08b47e764dcd2f3888dca78e9df7a6a7655125ce0ee3a5f8fddf68179c8c3933b785db77d330a37ca08c6c3e60469dd24efd9206c53a5b54e685f9b9a7078d2d264edf81ab08468bf6c3db85df15b70b44d5e5a8bfcfd924a79ede72bf29ded8cdcff107ccb5383f4f85e3b54a07207afe87f801b3a472b55fa4b05318d1124fadd7d8ff5eaeabff21bb5e68f9e23a4d5db3e2876600498c00729d3dc95ea77e0875682c311ce23a2a8d1a1ebe51759baa2d2f69f3986df1fc6a921cc898fe92bebab4dd6103211e36321fe335a756ac09474f58f0249bc0618e0956de4e5fd6a62cdb5fea9fb27b359d943f28963d3fb7adda03518d8558835a449afd21dd3fdace6b73bff0dec83e95299606aa2ab8673a817185fe51d20fd871bfdbcb0fa19af5a3573be51d55838b54aa8396fdd542e340ac78f036b12cb5381fe6bafe29496c403cd2dd86a5f215ff3cd84bdf4df53e661dc95a885b0714f7327151065ffdbe8bccd89393e84e24ca3f276f2108970dd401022a19cdbdeb5e178ab4add6fb90ff0795c5503a0a0dfde9cd40cba31009644e9e29348233e4d8f3bb063b228409810945a180294ecfefe701722044873d4d19c813322e29a4bdc3189125d0d34beabfb3a889232aa1e673561392c35fbd1845b8a8de8070197c866c5bf5b218074b1df183999c8fc85f19aed827bb7309a3d04232378de0d739afbe66b23b1858fe406dfb189e34f36650e5da9b03b394c810d3eceaef6fa9d789893543a9ba983548477f23230866f0beb40bb28a1483b0a39fbab14c909ee48fbdc8a9a91c39699f32f3227bc121e6a06aff9becd8ebdbb45f23b9086b9e5a2f8fd5a61b943d8d21443e5648d06179611c616a8843422e50183a42a097504ca36a76e34c3abc422b4d243437e5b85ec55b391d504096a457fb06b7cfcbe451e09d84255775a9303fd664697de6fe6b356f981defa127af15258898e910441608ccdf2caf760b991b7b0591a3f7c0277a81ebe4c37477d306b08ec25bbe6222932609d3626c166035287d5765a744d181dd74038fa78e38e1ffe30416cbc85ca87898937018abe89578abd96e70181e7cab666fd0c00b8eb427be3488e5ec31c490f08e09fd2e3acb9064f2f9b8984f06cf076a9e4916224c396aeb74a1f4e3d724a5ebbe0769befa8eb50ee86c0f8e15e1c22d37d5b76f1e0fb8b76fc06aaba686bab9c4a2ca6d9da3804bc2a78da281fce16a6dd1389e3b81862a924fbf6cbb19faeb834675a1bbeb10d4bce35eacb61adc2fb61bc7141264404d4618acac837813f1f97a37f6dafb1345a611494a1cc025ab7e123c4cccc83ebc725cbb48ac665caa230ce4f0d80ab0d2769fda350e77c20236574b4642de0bae95d8352ee667ca958c4a56299202b9b665bdcd1600faa8f0c2530b643b8d97fe6b00bf8ffbf479178e1661f23c602af48f44d521333b563090dd0c13fadf419c0f0d7ca5b6e38051475c87fc27435ccadc1bf233611c116082416fcc1a126638bf284ca2026f6041ba6e4b038f89adf25160373d773f8f0e8b15f4d54aaff1467e037dd6f50c0a169d5f147f03f384243f460a6ab16d49295f2cc2061e1d9c437a2abced819be3b2ae97c8bf44b7f504ac19aac91127233b8afd2c4afa1529643b91b1131c0a4b4c29240242ca217416c2c4e0cc6f7694789b77ac3146913597881e04627c361dc0d36707762de6dde3b4a588f8c781aa3c6ea5f705a243bf30641da85966ff6ae3779b0ab9a38c6f9e0d5df4d0ece0dfe0cd4ce9cf0bf2066003b839c641ad6dbec2ccb65bd44adb6b6f08bb7e38bc59ddeec5980d35e6adc209b94c8f4c7dd5eba91ba21b4fdeab15a6bfba49df15a3ed134f8b001a5a0265e245caa9d9912ad8e8625323d9761b2fe7d16218a739ed833117fb24f78b1b89264145db1de6cac5d82d7442346e7e3e22985e29604e9f37b3a3261aaafbc207a484e04d895e15ef68358792f4716235d826897e2d67c52fbcd649a170d56c894d2fc2e9052fe911782be561ec98ddff7f734c5b42c38b60701cbbf5ee2489eb91d32333f1ecff4591aaba79026b1d9d59469a0ae529f9a6ed608cf52e74f5770e6dcb843cd6224f598a9ada3fd41cf14c5eb0974087af5560f06adce08d002736dcd804c07b1a903c3208094f0a30e4196a4c689fc1953b9c304b1199df76ede54db9824ffd41ede51d4ae203ef6341bbc93d16808f09af9dd1b4bfb4e0facc894963ad0960a9670a4858fa20543d23a15b0f3daf39824858f638284b698658413b6acde61f3fe1b3204c81a80f1857b93c643e7ca1156db32049c589bdf50b9a50e5c385805b668391f203e1a4b147183e5e96f6a58565376977ebb161d76a9551258d348a1242c7bfaa183c204d9dafabc664ca6ef83de105ce35793236e1d2e1873c88da906f3903d6235e361d7fce80ac70e1d530450200020a1ca96b73153638fc1f0d1eba4c2d903633d495edf52026adffbe812c609c1c0dd3a9f47fdd057e0de9334e58ea45e4c43074980ca01de5c8b461fcd133f3f171a46de0c4b50e8ef87d68d345f5647e1a8d02a74afbf8a4f52186056cc0f2d93cbe5cc45d53e552bbc91b9bf325db8e6537e7215ce00dcd3c3050f1f4e9d1e18e6f992c75c5a98f8831a52214671b0002be31933627e811503716903cbd2476f44e8f1cbf85fe4d74d57eedd166f9b822f0a13862957378361e32843f13988dc326952a12690e6cca48629ac0555a7cc7ee65714c9a8252649cb0d97fe6e0b4fd06f8f72b9e6dc525765c0944d61b268b628df73883980014c61f750e2b9fe1c187b21930b22e751f761e3f34025a67584221a8cf38c508a6b0871ad7c90f9238d9e51bd805ebfc6674543515f531cba1c2fd8fd6d6d910c9cfa5457cb89f27b44ae7b31d11172b43c89420c3fd35cbaa8d45b8738fcb1a19e99d4e3f2bc03c43c9e7202f6108470dcc830d0f8fc3ce2475bd8173d999927c6358325efa9ee78a354138a9905fd86613bdfe0a7a02035ff88166183ceb465adbeb0424ec53307e5854a449c40b13dec4001f5083b4a3602ca7485e9860cf80ad6323e93fcd4c5026ebb382cfa67ad1767504560151d5828dc69711ffd1794b8cfacb7ce75ab0f942750f74712ff17122f6367fe0b6627f391a18b7df9187be4fda77850a1e99f48c2c7cf7bfd5b02a7f35200d4cc8bcf292c86c93a9709c00729de1e2eb223a1912a3c0bedd4455a6d9ba3e792e5481e06fc5583b54fcd4d3dc7152c2641348c5c8e36693bec51d458d4d1feb343c2812da3e39f0149c10844a54a6982f871a16da59c08c352727d6ce6228b0b2bb95354e87dc94df7d9d4a1319d0e19fb366d1951c2bc4118624a379236066d75ebedbd77c392ce323f2cacfa08c85bc46b7a9f95a9a8de0e3d9af212a5f734a938975c70187b15e9a6a8cf83eb2826f85516d59ba781427e850d6cf88671e085ca77b6b1432cb0ad05af3d6883830369e5b5b8efb499f1442df6141f132981cda780c5faa8e610eca58511c6b03d4a1b6a9976ddf6a288e56caf03d977033d896ed9d383d3d0546ce2b68f79a43a4336652efd615f527965fd1b3f31381c56a2dffea21dac187cbc74d941bacba728bf074f0171b683e658a7ded6187b481a87350408edc58851054dd3cf1e70d7da9171e09bf5d94256711a59d9ec04f19042bc20b6c2347afab7295742678e8c1e97c60086ea3139ac268b650f031e49906930bf53b7bd108e9b77fb3665839309b068bc492c6345ba8cd2d842880a7586e149168441b3ce17a002a54ac3207c57f7bffee06ce80752613a0d8267d3fe2a714f8748d4456717f890ccfa5ccf1c85625523c25f117fcf35d7b01de3fc32532a1bb0da518db88d16147e1847a5d6155a6c21ee860431e5c60f582980f21f0e4231f4c6fc903e5a1f1c54e059b04ee5c0387b67f5fdbefb65fa7fea7ff694358bdf4eea99254ab54ee9032e907e19421ddfc8b39a7c82d014c6c4b57e63b0a28b7c2ba11cfda9d05f2aad56f0d3ea21e04218c5536eb17def47af4cde05bedd27bfa8757628f55b318f0554e4f21e00f1a602604f033ce4e87c42cad343a31dd2f4b17efefa727353ce5dba90aaff908b2e207be2ffdd971622295582e7db6d9540c4c8e15e0b3ae4fd16eb8ab2af84b17671d11c2985b9569bd6c26ab4bf59458f5acd65939957a89001dac019e53d75ee92cfb30bd56cb6c33ac61152844227613559a9142b32da8a129b5e58c660610e49839f44cef0b517b98496616f2badf7f0d8ed3bce8f740a589fdcad99e4c1aa01b69b495c2dc8cac867cf496cf17799cf6857da2fc3abbf23b2fd36b0de5e0e66cbcb08000d7c412839c31367c192eb84b463e462fb78fdbd44852fa3d143aa9af21262c5c4386635792da9b2f658f832ad2803e617c24f0415cb17fefec1f69a5114f8b92d8b33bc84806df75e18a125eb94def714592e3be093d8ce124756299d47668784440f67241734cebb399b0ccaf9ec6e13b6cb7fb5b760c27e7c4bbe25c7cd3b56701f11ee7d59d457727478c89741f24627b169318e627b0d28ed4aa3baf8e86ded522343f3d93749b24f8fc630ed5604501243faeff89a1f50a4cc83b59ae9e5a36360116e0c868095c59ebb087fc86e8d23ca2a2ca3aba765b0e60c246365b65518b56415c92948fa29e4f122c7ef92d8c1e3048cdabf6fd35e6120b520adacac35ca635d146dd869538eea6d425b6b2e44b165f26beb290be2fe111fb05cc8dd289ce48809f9abd7e8d35f47e8f089a4c49fdf8d9f8a074834a4d88fd2a5462a0692b95e3053859090fc99a1297aced7179ecebdd1e910f7bd52849a1eaf0f992b588978664c09daed20d7bface19cd638b85b7613cfa8cacb9d03d813c4caddcaf72b36c698ec96d5cab90fd0df231fb601b0390c2e63bf9ef4919107b36cd7d8596a9159f19036ffadd00139aabc77e3af604ff76eed6387c98cf6a2f4c6ffc7f8f5b9f07d7093b3a731ac7b0367368ff2269db46aca8bac9b48e91d42278f5d1c363533f3014c4b373ddf778cb8e3d226a21aaa4b3dd46920433de745ff6265820310c21f17025c51094a68d51d07489e7f7e581a96784379d48ce01ee0f438fd8d18aae22177741c43b3e7f13989d552243a62fb41301a85a3612476badd65ba1397d4de23efb0cbe76ba1e11dbc8e291f23a6b3942077fbbcdf8bdc9832ee2a1ce433309bc088d68055aa3da1108742722798bd7e25488854a0e93b2725f330a6a069152d946ecbda1eea3fd8f8dfd97ffdfde890fbad2cbbe5e989e85645c088b8dfe438d9ea5526270839ab6fd3767b6922bd6babd3d1693608a2b76718d54ed77244aaaea46f100f383f95165bed37fa68e660db0b94d387bb6e1e5d94bdf706d0b9b470853fa4b104644fd4cd20dd88d14ef28ee434456e346b6ffd9b03f96cc30e052521881ebcbac3d67076fe2abdfa4b6f141a131bdfaf1f1b8b8c2b88575c58e468edd402465fc29eafe04cb47a98872c315c978b9ccbc890e473302334e4d827d25751e001e83246fdcd83f45bbd74814e4e6b735a8e3b62905a6df0a3ab56ac25bc73565205a308d95e2b453101bfcb17d94352f1db3d5b7d11d9fa23a87a5ee9c6e69c88b10bf23aa3e1deb09a1b10641fa8e4188017fcdfcdc898abf961905824c3b193e7d52d2c0c69cd8051d22e62a94d953f50cbb1403b5dc69265e84a59012291ab0930848e6c0cb474397cedcd5112adfccdb61bee8f6c0a40e7fe85f83ba459cd2cb7b3da4ff6c21e239dd0493164df316686552e74ab4ba1c27171bdedc53c961695e48033327af059b59fbfa3f947a0cbca083523a6a12f3a7547c18f1cc996d7dbe7248053a006a7c5e807dae181ba3f4966bd4193ff80aa15970c032a27358bdbbfbc122565aa9f8a9537a810c654761cb76ca41d03856ba59d62858e7599d5cf4a1468dd0e06dcb6c798d3d7fc1ccb679bcf05b307826dd444c81058c6881888e692cc365fd1098a651719af05c73d7aea0cc204bff9c72b0217e6adb6e6ff2d74d3ef91dbff15df59a30de9a89b8b20b29fd48ff6156d7551c6ba340186173570a63fd829abbc34116f50df8c5278b6f2d671e31063ce9cb0be5e5bc640f23f877af984bec39c7881500049a81525d7b134066ae35100e509b257319427e1262d251c591a7a72449a9cf3dfbcb34f40b2bea98278c795262c401a3e66c9c0c4881c27bc3459faa47ad6c7686efc146d1c35b1c51268b0ff29d63289c5e51fee583d5a0b4477a86171110a409b9c95dc4ca89641755eaee7148a60909919f5ad182c66bf0129fcdf7dea585577914159441c34f70295d85ea181d6b4fb03fabff24d2208a759b42556183ebfa9385a328ca30f331c96c95f3fdf5585d6617dbede32f6cc5e6753190a6ce155ba326e080f7f4cf3bd176be552ca62ce6adbf2fc361418053bc5c8979771e37d1e97de0cf809bc5428f8ab03039ba6b7288202fba33c7643ffa6e8b69702071d6d5bca8f088a932881d720a46895d6716d9439c668d5a0c7b79b89844c2b79493f645ccc7303c0c4784ed4d5b6a9557007beebf946a1465b094c2466a57fb208ba6ec74015932c47bbeb913ea8bbcd1cbeca132edbc945550b99253b56e80fb8b4ba3d326c0dc9f3aa1b466596e68a6383d344b86fc5a795220bb5acbb0b13fc0d4d761a9907ce029dc9935cf8677a3066c01b4762aebb94944d21d647b9e1334a5683d1d0bfbf62dfe1f53b42691eb19b45887a920688fd943bfdec25de15eaba788976a9cd9a7ff488752d9f1a4d33f36e24c8133c62438e96aad1325952abd46a3195ccdc8baaa8f4509e95749de6dc3cb66ab5855c76eaf6232d37d04d0668c4d407d7d475e533a8797c20547f2d4e88c51156adba503dd3d7967d9fd6402905a5d8e5360d11271598ce937b9cdc287198c55474ee40d00a77ab735b5640a23b0e03e73fcc9f231f4ee17553b5c0bbacd7d91f6c525fb6789d7b424c20329cb82a2e0878ce9c85fa054d8e74a0bb382e7254409f994b9b2cfadfa33608420d8bed360c444095dfa60ad923d1769f6e7b6917c13b5557d2ed75b32d33893194bf087c3fd87d721f37db0c752cbb79428176b47c01bc7c60cb164edd7374940b6923fbb00b066b9cbe1926dfdded2c7302f7ac89e30a7c45d747bd879fb648a7d6bd89d79e15317d4b8d0b574df5b3c6d4bc7d71531f60461cc766e463cfc7f4da519a7a03f6290c78cc4c883335e90a018e8a5c5fee79ba2378d1bc77c0d28969fc43e23796b52ac36abed054c6c6fd0805c47e7ece6d8e51f6bab5401b2e8b211d266920cbcc69bf24c11071b5b8c52fd2e56edb170c8fd02ef289baa98eb749e85989f7bdcd4e8d860c7d3902f87504aeaa2aa877771a25d92787706c2f3e4e3bd09075c278908a018b096ff9364085b637574a4f54902777f1944d3ab7d6f3412baea69ed77b344707dee75275028cfa288a1ac7e0761190a380f2ad40f8714db0c534b43442a8fa020733d723afda3a9d4135b88d493c72ef68833d3caea3c213b10611ebd7dd50154dd7ddf66c9c489f3ea486ccea7029d411eca00e7e6133bc3c9aa4b719540588183bdd89470a0fa2417cce4132592db19da018a550dfd2159cab503bf5390df7938f148141cdc5e775785366b9ce4724dd1907e8c6a01610e49844f5ab11091d48cbd00e5136446112c906da89086693a38b0b180a206e7ac7360c50d7ea65e0b8b9d9caabfd81621dacb78f08283ef409aaf689f8954a9368c7d1e5c7672fbb51d028bf68c46d8f8fec2eea43d633ac3be15948a5bd7b05173c77fc55e447affeb24bcfb2037bd8880664168c53d507e7c1249251086e6a53887adb8cb0b9595ebbf9f7cd7877abe545bc27f08390bcb43c4c6a02e85204da9e90819ecb9f99115c0acd9984a8ca10350d81a2eb6625cc599381dbda0f9c46287835a2a868aca5a87ad2f03d09628801c2c5c9a549fa90de24ed8173ca17124a2e87bf5e6937603631fa0d61aba17fbff20511b222bd2b2b64f77dceff9e6f03ea8f27d66413cd841f2e66a4185420b5c08b7f2dd59007ccef8a0da5a01744684c5d1556374a218abcfad6f42fd8a5e912fe5292bbf055190520a99a888c02695a07ceadb171d4c79d18266fd7f2bf06f85c3d7196af0c35558550d14c8ed9ae24a9fc76ba00071e5e4a344f4baaac80a7873a044f792219f612898f565e1d0e51b0d6fb693be421823f707c5fe6f00cc64251c87a5a4a080eb17c0b2a99ca0a31e8be51bdc1988916f636e0441d4a386405ee2c21c0913778dc2df08fe6b010d07d045d7bcd63aee372afe72744b9e5297b62bf1d3daac221068ab6ff608455e422e1cd09e06ffdbd2e2b14f2386ea904ab8209798b3c5f5903510aa910817650d87a9d9386b0a7fa38a02770883015e3f783feeaf80a44a4ad291d0a558a56fd19a2e6e332844ae3fb65f8c6458e18a533cd1f7bc52c7f845c80aee17c324f343fca9c265645d3bf9b722e69cebcc1103bf7e15f3b6ccfdd3766d50f03d758d18c76a35fd28a118929d0f5c13dc2f520946665094e2242930b9c2ad71472a61c3de66ee59190682013ed6282a73d778c8106720fe4e81587a4e20cfcfc5ad6b2e03e5a57ac1c9059a4399f12c73174ba33188b2bac8515dad5b0bef885bdc94d441a3ebdae20545e55219a08c509048775bf94e3e9d59ec782290ce17376cb7da51af99df09c7e7d3a5cc3bc64a8a76224d1581d0aef1818413488bb8cb88a5989a03468727aa6f51a3ae93d2c01ff1883496596c23edf624495e6fd09c9003931bc3d98227b51988dcd5f03f5372804117e4858d49973943bd69ced45f661adefdc3a0ccb911f391b3085ad0f31b7806f15e86315f678887f52ec77b18b69e5b475b7efe31ed5c1c336c45dae1fdcc5f67d13eb560075f6971908e46151c57eaba68457108ef370b7577773203f7781bf8bc46377df7c844d1b0e56530ab5a21f5a34b9ffaa8a09f2bee5dfa491d994df5601378614ba7662a71b3f4059dcb88f1c240a8142136f2c51a9cd58ad3fa9cff1d8a5657000ab19a3f17516959e1f4c838f18d9da02e5b49f8304821e06b9579573c29847c2ea8b30d53eff5e8e5af56494fe2632d70477d7ded26c8406e49862de249540e2ba2c0c1c4e24bd7ac3ce8d3743235009e04b77d803bfb200f3fd19a8b252c52c2a10b6350dd570742f1228fdb5e7b958e9baf76c51100ff4bd8ea3273b9327ce12f95f8aa33ecb6f8464259c7a1a04ee58e0517260b11de2cf696c2d1c24e1aca98267b325a7d8e7d060346295142414c9d2fa4043ed2bf349294a69cd37007b9d91a4447b0a622ea9f1e59455504a7033c6eb2680930128277dda16350a92d9dcedcdc1a62da72fda6c987bb18792cc84b98162919bfca27acd16001e77ada3d477b15faf56398c7721756cc52f7c93da549a9574433845ec5340dfbbaa3cd7540cdb472487358c482cf246e729823cec487029baed98ba3167c957757c494962c04f9ec223a7719102f16569ebfe32ed1f759a69a6eb114d21c4ba2885013f2e31e274eaa8bc59d596cd6d9de1f2494a2fbce006666368c8b268ecea8f3d9e6d6ba258c374a596e0629d696bc9cb13af9c5373ede9c47cef86442ff3e069d990c6a800fd14251eae33a57580046df78bc22c2c71b1d604111815f12297aafd90f4cf23faf1ade205373d583b344e8f83d0f5a6e3e2d204987e77b65a08b66830daefe735ec170d904c52e71d30c44be72348b3b61ea04287fcde530c7cfe80e7f2cd02bbf7deff0e2bbb441927b1d5a46cfc64cf0f494f453f054b9a65e0433145e95881034539715f3e8c295ce0e14d85f2767eef83917ca0e73a9ddf08a63df285a7da5cacf2f7ad364b4b3481e2a4b6f70014f17baff2aba8b630ee85335fb7081da69c5ff73d80eade8e947c7fe9dfc27b4531bf0e789a1f35582e38bc19ee693d2628b7dac9eb648b7f51749574858089dcc469220234928e93a4478b0f929858c0065a0c9c1a6fd51aa9670a2a076859a86b8731fc5442d5d5b65bca5e5b593a99af00434fef100fbf0343a6ec647c2fecd6ea8413e4285ea8edbb898db3748f1647f1476275a41c7496acaeb889140ab49500cff0df7b8dbdd150171d1629959d23304e0da2eae377e5579848158704188877dde8ee300f05551947fcb2c768038b8c152b0815b4cfd9ed2efcdf77e1e56cc6c6d5193cb08d5b352f8556894e3def2fd36b8d236b2e3830f687d7369b3129830b78ba95e8bbb7283c09e067f5201067d63c98b2ccb4b978b97cd3e7033ddd054e9ab658e9865e58355c99760d042747d28057db504a8f8dd4115fc47cc9ed3c9ba73c3b2babd0db57bcee3ff5b0f071670d74a3d34444207b6b9287b0dab9159b72337364c731475d09ff776f30bad42927e394bd971354a510be34ffe22fb1d6cf66fd4eafbe6e48d60fc1b8155b1e6ddb9811d23b0cbbd97aac57e1fab8af41621c59d0beddae762aa1996c808738c3e67f0cc9ee5ddbe25f73c2a8741201c9b35dcbeb4e0a5b4db05d755d5e3c14201b090387e7aa719da9be31e399c22ba675bca014e6d7b026a46881788b6d86e6daff187e2a814f86d59810583446025e402059338d91c492749a28b49ae3accf54d5cdd79860f6f553cf720120e302b857054f632b05686284734d0af2ee0cc74ed3c6cf1f0f5a8b1474c11d861ad5180988db3820755489c39ab6b5cab0b66d13ac3fc5a16d4a8cb06b4864dad6874c71c058000c017720ef0523af28a86c35ec4172a1441a6b9768d67931aa9c0fbd3a76c1ce11d1c6524ef065e4b5e30edcb0713fd735477768661cce4bb2b5f5f1b61df4d872079a77061238079158d02f21d9c1410337395956326d1888de9c36eb80f91ec8e61985e8b1936f37c7cf82c4180eea45f49eb2413f8ba77275b649a909a6e69efba1a73731c8c970a395fa4eefd39c594edc283d212d50b01cc4029bef0b7d9d1c4eb4d6a8c6570c150925aa376a722557e631019e19cfc2afb13b37f203c2e0578763acc9108da7ad17202c3460407b9c63e2422635e5ec80fca04b85b1c6177f64637c694e26ff91720514ee129a9c1d5eecb1d5aa7e421f75d19cf47d8529f15f945905e7f727d8f6665bea9ca3f81714a416a2ad9b67676f0fccdb00078282567349ab5a1795b3a404fc877e97188530dcfd3d903263261d6778a46dea5749b9ed6a144e13a6b1b7b53dc9c1650621ae878d6c1315a4d90016908179bca777bf8f9b5d40389cf78c1f706239e7c2e0978ef0f1c01c671818a4fb461f92ce8dd4c321ce9b77cd7905b8c94d1489efcad7cacd1d7c6af3305f25efe0d6901f93e9385075921aeb7f5b438fe93c252a9a2d7b3af804a42e46ebd28b908098718d40aaabd21efd2a09de6f9cdcebbb0a566a5597bf83ef23f782e694a7dda6a0f5831ab240915e48d1d761756f5a41652aefa5c440efaa22ccb0402c38df1025c5312c75ff0523adbae08dd22c35ad34d119c7cd678a864b26f1b16081f8c58d3a928bdee5b3558b98d09b52734ce3f6c85e3f47ef4f99e886e64a7f5f54cc9b8b718152436b16bfcdb8e72c27c8d48e349de6a4b5982250fd731ee20ee32a12a06e676fcf24ee418ab6e4b15e2c1ac604c8cd4e01b494287a2b4baaeda37599ace1230fa66c533b1568454e014d0decf87febacecfc29e921efe0140ab3ddfab4b4bd1856bea79b3689c32804752000d439486084d7a913ee93f6ad316d3c4f1e4ee49588c16dfacb76d4db6d26c82dd5f06cbffd82eb215a3133f332b04bb7dbed8ded78442f8539702455847064c439a230fc8ca90a5380311718dfc038642fe15be346d084fe800c2deef531412807cbdd6392f660dcff931ed197ab647ed0a25b3eb88cf619a9268f0a32e1b298a9af99c514efb13a00fcb5e6512186ad8c9cc671a8789fb8b63c25968181bd30073c7eae72e012e00529fa1e41dd68363bcccfab47fe69ef1254360cb6cc5fe5e7f169162e5fb100c6741c14aabac9f4d5a0d97522e106b3b6793724c34f21948317ace74edcfcb81be4aa7dba3b0fe662f91f551b588713037a7951bcb9f4d34309cde2455c373b446f1c57fcad6e1cba6f5ffebd8be2d28b0b2e48da30d04707727ac5af969f4c7296ee6f8aa186184d6a5d8d21eabe8c3929fc3fdc0d585f695f89a4a70fb43ba9d543223ea7542420d4c611d079a051674918bf9a94313d0120dc300eafe6ac3cf2f243859c86317e4a41e642ec9acd43f42635ba7b6b50125a53b140d72cf1775e33eb940b01b6081151b32424ff62e8729b0f9c9661a535a541f9a21671f57438783d19cf1906a4ace416e71903e50c99815dd73c39322100084648494a3d7453525224972b42d54295581cf6a06faaeb955f3452fda153bf9ebdb6dec650c0f12f64c52bf1fd416f6b48d5e290ee6ad303f4c21537cd1800658e63e51523ff23d7a09921c0700fe76024dddea7fdedf593f2707972b04fdb97c059d33584cbb31229fb72d14d22e1fa860942d8d2bd8916230d1c4873a7f6f8ba1845aabc931f7aaaef8386bf2ecff7d5816630719c1ab9f6eb6ae6bd99ee2d2b7ed3e637b31f26cc67dccb0250b98d34e2d9bb63cb4c98e9b64f4bd82a5cd1330a023474561e44cf2415c5ab7ad6ca12025ca24ac98d80ff9fc9e4c2d573a20bff4f83849d137a71702ab3f6fdaa757b328d58e9cf675f50f669108cff6ce5c5e7cfb33ca617c6d5e2d1c0e3a8857b4fa2f2247c417e0eb5d7e319f7cfe0f591c78653dd3b1af9310468d5f132890eafab80bea2f834b2f71d34d8c6217b14557dc162ba5c96c75384f713b801dfca43cc7ad054b0108a7e9450cb500681fae3b1c9bc7839e8e5f38175c5b3d52e9ab0fbbeccf2ef331b5c7a3322a712e0dc5edc2c8211c4e8a050698f8c93c82c3767c743ec989d4c5c6be35401825d80bbf3925d46b316870c93160fff68a206cebbd4ee32d7cd1518fed121ac62a292cf6d390423db1fd55732485c1c20893fdaa4240dafbd2795531ac58769df3714394f2773a090dc5fa9cffd3e81556e0730069b848c43810bbacaa39d0f49c82a08fd700c428a585ffdc86f30e16d97964e7dce1ba6a5964b66bcd6efa34a3bb2537aacdab33815e0ccb56d5efd88099f21b15c795bcbe6941ff4bc905fb83aa3d33849f49a097552cfe1ff1e7bcd2e325a1f96ed31c36782b9cc3fdb80989c18b162f511139ab9c6cd10073fb484f04b6734e9abfe543cd8d468f368ce1c7f0f2ec68f511d76cd81102ceaa2e0365c4a999bf913832f8a970fb2cef4985ccef0f88c2c7352a3c93dbf6f6d263446f8cf016c13b0bf160bed2ff151d10d8b147af3b9d252b377aa54ba2d81911c6172ee190a60ad8cded168e59c68cf302fe91ed8dfbcaa55fd0b03f006239d1f054ad1eae7a5806e6b4df75e095b337dd16495e2673c0e5d53373d14d948a4ad85864ca893f2a526d81a31a60c147f46d085c31b74c957a9908f9b2d26630454397b7527ca760b8ea35650805869023554f5384a7e5a5d62a88a28ca5ba94ef0cdc4bfdd798554c715774098a5e27b5ec9c52b005adde7f5c1e062f8f89487a263aa0ec47e02ac6f3b9f260f96cb3ddc1707ad2a99da853e40a525855291bb06642a66a8c2edaa3b926a3c908e56a7a6b69560d367d90d5839f256ed3636e8af4165a259c09acc75113549e8fec45f870f7efeba11806a2a01264353ac258fd25d180467aa9e74e2f297d166bc373864698ad26cf989991500892248727f55dd8ed1570e17aec5ee926dc091e048969cc940e6aa9c0f61a09931be1a5687eec7e80a3398edd1f7c7ca475c173c017651beda4c9e104f868fbad120be3c479f7658b8e792f4a48aa806af2b275a61f4817de1637a90e3f39c3bc7a39b140dd62104b11c0ca337fb82344dc1d175a5e07f7e4540fd1bcabc9d507bcaa0be55aa31d2512cd5a81eacf3331b5467dca83e9a7b35ca69a873ecdcb3cc8083f0686e9849484b96626c9551cf70c0d7f81b5016e398382f1c5160afef9ad1510238c82675646e725fc68c3a1d84c699de0eb4a41df07fc4a373a930475a18269288d811705a9cc0ba9a669c49c38dab72ffa34b04fec27bbbbe72ea3075f78d21ecc949e616cc17a8e5eca2822b417ce84cc6813fd9f64ba7138a24a868be66d5073c9cbebcd665ab6bd5ce792230856ebbb36b533175a52695661af75bd7dcad7f8a43092f972756b8e026604029003905fe777640ce48db8a7d4c88360a7b8fcb004cc43d6a4208c1afd192679475b36c9ec3d65c9ce4e4196a0a7088fc3f1466cfcdac95459275691ecf35b6beae0fba497f88744eb4aa05ea3652f565b462af243c925c65cb129e9db18f01492e85ba53ac7a2fd5c61a36f5fdcb3688996130a99bcacd1c7919f4c23e670418541f8824f6e7197a1ba3028426c79ebaaee39ad2b47e7436e9e60d58597de7c91b192fef9f55697804b293a4cc167a81cbf4ee2da03e99ade871247c24d7afa5674d1feb904f8d2f866c9212b15d7e9ea170c0b5181cf0c729cacc8b84fa15be79ca35dd3e6bae90e600cf60f2cdf9a6bd93b6e3fe3429a626d8aa80e5aef8c2aad5f1c2725e3c333c09736057bc7afcaf3bd89ea56f759294ebc674b8e329e11031ea30cd4046e4274c453d1d9f5f5be8f05783ca99f62c1922c0a00ceb54b6a6d700abcc2b756818cf1c6e796a318dffadb317c8fce27140d7117a21d560609e7693c82cb51b42618f1a876c6be1a529cc3a935fe7dbc6a064fb51bd89b3f66a26afcacd9bd38f5a7b42d6bd54ecd64be5cd34588e224e2dc8517255b5922a8697a95d8634bfa1e9c4d5f9252206f40cbfcdad50f2da9b6846199870592391970e11bdf91b7ef6b1e06923aed132505bced00b2d18914245c1beef6c71d7da4991e2da1e16c6d988fbe28c32b1fc5807d80ed057b36d2286f34503a019b70a499f775e8daa60c4b8904ece44e1bdbd8ac8e5a8fdb094f1ddefc4c729b63b3882bf4ccafa1e59e4535bd64d81be0df893b40703993d15129689a08efe2d8f3e0b5c1da6f06528559d31f8e3f936c67a89b57f1e453430278972a46a876bbaffec47eb94eda79c20b8453ed30e72e0c05e5784bf66017a4e4f549cfcf66e2ac2b49255531ea898381c6e5937a4d5b0065268cb7200f1d011e41f450068d0446565f67ca986a3c134a444fbaab353147664272c017d3b2b8c6f8669160e34e40e53570f4692750cea1889b009fe8ae86121311361091547f58a8ace3dcfdb22f8dd0c99d1b1abdc0a6e3cd5964b0b06712bace20c8e3bed35f9fcce7a24241e767087d9b41f04743d274f3ab00eca0e62685c3b1681e2401e4f72f0e9c4075628436f3e8aaa5d6936b96100423c82b92543f9fdcc82d6a5231b042622a9728f79333f66c0e8627008327d6224d35350afa29a64c4582a8de341867970238bbec4a79fa5bb221bdefbdb127138444edf90d7fbfeffce3c67b6122e96f18ccfcb8bfdbf05f015d082c78d4cc813138201b05c04c47b4fdeb789a551dabba5212f1a25a1fc9193190734012b564b5292c5fc579eb72ca22cdb56f780b57f1e52e11f0ded141cd4ec9cee500a123d6c0a9118a829581bf49da8087561299bdada4e49eb39a42812d1c1ae08890342ecb4ac2f428eb379ca5bbc29d9f3304e8a7909837eb4ea4c43e260a13df0d6d2a909cc39fca22dfc2fd5d070e35aa2d38357177e3319aa0f1202cdcf70a487d11c6498f85e6af8e3c173b1cead92ea1af0bb2386a7b92b3d1c57f472cd748910d8ade73e7ff887e225d3f3110b6b1cfe16013da972f96832d212c2fc3613825705530ec67b85148b8e6b70f03a988015e09fac65e2e1917cb242c76be2bed10455bb2c4e7c6fb611f24c078bee560b12d8a464cc0bf8f0781dbc93930c1f8062959484e18875ae444de574319cc67b06c78147b31721041a2a5d2240149741632dce97a5c3c06a2e9a527ed84fbe3099804ae90bd102bd66c2e85f3f2a1d52deeff2a44a6123d41a0b4952dc61c355b368b2c994fecaee8988984239d6c793cdf28839fc7d4d7063c0e9f6ce290b6fc39007a7b9d17d857844c8e54b026f2d3ce68856faaa959078d394f5543611167cfc0c81f33533964f8c14f990119044ac9042dbb12c6662c4ec7092991ce74fe312fc1210b3b1b23c5bb517681195c228c6fdebee2f8e938c60db2e869501d2782af5255bdfffb854c3a0a3580e0ee7ba85c7813b8d227e1b7430cff50d9bd0fe26ddbb435e8b935dbee4fb14a6f44c1fc733523fdce6f927aaf07e057606c390771d8963607e5e330db2df471de9379d5ef951a3d0e7b9ec39a35c7c6bfd7b2acc89d0886cef95930c198866d48c4df91ee0909220d2764baf9a8477d1f7594e0933e394707bdea41434604b277e19cef859b160ff1b978877fe454a77726ae8f00c2134e2d42c4762ce65a88b4afdd726004312e15975d26b2513f4126b5b7a3a3f35901e42e29ef0bccb9b1a7ff12eebc00e176924c5841482ea5e0893cf557092777b19cfd71fc0288caf96a2588b268bf98d08e7f2cd35d0bc9b6f4bf03ad6af4ce127383d28c5047b0293bb953a625998df5cb7d4669ba85bb659c7a6045b0d376168bcfda6672a4019b4b8edfc3502250cbc89a71fc59e90a8edd031d5b6e7b2dff40dca9a06563ec2f16c39aa48965d02bb7f3bf73452eabe8c6e75ed2fafa6bd04d9423204a92a42a8924c4647c275c9ce7cd3023acabb6f27dbad81b85e4ae2b7a0a4e60d9a5263caad595b73a29793a0dbf8e4ce2b65ac144a1a160d8025a77b163c7adc5843f357c89cf0693a83255bea431479b5dfceb6e6bf02deecd89ccb2a2cbc61fb9946d868675e62c7c428aeea83ca606fa0e7b3038f87b78b5a6053f3a07163252caf8ea8fe735f09b184b8ff802d2a549a4105c7417063102020cf73e59c5b559c3f07a636be8335430a8b4cb4c0c5c3d4282aa5f670cee3352dd0a51c10b03db9c79343f983ae26411b4a16f7fce58d7dc5c1da425f1c05cbaa9bceea7efc71d5986ca5bf616b86e84171d62ff382be5e2b94086f3d8eb48c507bb5ace27136a2cc4fecbde1560c5f9176ed786545c4c863e6269c32241840418eb9e0a3b5ac8ed8c216b8d0abf143cbc97cf9485d7eb819f1a5eb25199b8cd6e9d6bdf4fc23d34a442165ecd5f3b1da6eeccedc15f2a59948e45db381c780198e8e261f2ef8c824357f6658d476776d65b3694ae0c3a1095d072045686a50d4d652e232cb7ae83252165009fa0dba157deed932d8ecf2f71accd7dc5a8c6850fc697273c726d1657361ac752fd395a41d256181725f357a16cfc6194dce02ca0393d38ee46eb4f784c1dd8fe973c72c8a01fa6e17527a84172cdc49f0b6e370c6f7c0178cb4033ecde3b4ff184e7a7079f3e5cb8b785dd1dd71a441a457484688c80d3575f224005f5ce95169dd4acdcc8db49a3438b1c55019e8177807b9487480ad2e3879fe1c6cce37512d010ea9bc8d11de3d21b2fa7fc05aaa06c1f091af9a389f577e6f9324fd64d33a263073c6dbde3ae4f1fe8357475a3614cd0f3436ceac3dfe3ea2c0411393e25f9dd4026e7dd049c5996b6cf33e4e6d2b50bdeff28db5078745941fc88ee68c371fc18f4218b0a60cb121f4efc2c4e81bf2eacb3708f13aa12b3074b1004433fa074d14778ceb2d06030f9381cbf4cc13819722dca7b2f59093e99d27412b6103cb113dd0a120585c2a6086ce291794517efca91f0f6cb8d4084f70a9f5cc606ecc174866bc9bbec25f270cb396fb31f2444b4a137719ee006f5e8f47ac990ef6a30927c8a43700b570168eb6ed6c996bd2d7785f8c8f13b533f33a7489810486ddc544d7a9b1bc650ee3462399319714ca36478723afb7a2d53e6699a8cbbcf56957e61edf90dcd7f7c6b04cb46c3b61ad77f506bcee59eda38d6fa9dbbe0e4ea6334491f456ad4acf983633a78628fd2cab153973a29eb70bedb8deaced0ccfd03eb74dc14c789a10eea49be70b4d826f9067ee36cc7c4980e7bd376bbfc48f37eb9aead8fe895f2ce1a48bfc453095997bc7078acc5ad563148c82004cb479a9fe27a42085594e1c7739f3a706b295db1ab302a4afa612d4a66a00fba23fefb231cfe7409974e9160a1cbdc64758260b710d227252b45a12272de141b867a55fdff5d02d481d81e97969c2bb9d7ea1f8f371f8c6319f0c62a05969e2d5b4c48ead736babc1ac37ff4c869faae9f728f908616e864f99b062e4769232f3c243b15fc6ccb80d1c517dc4a4f4a27bad654441b41d81162d1a97854af0e4b7fb06a12fac9ec5209f3fba170042e3ce4441a7a30cb52a17490619ae2f9c52dc399f98d3718a02102345027585a364005f3c4b05d28a29c00287c251545ea04beecfbfceeaf0073c5baccf498ea3186ec138754e7c78ecdab7f515e8fcce192f6968a72bb02a5241ce71f7b0a9b6ee4b29f847a26c9def809cf9f6c0a713ea04055537ddc5632b9db5a700152590aaa6562b9ad97d4fa0e640a59f7f36a37a14a777e159a07dcef6079b60e62be900b949937a5350038d264629fe2132d422762f3992dfe04aa2b04dfc8f21ed0c06793df876c63880e3a2177d9f0aa22516a52f514b5a1a68956e923376da709cae6024b1deb27dd3267e13d1db8d2b29c8fce0846b3b424670d610e6a762c3a545aea0ba4d0a7e10ed5fa4da411c8653ad0d8ebad58642a33614eb6a244ad4a5e23511274105a87bce67adc9b2c7aa3bb3894e9740dfe783f9db90489da00ac5cd2264ae1fdf6e7915a5b2015f382aac9e504d642c224f53afe564d69856f1a4c4062aed9e40f767817c5e14500cff76ec69fe3ced5c54ab280853fb362d8fa453485424ee4320102825c7b9bdbd9dcbd4bcb70aed842e33db325bc7ce72d5b3a343b76e2a87d8dd8a4080c600e34254d487768cc047751d67bedb1caa3a9f876959cd77ca152b51fb18ab4449946538d6a0c3ff0408e953c6ab2a779dcb1dececb1db4b503cc241d097a9495581db5fda2f52d8d67769a5fdc37e175fd52e887ba43b51439a88cc48567f7d4ab18211b1e631fff62087cedc590e5773e9ac99cd505b6e1431a6ddfeb3ac64c05efcd0e25bc9740308e48d957615aea0758d811a7239ea793e7fc15cfe53c6cd516a111d9d7e5c720b503795957c33468db6068b1b5113d504c78a9896aa8b48c5e1bf2c40a6a143632ff585a875137879c1288e99a7648742c9f298fc5ff4a0b76c9710786cac276dfde36a54aad26fd9d22e5a610c3ddc30a45ea7f20e2d87ffcd541c34eaa93074770b3d3f625a395b3f54a0e2a9fb7e4427aee813b748e14636bede7e173867daa325ac8e229c52d90529bdceef9520d80274ed4fe9a9157633551dae7867474256802bcccbf1f2c1ad31388d4db215a67dbceabeb0e0ad252d678ffde5d37ec27b9713e4f13bb705d90936aa908462df6caff905a080a1548f1529875885489005839d09df8ed7a09cb0a28238d218764527fca3023a07a07b1183cc4ab07f771176727f35a639e42d4fee9e6bbb448da601ca861b4d4758a6578c34b39715cb0b22327221043c9347b5dd0f6e624e2f7bb9a9613c84b925d249a4b275104d5a02c71d9d13ff8255adc5db69eb4298fdda24a52a17ae5137b4fabc79bc2af1ae26b0a48618460bf1f625d3e28398108e1809d6d0af60d0794eb55a9976b0c76e169bdbf7c38cc1505cef66a7de5ba96abc1aab4dbf11b93a3d995074e1b9ec8412deccbc3477d9bb08a0a537783760264a21d82e767397d9414a9f76909c71a7bdb6fb1b78b1f5f4999686adb65e7665d2a12ef11d68b9707b1b0247e3f64bfad98441bcd1a53332037a178a2222fdc77333591b439b6fc8c16b117143ecab16cac7fa2e386bf14dc6a25be96c01ae8e27e563452d17848b21be2cbfc271193b29c6e8dc8f8abd42ccef254f916e566cca4e888f06bf77fec947d8d3ccaee04c1c615c23ce537c166cee50e7ae78ff364d07522d31fef320ee7eb1beb654069606f8911aa3fdf790a12cc9566d79f7c3292119f1060044221e404cf40a2700e56766fea9feefcdcac2e92d43028c2cbb873ff9e9d24c3c148c7fce3307c05bc54641546250ff3d5f48fad504d749d2e083e75449fe388ddeb959c7cee761d2c3dcf59a06abd176157949fbf7dca208e9b80bedcda91001bb507ff243bf43a5360fb1e2ec958905936c6921b6eb5378732b4a176b18205d527ed5ae9fed6a0980ca5479ae3785104720fb34c6d1e8ad3b38c30a6b20346143411e92928d404acda7087537ba116935935709288f366cb6bcb78cf31dcea90f6ecb33b1b83262f9cd05e561cb40165aceb6a36ed3d4175dcb6b55fb7c4ad4581d767875e398ac91e44f2a6f67cf1efd88da7e8aed6a63c8ff98daf54372b3722f4debec74a500175803dc3a3da319cc27af4bbdb9f75be62cfdada2f3eb7b173cb661cda1a87a18ec2ed3be3b91179bbea3905d890ad003047c0b205622aefc512faf98c05cba58d2f871f7e2effc468dc608ccff3f51e19ea4943c7587bb4495df324ab9330f7a679c743def65e14bec53e0b5b2fd5a9a4e4b72e996ef8f20a2fae71cce1c2ea4a4af9679a98adc1a60f363e82e3ad7eefa3ce08e05107a7c8b81c61217e6fd0525ddd4e3db32b6aa0e817f26cf709adcb65e0ac51405cef51b4d73c463ac9b80f01de76f2fecf564dde17ec5024389746219dd61301b4903ab4a8e957568c64d36315a79216a8da2f53f379181dcd6239e513ff0ad9d19691667b9a648cb5d6029c32a3610aed3a3ee0bb8b80201ea046fc15fc97a0552060f6bf9b105f5e1836358988d27e6b05d9703b257feb61959bcbdbe0021dd5e93648b19a1ebf427a244eab039fd68319dcc356e25a0ceec91ccc4f84f878d54e5b1ca0b40e4b5b3bf3586ab0bff18ee5e2f71241b02d5153b682ed05cec3d9ca3eb033d8d0dbf2d061680e72e8d73f18fbd8e639db19bec0cea2175888a053a8d789d06a51f8409e1d5da28d05b5a54f048f371c197efa458867d75b84f1614dfb4a73e833d81aabbbf2a6d54049b81e6d92b28bc0dc8896628f6b2177cccb99955e3f8dd44079b2c7d9024fb2766a62d34fae367dc336901be28a4edb58041dfc7de77ba4dfb36f883a8eb89802dfde95ca81e2ddaaca3e22c74f084aca7739ad326202f4817eadf79f19d2d6cedb958d5394fd57ae33116ae634e58a357165a7530ac09d0ff79bd787fda9fe0e1d0d8d119d82b1ec47e9f26d3472f76711b577df3eca558cd69566adc6d907224343eaae0595adb7bfaeda63551d151c71d1c13dcf1eb46c4ef2c0f65934c7cc775bcf63bdf9961a1fc2f80eefa2ed0d6287027c8bf729f8481f61373af94f24fcbd6eb3963681f874cb50ddf3b92a44d755163b4695cc37fff8dbb7051e1c08488bda61268fd469963652217d3d1ab7194f16a51db5aefdb01afedfca260a79d53d6bae5fad7d2f9a7ef7095c5de6e9c4c19a6a8a21c046ac0f5376a7526f32de38e1b9e27f4afb6d4382d1f34ae800cd4e042f20e8dce8a248f3a053f5ec28f1188d988a78a018379d7ac6f886ad7359086bb5665dd21d18b981c77e712377255bcfddf2e3666932a7c26b382eb1e0e2d0c2cee0114d0461e0010221985322ad38e62915b5ae94bec206b3d38044151a81434dae62795328966c3c911cad5e90270b7636c08413766c199ca61add25352f589f150d07e303c7608a3f1ca8dfdd4f762e9872076760418f217a495b738afa8724d73aa108cc9b102881543f7b8678f2c3846be8d30511096c7a55efbfcbddb9e0dfdb4e68525550c621a14417955dab1ee9dc2637627a1971404b6f6d3041abeeddd3b942a1ea6de2155d82b2ce0ff02924b6c021ee02c687da827047ae26389fb6617b2e830b3a2b1492a243bcc2b613e0bb5c562495e8e7e8fcdebd803ff05eabc10bee740e403321419f4c8e09d0bea37ce9bd0d17b1e980d44fbaa411bae2a99a6d50aa716eaaaacadae5ef8a1e4649a6d4a40e328d6a64fef43993f80f93a2c4c405c2110a016644ad278e160034b58081f82ad72b9da7dcd357f86b2a922d45f4ff91369a14d139f2d686147ca2846f89afbc2a3a4a13d9b34292c03b8908e29eef4ed348296f2978ea121550bf70a3c7586b131085f93d1c326f6b2f5170c835e9398b73caca9359ad94a2304ab423751b71b72559776f8b015ac7ef8783bde7b01781946b8ebd84bed9df8f89c89d6956d220f50dbfe532916d20a044834cd64f25ed270a9f8b522e2e5742f14597f42da758edf05d6c85a7a751125d10728744e8309729734b467fc265ae4169a0d22d569d1f723eaf8f1c4dee0395e1a4f13dd012a6f736acb1b9b892e1635ed6d855108b0229d6d6d3cc741b8990ceb1e5ecd1202c21a9b2190458e581d21c6d315aab375489f57ff1a6fdf936b628440e97ccf3cb1f9794d93e9a51d1d81b6010c81d2f80320df3845d96551ddde9834f6555896f92f5e9b7c5c89e632dbc2fee5e6e2f267211ef99182d317515682d4b126337f1a0089806c44875faf24cf953f26765bbabe810d2eee490b28c8894040bb7204a42ca83ef1e99d24751857c67b7573e5213dbd8e08ad21b4a7a5c5e21f48083f996486f619e4198949b8ac3df16d80a4623fb6d5213981d8c6ffb17fc589d55548ad934189aeb5f006cc4e3b3487dd9e2650642ec8fadbc644e483d1b5acf017e2c463beb6bf74becb7a14957757a3a6d0e3821e1f3c36967ef2130be57de2aae59917bec09cb6c27ff7a808777e4183ffa973483b1735feb6efc7756cf804353a1933d3d45d0892c5a0f776dedbf26ed85d8fa081abfd2be432cccf1199c3ab6e18d98e87f825b85537e4706ea0642a9a4595135127c57e61aae6ad32e67b82cec8e1958fa30ac9c7cce3d01f3e9c22003ebdbc4128824ef5480b1b347a3ec311148d13a6f16d00f9775b23ae3f33592582d214f74d9e066b445acc950e47465904577127d7975f358375a82a2c775927d3cff4027c139d9bc36d119cb094f52895d3f8d1d7b76ff1f70a5f2a82dc3d217db54563f12253341245f14e06e00425edfa51afa3acc10656e02a27de5abbd5a1d1f6240968c43fa0e9af3e6a296deea8513d26254273c384faafc3505c2ce4baa72358f800871657cc40a738781c80be8c4a500bc7c8013436f5df67081db8470d16e03e133175df86788389acc42761ebb70209f280c5a36b0628ff5b74d6b32c4e8dc30b76b6262a8ed637ba9b83f7a0d0081e14c70796014382131c160a1a77fd4c0c217be331df821082d3f89141de446c9a133f3e9a86d0c12ad339c40d93240bf0a29a323da686534557f0dc1d7792ca38c884fea92b67aa2f9a8e522bee6c0ac899b0266774a01427092e9877b08b3d5d96b8fcae22df5eea4757425a27a992f361b327f63305aac68220df82f4a8fb07c55e4742d03b9187596a96858bac3ec2c70f933b6df5e1c932dae23f3f3f89faddcfa8c9ef7b3e74edd9c7ce7a44a9292c813b7d85c4d8cefc88f21fec830ef7c35db7e539fa4b50cfc70cc3a50992aed552f01a2e99492735e5ba2c2ee27cd5f0242f8a439a58a93a6f82a47c6b6cea2b6ea0ee3e3c6e461b1fc84d49755a5b099b9a102fb179d6ebca50a243011854866c059fc1a7afbfbe1febafe367ff24ba44b53ca8afdb0350905623d86b7319de2d3468594b79b998fe2283b1b1eb5dff543f268e0b01d81b6d6614ceaa8b5752eac0bc2bd97f4739e3911363c94cf87f9ac1d1b702ee7f64c5517e79bbc786a83ec80a24eeb36c79abc1acba1c503becc96e67ad88453584865c5d6ff0a8817daf88905ab09f42e4fd7a55926c14f7158f6936ab36ea086aabc03533387e0f38b109599654e0734428d75c45ddc04c7d5e1e69aa3ed6f4a6d4f67fe25589eff15f841c71acec515b1b9a385b64fa3066200ae7d91b1e559c3607d057a700c668a89781535f61f3b41cde9d8b0e3d5cc3ee250be727d96e8aa36a1d9028fd82ce9711ca072cdb9de811f89cbe342b059a025ae92542708fdf8c8f2bc7cf4b177df637993fd2c53730169e1068f90f633e89168821e604238e53cdf86e55f80d79ea2c557558024e108c4b5168323801dde702ff8e99e07465b978b5338460781c0972c5a52433ce66e783ee447a1e80624ebff99dc0ddfde30c76e8745c775a15ca2a464e2e43ad95b9c073aacab907d575d678fdbe6e5b8b4f33bb1ee9f6ba76bf8b196730d135487390d552e2ab403ebc2a242ee8f0486d3cbf678630ac1920140c97913854c9a6706ff7adf948cc4c3ae45feac80b9078fb1503d7bb49ea9987e9b6bb8baf1f3a0601a46deda06bc6c69438948f66682f1d69868c62d5adcacb7551eb0c21e83c6035a67084a2394877526bc5d1d03f887dac597782ad5a77cefd2a15eaf12eebc3f493df23c8d73d2d8b9a871f1e1db4053dea8a97a5a3e42d47e160df993a3b35410e6b68d5de77479f96aef6acff9521e918fb020f0f4f288e69ab45d54d2e589d1406900896aa0ede2c9337f2dca56f9042f3f0dfefb1ae839c477461c6d14a433a2020bb09765e7680a1b7edd1184625512d8a084f870070430efe91090c73470c15d3ec995b6e68e117c75c2c779dcdd316b44e8bfb828279bfc32ba78be7c2bb9b2e9f2af4711db66aae0320954138c5948790087501b690de1640e941509847b544ea72ae6aadcb2919072b7992816112e56d399a1495c1b82d95c8fd2e43605838dae40451a2a4df0ba4c457a38b0ced044a68b85bacb175b8a86b802ba1838dc48f14d4a0da7c999cc01c7f56258602640534aafbd2eb59a31565dd07311b8a607b770b98cdf2cad800c3b0780d77648ee935369d304edde5be144cd8a860e2bb5d0c1fb6732990d796afcdd36229ce69e24e55e26d0e093dec93936646bcc3baa3242e9358054b6b31ad8ecf632495051772be9d0337a38c7b0afb7c609801ec76cf1fe39a5f1f127d4535cdaa758c220fd43e6d361047b43e8d996035c7bf028994314a77b17ec1e747eb66db704e24b340fd1eb9df8609ed0a38b5fc3d785f2d4027d8f1c15fbd61548b077726305a5d02e70778b7cd8cb887c1fab100bd732d5dc3c6d830d4d251a4430cf67784120443e1ed7a45e9dde7fbf66f3d64282bb09f95ed3f32367a7799ec175aff71e89dd114d493f0278edb3c9d45db47c4c2a3fa562d8e5d83613cc53f611082bfaa1a093d5e9c37d941814e3a1511643503b16c7aa019aecd12382612d0bc4c4573551ab5be8dc314b19a23ff36423090d98c5266971d9199a4cd15cfc9d86fc115ba164398be4df41adfa12095fc157fdb4a65bb13992f4a201a48fa14183b1aa73c6c9c93b84c422b97c2c6d68d404bc8ad7d7b35d5aba1540f42e67bd8f79ad588b957242419404ef3589cafe23e4901d3efec1e1713bac9c17ca840fea328c87e0387f73ca168ae533aff349409d2d430bcb35c3ca7899958591912eb36b28c70a2c804c80f80b6c5d6b59eccc64256d9b93345f469b3419ba2b7fbf9d111a4c51405b9ecd1b5e0c1721665b349a95ed0db3419678842db5a053184971a940c6e3c7dba318cad91455c31a7239240ec70ada3e550dbd6ed53ea02d2f4b08a5653d71db9fd867418d7f829c94e4bba37d5ad12be0bc6730122b6690ff431da77589d2fb663ed805f14ec93fecbc86d01d85ae2d2c45db5bb2877d5ae74d31aa74fde0b3839010e496dd5c51097bd07058c7170b2f58e2621a9382ce602dde4ae1a4cfaac669cfda9e66745d608ef58aa858c97fc328bef9abb1b90e309577ab62464e4cc93bde00c1e0e5570519e33e3733086d4da495446093f4942e9c54afc50c1d85878f0b2cc918a963be5c990d10f8c414fc38f9b9cddec36268f898609f6fafe881c2c29cbc4a82da3426c33b0abfd6925aec5cb372132c8926c4439928f8fbfec0c21e2918ff6f9df8554f7255eb9f3a0d9ef2d16357eb6b8a4f676f98c7da7125a398e71b0c51658b37faa9affb28da62105bb230e9ccfc908343a4c7175191256005ca66eab3613c93084cb00e78706b7cc29ec65bca57faf28f7c3f0c172d3fbbbffbcd5f5a0ba5027249a1104e18863308f4cf9f55c6370c48931b292c93ccc06740d7b03b6463f1adfe557045bf0ee36563785bfd9999145dc66af5e68545c6c5eb84a71dc6738bc4d12ec3dab0d852d977d851e13f50f3ba1b76458234b434dcb4095da80f400dc8c9c098b3a72918b6350c540660a0de38a2849b72e6cd5256659019bf2df3cb52c69c335a182896475b066b1ed5bfdb86fe6b925e12807de8fe35113722c65beab8fc74ebd0c7ba57a7ee9de741cdc22b74b58762960e49c671bab9d0776fc4c42fc2d9626650cc4465de1163cda5acc14b61c11ecc1732a0d408718a50dd35a25c54c15a0c0726cac8d8573a730df8f4b8b67ab90dc25e8d4dfd6ae9ab494840c557f3ca37afc7598b0ae9c28e76d88a15c20bc4aa162be033e2f1620d4bc5228cd07beeded6d1f4d155f230b8082ca82987adee887909563cee166159a52a5555a222398c61864e13ce2164063e7cf39c5e3899a4e92f3b07b0f85117421cf4d90a5ce376dce4ffcbbdd384a99a6a7b9f7243171a3fbdd0892a4b03b3fe5295fcb8bd2fa495aba419c4e6844c19bc1d9646d8cab33d9f50ef64d2ddc677f9c1c3132128949daefc5328c7c500867c63ddcdd23928c6f4cec23dc23bc3fdfd50b9c60cd767285945d918f20e27555e2d9082f7288a66a6eb99ac89c2f684b66cbed3778bfac29d958f9f27f2edd43ac9416ce4f982a02fd86a35236bb8d072d224420d24b699a58301283e35c8e29eab0e0304d59181315d7eaefdc5e6e55f9814bd422c99b3cffd75496bf2b993a1d247816349a2593e5a56c67bc300933353eb15b0de3794e4a492ccf3132115bf8082822cb58444435e5194b9335d7327a3b81d4d71de3f5dfb67974c2cf8cc1b90cb38d31b03025388814303f8a43e2d0c2e1327683a35df624515d53dea313fd4187f8010a7c3eacb5c5855440906a9b9e77d06db026a627d8db959607a0cc6727ed96faf5197a1c2d846edfccb5754c45753cacb350056247c8ea5586f9add8f357171398ca92be23a5d0c82851c2098021005d2f15a02c8af79c7f574e7e863829d3ecca4d7a3714c7f7be908ff34651a1012c7b5016bde21d9eaf4ce0d56989b5cc82f18187684a2c9d5b6f5f23942716ae55eb60ab0ffb7ab3bcbad914f2d7f2886a2cee51e7eafd3dfd2d1d8aa167713bc70b6b240cbfd3883c083f9e54572e464194358923a2ca60965a66caa6213186d26d18f8fad98720ddce182fa5ed4cf59dc2513872771fbd08d05ae053b8a9fd0b2e8b1eeb76a68ba5f0624c2c32d036ac54dc28531fb36455f18a9bbaccd0679ef09ee9a64a248802c6ce6883527ceef2bc3d40294e7f13673b1ccd6663b3973f3bd7ecf5d484545d0a130638350c7e580f63c01c68506fd8de6c6c37a78cac682131019ce0444331f0fb34bf582b09a62597ee830fb33f26884887038f31ca520cea96b992bdf70941540a91e9b832a411d0caa98170fdbd78b96f14418adbd8f166efee9bdf2bfbd1fd10360003fcf9da189e9009f140dee7d2d42f3c91bf178aeec11b478fb9979039669f2edb8db2d0b740fd89491c1c4e0ee2487f674d29cacd4c8a686229db6c0069160a546c6103a6c4d9048631f368a359d1f255779187626fd210977a71164998cc6d75ac5480ebbd48cc74fe284181d51f119070ff6b26ee7a02705804a0bde2a24071d3e211ccc6d1c634da50fd75a7fb02b5a68d1ee853a5bae6b1754344e1ad53a1e20445f052f8041e43cb4c2070af99a223e43e76a13ced7bec71fe8f4ec0d7b8d0777a2a086a04d465203120c681a82887802386cc59a2f625cc6b6f57119c2a8203362800636cb480595eca8a3e32d1c551ef7ffc3cdc7082a980711659732a9a58b718b5ec4b90120b5252d98f771e72068444e5794102cdc40addace9501ce844389116f4df3c848f4204fad7f4aa768a21e000bb5ebfde3c635a26b56ce0e746c06af39b3a6188a8cd0c342821c660f6c59dfe3d8ec373291e29e82af20c77a91c8be3fe49a46386cdad05b1669413352a90cb45ab087070375f37e706ac73dea52d1f2b2f3f4de9f8535dd1328897ca0496a0da1f37ff9a91ac8a07c146196af4c178224ec1184377365d929ce692671eb74f7634f1b314a6b554270f421e4981582438d773f2f127ae559bc3a553141a95b711b98e9e105164c0cfe86d2d1b6cb45040562b5b1c4b64a601b623aecc09b46f5efe021ca169a41ebc1bca5ab50f38c8a3975625c9f47369dae1987d0a43ee7de1de561c8acbf512e36406a87e8e48814e89d181491bd44658533a51b88cdb9e10b3d909693f936381e1bc3691ce53483b16568681a4f4fb877a2ff261b071226111d503980ce61e9e1e9aca538f178b3233b2080bdc651f985bdd93ece6b2ddc045d32f6235d4b7e031afc21e2dff7a74659158298e82c3cb02e35301b82e09a711e8667324935511beba036145ed8b2d6a4114cac929440f9aa1d9cfb5910918d9ad5db645f76da2654e1a8135a56b20c0343825eb49285f525715719960f92935506f6b5c3da5e97596a8bb3568f2363fe9c852157e797e254fcd56e5f773f83ce0343afe500f4b104894a27f11e7704e0ecaa3595d145a85de2f81dad5d2aa49bf8bc8aad009e56f7eee3109f295faf8d20f3a46d64bbb95e282cb8b8d4e8a271300414a7ba4177bb5d89ec4d77fd83f7f0924d1c1e2c59d40309e43b0bf9a79d43f02ab566f5810d0a271de8586ce119ab85d7bc651c662237af0e010311a3675ee0b0a44170555045723dd549108b8c3760e8d0b0c290e35df2d9b56d7666e309ff31f1228b07154ed619215ceef6e7d6ec99b2cca9c443417af9176924686f48c10b35f4b677e13cfd5a2fcb171a08809030e830a9c2471f51d316bff76190560f36fb1a5db0390252e2f8e0a4485dd3a44db0c4c00a08715f23703bc543f72464432f6cf2f3db0b22350142e6e03837ccbe375717ebea0928669281f59f9f39ef9b8301a3dfc023c1c5a312e272a0724c21b141a5216148fe2faee5516aecb6a253766af83905e28d27d993ea3ce60e39b71ddddd5a530aed8d3c7e17fb1bca3de349ad827db9ccfe80a439d1b43839e07eb322c16e3e90437831b63b97befc78d132b4606b96f1397a7c6c902cb04e42c8b940172fe0aa88a3a281e5bb5e4ae670774e1e55e2a8a7ac68b0a59f474b3684c11947372b3834585979e20dc23ea2074b3f5a37a6b5e5323cd5a88d3750e8c308ce7146b3c6ccd2f247beab67d0ecfe3ca7e3e58e5999421c77465aa25626a9ce884582942c95eb51d9ef20d0a59f0f240dea6d257ca4f023b1470349c51f17abb50e3fb6b63dfa1fb38069ce57eb408a27ae6fdb789c7c90c25bf091786e8dc45f6aaa7fe5564668aa4a561b77f31c05db19eee7c288051701b5d9fd45655006058b30137658ff807579003f0c0199444672f91a74a30bfc0a52e97900b647993df53fb725d8fba551a1e2a928ecea06aa5e4396657e41851fd4ecd83cb62c8d5cb0e450f6093088ef416d93ac5f2b97e5480ecb0a6321ab2eeee22df1aae8d6140709c4b9d3b37a76f73b418fbc0120407af96a22f370713b8ca4599520a7858b651a1460fd617a04ed431d0d06bf5e3d76021ae3f5c70918170bf3abc72b81dc1047185924b4ae4064372e4c4c0ac91f344cf68f29f6d98b28ded3b7b1355bda579a74fd4a0552df4f4a35987b9ad0a07f8e08c978de6ed1aa7eb6ae694405fd467f02c99dbce437253f474f867f759e0d6e26d0e1e20ae7e6f728064f78814ecb9b0526ba08d10e935496a36952f5ad648f11078b964b3c27ddeb09170ed2b9f4533cb6161b4e28316cef43aa68a065ca4c349bf5043e14711bde47fc02a67e746b5fe051c3f92a73c04dd8aac4a75a5c80baf85707a789acd6ce742c40feef5c2047e1193085c73ef94ff7f9cd6320f6f7bbd89964477a56acd2524503e042c505673f5c3d0107a995f1196bcc2c33b370d63d2e74dc872862355ab8c44c56d6476e31453fb9eadcd7471eaf83b1098fd683f12dd76ddee076065edad5575c79ad02111bbbdbf627823adc71b5e144e2d25d45293075048dbcd7ce080442a91e78d67fa5f9dffbf21dc445dbfa34d80da7f15f3a1f77654f688df6bcb4e58d1037b9c1550a6145843ac3ea7800b7943189dc39f9331174e5149e05b8fb2588170754867af88a24cf5d83d5f8eb8e00fa7ba8ddee09a57598421c6c8c51e12db290d9083d82da16fdaa60fc7c515d14fdfa0205c5fc0e60616deecb90f80a01e8531c161d5e50eada524d130b0377a55d37068c93c741fdda8587719dd164c332c73e629bd2e64e9abcc5c35714a41aa9711497bdf12fa61a0f630e01b48c94d8d769d4eb81330d902e3130c1bf016df09110bf3e469e049ed19746247adf8ffc5023e9d1d9dc55f5d313848dbf71c9066e3001d062dde6ffd4af853676b498bd58a14e7f392c2dcde05bb6b6bf29d6dd173c2acce68cb86c43acc3c1dee56ed96d309b865b8e7860490a5cb0d342aed2c005df4c5e5eeeeb7346950db4ec0adaed82658a5d8bb86d1596af26c4c7034c7b5bec8b381fb0cead4eaecba99350bdd8c3ffb9ec9e001e2ed54408e57b137060474c4cffff318951323fd6d570131c6fac2d21aa6d37a3f165ef926a92bc210224ec81e856550f96f34aab70494750f033da1ba857c228887f52cea8b3452fcb5f702cbe899b5c363c8f242a6ab437b1e1faad19f8b61cee8708cc3125dfc74f00891830798da13164fd466b154185dd435813bcbd0c0f27d6bc072a5a51b22010283430bbd4d9b4649dd859985052a55f1143f7fb0072ffb5938aa0273113a9ebd250e59d9ec4f34fe63d6aaf334231499c567abeaee3e7ab9b9330687731d038817aadf21e28f90ca857c04c811e38d41e42e80ee165409449d37067b293549027057136370f316230de9bd2de31d7a46fa67723555566c1c6345c3ffe7a5bf48d5b1a30157519ed24ce6902b98f310c521228322e190d897c1e5346c5b862519f2841417732f9efc9dfd8c26cffe92e972aee925e7647c1b9c82cac2e7921ae01893dad92efd24c708a2a5a4ace31e81d54837a16b21cc8ccfbed1f0b86aa9db1ce942fae673466bb8aae9f90608f93872ab5d1c8622c8f426ae48c2ec3217a9a5fbda090f2583b76a2b94c5d283f4c86de11a58cc92dbaede64133b6e6cfeb30a3e477e9438aeb15e02810a2d61d774679a83e5207e9a94d171fc411b8908eb946d966b36932626233719bab43a75b372c1bada54b3880ad58de4d2b36f8c18ecc769031f6c353303ef2b69e68c3b979c11dba4086ca60b7ae4f24bd509e2e542829d6a146a24748a25aa09030ec8b1de3fd9a998f3f54c197981ef235104d5ee904e96192db7ea9a38066bfc08bb4a6a6df3b732767273da0a5eafa5ecb8b2f0363bd3517f3d8d98c5f598da287cdc050a492e2247bc2284dfad2ac626d619d424ce85e2032a669ae69f40b568628421fcbc06e9df48bf14d78d810163f0a737c123e0f1cce0a782bb62d5face37ba0c1613afd72c8409b1df0cc87328db5776a83a530c7c3c9028637a69451b807cfcbd4f4e5c7e285837b6b550c86ca333c5aa3a1e03a0d1846e1d5b4768e6dd35ca61bd743ee5c540d648c0aefbb5ad2f9cc8f867baf62036895e3a57dba3d66b581d2134e94017415bf58e95e971bb71c23a5749835cb569ab21d73c06346084aadc47502ce7711502223018aefa518e57a348359383775f5598b4eddc73d7baf27eb1dc7f103b1fef28646b692296a7d760170c36951c106f07f8fe028d1c3711ffe840cec365b6c890fd0b0056e3b894387139a790d73d01571f0cd373c4dbe8bafd61626be977e52dcb2aa1bb50295a58a2d8155eb2759db0263be87a667e791cf9b877a88c9246978c1261b2ca14cefce0a525e50d035d60ef9faa671b60204823741a7c321c8ae75605b189596ec16b544145669850b290c4773ac7a23e021cf373f29abe65f208d8f0867da25639462747492d23b5e4e7245f17f3e8e6ad6640df2acd85b01a09eb46842f281716452affbf751b28b496b7ba1feb4e016d412360e50bf16b753217a548a6162e26caf11eb7ff5df94f3681b7c476fd584b79679322cfe847817836ba603a71f9dbed1bc1bf936806c6bf0c712bf4d3c8fc9adf63c823ce29528064d734a8444124f6cc05cc703053790199b812ec00265208ff8e1e107bae184d8498773b1d67595cb68223e998d57c4139b5f4035a9950d2f55505e0671e244705348a09aad23b19c2bb846b9514aca92b1a3ebfeaa2facc98ca6fb6f903dca89ffce96c5460cc9ed8f172857dd5ccc31bef98bbf62e2cb99324bf21a52a5fbd72e26185bb25e04b822d1e7c118f6d7e65f52bf075475f8efb4e89d68164baf42c0e18e8d2e3339c74b99d71693d4fc2dbcf7d5961292ea0c3ddc5fa5bf9a345c990501854abd4d0231c1d674c88b3119867e75aa4e7afba39d053e2948e65f7700eff32098f3d5b94f78ccb2ff073743936f6dde374781cebf7e645370f292351e541f941c2b65e5f230f3bf4256e58716cdf08b30989a194103028e484f0f26dd8a46b9275026e8f7e02d2fe562ee4f1abfea4c7ddc10b4cf5892359e0cabeed72593926c27a3f649a376ab422e3290a443ff1155c9f583a90c5cc8f122d486c4f90165fb567c03d1efa2b6a4251bdfa351957a9abd26b40a2546e70e1d785b6f44577d45f619f4321cd292829ec655beb599ee24ce3fcc5ccfa9094a9abe8f5d6e792849bea55e5f2bafcf7d87e5532c98903a2f109af4f1cdafb532abeaa7edaed88f95c7c95f4025ab7c80de1e734eec3b2860930fb701e8e25e751b2c9df5b0d019b408e3cb9f3c7a6b51a962b185790d91a5d4f60039e2a74b32a33cae1735cfdd79e2e5376de5d04f4d3764671f3a7b15e39dd2c5faf405acf1dad43b1f2695daf64b62af7193a163fcbc36c34443e390b0261e84859a65d92f8738530412165c0e83b4f37378758da1801185415589164e19ec1718751b7f197863fe4396415fcd86b8b3214244192c914c49d162bd39232e5561e52d032c4aca7a0f1423007f8e0767c2790128658a40dd4e8dd8641aae84bc74f09251787b59f3cf818c8d1f1b4c51a5d51dee622d5070e5ca174eb3ccc5216ebf4819c6cd7cf5253b9b203a60e3f137393da2a0d720fc7407cbef1f08bb4bc423f237958082fd9767b41bed9c4c47c11ff934a732a991b8831d4da26a9734387122db36e65e5075aff5409118a4b9d79498e859ef94368a063921583e69694f5ca1b19b88e4f95e053ce17506b004682f0acd1c6488564322c9637338b71ca939128a0a78613acd8982f26a45d6e56973e2b23e11003eb4948a2489081ba8b813335dd5f0264413551a48139c9841ef3446e79ae3ba934b740ba651a4111bf008424310bcd236ff949bd413a9f87ed654049693ad088fb17318383957e103a729621b2890481e05b72d48c1b92fd89b5de053edef553a3b311e3e7211b8b62299c514a2e35f85f2d0b7d2607630e90a08bb3be9eede055a17ff17dbf8b0be27a2d07abffad2e7c578d515aba617a5993d540ac107360ad49fcccf9bb77a14d330135df6497f608e2acae894e20296b75b66d2b3719259e12465ee34f078116674601e3e62fff1f3ed4c6294c756a2adc1b693de39ff2dcaf9be00aa8172106948d4f0c7f879b20fb41bd6b0773f2fe669037b1441bdf8de80339c4505b546723fe2a293f1a967e16b1ac6cd68ce5cdd09def87366e3d9cfeae6ed78a83f97620ec60f4fcd7d9a44a08a14fe2cbd53a296215163ddd8037fd0ba1fdff8003a1a35a9b7a7ae0fbdbf7f93d8e4d090212923a234f76cd1c09be2f0bbd4949ba3a9714f4f261b804d24ad0091c686fb83d3060b451edada262230bb1528b1c257b631ae5f0380ff0e5b1debb86788e92c918d339d4cd30bfc3a2f58f8f1844587e40da87852a2a50b67755cfe09e7a5366da9164923bd67fda2f8ee481d7de00c9877eec69e9b7c29371773958ad806370eb639fd584067c109ff20273c1b9952d34c8989ae4e1d23897376d83ee20dfdd00b6fb76cf0a93e24610b26cf656728bb99e03ebb46ae4abd7f0ff58a83cdaa5d008a0fe17d2e1ef52ab5f5642d6944b259eeae16c8849b589ab53ea6a06b7af0c018a937495ae49743b338c8bf1fd392c442b9aab23d318b43361df933735d2d2ffffe49a0abaebc93757c4b1c1c7f414c2d270d9da333c95a40a630e614a3c41d7e3ec6a0bbcc2971af16c7ada6d993b952e22f4f597c13e463eddb7a3b00c3c6a913deaec2446fd5c61d2c443f4476af40a304070ff9e9fd2a9e23e54243cbb7e3aa01d73218dfc8d9c8faf383e2ac5f830e69f108d1fdd7f25bfa9cc0bdb8a225af878aa489df1c9b669bfb5f419d6ce2f39874b702f0aa04dda256a78b66026dc95b49c6886a5ad5d9ba0cf6646b5ce08da0b16dd1369046cc6156dbceb381d658827ff4af1547ddf3db73da2bb9a06edd4f47c535b48318a9daed07033b9bff2b2c54e64e2003c9a2826d3b9593412097db3363ae98f06403ca00442af325fef3e59ace4a1912d0bb4a7f428b0740f315671d37c15a3ee5241d8f2ce6309bbc3e1860b4170d84d22f545e9a0f46b01af54c3cfe07f69f783798097b59c9047c7569f07f496b512c310ab1280364da3c804ef4e14e681a2abdb998fcc2755f5c0aa953f66589c9871c7abbb4f1f5ac9e0288a2db5a0e05569016e9f6e110985716072b07f86b57ee6b4885060d26894065fa61fd3485ba689c9c0ae808ff155b741735c6c67fdbd9a762d7b9a29c8f0c401032e0e932e06cca751a970a023f8c05e5c922b8a3bb8bf5efdd9408349d733ba4af016ed7f529c6c60c3fddcd56cf1b877eb2bcab0c5962d0cf3a131db3751fbdf1d5c549be09dd34e08e7bd11b69d57172d477da60b4a75c23c8c27d91e212af8c53dacffcf7d2b76eaf89cb4514ae88802d18faa2fe28e49da80dfe249ba319959f7096cfb90f5d4458d16f365d52bbd12c00a48a537b16e8251f4a207f56fbd6ce4088effb364d2db24fe454bb3ebedbbd5886199837312237e42c02aa91df0b238228978086d9f28ea2e732bc2402f8bf5b5408e81cd50e3217882d21f9dc3c3f6c248f5f1f7a4f812757dc18a2ccfec89a99485ad6e1f43a3d2f6b3c7710c74628128ca0aa121b700c762ac892313781d62e3f89a53b72311acd8b6c9c18ae71f8fcec4f64075b177ecd0221e19cd6f716cdea68ff8a0c5b5229624b49f5e040a8bd2649c4f7359e2380ba22c1f6a070be78c4fdee91147551dfbe6a716d38a30bb1b1774c9465e60ea55812e193fa0a54e9aafc2fabff397c337e26ebcd1776096ae177abb1e2ab205558a880fea47ef046b609db82da499d6f1e1fef327f84fd6f7a3e697239da83a74449eca6f3b1eb0a5e75c98373ba4a836ae5e33a7a8568f7ffc180ac0a2a8a1a8c1025b17967a78a7dca891fcd70ac1b83bf342883070ff7d98da3488460e642a452a660ace0cf21e2a496f50f721788e11e3ae306b9c707439373e1a3e8b6f7ebbd70b589ae81526ac619fe19597ec03dbe7d7089fd9766d021eaba092c43fe676d5785dfde5dbc61602021f68ffdbbb5666664953c0ca5e5c41290a64787437a4c40de0dcda37da392520f1b6f4b3468afb5e359ae2b3d039a7eb394e1958a5ab2b6dfef5b8a0d889b8346ff720937b8702ed42cda34c9af84d019d8d49a9c9d9ec07e6fa2c3a2cc238d956a41c134232267e91c766380106d70eced05eb1fe6ce111da9f93728a46e41c82f2bd64c0e58d8ca46a115c6bf2d19f6cd85a28786b96ae9c6d5b74f9d79a9375901977484206b587584cf3fb61eeab4c7238e7317e346be4aaf87819e0b61bb7a525987115a3130e4c93a17ed03303e80f08a94c9edb4566f157355bc285f5ee0086fa0f1ea20ffee3d6422fec03d720e840551c344fdff0724077ec6d53ecce707eace333f2bd406c52ce2cb5e888df952bea2621efdea9575edb094aa67c7a990a55c7ed7b8a3d6e1c3b8f4b5ab0c8a0126c449f41698a87f2bb10bc73a296e4cfbbffd691b2eeb44478c8d1bed40b4bb61f2ba98f2f40c70802f8c390c3b8255015c42a939e77bb4c6779a65e619d402fae91ad19ee094e127e6629eeba5f8b003bc908335f99d50e656e38458f21b464b5d8ec2c27ef80efc5a672d9463d0dc65340e32e38c4f9f5e1374ae703878219b7f5f11d4c53f2c68d629cdb3050976294f4ad527ab4fb51098d0fbc77edc25b38d931df6b806abacd72ced7c95213028fcf0ec931c11ab7ba3b4856b6e6b26db4f33ecc249b6abc1e8f08a5bd46d63e173dbd07932291427df33c4e25a9b0550ba547e7523ad6989939e348dad2ec5d65cd7aab1cd4049317515243e5404b99b65dd9b80cebac20a646bda0ca92982def44c01720b86b58c047a4a8349b84bdd0927a35baf3d239290c379013916e146350dd70207c5b75e3d990d0cde080080f83b5c3b4371558c9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Byte Camp 2022 Day1</title>
    <url>/2022/07/11/Byte-Camp-2022-Day1/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8bdfb3fab763dd99690fbf117fe104497349625eafd332f67cd90d5805c864bc">99251fdceb9fe96a1f47814acd3007f0ad4f263f13f7c46da993e0ca4df2b67d49cdc9ee6471519fda69fd0e99b65412e11c1b5863f13221c953046289904a3846a76b800d974c8d0e61eeb8adcb9aa2ecaa1e9be19c4e80eac7f356c5fc23dc34cac9cada7b11b686cda18024ff8f76976344d1260bff50aa06d46d895ad735c6f41bf10bedc174ff69c9a19fd1323c2c6053304994f176897296f94677a9e1a61a19304c98b1131c402681a4eaf2d1d55ff00e5404fcf044d8e8b47d58cb45c470ca9b21056c0efb640c931beb5b62417e4daad131a9cb58c77d1c79f84ef3cb1180b22af452ccc4c198a023ea3d81f9a910db37273fec225de4a23e6b26dbf7769b392eedcfb2b42dad471ac48fcbed05322fd9c5705a653906c13b28680b8197916c5840364ceccf78befe4d5e76f287279642f48a7add94a7d7a716b3e857eabca2d153d694b48ee515f522d2fcedaa9906a0b64f7bd1c695d26fe69dcb611e1bd43098b051f8423c49c82510641c48de0ecba813fe0b6b813113285e67d776794e289f01e7d9534562e2162022bfb0815756cb8f332dc19cd791b6cba3596a2440b4bd6a21ddb66be81a15efa44fa23e3cff5519100749a62ef525360071a72fbaff834cea77029fc47b4f255772ec2f01797e70ec44636934e8f005d96512a8b56f2dc3966d66c1f3166c55e1ce7b69afd2880242c8613defd3175053a19e78b3928fb20c46f03ac4bb99472e0fa13ceab3b298f930a0a0378db18c1e85f7c969858df54d9b027f306c35247171a6d3d1f312c75a52ad878f8a9474f938d7192191879e638f30b1d083250a198730872d1c6e3451dccab4458eb5a229f1c4aa63a1830b9ebef5c6f1cda7b64c58eeb3d10677aa3c5141999eb3c5e35f1199452433bec40a21a5109659102592a1f58f14c69de47e3a6f428778b0b2020010929a2b78f98fb15b1bbc167e58c251c2e7d3c9bc8317b672c975040cf42fce7982f79e1e442862e580c80c5f0051be64907db2d75077cb780ddac18dc009b061107eec8e1f1a1fc1c9979f6fb54b7d05930067b8f47a66ab1dc864c7064de01ebdac041650837362df9c408d6cec2eb6dcbddd34cf67b8c258e0030be2cd50950da3dba04772d92cdfbaa8a820546bb7faadefb947d91dcc1ec35c8661f88a02a4c91c45bdf5c272633718af87522b9ff4ebd14a882617af0e07cb2c53a7711dec1d6662870e5064a7373ea1be15b32e9e61febaae8e8238f486dd22e691353a538da5e72b33621cd8a295301cb6c4e71cb2677dd54946411a8904a642599f99afbea253c4f050f2792aa7483da1dc7c480efabd3143e86e6007c2272c3cdf3b87fb8cded0b93e024994fb6d4cbe5e92e4c512f40dd3a50498891a137393b49b42c062984830ba79d6b933c70272d0b32d836dae3993a2e1eb1e4aafa4ddda3e876a57d5e81bdb8708effb51b60e84d4cdd074d1105a64252260f6c93f238b3fc969b2d81ec8f4795942203dd27a3c53de5759e9d3b65896d0cda786b8034092ddb072892b913a6e026ed52af1426e72230e5b318a87d13841bf26083c3a285dd758c4060752d0048107164b7b8f83d5e92098b0e7a883829f70f796576893f8769e445df8e3b6a954810d213558b817151af8014891ae85d6742837206f85948365d1539f7b22e7e68bd17a131ff3990914047529c8e6786090119374494f88502682f517a2dd237f99f25bb0c4d9876077cb8e1152d4fc25ca373321cb9c4c704079c5c3c18dc78fde8da4cf9e21a5eefa375d257b51fea223f05f05f7062ab2cab64ae01bd2a0c85f4fc43d03ea1fe67b2f862cabb2415ba703233aa5afb1da952161b290b5cdb166a12fca0e904f5abaadaf04ec0695f241337556bce656c6cc1dc197fab281953e20846a9a431f603161ec676761428f569ebe95ab89d8a28c83fcc2a67d57cf43e278235a0f1d512c7902f3655143b7966fcb85aec24a4e5983dc410808edf16be39a1698a80e94982f1fe97936476e44fb88730d6484f4af64dd783afa6a17a6f231c04901ec5bb2d4f743e341974f94b73c29c4e61f90c6df3e20a42ec36297449caa0841a61d07bd954e102a877d0bb30ee2424531c2651f85ed528599a98db878e978c215462629e2fec6be7120dff0b51bbb800d3f16e50f51f21820933502dbe7c9edf968d00e1e0274e66044f7155c37d352dd1ea9001a30d03914e68612cab8bcd9933838165cb5db0adc8b1138a5377f1d691a9f29540400fdf5479fdc7cb5661ea18fc09835a61d8192076a51a59e04db6820a4b2cea4e14630636b7ed6407e5006d095823117a9e7accf488a3b9cadaece5d82e6dc79671bcd4711600381820af214e8802bd7090605537f8d6291d5fa1fcfebea9fbd78a33484724120ff8c38953a15d92e9f24224fea443ec26e41c3693018e8ad0754478536e2ec59fc5b275115589966ca55dcefd3695bb63d6c7c0918a3e1c0067baa810dd500d27d6562954750e18650b720f5bea2726d25f38fe8074e630edf52a8a0c24f622d2a0fd430cd069cb534fc3719a1ceaf6ee3e905e2625cde0dd1977dc61405d2b1bfa4e3862ff4c0a55c11ba3c332872e628dba274eafb59ca25165a13309113aa51497b119e5eff81fc010689849910dfea6d186f18fa7d8b0c23869ebdadb37491d32ea8358531bd7b9ec815b244a3193465c30354ec4182b706154fa5735e1ffbe1d631e470ad688e2178bb396ca97a5cf7555bba9bc908851194d312f3299a94cfdc188aeeae26ff7c10e3f129844c9d0198e1dd9e8106e6aeba44167bfa56fa0713de5d9452ca1e3c8eedc7a58012abc9fecb74493a2757e39e8970b2da19764321fb9a10522e8943bd5bc0425c4d502c982ab36f9a4c878eda9b95c5a131efb7afd8f588c1e58db47f3d0342d3cc0cfdbfa0ee952ae7a8f4522042c9642027fd289cc4cbe5cbd07056d9b370bf79144fc9639dafa41683d6bec39b97b8e70426f64e626b5792b4933ff11b21d0965659f6beb29c6071f220b462d56259d09c5ba6cf085aac4803630a2c092a47f06e965200b3550e4a7cd62a1a5368872f97f2a6577040d5d9df29d05314dfdef554f937f17dfd452787be089ceaa54bee6eb3e1da7272f38ca3c7b44b9137d25b9fc904943f12f0d7d094fa1df6ba25ea9046b03352b50eac0dba477c9ecd470754fb1664070467c9c9902eb5160839cbfb854e95eae045ea79dd9d5976f7cfdb98125c49268fdd7ae30b2895e5101fb4559d020c89ebb2946187e7fa3acdbbee858cf47f728f6cde073af1339a5a039b847ef73a0d00216e235ede16c32951d858585edaf5e62605f01358b4cbd43adb86b0c503731f4fd9ee14675f21da034048c3e8cea727ff1f78235450336f8efe864e20f9ecb8e6b3e89e4cb462db4bea386ad72b0bdfa3da138f52db87cc8761a5aa819b832e6ae56d9146b7545a82497979d485939f852eb5cc3b99eabd19b62447077e23e144f1765106815ae8c3419f4f0ff9dcceadf58b59c79a90e1a35fc2153d4b4b8f6a7950cb45163289d4ebadd81f28f39b5ce3c6ed4649da7e0bfc5d40afd9164c50303a0c4c809be44eee960fe2c55c0a1e91795ca915f89c9bd5ae1f51916e2c3653cb34b61190623210121787fad5bb00154f32c8391e0ae9b520b60234c42239a881545e86c985d083317a1610833d0a49ce4a60dea4627349c9d4105cf7cfceac65945196a0b474a0765358bb3e3b76a23b004b565aeba6fdf46cb79229527b6f1a8f7dd27b8ae209dfad2138ae51d19738da4bb0b756f4c6984b8b4a132e1cf9528c288659cc85c76449ce6fb6a69de5bb362819f657b209986d54fee25a95f639ccc5df5a629d5890a0874717ec38545519c4c17988630ffbd5163357372ba2ccb033ce272223ba1e7e48e539717005d0e470e342df96d6018b10b61dcbd26636e1c17b8ef64e1127fa514d413c249f7dd603660a8f3a6f53e9ad74f4b5fe0edfcf61863919d15c995e6d77105e7d514b24ed390aec8742efee75219563b48ff9f9361b8860b7e731e32aba32be7b153fd37bcbe33c8ef8027939b937b39df2b18d4363bb553640de727f2b04578f29e10faf595532ed3ad52682789cea8c2e0f7a1b5e6b029a8aaa4eb5928491d85bb36934d50f30d78ceeb97459f9dc69c16d6081044014a86b093d6bd2ace0f419990cd7885992e1895ec942645e961772ad744a93f58686062b5757533977956ddb161009606bb13955a41c9f6aa143072ac8f0bbc34c872c3f5fa2413484d09184052d4c084417a1ffcfde9989b996940ad197be65e0f44ebe047fa0ff72ed57241d0e608d7f86bb0c7284fa9de3246d3758a84355243c58d6af60a4ab05ea75fc90c6b4842f76e4be09e9fd03475ca07ed02c12ce61d1bb92f6402df40d3c937271ce77cf434624582351e42938f560beb9404780d67945599e6094cc7cbe1a2f63b173769f57042f0e7b0f9fb0cedeb562e6415980ff545705f9c98d0fcb477867643cead843e75b56716d1be59bb4f167297c13622e08af5655af2da1d8be3a8531099933a0a4d8bb2aa568822c5dfd00cca071dacaa28555dbf9d0e8d35256770de0fd4ec6ddc827944a7f1bb097dec3bc8b7fef19cdb917fe49e2d5d76e40f70f10dddbc7c041979327387ce5927f2408e86a0b38c526641e02a40ab19eeff788195e72f5804bfa9c0cda7f6aceb13e22116850255a804a325e7427c2b7694a1770994aa91cb4ba3de15d4aa030e95a8aa4976d1f58465c8e697f4aa625a72e8c490400ab48e1861919985cee02e72c91277aab06f2988992c486c16e468a888d1d0a24f4e438f861ea9db3ab575a36b06135f6397c58e8e45af9ae3b5a49d341a06b3ad3b659f87f996d2a444e8b2b72079e7898581e1b818f3c0d22cb2c75165b470119ba466efc30a5f0814cf7b5b0a294f667b5da3eaaea47016a8db31f367d6f9edb873a9b0aec27953adeffbcf88d50fe7c2b52b4082b8b213b8bd25fb9a5be34223050a02742c4d3ce182df0a867a2f541572efc3da04da30e5e975f6f86a44621579d38f72a93e5036f7cdaf2b9dcbe7550e953ec7e5919ee78ff5889735a4c3f6767139f9a3fda11d37f26aa37b8355e72ca544f80164bc0d76ae8481cd7c8728c9505e2e477511eb9466f181cb7b873aff9f660f864362025a1cae189b6527b56c6330ee8db04e426de52a3f0ae353f1ca3035431870378dac5739af5c1ef1dd18a09f810e10c94e5f6894a992914c8f1dcfea73c93c4d85140757a5fd32e4e6612be53ae60a9f8a93e52405b5297423d95557c16feb03473aabdf558e220bd966363f77a15ba4a21c805c8fd690259949a12144df8fa3e4072e3004516232dccb704fcb68c2dc720a1ac5244a19689fe49b8b65d51e32b8e417732ae49c8e39b3d26f29f9e14a6bf699e5ee8bc6e9219b055ac02424ef95172e2b3c0258dff97d35d47ef5e384ca391c91a6f80e154f049130324e9761e16dea46f668b39d32bc22a6968d8b13122e004cd4600ebbcd4f840ef61c69a4814c186c2e5f01fb7ce77443ffd8921e7505458fdc8e5195813286b02599b796b2734e0030bd8ef4bc25b2f8b2c5293c03f09790fb3bf92b570d609b1dcf10c195eae645f5cb75ca591b7f7359d3bb44d60735d8dfce9e28ae9b172ba4344e2a0200a5c87b35c68ff489ac96bca352aedba1aedb2af1c4c1152d23b8e5149280c6e4869177d2564909b56ce0846de230638660a856b01554e54a24667acadca7cd019b0e5216bc57fb5cef9c32b9cbf9ebe4ade4ecb165c7af850157fe89c0da623e4a4ee7a1894052d0a08e976f46373ded285771bf53829e536bf47f46875e21b95f8921b8f79e7b5ab774e6452ed48232758c6bfbe31cefd3de63ee2e68c953aaf869c237e7e7aab52563c55a75acb70412ee41e3e399d40f6b356d5e2c10d4247ad3d00ccbbe5026250b8ad0dc0b2258f9829de857dc56bac6e1071e0700494ffa30b6bcc917b4fb69a94d368be76be8c99bb6ef413b3d0666609a301578bef575cc53bedaa68f0e1361e4ff977dd45f51864e7bcd24db429409c5aa25fc30928083b7dba1b549d3dde3310fdfbcb89a8209bb4c6385a9d6a4dcd12c9c1c899496331679fb1005391c50010b607d1a42219d31729e10e562a00ac400b841a0545d01465b83c43270d926e363e6230a4987d667343895f7db656f25b06ab04f4871e3136c0542db51aabea5c528aee18cc509f3e28b2c65da162002432e9498cd1795ec1d1502339bd56ab035a0d1db580b91a9df8034237fea592c978b1fac0704903f0104ac850c12320b3f9625837d90b2b3b28f0f554081241cf8c839135a738f3c066d758508057664dbd3344bdbcb88468ff50bb35309bc66f06ba3023d64844161f1bc49a37be59b2c8a6d395a312914c3664f5d5561c54815db9c0204f984ed3eebe96431da33f72e540715aa5845e72beaecb2534da6f2fc12b7a6d643e88f312aab348c51564469ef437d5634507d39ab9329cee9dba2e8e632a25865c46a84cf2d0c31786f32f4844245d78599f6ca3e7cd0e8024aacbd6df4df8ad16f918633f4bd718cac378b639c68adeab8397615c22431797ad7ab8f0650e532dcefe379d86a78818a7f4a35b5eba42809c49681ffc31ce79cb00b083a041dd9815676515357a13025ffb4ff406b30ce9962aedd19c17f73b2015f44e6719a360fa2a7e59076b900789bec5f0a37e7e2d50bba73ef6bdcd51e1062b0e056a06d70f8f5d76a53e94f13f8e8536a529100f4591ecd643fa88c073e14137fc1495952d0794d79d67bef6792e5842a583a37730e3c2492c9e07efbcb115dafb12409776b0a7503263f3c057d5fc7a2698021f69bf646eccbaa60e48939c3a41f2f8f2ca6cacf9f02ebf9af96372db72ea8f280d19fbb92ceba4dfa634ae0f1214024d84145a6b5ac7a68c7ac11df7a96d971e91a833b1724f1b2b18e9732e09275b19a1e5666f2399a1ebab88e7d7589355e2f8726c80fc0f2f7c90674a00621985988c5655d2b3d2a4e8e8216e3d3d696e22cdf97c2638f726ea58e0ff3e2e9dfa1c51560bb9a6773de795a6934b32eca6c40fba72eab5262507252e8ad0d6ca4dbdebbe40bb6007874cdf7dfa0f5fc5dabd643a7e2801dced82508c95572444df446a0c9e3460083497a8466cd4ee809da5fbf3891c86b05d7a3545922aec69610107f3d7d03acd5fa2d09d643ae34945509462549c981ccba98332fa6df6164715ad693c4d122e1a5f61aa9e47e12f36d20e00624ac84beb15ee19ff92b01c04460f3f8b878141993ee22cd42eeff98166257f24e0748c81c0c204c5464d0348ae28c386a681373224ea78d1b8838adf2cfa5d793f44a75ebd66653bba19ad9fbd8896d5e92e596fbefa8372ae02da4cef8d18f58469337ed08b56580598fcd2423c57a1c86915de19802250d978cbf0bdeb1e16e49b16917ca18d951312c4dc95c9e14c4569c66b4b467094963dd545662b265adeb3362ba5d5181c064f3f8575a06dfe90c911c93cfa6efda10245f12a372485d7597f90fe103b9eda43b8df46e202c0162da96f67e02004a1c2de43a5949402ecb1c60742a08e8224de6d685ffbe801f33d384e5c3e5d1edfbd72931d216817f0ab6b74dd80679d54685a2167eb7865470a6d4688bd5493870bec6044868170dbe23cc41247c651cafbb0b49d02e6ab222780c1f10ae7ac4f9e8bee7f6bbafd3c9224c874c1fb3263684cc7c3147db8e41516d22b70a88d26e4e57b5cf2042d3d6d21490237980ca3ca9308727e7918ebe64551b325407a3b936819efa45d3f745f76dca8fac7fa8c00f930f1aba16d19ff21f3384f8aefa77b82f144238f6537de01ac2f9462ec70d25e93b4849f40198d0cc09b1ecf96e016d5a4485cb949ba1df4af9307ec1dcf52e9a9bbdbc349492e44a610fc5f2949354cbcc441ed6f68d90dc8516a453a24713ebe9b1415c0ba5bdc33d253e2aab1a75224a297ab43a58e840114466a1b2a39edc65cb1d27cc54c076e1c77592a5c10d632aa4ace0c37ceb998ba11f54851dec99de6b283e2309623602685a1ab1ae7ecc96e3fc99c92e2b016f644dfbbf988944408944d097127dc627f054fbad01c4124dce1688ec6907fbf489d92480ebc4692d54cc7c67fb6a296abcf13e0120c7256bea8a2719e39cd0ef7a57c2a045159601d38b7ebf47c81440b99c21ab7ff37bb379aa44c5c8d8494308b8ec96f1e248659f46da3c962cc18e735b6127bfab06cd041337d0668d56d30f973a24373cd03297b6b4fd9fb5d3b313a67563050b8ba0f57cfd634670f6ca9bd89140b9acbe2903d8f87f0ed537312470885b7b797bf01b7495cf14c882836673714093bb057ecacd93d7c628d4b317b8e5067e0197d3abec095f06ce28028effeacf626aa9479a56491350479b78d3fc9cce54034cce6695f55f1924f9f70151dd386fc979d442701cc0466fcb1a6ea92c7736ac2efbcdb12a5ce8883e971637abd5f2bf04be5622cfc8561d0c3eb02cacc62b57e545bdb9003f8aeb12d6f62bdbf0a4b4d6b3615c713caf07a220dea73275a5da1210d94ea46e48585e359b37d006486c316a23b009e64a4eb3684ca61d76287962e62a2d466cd52ac1d8b6c30bd18acd5868c083e31b2938649e7203bb3bcbfc1a42249e5d60211727af995e6bddad4b9db9a0cf00ecb4c5a52de136a26bbad47fe5244d5e2fa3480f0be94198aeb836c58c362412694548e891983a0db0fb99bd1029323ff9aad60a202d5fe915f01c4660caa1a2457dcdbcac5d1aa3896189ee20463ded16f68f1c2ced8018da7e11687747644ce50c26110e37623a49f6c02b52cab5b6fbe4d9466840fe374dfc0f5c86c9b1d31480819d0eac4182345aa4d2c0b0d1c1ad31a1164940515e937541bbc0f1c68ae54cd9ce65b359f41488f8f992b939326e6c146ada99b26762dd007707a7564fa29bdb18454d03a8f474ae70f8018d55da61269ee2c912b53db1ec8f5359b5c06d54987fa9e05b3f937edcf1760880762b4d0742d8111d9e6a8f1f578e56cc240c581d50ee5db7bfe35e739b8143135f25f34dc74241ccd52eba502e92c633685d0f8d3f09393872e4ef110c22831d65681eeab767a3175dbd350ee2fcccb680e0ab7f8a713a00ca5811f96c68e9d3ffe8a585a877d669bff916cb22a18907ed614c22abc4a5ffefad1c1b89e11c7948abb445553e3222f748b6718122373e6147da2cad79eb0f0bd29b2f8c484e5a76647f35a10b1cb8cd88f487fcc8fc12d96cb40e77ab4795a16929f6038a9840ef7b05efa00d56fe96109251706b86d2c504272bd7d10dc4ac3d4a56366fcf454a1c5684eb5ad193a8bc5f9c7a89462b5f4386ee45547f967aec2f73b4362df3bad26498902af2e8635669261dfdd6379bc0ae513998024c9fb06d7256ede9a9383a7698584bccd8015639088136f375438b4060dcc6a7bbbe2bcfd11391b70e71129486f485dce6a32684cc4862cd3faf458d023ee67876eb8e0b93a48ad5644caf28e1460f2917d22d45f4bc935edd52b173cc66db0abaccdf777fbc8b0208afe82e7dbc2a760bb7f2b41a465dce0393f5d5721a964f715737046c3ea030f1fa1712c5539a706b7d5a531459d9ec464011039b8ad067d84700b78f77611ccb5f5488efe612d5a25d777f9369173ad787dbda47172b89f3aa54d14a9941fe688a43eef2ad3c9d75f56e7dee014ac0928c2ae4d0c59a5107c94d06a08c28988403c60e91b325ef36f1957d396258863d87aaac2a004bddb64488d81b69cdc5b1ddc2a1a4b2564e0e0d7b374e04b7417b71cbb0cd6a4b000e375476525294872ccb6a0a504441dd45f73ad23f9687ba2cdb017e27c55f76ca3841fec12351a03eb5f5ac0ed5ce81d77e00437d1992c28d89bf6dcbf4c782a94b78825db78d7a382b4614f386435a51c77ba929828a6ea1b05367bdab845c850f39e68a37e84acfe2c7aa271ce48c7b354f1aa1ee4a84852eff868e517242556a1ce6612f2d6ba254ac3db120fed36baccc0e4090e11bffe3f70262b23ee5ef20745cf007a988894d7f07d1d0653d6d7d08199fb88f95ff4ea42356efe301e3e039323f7d24eb9246fc997ff123ba2d6ca735c9971e47e654e0057bba96278f85a2a833288569be8c95817ad3088f47136551e543ee7e4b629d5f182be26000bb8ea1d698f17bbf02c2de98ec9d57fdb4802685aebe2b7a342c1992d8edbfad2ae54be6e6b9cd06b8f7f6b68271826300cc3a1a5053f896bb69e53f940de66d17b9fa20aa25bde6fbd057142a236c6705d113a7e3422b503105fba0e12794e5400a99edc16c6b37a93d5523d27700f2db290f7884341f08c43e5aecc6fdb8f8d3f763005c1e736e5f45bec0bdc0fce67c62e13cea701dcb300fd3688714a481098093e9c00ca5893f9906483407b18180394d036939b6518f4c4463ec4c358533b959ce7024a71265c0b8a1922227b6e3259a374b3da0cc24f89be41e7758ddee53b87f2de654420773694ac1b736834fe078ebf7292a8744efb2e92788441396c87e99fa37f82ebd9645b1f161eb8a6e036e36d85ba1bc0483df4049910f798d86bc5c5255fda292d93ab613f2d4e72dc7ee6124505b8cf767720963e891ee91ff8eea1e13420142c1e77e3c56babd9b43b4525b4ac4abf56e0cc13a4b119e3f1a920f9bbf08c5e3d08e4b5bc4b73992ddaf8ef27c2bd58bf38183c48dafe99d75fcd7c6bdd6c1e50f928ed9874bf0a7b7407137b94ef50b7ed685e67da4660fc8bc47f309c6436dd6763fc83f8028b54d8594b2741ec3af9c32c6dadac2de59ebf6a8f3e3592d722cb9fec41a291b53a16f461953f6c3559e9bb2433ff7e6a2edb8d40462cd92be49b9de654053c2372f63fa00981cb3dc1a2e57f9a39891258aa7c5f730f7e2a658995ab1e9618c1eb64d443aa690f88f93c8589a8b283f65d0634a3cb8e3dd05adb3bdaa819487065dfc14d9eec8d195669c086cad1265a2fde5724897fe0495a1c807b96c66498caac7fb877b5ea52827d98822f29e451e4aeab4c0ef132a62029042cc1ef8ee5a71106e1a0a81a32d5117aa12f129165332a0313daa04b94f91a22501de37c21ef8a3ea8606e0097bbe3edbd241249766f948c459b21a96dbdcf2ff5cf6e361b217c7ba2334f005a34a9cfddbf99de197a4aecb4006e6fb8f62468d46869fd392b12e5bd411078ce4c8373aee859c1317a214d8dab4eb6fd8bc0b08d006fbe3a608321ea8bdb847a1b7a2508b81910f5dd6605181d175d0a203849adf3a7690d33720b2219823ef1814243fc6347eb6d67afd81ad47e8f86163ec591515756ca58786ee6388bf24d0309452ba5d61d7457e7eb65cf299be86f823b62ee6c5017fd472a9abf47243f9336296db8fdbc0ff641283666068b35a373c9c79b0d5ede83f67e0b3552a4e4dc6dfed09a0b41d7010e94ca4febc13283619430777f4a874968f9ef0b14a18b60c032a2c70f58af2aac27af755c1be4bada891a3325d2a72b235fe80fd2f88ace37629966f71d3450331b33da84bc66aab2799824910fb6f626ce2f5cdc9d3023f0896d260f6a482ed05b0920bbe23b9b431e2b19c729456d66e4a4875f03c37cefadf3e7048f142ec2547cfedf8a765d81914569ea36f435673eb56688e915fff43cb551f5ae38e7e89c9ffa0775c08fc6698547a0e1afc7f321233ff3b3ebbf72b60b8bdc2597521eeaaddfe06f89aacc50910d7da1e2874a4ceb3f28ad5f89766f8463d40cf2e82369c2c8ddda9960933a40fd8d3f1b08a78da44294de88476087e981916e69bb68841cd5af8ef89cecdaf9c4063cf8e1f6aae243c35bb8b7deb7523f2e9e864e3c6e646bd712feed4adba56e5287590dd679ebacee2c6d4404484a67d27621dee11233489f7c623bd29ecfd9db270c59f43e39aecf0a2abee4456f1843150625e47f9b9b1726a0bd17d89cdb95239b11562e1520b13f33818bff2734d009c37b095192cc272be87059c00e60e771550ca691d2784a915a3854f3f47ec161ecabf495f74c106cd90afe07d2a9c236c80520e57e23310e5410bfef70fa89062656c5def46af1b1874f4e7ef97608aa1ddc29243b49bf6ba788074b001ff0b1d4d74b2ee30b5c5d8786f76a7f4611dc51152a481ae6d4f5fca85ea7c9042235a6f01e8752a8f66816ab5d1582a5074724ecb781b951bf93ade405e6c4db8bbb68daf80be900a67c51e1fc5647078fe6e5a1f2503b237b7587b3a17f862abf50c400598c8f68d17b8af5605b02c47b0766ce6d544ae85e25bc59f1e8de95e635fd636fa1292f46cbf8cace2a8620968f61793917fe56da887f19b693e48d29ec7072fd6edd40405cfc4841997963cd03008472aece3fb5c32c430d45ae1d95c8179e536a902d83c1db36417784ee8107f1307817bfd46cdea704c5dfcd831a6430918c0790198aa87a4dc38f2bab4733da69647b1ade316748ae7da5a26ad7e449cf9905d03ddba1b57e904203ca64a629b2b857756c5b6ca242f2841a24bf657ef697aa4222538cad18c56044a0161c41a66ce93425589756fe284a02d5822a6f77cc858c87fd7119f08bc2bca6d44de449317df183344f412e34363ddd3185a23d30b7aa0cc27edd9585e210793cb6c2788ce9c09a8bcd0900aa1fea6692a0a3589e3ba361567419a920507fbae5c92757996f17adc1138caa192729830784f7727dc457b036da09a653ee88b6b4adb51f72ebdff012153bd0bfd3630c44537b0dfd6c4f44e4abcdb1dd95800a7acf487ffa585127bea28ce279b3ff5e1fe73badf80c7769d419970601137b01305e6c6e4257fcd04898d90aeaa0bdeb4cfae3da027a56091cab0c559ef41df23aad557e1d3f0455e7d7563d8e13151e5c06a09ebebbb8bf37e90be3aaeca86faf7571c9166561b405837a5455e549f5300fbc6b7fe112fe93d51fb422ca7a57b95029894056fbebb5a8af8245824fc95d058a54f1efe5704afb4be22272b07878ec3b9458c48d1798474ad93241264d3443c268acc5a1826d2c65648ed557069b7db62885c8cc09955f1e677d8eaa523851d159b2434d2f4d35c49df253cc2fc7502c0f6022c6099f680c1c8074a10f8e6eda29c73e6192c81121866776b977478a88ee0207b65d5668fe665fd535ce17b0a81f35a228a43447abf4d4a6ef21eda4c292b155339a4b9e3cba9cf9e24c256960344ab302a9af2a542a053c828356da53815b7c427cc34ec8c3e612092d49e831936d7fe2266ec97cd0fdc1b6bd3c5fad3850b7d3b16a3ebb2ad33c8a37dd5fe68a7109f848a1ac77401911f1d96ededcd48a34b97f9eaab00c44dfeeab6cd9993da82d2f0f49a14cd9dcee61fe403b58659a5cc6770894d3352fcc2c83504bb090951da80ef8de65da8b14dbcbc03f799ca4115062a18a9f94b7de1a06ae9c8182e802a0d198a5d26b8da91e94f0ed44a7d76e1f41c28359e3068c9d14494ce080506a6c6b2628fa6a0ca083a4f3f3e36b3446605e32f47f68aff59300d327ee2021c8101f3363935dfbf065edb82aef83f34af4cc040d7d4aba3f85668b19c6ef74f07fafc14140678d84e16e2fcd1482d8173beaa925af0d654cb704b94deba1628ea43c8840512406f1a5773f138108fac0e0b8cd88bfee8f4de211581e97ec5394a607985a9cc81a898ff87c597127816d893f8a3d9ced592d18fe5e5b388f64f0377995876a048172dd829185ff3c3d54bae8c139b659a8f5bd74e5551173b7e24727e3a636e464deaa77c21c4596a75f5e089ae0595a3e5d5a71945a9e1af79e7d138d6f1cab26f49909e4518ec2d4829d0fb0b3cec0c3a7e9274bf31c7547ae1b9ef4425a840f2a487111305f9e6bce96c8c29a9c6c33a432e2d6947397d22c9e5ccaf1bc3bb16f790d788d4491419ebfcdd0713a72de65cae18d16c8b92e8b4e997571604070078e9d1153a44c7b4ae43a3f7fd3fa9cccb98d61e61f47ec219c59be3a08662850772c3b4849df58e792dadf334e2e6ce57e9dd2d16e5e6224629c079781deb9252448f2ee611d4728db0782d3888b769c27693102dcf47da2880d69c7479c2ef0219f498a7617022fb751a6d870135332a4f682b0f328f635003cb5681ed67ea2bef048015f7c33b92089859adec85040ecca71ee8b70e4c658be280efece5cdbcc098ad06dd5d6c5d75d561e5d12360c3384eb14a280e377142a3292218be919b07259527c5b7f721720f2cddd5489860330afe8a68d1ac953cf94c8db1e6ae741898543461fdfbc712a88b6f32069f22ff04f6cbaecaa4ec409cee20c16848af980d7e00add14cd5084d655e9a924550b90369ab4a036afac6cf7a9536d2c26b229ed6afe3a8fc95d8adf20070911fc43b12ad4af08c2481dda20ee350e7647f0fe75ea066ebf7658c6bc8d182c923c2241c66166d7be519b7884a60cb8dc4cb9562ae7fe7f8efbf935861c58fee195b683443d60b67f072ef009ed2462ff6a93e2ed472ea053b6f949fe0bdf814ef46f9e521f95e347ef815bd905332c1b0deca89f2241653fea0fdab1abd135f54c13782e4dd77c4674dee62dffe33ec60505e5d9a99edeb4f9ee6459d44d3c35ae155535ed3e16ea05dc527bb1e49e98c00cd33cba68913b87a2d0c7a7464cc29a06e116496b68974865f30dd103c1fe751e20933fbcd07a3ebc57a450b60e606ef1cbe1496970b70ad1a912649c1e410d28d2b35648b81f98ca7373d032b89963a995be841dc9b020f03bcc969809146b8ca1d1a1935855d4c9efa9adabacc7e1f6631d382aae482755dec7c01a8dbd44d2dfa8eb9026fc7e64bd0b89ec993750d0caa9ab1f7cc86bc9beb717a107cb6a36f7c6f2370c0dbdcad3a0ad862808ab8eee4e9acce06b5a0094717e67c8733a9a4b3bd6b63976474c55eebca89e299bfc7862eb6d093f299c163ab1554e92e6564e0e598dc25136568bb392ca37fe5b3d96ab50c5e0bd9200978a3ba8f53c0b6db04d94fe5f18fa58c406c22ab2a7779f958c86075e3c4e0346258375c136093b58e33bde3399bc55f43724d0849d4c30ecb058e0b4d053defb0018a95a92a7346341a44c98010c89aebdd5a95b99a8d3fc55e4514a7a857d6cb5eeea732a8f8f4ee5fe8d7efee1bf855726a33dc1c78a6c411933ef52a2ed24b03368da3fd1fd1440cab60f49381f87e32a142bf18bd622614e896e3fc6afacaac5106210c83620ff3414cd522f67ebdffda7f96208eb0cefc47a6a6454df898108913ee109fb65b9b28c509b561f105d33db5b62035516c55ae36491f442aab6fb7d64cad3a807d8259fa5230de07974d69c359884bf2139105a716964dd106460cec2d98d2a2665f3548b175e28f16d79c0818e150a0ca45c5f41688dd96d9920da9c94e284ab49af28ada5ac22d1d38e2cd513ec7289a8d343040507d445aabd645689910269d61ceea43dcea309e306eeaac119bff00bc2989da7580e64eb39ad55f3721fe036927a586d60b2a3ea1e126549310df5aad00c83ff1226031cca9447d9b5b42fdb7ee549ef439019db7d9b3491b67715a305546677bb70864dde3c64c48876b221fc1d7a4ceb993dde551946a0f344d2d3b07cca52e3bb063cba0676e23fb1f4b80e58d6bae56fdf313bb241a6956df7d72348e7df83a5f6baaadf953f0d65cf5be8ed08edb934867cd246e8b568c823d66a412aca4d1adb053a91c3643ceea53ed98efd7c899163f79a6a84462574fbc6c19a6ed2daa259fd7a68ff12ef4eec0db0bba91dab3e7c238533169c4f27c9cc1e6a4c194dffdbedcff30cb78acfcde8ab1f76692f4747575b1302218cd6c9c8b3866726ca0bcef822b8e6dac11a43340bb1293c3d168f6ef8d59b96343052f468aa60a67f68dea8038f8e76353d939b125d1e3a98dd3d31682b18fc4a730c4e3345d99ba4c6d86efae68e0f9f57e43309cd9f23697238e28582c43030d7efd6defdc9d2a906035a8219f010fab09fe34733d3d76d2a11507cb344f1337dbcdac373f9170e1e6445115d32aaaab36616cb68c36873011a48c7dd22d9f7fe24a1b2973f72afd1c6bd6041737c46fd29c5b0de47715958a0b52199f6d0c5c0c8c60724fd461dbd7f5d1395b7f58526860f6903cda000e9fc77279664f60dd199a3a104acc5116b5b25aa0b3181039ff881dcbab06648010f6d6d8cdd1d27e851905f31927c373be91e3f100d1c02b441d28f9480ad92da7a32d0e113fae04e3565d4d844d2b53cce41e8a72aa31e651f725ffee1d8610ea3f31ecf48e0ad1b30612204f85f1669462b2eba009dc63b4b735d6e8981c241e0ff3d87d1df0cc18d09df19e0360312773dddf942f626cc0942bfde90996ec4fdf06c518f8e14435c47ca39a178eada383df6d2eb234306a8a8bf70d6e620b16cacb379651aace84383ca4e3eb7bce811900dfdf6a02037a9b607398642c2d96ee13f2aaccfbd7acf7296fdcb5cdf51f58de1fec28266b38d081b79320b9e861c8b87770ad6f0cf51719a6e5ba748800cc2bd6afe7b79e0d6961594fe8bafff15230efe98f43f29565886447b41a03362f7cd079f4a560850487189a37a1b47bde740ab35fcf6e1c8324b9068498fac236c2a9618f28ecfef8031336962c0000d85150cd0737a4300d5aef2a4a7399b05b2932684de535873daac75ca6f3349f3fb1af15915c14098e67429d107550f4755453bb1aa4695fd0114716b7e91fbbe920c1e7a8ecdb3e25c0398a98703fd836c8cf90971f622ab51556e99ce768a797bfbb7f938945db331cf626ee303f01bf3a82d7da94e0905af17fe5853f6c7a87ff972a4688fd8d2a9741553720d8beae4f54f4b1469d552d02cb71f668c4311d324f1b7e51eee980a4ca9c080fd7c5b15ca43f1bef57dce27e69e435479607c8c18c2b4c67b201245456abbe95db62fa87def4e4acee9ab524f8be2b6ef05932cce4453b70574d5b52693e2bd7f2bb02a1fec86f843e75657dd136872f467e71826c16218fd4b53da76c074faa82bfc57abf581c3b6f5454da73177bffcc773f1e605e632c2a4a56a50f03fbf459784969cb47ff0d6483bb06d43e32f359343d0a36b3ec572ad50596f8cd8dc3ac8a04f7c5cb57b143505615b8c2f5b885df5bfeff94debca715b117e388e97168b12e6e374f377593bef9950fead024b6cfe461a7737fbe5868dcd179566b5da83a5aeffa1bed11b87ab16a839eadec3c1c411d71902a70903a855fb16869ffdd27212e09a0b94b52f24ea5bd4eb42fdda54566e8d246ea2967d06cb399d26d2a425d65a0f6f267afc06bc958c86f8db0e048dfd5d1c5064de4f37562ca3c688bc16b0c639b98f26010ac0f1efc1280e7363da00e5ee5e0a23b5a3f5d5636cc290e71ccbd6077c09759537a6d548f7547f813a43b9319ce539bff8bc4bf6248e00506e3a672ae6b763b0a8cb804629cbab1c907b95b5d41c4e04ccfb5da01b4dc9b1fef9a135659c6598b9793f1ee152837c0a7b8fe7dfd51cd74ca32cddc0d76cd9563be1397b3f6f9cd31b7c9eace09df14c8f976ab50dcf2dd4b2c6983044bfcdec1dfb38c66462583232bb2d5e509ea61a1ab8f15088139438aa6dd833ff85c6c06ffc5d0f1a12c3afbf309c6750f0965f978d916367d421c115a6a996db7b88bd403a847c27165d7e724d4dbc54d67f0d1fd98f207647c1ae6dd35c0828c1db27b25477171321acfde6dde2c6ae9e6037729727e55b0305b35c855ef35bd02f28927ddd912ba6e68bfdf5d84043df6e5ef6f8fddf0ff9f6a905e42eb41bba38c2c1575a7453421e317640eebd0586b66ba9f6c5b2ae6d2432a6f8470b9421e616bc102aafa88af7a6282898736745de1fa17322e347ed0e5c2dee6b934c06cb6eda597810f76dfba9850f942e9a15b5f36aa9a1f3fd82e72196dbd2e824ee8cab4532c83cded149156a8ce6cbdc978ce9ff22b014a8b509a1a1eba599b0a742442553ff88bb732db46811159dd9a4e7da74ef024f3547d5ec0b5d5a6ac1b5e4f40de7b395d73b83231c8866d584fb9eb99e4da37a10af08658227bf04af471aa7e013ead015d2a6c6f42c02dc664b258a693dda30e0b71e364b19ee7e1f05e15da2318f8a28a514ba0ceac85f093f506c51d67e1f466bc290d291165b7cdc8bb3b895358bb08f2bcdef666f6892df0b50e4506bdc8a80e7720786eea95eaf26aa4af1b184e6b2a02ddb54c2c24b7db1dc86dfdca386a45e39456c3713835e904f41199afce73bfcac40e661ed30c19d8a9e4ad06128141ef9dff11d3e1ebd4248e6d622cfe88fd751423b2f210055228b8823a1e6b82716254931670fa9b2f820d7d779c5487b2939c225843a47f7dcecd1d11a4600d687f704dc9f4c0f1dbd9a37dec1f35b34786d7ab9841558b544f71716579c3395550f394ac812ec335ac163b60e5dbaa6912c9af54af6e2c332e250de9359239344ae756ef62b31eb740f7850746f3577a719f052c2db76668e33bf935e6933ac7b13112e651441deaede39fb14b5b963f7415f56f0c84ca1283e0519acf096a527e99fffbd7d580c8ca6d08174faabf8de8123a64712f887284a62e1d4a982f2a405903e36dd96a1062f236d87b5bdd703507cb8baa87d4becd67e723360b9d8f76b96fbeb1827a8659c7844a0162e15bb9f996a6030791bc99d930e27fa4a6a33ac3985eaaf587e0ddefb77bf6f978b009cda951dc00cb599d30ba5c8905083b44a42bf30880cf2394f474b39ade0bc867e881a175837859d01cda8476abb374951fbdf442e191774a698ea120f44f75aa91443b1a2fc2cc9a7b618b7c8a0c909dac2b26bb2f8e55a0b768a29fcf68220ffc172d744214abc8723576f4574df4aab2ba82e42739e20226649713c0f758d8f0e7144b26711f9604f18a41771034423e17e02e0699a0a06736f4fe4addbe0abbb21f4157464e6dcef2bfdaa90e283cd55ad371533c6216c819fff9f3d3802271deed274c73d070474f41dfbcd075fd7896532e28682481ed3ac6839532ab5ae1140fa2c372dc8e2b1cc4d9437a3a1d34e2ebfdb1f2c1124f73fb01123c72bd23115d87f4781105a1b08d6769828350b6ca302913b6b3f9e8a99a6c93b6b64c1dccfb3d502df921bd94f018694f26d6545d604bed09712716bf4b8bdec98a61a9489481b102fb85854384fea8e8a9077d114fe32c234f9b0fc359988a6e218e9cfb3a0c87fb23507221f358b8d9b032242a6f476e48a0575bb163f4a7468dcb30bfa038cdec6173f269a2968f468c37ac5930b71151e58f102776e59266e5287511e0576629407ecae0f63c8f303369dee277c01132923a19161f62a2b6bcfef85cc67279c614d4f62bdf7c86c937b6fa983b52863d189b494e9a7e2c085b97a01d0ce9f124f1f4360d2d9c820390e936e6e6477a83df103dd9d01553885d9b83b076840c703da56af261e65b3be9caf3f38ef7ffcfcf387f36f026969a443440cd9bcada0dd5d5c13d9932ab499a32655943b4a80727e5482f572853f184cd75717129b75e3afe8c14ff686d312499f1f5ce8e670b2bbc5d4e8a9ffb9835164c5f560f81c324fea8c3219583ce09be930ed0b2246aa03ee13cc433b418b3c52a4285111c01ea51ce716c3c77626bd23317375caf88a641bae7c57b580ada08677b2225fe3021d63bd3703f9485b4e434f2dd5f3ee436e4c658aeccdf3645620e579f5e527d7e2b3feb0bcba2b608291fcc0d59db16ed8ed6c930a759bcfa90fd157eb8556a23dcd4a47d12bd6c6af58a6262445a6dde602b1b787979ee3d0428a50da436a117befc947658148fdcbb46ed9e72bab3399c6f773afbc757a383c438426978fe4334fa12072253845db3b7457fae392a64c28f0500c92cb0e122488bccb18173736f6135e6e7a38a490df6e04beeef544e80115670a5e8a1704573349a160f2568b3b527c02269cbcb9bd49847f027a94af283f8cd1907869b5986a55c0778315e9437941380ae2e22031f938fd3aadaceb207805973f5c4a8292722a37c687a770fc129636ca8f1c159e3cc974b08de68b65f0e7d157333ce65b69c2439b3a463e5f62373d22bdf98494bd80a79c283b94c7c533d87cb2b96366bce508fc3ca14dc7fd6190956252e0251cd71e93b428778614fd6b657149af7c55c86994a966a3c2c497424b07572702d819639ae2436fb07e38163abb386a53957cb382e94e3835085aa0790590bc3ed163520bab307a44deb0d85d0048b3985963ea3a5b6c787a9b8cb440c71a971b65dd93372ca2c679b1b90fa53c91bc62cd2a01917c06e9b461bf662cca515ec47e5e360bf62a49cae5fe5c661747e79bb3cebb0bad347fb9f69dec2eeff67ac3ebe819c8c200fb71510ebaaab5f217209b5e4e3df532a08cc22d3bd80c30e95b1ae127bdc58348bbc29fc909f7a60842a98344d7c54c61e540c28af0df2c78e1530399f1a92e33cc04803261eae000030e54d2d3d675adb18c3eabaee261504a60b6e317f3f4597d12649669fcb7179753cfddddddbdc7edcc9c19c2625a1f257c4d9f8c01a580b14a174a1681200f0f3d99dd43e926b0028ac033831c1cfb1a3aab93ab2b19ca8d79aa6edcfd958986d9ab17a2c2c498457a4f03abae66051d5faee74047b874a852a1734501a779ddeb32215014f3381ad658d504afbfac38e69a20f8d4b559ce776267faea6d5cfa7014016ea74e9591bb1a1fb27240620c51b704b782e48a7e91d11ab6751fadfc48a713bb8ac809b95f6bc45eec6856ffd32b6ed36604222fad573e3c98d11e50eb4d42ee1d88004ce4ab8d70cfd9fe8d23be3e7353264179bbb6e04a42c11299ff5ab4eac26fe50520a95516ffcbdc364c4f30a8a1cfa0c98657678c984f24e2fdfae2b7f65b80e5464db6f41873a686d222db03469baab462e41da40492e3020d6755d37f7bd3ed393e05b62df8078043b704d72801412f0d4258ec3b46edf19dd5b489d8099775ae81c14ad892f2772b0192cda8215cd8637eb53f72507121505ff3bc460970c92d220c059e26935603a0c7065b02d7fffa792cccd895952fb145d9dbfb232149c3f785218699233b19b0610209b4cf3a223d3641ec33122bde38e28e2ad1f01771a2c7be2439463ff28eb6b62d2798b852e991cd5ac90f00e83f712c76e7395e69671586c55397d57878baf21f26a0a24ea8604c8f99896bc6c76df1b99be400ec39e076288f81cc7c37f40e40a5c2eb9d465154656e582ebc6f7af0a1885497a115086a6f64bc5883d74fee14889dc74ba8309977dc0275411a299ee7021ead64404c39af6c3000d26e07e9ef4bf892d9f9bf11d4520dbde6bf4abdb57f27c7b98551b2473866c552f09c3d61816ed36c41a86dac3234ea54ee7942af37955663c4b6ab52a7c10cb8a4eb79bedae39720d6cf8636654694994170d42da70a3f4bf1b48fd11a16dd7ca6cd6a0484623769a308ea1fc595971af1c0c7f892c20721ea0b750673a94d210df327023a413ca8bb23d3e4c0067499559622c1b4fec4472a752239ef0c3ebe2152a722ef99eb043861715e736e570f8b8416b8fda831bb41ea8775bf65bc720cc2ef8294a73c058a340e27f366762a2e7f95b33119c600a8ed27d52782124d777b1ae75dfcc4ccccdb4b0eaf1b097a5b851fdcc2626e21f312771b2a26a0ee0c9094dd760cb1cc9a605636817ff0691b5e6e7bd4e03625b7e6f2f17a47db99d9565da2a3696bf080dee3ca4f677149c949bd8ddf9d4a118450c3e838f453ba26efbc1903fcd32d76b29a85cb29b703b9788a742f84bdc724c8308fd217196b1433b6c1e4c0951a9b2d511d4001ff97ca7ca26b0bb6d7a45b81b3372d0c3d1852c7dab176127452f49d381080d688a7bbce50c3e5b1c8f6be713e79bc93601addfede9d9ce8d1bffb6cc1c983d7b1abade7e62a2ea44df6bf7d93da1825947cb8eba288692ec60fdebad4ba9f6d75e4fae89fc0d2b5a70d2e545e3be25a619c2c07f9c78237e7e27cf5b1177883662b6a15dc8aa0776cdb85c770903d3596800217992c717d812904c5f7c2c98f375a429718c5e67358ed7ba2378f66c961e7caa81a9633dbecd37d011d48591963abc93820c21c3d511dbee9ffce4ea27275ae70199b094f56f483d61a8e031306c13f53478813d88dc306f4c78fb18d7af8a8ab9660561d6be5b3b0b6c014081f48ff31c263b2881b5baf9ce320c09fdc3a9b0d581d49634dd79cb0a0063b10b35baa5be0685fde67c14a45fb33b8082eac344793ae459047686f5ea006fbeabcbcac62a0caff01f2be1860cae158abd8cb2e3aa057e9b8f9e30ce252526b3015a491bc173cc6004b5dc57d3bb7ebe00c7b8ec519ae1df5ce695257ffe323f19704738f5448beea740bc8e188049e4a35ec5b038f65dcae8bd2e34ba38e0340348e5d00aecb5feba72a80fb6ce0e39cbd208bf08e71f22b20f8f5538f3537452b6445609ed3d2c80f590259cf2386ca4dd051c931240ba9cf88236e7d075b248ab0fff9020c8d02f63994fdb67cec515f284d4a74f2f8c14ecb16994cdb91953317b5b22ee9a47a6298fc300d23f29557fa4b27437ba6bc0ba624375201dd24427df4a491192120d27dfad3dfee7b002053a8d984d4017f56e00f94cfdbef54ef51417554fb0bbbd98f0e0c4133062a57f2d2fb451c1a36e8361ec1f5784be60106417dafa57ef7bcbc6c4b319c1705661fe8797de071f60871c51755ad66f4a7fae16ad3cce38595ee30b1666491b401a46f0add27617588f6cf8d526437960f8fa3b4a72cdfb27fef62985aceeab046f96532a4804b2382577ecbd2b9177d65f3c9d5f606c34ea5f2068f1c8cd15e13b3e17c3841b5ac14b7455977b9cda165403adb2e06142cbe1d1d8c128572240a865e42339f6af2f7602868c8cd0fbb548bfad1e3c6af8b3b502753eaeefb2f7fd0b45f2e4a2f196b0c78e1305e9ee37a4ca321b3b8c08768ed3d5c0c2f007817cd7ce9f191c1b29e566952ec73f53f30e5a19cdd875706a88b4529799ea1bef61a2ecea9e38bbd7d31e433b6e4469facfffc4bab97a1367b6cf830c6d06184ed8ab296b93eee0c9634cabf0a3c4f84fc4029eecf5d659a3083ee2f19dbe30eb6358f5fd842a1ea5da6461945166068147f1a204f4198bdb5d9bf04e7d7d953c680c2d4f324ec3c033c83f6568b934df2d8b231b56cfef896c4aada50a80aedcac87b3bf5d9994330a0c369f51e695c35661b122197eb5fd4b1621bcdc60ac44a39c1e73bdaf6b30dee8634bd4574f4fd771480597bb448020c0c6df24e15b6ee30dc6b3b770e1fcac5017d5c0357482af7164a167c3c2257f6301bface078a7af35dc4f513fd34b7904ef4190a4b1136ecf83576a0034e4d36d1a0bb748a519d183a017654b4672fb86d333bb9a0532a1f08bad387a993396377525a14dc0c36a8b3785492ef606e097fe7d455b418b0f8fc450c3f6fa0ba108bd013dee1dc34c6a274ed05b3bb0761c3b826088101225ef316bcd8cc7b6d540401cb400e04e63739e231dba90cab46a57348bd9e01e3679d375f3b4e618515edca40ac85bb027bc46a2011afd4d997f6f15ca67ed06e231e4a745ab57b8e3ff37529e7dd53c0cbd865390599a221c80367c06a537ec8e73ee0ab50d0796d4f73c32deaad5c3d3276d9c5e0bbb8258bacc05cb2974fa3406b56d7660aab9e4b0621ae9cc4412bbea16b1625c1d586c5b07e3f10352876f3d86d4ccc39ef46d567344968b37e4aa6a5456d6c693a533076ed97354a8df8f480f554c8edc31bfaa01c5cab26b1bbd7079f835b42f8fd4de15a610f69b1e79bbf2e21b42661d4df1bddaa95a9e4811cc458cd8afa5cda9af260e9f6d2de6534f7a535118b2310ace414f59292c555a6975c557d37e0b8867619af4a66b85159249150d7071bcb5d4d58dbb25e13e12bc1ac485c1fc9b78cabd6ba0c9b62ecab563b6f60bf959d8d372d2996b55df83585fe7e7ac779ee58a877478879d6dfc0255142f53c561ac0a2f8b15da6a65bb740dca2e64a672acd6ef2ac5105c0486091f5aceaed4560bd891553f8ad894147ea2eb46500a57b582a41e3b7f205cf11f1078ac5f87d7e1a7fa3fde9eb715ac721827208dd67b9ad2627e36db476932498147047206cebe9bf6eb7f58fd2a1a91522f753c06778192f26b2c68e9da6c24d94034767c0a6eccd61057704204c5525d40c3f1ebf4d91ede9909d2418885fc9a9a988cc47bce8509abfd4ce3abd9497d653ba2dfbf74ce9efaccc466c98d5a431b6f667b959a4a90512e1ec79a0c68e9be1ea1d82d86d477019e6d5c127ebd97ae7b302117aad51ae14b90ee4e252283bf87ed05f88e503af5eac85d4ef425153499c760787ce989866b4dd7312f468faeb64d39929116f91bfe04b602e71ca3e1e22ac7d6ac05714ebc288cf214c211036c2fffb60024d3711a6317fe944cca5a901fbd032ff661e1f80cb564ca8be021c54c5a9080e4a4b6372120cfca2063d3c3f6a34d72946b7769fcfaa8e47258f3dacdb46a9a1d59b2bb909d44314c81551dd2112c0a42efdb9ba4e0219fc53f33aba4704e990ae8b4ad8ed7ab9051057f909fc8b4f8fc7dbc76114ab025f839ae02531c0068df45af0c6d1684200f7f95c3020c28dca5eb9b73ca3ddba54eba478be1d527bd65aeaee84fb50b196587b8e743e3688a4faf6859be673fc49a8bd50d1f14d51c6118d9d247a4ef1def72bac3816b36a46dbf4f77d1304e72d324f827962c445b505c0bd79885f6bd5f18e6600154b182d8c83dd331361e283e2da2e5d90e01b98311262da45daede9c21ae77d391f62e25dd82a3209c3619af729dd878222680a87df1ffb4e46538c199bef84fbba927e8dd08a02eece46f54184d10b71761ac05136de3e4c41d4ef0e9d2365c7e06fed32f74eb2b20600c43b97e410a85828eeb38a2eb6cf2add969c8697c8f30be75b917617cb8ecdc0f161193d8020553d793d12257b517924b539aaa57ce2b574d35a0c175cbb60b1f347860f295925208a64be31e4ec4929fb41e19a3fad2e8384c2fe5ae9993b2d3dc014e16f25b3480681f8413d20e389b3aa5d8d027243d328f01135001751f63ca0e7e0e34a3b37a23fd397c5da7ee51e620d82789f93efb4f71faeec24acc0cd96751b2e5a822aa016707d5b7b2892d5cd3be43caa56ec995d49ff1c2a689d3cafccd9c0333d39d5a0f7f8c2a4d0e84acca344fcddcb6be5947fadd7d9c4851899ed567db89afc650bf861cd714641232ef056394fe8b791bc39ca66806d1c360b442e9af7fdb217abf1449317b4cdcf6b7f6c90d56bfaca1208fa4a987cd7e75584580eb8f8b433d800518d78bf54a6162e8b057324a5605168a556c1224b2816d0451ce87148187fc6ca6db39c620500a11d536fcce31a4c17dd784b698cc9541aebca5a5250f0f014720df284eb09deb35b90599081b01dae53b6f3359e8c4cd2233b437fe61911e3014c8892c979bba6297ea50363f36eff0793dff311de87c6569f81e8c33f966e2640714c829bd2ab75bfbe2a756938cdfe29e17e5a7c6a57f671efac8f327d75e0fe23b6729e762054545aa179b7b7dfe388f7f03613f165e118627ddf79fdbebbe18df1a3459eb644701225c9537310035dab996a555841b6f4a9628c64a9301a15a5c125f98e1165cb7b9bcb4826c2138b6775212d99a16f27e0856b29e8ed49b7c4ea4edccdc5892e6e39f36b0b20575578735e446ec3a163679b3abd39f7ccf71928c69804cbb71fa406afbef94b21416b0baa8d2e7c97d6bf2b35586fd3b04c961070ec48bcde3ae59a1fa81ef3d9daf31eff171565e116a91d828ce20be363f9da78f677acae6b7238b0a678763ae518fa83e4a267d31c421366a3ab41e0af7d03989dad03042a976f5c808a4ac8eacc09abbffc3d2b67f519b50b56ae5c30f671ab5a49ff2d45bbec981480161b60d5060655290aa69b4788f47b28da4647e813121adb9d99003626a9a7071992635afef7cd4e0d1b1aced9f4fedc2dd42b4a65a0d0537b7fad70db0d248c6f28a66d89cab97f862db5dc271ccb1c148e51c313d27f6b30a988847cabef0e3b40438263f772f1ac638d05204a7370987c6d534ed32c7b7500be8685449eae8ddd387ff301f82c194e3741921b55419bd5bdf1187f21c9d48c2bcfcb71c74b15f7d129a35f22b3151691b8ddec8e8d70a3d599839945496c3be0695afd8f03b21be783acd71a841698a3d38fa7776aff4a3d8071324a745cdda84e506871b0e4a71ec0c2075933610a49c1c699804c12dced8f2c5c3326948e764bffc06db9c267aced5ee7a5c107bf009e6f21197ed54956eeaef9cb1551b90acb1a797f7c77baad6abbddf1fba2eb8284a37fe8f1be6779bd184baf271f0029190c0164386a0484fb16bb73c4322b117808ce579fe6059761e7622d4bc0a504cfbab4f40ba4ec8b27cc908f850b325966bb37dd432d0c392b4b88db7ce300583a4f2ef89013940cc2a50f50e53a15efb2101a12c17c9aa1dee75b73ccc7eaf9ec9d3318636e928f30e05c23e5a740958799a95314069474fdaa253495ea5277eda589abc10a922065053cbeafeff9da5f21f61f735a811ac9c7704b387b7293936e845faa25290209a259261c7c36bea3926affead837cf338d9b9c194f003da2bcb748316fa0da75037106c44f7cff52538de9efaad8aacd61e7c6790bf6a9be03a3a1b766d1c9e53106607d481d1152bdd4b3800b848d98127116bdf01260de9b55ef25beb57ef403527e67eeba4fc096972cadb06485c68510bd24784418b0b9fa87bb7be88720f42706e050b2c77518ccce807941b267043da9321ef3e8ebd6aec932444a0c538b4cb3fd4a368feb67bd9d3f8531258867eae4471ddca0944483c60b53e05c05e1cbc96e2d9362bc8016e520e59a0e327859b84b83435e0f9e27ff2bc591a0c84a099860608ea8077ddbf6781edc52d0a040439c3a5aac310c27fd5f8b2cd7ff1037f1f61b33a7e1cecddb4924c8c300ef7b936126490bbc30c49e527e992a5537cee854c74e2dd3d02f64326bc3932fc5eaa142bc8a9bd0cb9029baa0a73d51ed2398fed2a6b7d10191503fae1f5a9efe105659e998141a2ab80037903cab46bc5f9bc49a04ddc125a157b06ae7b06ae8afb87d8bfef42edc66d3956dcf797825ad767ab2e9e8032c6c1a9de89816a12cf32b4805338fd0c4ddf8d49ece840681886bf41e20a8b87d9958032ec4ffd2ee44bdd682aa3485569f7af63e49f696f8c9d2b3052067a22981683d29bc128003317cb3e959f16668d2dc31758787750c2d4686c31571aac3edd7ca617ca3e68823a152f64306ecf2f91cdcd44579b29186c4e72645160bf8407567ad7e7fb4097fdb46d8b097870881c52e732946b9fa85b3c23bfb8778ccf1e9fd101fd0e074bb1951cd77d60b91d8da8c73e9e9aed5f8e59e6055de64763bb757ccef3f6e82257815338f6b55f219620ead3d32a63bc3ccfa113ea9f52613892dbc2c1b86d773d98a8845108b0dd73cff402b9ff5636eddd2eae510c91c32dea0cc052ee4b019c72f77901a6dad0a10bb9535abf769601a25ca6007dddc0f61f0c9a896a78250dd856e88e90e882b8a29f9e4864bd5b47af2b1868a87a1faf6b36cd51ea2ff45149460a74362d697568b2a2352baf865469320f6d692596ba20e4d47b7cc7476b6cb31e497407552816eea345b14106aaeb627e38ddb5ed82f2922526b72ccdc7e08e1dbdacbaf28851e9e8b23c832d25f6df862a3e7f5afbbe0f0e9ec349b05efeb51c68a650091efe95cd7d1b05150e7c17de677b67b4986e8a76e1f88e85a0849f98714fa924d671e603422701a9d8555e55015f729e70c5602abec495ab23f2d3b1e0083f089e009a2e3a82204d73794f569088976be548bd217b041d033412745548d0c99ecc5cb03ad70a54bc353ad4d068a800ae3a81e64046219e942ec6c2b11cb3df0c7656a40f14f4d427e02c08974004f53d86a32b1df092ec0d22f57a90aedd471e0d8d4f532c7118a413db68b90f823f20b89b83a37bc21c0ccab60f3b30b7ac3646ebad93e518808c25c469747f6a82f9e9b85f63a9e6f1c61d11674b858eb1335b8d6a8669bc857cb56c967538f8d6bec3966daffabf01af5c512c6dbdecd1028f6fc3f6368ce447749f99b6f8d5785483852524b35cc5e5b0b829dcce2f3e460cd8192d7f452e416101a9b5260d2d683892ffd047e22f1a7f82ac669f27a2f495bf348681994a4e3e128c8a55f844c5ff98d9b2119194e981c66d1dc2b49d7bc95c9d4da339e7c8f23e4a9b0c33cf6cc7fe19637ea12146570b6f6f5686fe2f8a8a7522ac17a8ef0d57d7563f8a4b6a36618d75102f9845d71993dbab0181b896afae33b205a3d23bfab774871d3fcfb52784b88c2d1a0a25a22db320172e63ca1f1f8f951ca22a0d374419c2bf1c4fa0d8493c45c5e83c96393dd7044308faddc537180c2ec9f854a313dd8646e59315cd36fae2e3021029fcc34edb1b45d331a4f830f8053eac4db5878798040b5a11e121e87d4992532276b0f448e2138ca062aa6166e20ab1d43ee96ce85f05ef0ab15f238d0514f693dd8d7d9c218737dbb7c19a0bff64ebb15cf37b10fcdc48bbcabaeee555019dd784a1e11fbcb75415809efb8bfdea0931ce1f6881a6b217185c245706885fe800dccb2cb6eed26e1df62343b1adb61033d5ec6527aa9791e730ade9d248cd2ce8597c71d85ae1301e5b046297cf4a143824e30b68d21a7752212b2f91d26f559a25484cd822e1f06352c1faafbedb5dfc052e42813746a4851c84ddff03711b662c6b31c1e9752c2ac89cb01a2d28b0ecafd7ee14743c435dd42df86218d38951c4739b013c54aef57a2851e19eb96579b07d2ab1ccbf8f25e89125f47c6e1f8b73ae98af2e8d9d45e6aa441bb71fe87c6b2967bd54c38fe89eb83df30393f27051c90bd4627173b0581798c0dc9d408be73efc92ffb7b0013fbd67ba08b851d858e5789bd28eefebfe319367dce07e69351fa5803f3c22378d3e3f22cf7628bfd62f1509f70f17eaee0a342200c41f6002c20b07e80ad508b6ea11d068b4ae78f56d8809b464dce313352aa3da5727d85e544576ea09cbe3bcbe263431482fc947c7245bf83af470309b0e0998329e0d79048d719b339c6ab800c047e8c1a81fe680f3120b27e00f5ffe821e764a7a78d7d046e0c7d463ae9a23794cd8f0a4c5c8ad16138a68a8a7624c8e378e41fec73fd626b46dfb5e1c78f433739444dd4fdb84751638ec0f4f6bd2108c4316182a2369c06e2e983f2978bad6b9362d227a0cdc8248e9a78377236e9ad23db6177614c06ba6861de94d68d2c7771966e1debe231b2bb929ae4a592112ca3cd44bd0f10afb67289ab4a835c2936879bb056229f1a6eefdf9460e1b8e5fcd625cae27c08264f4320965f86b11f8304af136ba67ee8c4c8c835b7c90da30686a4572d69c902203ef3c97dd4184ca705eb9dc22a254bc34d4f48d24bd982a1b8eadd7371f789077e5ea89b1dc8a369bfde6d9af03c80a9abecefae4de2d6c56c27bfc75b14c75fc90d68438aad933ac13ed5e48d58ba800b0d0398327bf259df37855f21a96ee92c0d9cc4780fd0b5d7122f14e779ca70edc5cf28967d677fd9a6452637f932f28793f2e48276a89157eede44e273e36d16d64c6442eec14a1fbcfc289597afaa42e92b6fd65b3dbadc67174c6b871959a495debc00cec17479b030b1cefa1c920c44db05a2b508d266ad3d3195f2c0bc7a5d4e0064fa5da9952d744eafcf546caecb715211e69cbc8d330903c279bd02f359a67453e8ecd8a8912883d0b4b77c47d606ae4852159c440cd1df687d34e10729c17f0cceed91a9c0c4295bb2f6dc0df4e58874d02012e9380794af8a551b997e8d6431242c5b46c4bd766f94616e03734f37eff9c4f4fb164c40b656325cdeb4ab9aee84b6e6be6521e2240fa3828e9a061121e669733cece5433b5edebeb418bd3803ef0bff1d36982d19f68d2a1ba1ea2a671489d2a39f19c8f1d9b34e00dc03b1bcff4d80ed01e322c1f225834bf747996c06f25322d48a5c874f2c4872f3ed6585e21dd652ad089ae0336d8a29602bf48a16219efff44634eadf75bd266b3d2e36b01087f18a495fece10f70eb69ba69cd30bb979fe0153656b035de98b37bc45c475688cad909849f0a293580457e51184e28d045e15f4081b6a7f517d672f7370f14a6291e3146eee3edbdec2ac7c6ae90240fd14facba8d8b80a9b7510f7e5cad82773a15d1bc09d499d9801b51c53742c8e74cd7a71a27550b9d528660a6847350fde21d7d0695af5906335e8e1b4d83c93022a4f2e0bc79d18c9df8adbae52494ad28c99bb64e4cae5a52e2cefc2503e3b2cd71d4f081429bff0b3c269c2600164e7301118e9fd13d867fe9355dc067dba40bae362beebc021d0296708905e0ee9bd869774157e2cf636162843e5bc7b3ab54b1894cb288e44bd884bcfbf7b2685f722a7d7c32e9280ce6bfd0ae527b22b528b4993d9d5c42cef80011498dd40fdc0778ed9d4c13cfc61395020347afc0920e4e74307b39fc8e4e912e3a0fbbe21680d256718cb39d3d27c69b1a3126bc2203688709839473de9d6a6d8054a947576778cd2560ebb4d2b545e82c893347f3cf9c0e10af9ed33743c1b38576f1be64a7d6590639b8c33602272e8a3ea37d473a559af72ba1e0154a9fd10f0332c62481954138db39953aed9cb5934f794bf9ff081f60ce842402feb55425da6066f4dc0cf8d77e7219d032e90e8757fd9731a8a4ae7345546655029356e8fbdb99addba93177267e9adeb5e25935f1a3bd86fd09701465082f2d1d665a59299bd87a964db808de868b292960db299cdd34865671a51a66da10bc5db5006685658d3acfccaef089b8395b02a176033a850a06f93134df4c77c0bd5977263ac8475b4b206be11838d67e126a1588445da797046ed3fc07b26b0725f959ca48f70f751cbea54b646f14a98920172db84dbd4f164186f1e4a812853092fea9b5e99e12621c57eeb9f5732802cd9efc305310909efd81d540a3bc9f4bf2701df49ebb2231577b7b8881181e0cc08af2fe48eec6a303dd529b7465ac43aa4ace970d45463f5622a06ae5436bca5b9e400664ae6ccc81177df5acb65fdf335ac32d85e8848302950bfbcbb03da08d9637bac4da2127cf59e7db587f53d043e7f5a9f86d164d25b7ae65a28497090f19bc67f1cfb811a584a2ad221123ca52e1eaf90d855d22d7c0d14fb4cf88c3a712e65d0e0b205561e65454e8a4a07ad0ffb234d23a4a758a68ea0955ab31f862278a17933db80a9375f043a9945d186fdbd57db03f680f94a627519902ccb5ff09236a1df18e2dc59f9526501e00d399b595229366443a892f31d965628c16e6f6bf53955598890989d60101e54b2a4423c837ea257ec806daa7bb54a967620c71ff28e54f4b508a66fd2e31d2c78fb8317cbeaa95ce26653c8cc5c592853499bbed94d463e564213280321522c2fbba79cd7cb6709bc6adc865022c413eaa9dbd224e9ab03a3e0e263024b63df50676d93381de63c6401c8fd6affd57823b5721d30441ff0357c1ef81bc9e04d76e0e49470079184eb8bacc23a2a21172bb971b8e48959ad1631ede666523a28d861dd3bd0aef3b6a5ef6b9c3ad1cabd63a6e96b2a9247cf8db8a6596467ff09a49624ebe4ecf661618262103979a8deb49578ea3ecef234c445aff920c5a2ef9754f38802fe0e18dd9ba1493b89359bdc8a5f41a95f8e78c9bafa2f5285c65be2beac5deaa03f4717bcd99329695da2a01ed669e92655c901764fde411647414d10ecb78c5fede08a67b419d4828e2b8319fe062e6ca2b725865a9c44ac67038e4792f67de3727e32c728d38985dce3abc3ea827a2f3cfa5f49983fd2b864e4c31aa3f56aa4eb51c8d479c988148d42a1423e288a0eb8b3193c91ffad29a2d7a32a4b33ef84a467e1670254974ce1fa9ced8e07ed156bc29ca8311f2e1091490ef6b578efd506e2598cc77b1d7d889326797f831718a819fa6315fab6229af35f82d88cc771e97e087b27dbf94099a99e896be75f81b1a127a9218fad3ad23c227eca093797b65e1454059a5bbf02ca5711d852d1051479acf28daf81103e8c9cb86389179e2a315d25ee7c72e4bfb0cf33d3b573b904a4cd9e3b6f467a3521e130281a254019d506b993d6688316396bce5e7ccbc9b90f681225fb50a06859d9294de4a2e8424d8dd7ca643195d4c96eaf2153515cbf7bb2d3e3799f5e2ba6e8fabea4f94ff2494d0387fd9f730b9571c5bd0cd277f2e08c657507293f61b2dd3d1dd6f0bbc6d7bbcee973219a0a15b6deddbff1cc1e6305d70110b7a0ae8a8f5d086a76897f08ab2e05a3702565562f9b312e1e7065a7309f85922578f7d8cc005dbe0d157faf08c3eec7b154b3ae03417dd8315a4ffbb380dcdf7d7ee2661347c3e9723a673ea4a47209aa250d293531377d7301966b9816e292cf8ee63f5bf39564c12b3926693d847103ce43293a216b5c285a0f87463685a54455f609b3257607db02c0464961e0f2b5b0b94004cc8764a17824d9d98ae29560eaae2f4ddeaf1c512e1ed61cec155636c1717ba366c84f63c055ad9fbab49d6f77d6f71cb86e654cc06e6836320b2c76259a9f8b69bee61cc5abcabcabc710e4c1bf34e5318118a9178e348e18ec1c32bcb19716f37f220df1c917bf9d5d8d33aafc80bac7f85a013fd3ec03f48f02ec26c754b523acf5439c8e80e08d206e470dedf81b809a04a6f5a96c610283c4f505ff0a8f178b3b2606a1d2e40ea32bc623a86766059169214d3764bc4d5e632c96810e35d75f1ef449d4eca8a32c5a05e06e1634a65089f909572050172bf4b9637ef4dd9dc9a03e13dfa1d9fdf5ae611f65508d7499b7e8e61df4e2fc7b97d30624943290bcb3c023b0818c1102759e8798816e8e3a37189ae6b9b59107d6ea773357553faff5cb4bf8d2da324bf60d0921ba8d9f9f6a618c82ebaf3cf741e622428f3c039ee90ac606470e5a6eebdc96cb8bbfcc37a7b8b72e84f4611364b25ed03a6dd6d17063b7bed902ff3152bad54aa2a4e0c8f938bc260d39bd7b8ad6ba81af5af4dffcc45f844de28141de829bba9c7bd8f618e4e33d5d95a38ad08a217fc1790bafd192cd74d42a086bac36c7c2221823dd5626e041f0e798825751103812e9d13bdf61b21a66f72cd17723347e4f049ef8e6910235bf4c95623a79097dfeb7113042c90686cfa9ba4c2aba4781b5b9c1fcb0a198bb4bde30d4c5db6016a1fdea6c771ca67c7252747002b67778501bb70471a1e09daac108e836f093afc350d67a93a01c72028deb8e738e4b64825c8568559e5f8811b0eaebc1128a3b862ce68bd44c81c2fe2d40c59031fcfe366a6b210034d2d03f3260383eff0faa6fe30ff003320986143c549d1fc821a947048fa7d1132719092630caaf65941d206a0f4b2764267610af76095a9d7bc54b11824ac0d010e3601ae8642c524411a95cec7d59c9a85cc1c3f031ad67ae7ee49a017176386add8a3a682c5046e0b7d2a3392bc7bbe4593cdbb9c9d3ffefb9df3e27c34b7e552417e854ee83c8fe145779d62d3f25c57947778fb0a18d4646f854700391c2a0f67106a65c68b05cf35849eac68e1cbcd4c77af0d92dba8eb35df3ff906ccd5df29542907211c8e0ca7eb58817b5ba76e2b49994e9271cc1dcf554812ee161bf968e9ca4628e81002a8445f35d4a614b7ee8678f7fbb64245c6da9a3853a928e979ae1d7316e0e0282467aee647e2074e452e8644361b2f8d6b3556e6c8ca8dbc03a8b271b7da89cb8af72d82c10ef05671099c5ae8ed7969d681f381aa17083f13348227464c4452effd7584c0ad1b0d1da1cdab648470a1e5a0097227d1b2387aecdae9596e8a615f350a81b4e47e9fb8c4e5a2683faffc8c575f45ab0a0a90ac518af9ad889543f234c73fe02ed1bff8dd4e319227cc9458e86a0e48bd7944a1dcbfb7c0ee0d02e7b08353070906159d8d7c216621dfb647e385c7b37f6bc86e763c94fba65ed04531506b15ff9488095108936b1ba63567ff7b694019b07d669ae9753e316de20e46749e660bbb0c72a8601945ff2f43c87bfc36d05f3ae0e302c37ae050454375219371b3796735a82d490426463f97a552b077ffdaa3e12533976fe7eb6b2ce0d01cf9667bc28d05890d2156b659fb76162f0b3d2ac77aa613faab0c2e733f57ca996772da038c64d8d7fe63bfbb64d4c0598e933065bc5565a3f44b8d778e420eff14e8530eca76063af7e14e7ccb4457c8431f5777c9cb56c1803e008166fecd20d520bebc47eb2931308e3e016f64c83377ef7a39e8420868db3d269385b838db8711d495e9d7e81dce46abe376f0cd0e7bf794df41df38a5595a51b1e277f4097d798ad089029edf014224d1737d042c94b9aa60426eb0029817fba334bfc6fd75eb3e488ed3108361edca3a84661cdfeb3185c8960c87bbde40c337da83915d7cdb749c48ada7058f34aae6a3482eef6de6c658fd283c97c123b9b1201bc664a9eb8e307e05eb8d06ccff8a3025c9c9d43c5aa38bf272395bafd563a26841282f6fa9455c3d9c3f88409108bd5438ccbf66746db1f1845062579fc5b8b6c874f58face914fdd2f57a1e1fda35e46df67a227a913cd814ae531c3891dd5d69ac063b0ca63508c9c67dd5c565ce8defc0c8d096acf45df9ee0e5e5911fafa66461eafe285707a3a68365157b835f4b8e0896366d0ff39174662f64f205d86500d60966a2e35ec4616faa4eb32f7c93172b6b488d689fdc7d08b48324d7681aa30945f5e2f81a3dc4839a878a6ae127a935dc891497ccc215c9fb605fc962665b325b33ac952224f74cf70abef1493515acce8fba4bd9555228810e539488166caaeb7ca085cedefe47bfdc2281c9b7f621ebb8c829a61c0128c2eb3d4161490e7baa6547a97afcdcc2c6d18a5825a5b6f6048a8b5089e804b9f07af3d06a9f7f42e99c146e7fdeccde3ec0b9b2e2bc44f44aa5c15a54bf39df7932bc75527b13ab1c198cdc28f90c9f36ad9b7aefff2ee8309efa5ebb8c2ed8379cc5d366468fae23fe58d5d7dbda46b38496c87b0f40b053b89a1292656119e4ee8ec611631eac24a8be931b2d61d7c91056dc679aa15dbd7c42e4817efec4dbcc75bfe2b0b9c43d74a45221524b5398559ac7f594a9ce920b38d9b69c947c67f565921e08a05dcb0d810b0966b3821681ef7551a59b0730d3b4087a83903f43f8eec82519e96869098fff05263977142e97224b312525f42c2744924a19098028d3ac0244401151e87cac17aea86817e14a6aa6d0690d780a3537709e415b86d4d75597338331d5f3fbf4f23bef64a27a0c57ce313b4c5044645d0cafccad4f0f61bc908cbef2a3f6aeea755ff31dc33ee7a78e9a2f12dd019d6e36e8a9fa82e969f412ad81eb5cf02149e7dd4304f450515738d5d8e3a04646d56f2f8efdc7031e9ee3c1aaadb1694c54675625465e9e43bbcb839749dca017254611e0ffd337beb4a854844293882ba6d4e74de9f8253a8e996f26ce0b78869b1c4e25442dc8ebe80ea957b7db86c5c04626471ae9fcd706e0e50737676155c3a5f715834dfc60445fc43768c64da14d3a09a211d15b797b4befc59abed52a9052dfe1f23a26fdb48186a419a1947a6c3342947ff856f4536be462c97f073f846972190338d1d046ffce197074ca97f996e6ff328dc3402b80345107e86844ed07077b86aaf98b96877edb0dc2c4d8d0636ee11952c62f51bba5aa8540f27c25fb9e64a7dfed1301ee18b5b507fdb2e18c73b54baec410107c235a3da7c7d5114ccc4332b2b59e1505bd336cf5006c360dc730866e41a77311d244b10a9030cb621ac4f6d9c321674fa366498b65f8a5dd5bfdc6c5fe861ee3bb0f13997bbc38cc8bd70dc271a87ef0f81a6ff98aea9120f0771622ec8e7c0674180df0354cd534d876169af34bf638dcd3eba0689dff4e038752cdc09fcb830c9f424cc11e816ab8ddb72b0ce47205192b0076bbc8034bec2f92beaa0b51a9eb3088345a84b87a9868a1d4a3b06fbf1be490099289b6366cfa52aa7ba89d4e1a4a0c23ebd8a6ae9f9e204bad8d817986bbb138d4e37530e33baad68291453b9c7e518af1b6658964a430d7f676375299ed37fc67ef6d3dd5ee8d659c2fb0fc31465f50e2e8d59fe6fbb9dd7cd38130c927ec11822e2ff7b3d6a2b4e5f102c8bd7f57816ebe232e115df95716ecabc3e8d37b97a9cb1977957bc1bb5e7b6db765f4c3e204edb55c2a8c7f7fad4f73d20183dfb11d9480fe0d3c8fe498a799f75e863e85eda50e3decd6ad0b929383133b7f184622c9ef3e163a0a37114ae3d99fe526832a4769bb129cb8d858d797bef7d9e2ad123d74ea6d855d84df2320190928fa894478cf31d5e5365b3b7a7a637d6e7861463e21455d30d8e8bcfee3ac88680279f2ba2f7448df6d94e2853bbe241ce26db1a244cc63c28e1fae24efd436d3380b4e14de51007886163078aafa8cfd98fb5ceb3b5ee87b0e0baded214c1fc269772f69b88aa717df22c5cb514bfaab97d108babf5b06d34122d6c4aeac81049186fd774d86a82ce020c8e20bf1080ee08b5ee7a20b2270d02c9ca5ec7bbf8f58d2cb9c5eefa3a06f5064f9e7052bf0e8f537b97c010b3f77b7c4fb1b309e5bf38bb8b71798ca859b734cc09c24b8e83871a734299ff56a5512f28f3c112df9651b8656465f2602a6f4335be6258065a96e597a92b816f775cc260587aa08f13d99d145cb9aa0ade0bf8566d8fc711f882fb1111113a7439969d5969445f5104efb64118633a07901b93f473b0fa1861352e29ef3e0fc8fe49601b05e91525c05a3494f63053bb2e8e4b8e02bcea6e0168c9d32ce273b53300270eb047cf9944c645ac622af8e0688d395f4294ab13caaff97ec4a3ce9960654cd3e28ea9805bf6579d4993d0e739e02749dd27965b7f87d2d35827d5fa5de973fb2a1a6059d300911f986d386d971e3626ec6b813eca22c8bdc2dc85ddb560e6215975320936ca3827e2f5f94312a4c95e21c90e76431f8b9051a4a6a1feb2dd0c198bed6137d62e4e8a69f06ce129796965f78df0ef25555d51804dd3ac6900ba4f14dba09863fda012aa50e597a77eaf5010af44c5228ef3db96b4add18a931f819b9e3c105cf7da035585467c2810f63c89fa309fb9d68f4e111b341e05f6555da5e0aa84e90c0be4c7952ed6f0be1aa60a787006b834532b48e2f275e54b41ed20fad1b66cea1bcc5fe27b685c6d7011d29fa695b187980842f3a174c320fc374ad2c9651516e6317adb4cf0a097b055349fd5ac1ac5afd418bf80cf01564356fa5f999830dfc6c079027fb5d38d66f2f4548b28a6c16d5c9863919d7631fe7dc7a015254387376b20d2f0ae3f0d38a0780884f1d08f2bf1230c3e9564aeb46d9caed28aa4f53eb67007ffe854e9dd37ccffcdd8d066b535303c404b2c10e7d80344d2256b84466d94b1000a0263116ba2f82fd81491dca9fa6e1d280ed6b2a35663c77f7b1c3549d5f2d7df85d580a5607585ac3a6a5f12b211fcea8e3321d6c8e3a9cf81cb787523115382228d94f4168317a651cb4733ec9861e481f0c72048398ba53c638dc5430d777c00465b4522f948294dcd9b5b1259fa9ad75fac61de0d6951b0a65b2adf74d60de1153a82565a12ca6ea3365b505c999d072e3f8c2ffb67b5e943f302e2117bc06cf1c50eba528d39a70746a6f9003734398185fa79d5a5580828da7a89a76d73dd6364f49c5e2c2bd881d7a96202e79c4db342fdf90bca878e30d59de5f90e369a5edd0b15d2fe596afde57275be9f7fc6c0c62452cb707477331be1a28e998c185a0bc287e3847588e4aa5c801b5c0cbf1bf55fb567aeea0dd536fca0b7a9df9ef16cd1b76b0547fa0fed4bda84a5d043563004aa7022ed84d086732083bdbb68c6d17b2a2a43cb288e9d56b0624170582c2e35f51bedb3bc6e01355f7d7c72469abcd8a896acca0e5f8efc7ee6fed252dc7f6180ad261da116a87d701ccaa55d8d7c3608edf17f512a22e6204b91543516d8a7b6a112e116f46da673e8fbc57564d116a0f7df75188dfeba20629e56180ccb03c0329e9bf73e523135431c230aaa6954470493ebbc42fc890aab7f657757e02d8670d657fd1b2b835972b895dba3abab067a05d6957d20de56a2ccb0470a8430458b4777c688da0180876884a2ac8fdda5bd79cecfef85ab78007049c0dccf89c333d30680a4430a493742a47f52dacb61d75b5fe6e22b4e18cd4cfe3b170742bfc93b6834e15f940ea691332db9d622fa9c11e4fc38b1af3fc3dd652d13da57330264a940ad886711777d2feb04712f490c8d6621650162aec6480b43975c9937c649da25a002a0b0f39a40c544a5febf05858abc799e030517304dc8f623f97967367fe31c17874d82c68c008556e169d7c017e678b2aff084333ee8bf829b5bc28ad0f1c2aa4dce68f9030e1f43c5dc1693598b776efbb8674944faa6dd158ee51a87ac81f0155b48d31ce8c1e6f9b1f1540722d59f61cf9461c0f9bb38ed171f7c7a13eaad97650a011b68d3c0d29dd04b21ea18570f4b9bafc84bddbd0134c4d3752dcee2e5d8658e9d21e561c4b9788d25b60fe8f1402e4a26643e77e5b826ff2c3cb55feddc21cc9bdcde5aaad5d72d492e9c8ce0cab48f6deb9a6b9cf613e110f508ebe926b7c5264742acff9507533d5d19f0ff55e75fd1a32e1bc30c06447ca6d4b898b614af36eee0ebeea5167da672838e833311d179db27a6ec1077eea3f11b9e81a3ff3a44b680dd32abd307e7f067a9560681fc0b3b0391e72ec0b2b207d718e3b07f99860748b9fcc122bc8d73bd13a49500e4d4a2ccb12129aee9b7f1b35cf298298076521ccae443921435500322fb42e010a3c5a25acf8df2c96771ed4f51cb1e3ad133c09a14c88f2afbc36fa0068a3784acb450d39a9048085352c0bfc5b8e06ac4db719d9879d2df405827e79edeec21e9a11823889ed37bbdb14fdfc3dd8e482df075a75eb02e6e1e6df1630a9699153810e92a27e7feaecbffbb8f1247064c10c216f0115826c9fc436741125b7239bb6ca062a0f69e8badbfe235f260124c047fa31d5afc90c180b212dfc5e3aa06c51b12a40f5020d96e0c4edb33843be812c081353c99f57d286a2c7a42dd3a0116a7d140fe8f7b2d07487812b012c9203f971b09380a390489acb7d4bd5b017f5915a86e34f34c8f480f5624d469d66da2dd7a4ea19b8f06ae0b0283c191fec1a673399c5bcc09a7d38c0a359df65ad590cc9fb294eaf32b9642ed6444355f20c036c3c44ac1f1f9c1393dc540ea64df00a267610a9a020cb831ae8b96e6d66a88c3e590f41ed9e5a993ef4d2b0a006030f7ef460752a0f0fedfe003338c2187e498cfb294f9a2e5cc42aea1eb07df69a09b607af7578c7870877137c6babe9437fed4763c0d31b06b8730bfad1f5c1e5ec16e11be67aa020a564f7d44e2a24312b144ebc6682f77c7eff87e40424a8ca8c9021a5b034e1174b494818b292ba43b3869a41336c52d62174a5107fe86ab89987af4013b687dd29dff05ff1b7eb0f884bbf21899cf35b966ef8a920cc17d8a5fe18f9c11144625838343cc3752b89fefc7efbbf0ba207fb0accb1c28836d29c0a218dbdff2a86e16c165ef39326f6995082f3f361ed0fcbdc7f1fd165c0341460ce7023ab1e9e123a0a940804ca5136905c3dfc89beb4f049568678214deb33519361cf008a9fb274e031e6261e3e2b1b708953d07a4866e06c5fec334d7285cd0987ed0c46b90bbed65df185f56b5314d5131ee40142de9cabee894e4269a53b28e8be8d0f2a9027b8583c3b9d8265804566e7ed48db3b0d00edda31c454f4806d7fbff0510827849963237de55acb38c1c69b181c3209e814263b18676073ac09db2e78c836bb17b28252f53264253b73d479438e9b6ed516ac7a940a02a0371a2a5b23a3aa74c44bf7aa81a57a72eff24fccdb9196395adc87db16b8b40375988693e85b42b89448362de27462624d0a9f9f20efd8ec2dc75ba68806455dd92e91e176c5765170e4aafbe08b8611f4fe1769187302bc08740642cd1bba4d9dd5e5a20e35a3a5b27492678e7b7acdb0c26ef7b5cb5befbb647775447d10475bfe2129c6a17acf20d872ccc5703836d75b30fe80b34dcbd5262f9ca1624ee58f2480730485db333a50dff52705f355750b49a8bd59bfc46eec963186e1e35acef25f434eea861814d97733e26160ab215e26ae7368289f1c9d942b181f9a9431fac2c5e80fe5c8d131b3d1ed766afa9476cff8035fa96cb6d2812bf0741894a83420dc2ddb75ae4fc1b8811c15f4368c9e08142429e78f52d1ed4409fc0c3a0b84275d1eff6b75ef658ac4c0efcbfeed860891d97589034c73f68f442c346e130e0e7833f2812e44f01345d49a2afd20f62a3e34f8817d40e48458d99bba058cfcc8918d9d4c5e1a4e7690056ee6d6de4aac53809083c7d06b06c9c18209688134569a5e305756e04aa3aa8ec0e4d2c0b8be84b2f148849fa0321a935b588e51cfdccfadb074802be19f31c75f7129738b73d32f5ee0cd1d95ad6fffd16728a602900cb3392e5eb8528d205b26cf98d58ae89a4b13f13d876e0fcbb2f7649af0522c4e2c8d2533105662e7b670bbd1e9c093cb2948e74e6f1ff27bd3dd223218c6298094e4a809f00160f196b202b520cb94080107519587100a090b88e82454ec1ba03ff452f24683ef81f8be88e9e9e0bea35eae47645e03d2e9b8e286ae0968baf391097b7b22b16778e8d5958d3e517e2273ac51ca2c813ea6e6b5618418cddefbeb2df02f07178dd8ba1f1bc6155f8d056e8309d3d926c0f03aa23abd91c6cdecd0acc9f278bfea9fb8d009b5578dab448212c198bad3e30d48cf59cfab73e9bb8e51fd4d37f56515ec21131f59ca36671b8020ef7b36ba843473a081a54a9d2089566f1815d7bffe14af3d5528bae9655307e730b82b708285ac197cbb7d2376c8301c689bf701b94545a0381ac31f535afc6eec6abd4d7f196d6ccd8c3d044964725970ca92bf05b59c283c8dd5e91f0c71295d5af02c56960d323eb57ce1ed1df5986b1e7efad020cf1eeaa6cd2a372d0b46b4e5c219cf5ca9d98f408faded318de7bf790c47171b7f406e9b085361034d39999f6bb5053188ae6d86d23f1f31c475002fe7fa2b7b52e3f0ef4f1d05bdb5e23c3bd6a3d35d1ed83f30949e06eb016089fad92bd4e7b7fcc92f6d6c865f19ac1a2b3635b14faa83f55bbd6a3f8acd41bd38a191ba89be6ca442d601d1cc353782947271395911f0025af9f8dfe4f769bfe274e0ed30166a75c0bb8949cd5cb296f49423084048210307e25390e478056788aa9be5dd2cc15fef1a28c576722ea7f87855f9cef9206abccbf79a8b51d0591f25e0d1f223fbfcd32eb69802101c05886a38daa690782582d4bbd3b116dcb4251e48c4469d766e76cff9aa280a991b377b6497546686402886dbf1a2f132d9f442fcdb57afbe12e49e78278cc510d918fd8720ce26122858035ea9c4e4e1e4e2b90c2c3aa999d42d0190c1cf24db95ec1af3931fb8788f6ed712f931ee03a2de0fd2dc5a9336c635475c39c1ec8d1a60b100aa0bd851aefcdad5c14d811c534b64c7246b30d9f57edfdb37f669a5a750e4b343585880e2a5e66a6b6a550b7fe48fb37fadca751494a84708e049a8909bee1e55bd68a3661fb8268d35deed238ab036da34eeb030874fb8c34a2f18b12eee3fc2664ec15fd4f08064b98fa861e16f2013a67214a72753e142245d4be17e638e9ceb8c80e68388e4abfbf79b1652d0160f5a4786dcd3a327cb6bf570c33383f9c85819653be6ad932d042d1471073fd6027b0c488c1021009688cc275e0d513cab32a8f15427b01d9ba449e941e637f0602927688e54d2070d20d55e814d91ab2b58d0ccc2462cc3e726fee6f3be17f4c1e1f2ca73f3a3fc07a47e16fcdf341ce0a0e7d2df78b9c1b3410cca4122af04a72c3ca99430bf61c4aec10700780bb74281cce1512b93fbfeb740415368fb9ad05650bd9e67296ecddd79ad2da60f4a5e35d30bb6191248369cd604f93aec39c782de82841622f7a2c7484c4eaa4e9ca443725de0eb46f4ff147132521f634f1b2fb629bd04d99a8a166331fe25b5804ede9f1bf5927b6b49f8c9e57bd5e58eef9376e346e4ffc10796b727297509a14abff80973923cd2c363d45306c2608e930ef581f848941aaa38acc476728ea3f8d39fb03e03b5b98f1282fc0500683ae62cec39da54c71d11ae3fcce0b2fc77a1f109f259844ab84698681184de5fa275f6573063fdd8793a9d07fff06c6e56c6177c457d804d8a72524a7f985a7b04d8a6a956045545a91c9d604340fa541b0ed2251ae215316b82e0b29c89d91c66875219e4c28e2fad21b88426a953adf17d60443d9d362d48f7007b25b5d2f8e96962806233cfeeed4d7b6284fe00f1c6b8f35c57a1ce3f6f44fac5785b441596e596d16365ff6cc7f3d7b9094b6a670263fd2c17329ac0bcb0556183fca294ac84d1ea5590e6b6d6f471aee4b03cc0525c27cf07b2dfb086e5f13d9e6f8e606f8f23f5324267c09350c58167cec5bdca872be2fa5b25bfa64abaf4b49951e2a007b9ca9e0d0f26883a5319d207bfc1efc792fa0db96d6869c7c786a33cc081e3dee3b6f92fa2cda5d8616c87d0715694ec8f95fdc82e2c4521ce6b515ca52d030ddc2fea6a6597c192bc5a06c91fd02454c522ffabdc7c0960e0053a3e8265aef66385033dcb7640e48d5fc2a1be182bc49e49b68580c8a6d16f8bf5568c8ca45f17363325776cdfa4c8ac01d62046f73e93981a6bb70a84adbf3a437c41e03b2e4952ce59409602b1fd3f1b9f76861ff5c019ddfa7bb1edc1e4b42ec0c347f40d70ac7df33d5749383e2ae6f5fbabaca8b33f2b5b5a038cae342b469a41719b929b79c5298026161baf8f70d13834cca4fb4c324028d970fa99994604e498e0d591362d9a83fab6561642a57373593929918721250e07277364027dc7ad71e8343226573245d2ddabf7ed4da0fab1ca209ab4f97d3705cf2836b8f71335d884b313cbd3ac80cbf616297cdf24c55e1c994b411482b9580041d81ac2cba70fce2b236d57a7297dffad47ad6a2ac94598b4d39c2f5b6230f2b499c17eb45c0830c23df1772d3ee699cde974fc4d8f69ca32136ecca24b2ed14797cc00b8771c79d1c3880ed2884a15ed12284ebbca367205f1f068aef67bd6dd10ae9bd1d628c139a52e3f8afd46a662f49a518a1bbb7b467f0931d1c5def20fb11f4a5d590e9f13f80619dd7062da1ac34842e10fab00792889ed10f041c022f763ae701478f38bf0c698b731b6a21601e07365c932e12949d9f02bad83061ef62f59c0fd255c58a820570bb7f4a45a001947824fe7cc273fd4802faf82a3d1c5b8acf1deb1fc30960311c5d4ac5d99cca6efddb7775d8150b297f68e704a941835ebe45d2c3f70976eb4c415eab2efd130251b30ce8f84ad0343cf6ee048f4740a25ddd710e9d1eef3ce59e66b2baaa17ebef3791820a91813a7430c5eca1d50c081a1e9dfcb6fbd3c215236cb8d3e534360e5b017ff9e40e3e2c17f916bda73c8dabde3b61283012d6a61e664b60ab088892a7b17e92e9670fb568d964a254e7301cb9f15a05b009fc24648ebfab8be8f86d0e46a83548d6cececbe7e820cd946b38ea3a1391b1c16e7512cfe7af3613d1d8ce50e5977f93fbe0b1c85c02d40b49994eccded8d3a381afa877904e7d3abf3f161cac3fae7706e6d201c5b0bbae6d038a59d8d3d2515f57f0f0a57cc12968e2ce0286db81e1ef179302569b210d870f6a4b58c646282689094f6b82da8ff191df8b48f9038334c07f78e79ac4b23db406b7de0de3964ec22fd27d19483128a4fefe436457631227d0e65934c0d2adf916d022f3fc0b49410e57388be074a62f3f4c6ee3f821dedb817ec70d152af7d89cc12fa25df3a198f014d7d04f4541f8b76b6ca3b997929eee836fccdea1f39978e50f1f31dfefb24c9da23566bf0abcfa261ce9dd33902078920646290f64250765764f32a92a2f32c354c3c0ed5b9af2c5f0638d183e278599c58f88d349681914fc745687775b832f960ddc6524fd77542a3d48dd0e6ae582c0f210b371cb4060e40a2d2a52f7d5f6e319e190245d650cf8cc48d5355e402a749c7be9d2fb29a27ddd4e418eea02998185ebe54df46bc0ae98cc05e2d93a4e4fb13b9a09fd156828f8a41364b64d0c0111c12374d8f2bf5d0c5ce925c46a604f3a7534ed432c4ef005bb4417bc666cb601f823c93e81b1a1c1fff114fcb94760201ecf822c7152bc4a8dc52f523e7d5db5b24509e4672776514cffbca0ec9dd1f99e6acd4a84c077b1401029d4a1db61d9116f3f7a93c903f519424744955e5c5c757a54ee132eaf3647e8469ee4a5414bb827b0555a88a1d854885389c162bdd7e4924e83a6cbb2c1b4af8d6210442c7b58c698eb15d120f5d506964c578d25b03964f83eee66d52f11676fbafbc07c0bdda926707efe2bde37a76e9fb27260f31eff6edb6f2880ea23dcee09130aae4536af4ecf03f1947dff3fe198178425a5d63a6c8d50bdf6b5ca6bfa41d2e86d70ee3bd3f923e030b485fcb2af5e307692ed029f11d32e62c30bb807019b41da7c1d2ba636076279c997bd70e44667d222f2c099cdf25c9806d002a2f73fef5daced25710710f4c717ca5ffaf84f6b5c573b428d34a95a766c9db624a8746a9901e6e4f0bd7d58dc5516d092ef496ebc5b3685a8d08daaf9c8f3e3f2ee99c31e64b959789115241908c36c382d03c032bfce719d69a4488c193210f5dd3df3be40d3504dc8f49ccab553b413efc6d08ed6039bde9786d5e8a65082c79118566d335c75d686b840399d99bea22d47db9e55d79a8d846c4044437bf73b181f43c74b915e20376d97ba64a772c440a2db98e6e2d10c28cd40f1d8ad156f6e24984f46e98aad841874e6bbb7187e46f524193bc81372eb1314c1f9b121c3ee5ad7897cafdfd19329bcf199ba0662b805b596acd4cf10931b49142e3e30717e16b1d07bca3cd8a34cbe63da2e4cdc6445c77f6e7e117e13dd3d223d9b50bcdcf5f632b79cbf5a745a9e7d49e47a2e4558e21fd8904ceaf841f23814c2bb2cb97216bb4fdc702f79f773c0cdd2d76cf7649394a6c63df9caf44bdc5362205f8564862ea28799e7367cac020f9ffa2af72656fe20e93ef2237be472704fed2459162e19dcaba23eadd485baa8a3f2259e45b6656cc326d8bf7525b032223179a188dc6a176c364b3c27f1f114b217fdc09a0ae2a7254f88b4fbb62401a25d30148f6dda746f1d3e491073f567776c980a78d6bae64a7d0872d89c2c846b4ab449eb44debddfcb1afe0c14e54285c040f636357a6cae37b399bb4a525e040707bc23253ca1092577f2d308fe8b1756c718eb41aace7e716c1800a5527a1b1b47840e52cdc2f169fbed149c9cec2148c7a21ead5bebda1c201802e71587de7109d0bd177fcda7aca9cd6f518f8f895fe420e90225e3ff6e5c8e7c3298d09c20e1f30a4c551480ef72c5b628f87ec116ad62c72efeeb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please enter the password.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of NorthBeach</title>
    <url>/2022/07/07/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-NorthBeach/</url>
    <content><![CDATA[<p>最后1h过了两题。不过最后是双开，不然应该过不了这么多。</p>
<p>想得还是太慢了。代码实现能力也差了一点。</p>
<span id="more"></span>

<h2 id="A-Arrange-and-Count"><a href="#A-Arrange-and-Count" class="headerlink" title="A. Arrange and Count!"></a>A. Arrange and Count!</h2><p><strong>以后都给我写双哈希！！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line">ll Mod[<span class="number">2</span>]=&#123;<span class="number">998244853</span>,<span class="number">1004535809</span>&#125;;</span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line">ll base=<span class="number">1e5</span>+<span class="number">19</span>;</span><br><span class="line">map&lt;pair&lt;ll,ll&gt;,<span class="type">int</span>&gt; ma;</span><br><span class="line">ll pw[N],f[N],a[N],g[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dec</span>(f[r],f[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);)</span><br><span class="line">	&#123;</span><br><span class="line">		ma.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">		mod=Mod[<span class="number">0</span>];</span><br><span class="line">		pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">2</span>*n) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i+n]=a[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) f[i]=(f[i<span class="number">-1</span>]*base+a[i])%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) g[i][<span class="number">0</span>]=<span class="built_in">get</span>(i,i+n<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) f[i]=(f[i<span class="number">-1</span>]*base+a[i])%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) g[i][<span class="number">1</span>]=<span class="built_in">get</span>(i,i+n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n+n+<span class="number">1</span>);</span><br><span class="line">		mod=Mod[<span class="number">1</span>];</span><br><span class="line">		pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">2</span>*n) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) f[i]=(f[i<span class="number">-1</span>]*base+a[i])%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ma[&#123;<span class="built_in">get</span>(i,i+n<span class="number">-1</span>),g[i][<span class="number">0</span>]&#125;]++;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) f[i]=(f[i<span class="number">-1</span>]*base+a[i])%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ma[&#123;<span class="built_in">get</span>(i,i+n<span class="number">-1</span>),g[i][<span class="number">1</span>]&#125;]++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ma.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Build-More-2020’s"><a href="#B-Build-More-2020’s" class="headerlink" title="B. Build More 2020’s!"></a>B. Build More 2020’s!</h2><p>不太会啊。。。</p>
<p>二分答案 $x$，维护 $x$ 个栈表示当前填的情况。</p>
<p>遇到 $0$ 优先填 $2$，遇到 $2$ 优先开一个。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h2 id="C-Choose-Two-Subsequences"><a href="#C-Choose-Two-Subsequences" class="headerlink" title="C. Choose Two Subsequences"></a>C. Choose Two Subsequences</h2><h2 id="D-Determinant-Strikes-Back"><a href="#D-Determinant-Strikes-Back" class="headerlink" title="D. Determinant Strikes Back"></a>D. Determinant Strikes Back</h2><p>线性代数基础题or找规律。</p>
<p>找规律/结论就不说了。</p>
<p>显然一个方阵 $A$ 的特征值为 $0$ 的数量为 $n-rank(A)$。因为特征值相当于沿着某个特征向量的放大倍数。</p>
<p>矩阵 $A_{ij}=a_ib_j$ 的秩显然为 $1$，因此原式一定为 $x^n+x^{n-1}\times K$ 的形式。然后就简单了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,x;</span><br><span class="line">	<span class="keyword">for</span>(;~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;x);)</span><br><span class="line">	&#123;</span><br><span class="line">		ll ans=x%mod;</span><br><span class="line">		<span class="function">VI <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">Add</span>(ans,<span class="number">1ll</span>*a[i]*b[i]%mod);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Pow</span>(x,n<span class="number">-1</span>)*ans%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Efficient-Data-Structure"><a href="#E-Efficient-Data-Structure" class="headerlink" title="E. Efficient Data Structure"></a>E. Efficient Data Structure</h2><p>$c_i=\max_j\{a_j+b_{j+1}+b_{j+2}+\cdots+b_i\}=s_i+\max_j\{a_j-s_j\}$，其中 $s_i=\sum_{j\le i} b_j$。</p>
<p>随便维护。</p>
<h2 id="H-Hamming-Distance"><a href="#H-Hamming-Distance" class="headerlink" title="H. Hamming Distance"></a>H. Hamming Distance</h2><p>性质：$i$ 这个数的所有出现位置为 $2^{i-1}+k\cdot 2^{i},k\geq 0$。</p>
<p>距离和比较简单，枚举一下每个 $a_i$，算出其一左一右的位置就好了。</p>
<p>对于最小值，我们找到最小的 $k$ 使得 $2^k-1\geq n$。</p>
<p>那么 $n$ 个数不会跨越两个以上的 $S_k$ （注意这里需要稍微特判一下 $m$ 比较小的情况），而整个串必然是 $S_k+x_1+S_k+x_2+S_k+\cdots$ 这样的形式。</p>
<p>那么直接将大于 $k$ 的都看成 $k+1$，整个 $S_m$ 看成 $S_{k+1}$ 即可。</p>
<p>剩下的利用等差数列的性质，从 $1$ 到 $k+1$ 枚举每个数字，类似统计距离和的方法，使用个前缀和即可 $O(n\log n)$ 完成。</p>
<p>有一点细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">19</span>)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ll pw[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">22</span>][N],g[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>&lt;=n;k++);</span><br><span class="line">	k++;</span><br><span class="line">	ll ans2=<span class="built_in">Dec</span>(pw[m],n)*n%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=a[i],k1=<span class="number">0</span>,k2=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=<span class="number">20</span>)</span><br><span class="line">			k1=(i+(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;x),</span><br><span class="line">			k2=((n-i+<span class="number">1</span>)+(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">20</span>||(x&lt;=<span class="number">20</span>&amp;&amp;pw[m-x]&gt;=k1+k2))</span><br><span class="line">			ans2=<span class="built_in">Dec</span>(ans2,<span class="built_in">Dec</span>(pw[m-x],k1+k2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(n==pw[m]<span class="number">-1</span>&amp;&amp;m&lt;=<span class="number">20</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans2,ans2);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(a[i]&gt;=k) a[i]=k;</span><br><span class="line">	<span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x,<span class="type">int</span> t)&#123;<span class="built_in">return</span> (x*<span class="number">2</span>+<span class="number">1</span>)*(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=a[i],k1=<span class="number">0</span>,k2=<span class="number">0</span>;</span><br><span class="line">		k1=(i+(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;x),</span><br><span class="line">		k2=((n-i+<span class="number">1</span>)+(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>))<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">		<span class="keyword">if</span>(pw[m-x]&gt;=k1+k2)</span><br><span class="line">		&#123;</span><br><span class="line">			f[x][<span class="built_in">get</span>(k1,x)-i]++;</span><br><span class="line">			<span class="type">int</span> pos=<span class="built_in">get</span>(pw[k-x]-k2,x)-i;</span><br><span class="line">			<span class="keyword">if</span>(pos&lt;=pw[k]<span class="number">-1</span>) f[x][pos]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(x,<span class="number">1</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(j,(<span class="number">1</span>&lt;&lt;x),(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>) f[x][j]+=f[x][j-(<span class="number">1</span>&lt;&lt;x)];</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>) g[j]+=f[x][j],f[x][j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;<span class="built_in">min</span>(k,m))-n) ans=<span class="built_in">max</span>(ans,g[j]);</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>) g[j]=<span class="number">0</span>;</span><br><span class="line">	ans=n-ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>,ans,ans2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">200000</span>) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n,m;~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);) <span class="built_in">solve</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-Integers-and-Ranges"><a href="#I-Integers-and-Ranges" class="headerlink" title="I. Integers and Ranges"></a>I. Integers and Ranges</h2><p>根据套路，删掉重合的线段，然后区间具有单调性。</p>
<p>将 $0\sim 9$ 分为 $\{0,9\},\{3,6\},\{1,2,4,5,7,8\}$ 三类。</p>
<p>一个区间里面只要有 $2$ 个或以上 $3$ 的因子就可以满足条件了。</p>
<p>那么设 $f_{i,j}$ 表示考虑到 $i$ 且第 $1$ 个 $3$ 的因子在 $i$ 这，第 $2$ 个 $3$ 的因子在 $j$ 这，$l\le j$ 的区间全部满足条件的方案数。</p>
<p>转移分两类即可：</p>
<ul>
<li><p>放 $3$ 或 $6$：$f_{i,j}=\sum <em>{k} f</em>{j,k}\times 2\times 6^{j-i-1}\times [\forall r\in[j,i-1],l\le k]$ </p>
</li>
<li><p>放 $0$ 或 $9$：$f_{i,i}=\sum_{j,k} f_{j,k}\times 2\times 6^{j-i-1}\times [\forall r\in[j,i-1],l\le k]$</p>
</li>
</ul>
<p>后缀和优化一下即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N][N],h[N][N],pw[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) a[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y; <span class="built_in">read</span>(x,y);</span><br><span class="line">		a[y]=<span class="built_in">max</span>(a[y],x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	h[<span class="number">0</span>][<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fd</span>(j,i<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			k=<span class="built_in">max</span>(k,a[j]);</span><br><span class="line">			<span class="keyword">if</span>(k&gt;j) <span class="keyword">break</span>;</span><br><span class="line">			f[i][j]=h[j][k]*pw[i-j<span class="number">-1</span>]%mod*<span class="number">2</span>%mod;</span><br><span class="line">			f[i][i]=<span class="built_in">Add</span>(f[i][i],h[j][k]*pw[i-j<span class="number">-1</span>]%mod*<span class="number">2</span>%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		h[i][i]=f[i][i];</span><br><span class="line">		<span class="built_in">fd</span>(j,i<span class="number">-1</span>,<span class="number">0</span>) h[i][j]=<span class="built_in">Add</span>(h[i][j+<span class="number">1</span>],f[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) k=<span class="built_in">max</span>(k,a[i]);</span><br><span class="line">	<span class="built_in">fo</span>(i,k,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,i,n)</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,f[j][i]*pw[n-j]%mod);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">1000</span>) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">6</span>%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> n,m;~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);) <span class="built_in">solve</span>(n,m);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Samara</title>
    <url>/2022/07/05/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Samara/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102916">CF</a></p>
<p>最后20min过了两题代码量超小的题。。。</p>
<span id="more"></span>

<h2 id="B-Fakes-and-Shidget"><a href="#B-Fakes-and-Shidget" class="headerlink" title="B. Fakes and Shidget"></a>B. Fakes and Shidget</h2><p>由题意，我们要求的是，在每一对 $(a,b),(c,d)$ 选择一个，求 $\max\{\frac{\sum_{i=1}^n b_i}{\sum_{i=1}^na_i}\}$。</p>
<p>直接01分数规划即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],c[N],d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">read</span>(a[i],b[i],c[i],d[i]);</span><br><span class="line">	db l=<span class="number">0</span>,r=<span class="number">1e9</span>,mid;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2.</span>;</span><br><span class="line">		db ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			ans+=<span class="built_in">max</span>(b[i]-a[i]*mid,d[i]-c[i]*mid);</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;=<span class="number">0</span>) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,mid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Cyclically-Shifted-Maze"><a href="#C-Cyclically-Shifted-Maze" class="headerlink" title="C. Cyclically Shifted Maze"></a>C. Cyclically Shifted Maze</h2><p>meaningiess直接把这题秒了。。</p>
<h2 id="D-Two-Pirates-2"><a href="#D-Two-Pirates-2" class="headerlink" title="D. Two Pirates - 2"></a>D. Two Pirates - 2</h2><p>清醒的人一定先拿走最大的那个。然后就不知道怎么做了。</p>
<p>可以发现，排好序后，选到某一堆的概率与其本身无关，因此可以使用DP。</p>
<p>设 $f_{n,i}$ 表示 $n$ 堆的时候，从小到大排名第 $i$ 被选到的概率。</p>
<p>分两种情况讨论即可。时间复杂度 $O(n^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">db f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> opt=(n-i+<span class="number">1</span>)&amp;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(opt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,i)</span><br><span class="line">				f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">			f[i][i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,i)</span><br><span class="line">				f[i][j]=(f[i<span class="number">-1</span>][j<span class="number">-1</span>]*(j<span class="number">-1</span>)+f[i<span class="number">-1</span>][j]*(i-j))/i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	db sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=a[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans+=f[n][i]*a[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.12lf %.12lf\n&quot;</span>,ans,sum-ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Powerless-Mage"><a href="#E-Powerless-Mage" class="headerlink" title="E. Powerless Mage"></a>E. Powerless Mage</h2><h2 id="F-Exactly-One-Point"><a href="#F-Exactly-One-Point" class="headerlink" title="F. Exactly One Point"></a>F. Exactly One Point</h2><p>假设我们从后往前选择点。</p>
<p>若选择了点 $i$，则该点必须覆盖至少一条线段。设 $mx_i$ 表示所有 $l\le i$ 的线段的 $r$ 的最大值；$mn_i$ 表示所有 $l\geq i$ 的线段的 $r$ 的最小值。那么后面点的合法范围是 $[mx_i+1,mn_{i+1}]$。那么在里面随便选一个就可以了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> mi[N],mx[N],l[N],r[N],n,is[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="type">int</span> m=n*<span class="number">4</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m) mi[i]=inf;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(l[i],r[i]);</span><br><span class="line">		l[i]++; r[i]++;</span><br><span class="line">		is[l[i]]++; is[r[i]+<span class="number">1</span>]--;</span><br><span class="line">		mx[l[i]]=<span class="built_in">max</span>(mx[l[i]],r[i]);</span><br><span class="line">		mi[l[i]]=<span class="built_in">min</span>(mi[l[i]],r[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) mx[i]=<span class="built_in">max</span>(mx[i],mx[i<span class="number">-1</span>]),is[i]+=is[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fd</span>(i,m<span class="number">-1</span>,<span class="number">1</span>) mi[i]=<span class="built_in">min</span>(mi[i],mi[i+<span class="number">1</span>]);</span><br><span class="line">	VI ans;</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">insert</span>(m);</span><br><span class="line">	<span class="built_in">fd</span>(i,m<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span>(mx[i]+<span class="number">1</span>&lt;=mi[i+<span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> it=s.<span class="built_in">upper_bound</span>(mx[i]);</span><br><span class="line">		<span class="keyword">if</span>(it!=s.<span class="built_in">end</span>()&amp;&amp;(*it)&lt;=mi[i+<span class="number">1</span>])</span><br><span class="line">			fa[i]=*it,s.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(*s.<span class="built_in">begin</span>()&gt;mi[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> u=*s.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span>(;u;u=fa[u])	<span class="keyword">if</span>(is[u]) ans.<span class="built_in">pb</span>(u);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x:ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="G-Lexicographically-Minimal-Subsequence"><a href="#G-Lexicographically-Minimal-Subsequence" class="headerlink" title="G. Lexicographically Minimal Subsequence"></a>G. Lexicographically Minimal Subsequence</h2><p>贪心一个一个往后看是否能选。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> now[<span class="number">26</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s\n%d&quot;</span>,s+<span class="number">1</span>,&amp;k);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) vec[s[i]-<span class="string">&#x27;a&#x27;</span>].<span class="built_in">pb</span>(i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> pos;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line">			<span class="keyword">if</span>(now[j]&lt;vec[j].<span class="built_in">size</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(n-vec[j][now[j]]&gt;=k-i)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">putchar</span>(j+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">					pos=vec[j][now[j]];</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line">			<span class="keyword">for</span>(;now[j]&lt;vec[j].<span class="built_in">size</span>()&amp;&amp;vec[j][now[j]]&lt;=pos;now[j]++);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="H-Video-Reviews-2"><a href="#H-Video-Reviews-2" class="headerlink" title="H. Video Reviews - 2"></a>H. Video Reviews - 2</h2><p>考虑最后一个人 $a_n$，如果 $a_n&lt;m$，那么一定不选。转换为 $(n-1,m-1)$ 的子问题。</p>
<p>如果 $a_n\geq m$，且 $n=m$，则这个一定会被选；如果 $n&gt;m$，则这个可能被选，但实际上选前面的一定不会更差，因此这个一定不会选。<br>那么就可以直接从 $a_n$ 开始倒退至 $a_1$ 即可。</p>
<p>由于 $z_j$ 有逆元，同一段内可以由 $a_{i+1}$ 直接推出 $a_i$，不同段的边界处需要预处理顺推一遍进行计算。</p>
<p>时间复杂度 $O(n)$，空间复杂度 $O(m)$。</p>
<h2 id="J-Lost-Island"><a href="#J-Lost-Island" class="headerlink" title="J. Lost Island"></a>J. Lost Island</h2><p>第三次见到这种题了。</p>
<p>我们记一个颜色的状态为 $(a_i,b_i)$。设某个人的颜色为 $i$。</p>
<p>若 $a_i=b_i&gt;0$，则这人看到外面只有 $b_{i}-1$ 个，不合理。因此这个知道自己就是 $i$，将在第 $1$ 天自杀。</p>
<p>若 $a_i=b_i+1$，则这人假设自己不是 $i$，那么外面这些颜色 $i$ 的人看到的状态应为 $(a_i-1,b_i)$，将在第 $1$ 天自杀，但他们并没有，于是这人在第 $2$ 天知道自己是颜色 $i$。</p>
<p>以此类推，在 $x+1$ 天，某人假设自己不是 $i$，那么外面的人将在第 $x$ 天自杀，但是并没有，于是这人在 $x+1$ 这天自杀。</p>
<p>因此，对于 $b_i&gt;0$，颜色为 $i$ 的人将在 $a_i-b_i+1$ 天自杀。</p>
<ul>
<li>若不存在 $b_i=0$，则 $a_i-b_i+1$ 最大的那些人将在次大的 $a_j-b_j+1$ 之后一天自杀，因为其他人都死光了。</li>
<li>若只存在一个 $b_i=0$，则 $i$ 颜色的人在 $a_i-b_i+1$ 最大的下一天自杀。</li>
<li>若存在两个或以上 $b_i=0$，则所有 $b_i=0$ 的人将活下来。</li>
</ul>
<p>时间复杂度 $O(n)$。</p>
<h2 id="K-Bloodseeker"><a href="#K-Bloodseeker" class="headerlink" title="K. Bloodseeker"></a>K. Bloodseeker</h2><p>首先我们把这些怪分为两类：$h_i\geq t_i$ 和 $h_i&lt;t_i$。</p>
<p>第一类是可以帮助我们回血的，第二类是要我们掉血的。</p>
<p>显然可以在恰当时间去打第一类从而充分运用其回血，一共能回 $\sum h_i-t_i$ 滴血。</p>
<p>对于第二类，假设有两个怪 $(h_i,t_i),(h_j,t_j)$，当且有 $k$ 滴血量。</p>
<p>先打 $i$ 需要满足： $m+h_i-t_i\geq t_j$。</p>
<p>先打 $j$ 需要满足：$m+h_j-t_j\geq t_i$。</p>
<p>其他不等式一样。因此我们直接按照 $h$ 从打到小依次消掉即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;ll x,y;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n,m,x,y;</span><br><span class="line">	ll now=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	vector&lt;node&gt; a;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(x,y);</span><br><span class="line">		y=<span class="built_in">min</span>(y,m);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=y) now+=y-x;</span><br><span class="line">		<span class="keyword">else</span> a.<span class="built_in">pb</span>(&#123;y,x-y&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	now+=m;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(a),[&amp;](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;<span class="keyword">return</span> x.x&gt;y.x;&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:a)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x+y&gt;now) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> now-=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">CASET <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="L-Not-the-Longest-Increasing-Subsequence"><a href="#L-Not-the-Longest-Increasing-Subsequence" class="headerlink" title="L. Not the Longest Increasing Subsequence"></a>L. Not the Longest Increasing Subsequence</h2><p>值域也为 $k$，那么直接DP一下就好了。输出方案可以倒着推一遍。</p>
<h2 id="M-Binary-Search-Tree"><a href="#M-Binary-Search-Tree" class="headerlink" title="M. Binary Search Tree"></a>M. Binary Search Tree</h2><p>树形DP一波即可。opentrains卡我常数，使用 $O(n)$ 的方法才过了。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>2022 Hubei Provincial Collegiate Programming Contest</title>
    <url>/2022/05/26/2022-Hubei-Provincial-Collegiate-Programming-Contest/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/103729">link</a></p>
<span id="more"></span>

<h2 id="A-Nucleic-Acid-Test"><a href="#A-Nucleic-Acid-Test" class="headerlink" title="A. Nucleic Acid Test"></a>A. Nucleic Acid Test</h2><p>Floyd，非核酸点贡献为到最近核酸点的两倍，核酸点间的贡献为所有核酸点用最短路径做边权的完全图的最小生成树的边权最大值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">305</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,k,t;</span><br><span class="line">	<span class="built_in">read</span>(n,m,k,t);</span><br><span class="line">	<span class="keyword">if</span>(!t) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z; <span class="built_in">read</span>(x,y,z);</span><br><span class="line">		f[x][y]=f[y][x]=z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">1</span>,n) <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(f[i][j]&gt;f[i][k]+f[k][j]) f[i][j]=f[i][k]+f[k][j];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,i+<span class="number">1</span>,n) <span class="keyword">if</span>(f[i][j]==inf) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	VI p;</span><br><span class="line">	<span class="keyword">for</span>(;k--;) &#123;<span class="type">int</span> x; <span class="built_in">read</span>(x); p.<span class="built_in">pb</span>(x);&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		ll sum=inf;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x:p) sum=<span class="built_in">min</span>(sum,f[x][i]);</span><br><span class="line">		<span class="keyword">if</span>(sum==inf) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,sum*<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DEBUG</span>(ans);</span><br><span class="line">	vector&lt;array&lt;ll,3&gt;&gt; edges;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x:p)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y:p)</span><br><span class="line">			<span class="keyword">if</span>(x&lt;y&amp;&amp;f[x][y]!=inf)</span><br><span class="line">				edges.<span class="built_in">pb</span>(&#123;f[x][y],x,y&#125;);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(edges));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [z,x,y]:edges)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">find</span>(x); y=<span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(x!=y) fa[x]=y,ans=<span class="built_in">max</span>(ans,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x:p) <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(p[<span class="number">0</span>])) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans+t<span class="number">-1</span>)/t);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-Transition"><a href="#D-Transition" class="headerlink" title="D. Transition"></a>D. Transition</h2><p>性质：</p>
<ul>
<li>不会有 $j-i\geq 3$ 的点。</li>
<li>一个 $j-i=2$ 的点可以被两个翻转代替。</li>
<li>两个交换操作不会重叠。</li>
</ul>
<p>DP，设 $f_i$ 表示考虑前 $i$ 个时的（最小操作数，方案数）。从 $f_{i-1,i-2,i-3}$ 转移过来即可。</p>
<p>时间复杂度 $O(n)$，常数巨大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line">	ll sum;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.cnt==B.cnt)</span><br><span class="line">			<span class="keyword">return</span> &#123;A.cnt,<span class="built_in">Add</span>(A.sum,B.sum)&#125;;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A.cnt&lt;B.cnt)</span><br><span class="line">			<span class="keyword">return</span> A;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(node A,<span class="type">int</span> k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;A.cnt+k,A.sum&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">char</span> s[N],t[N];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d\n%s\n%s&quot;</span>,&amp;n,s+<span class="number">1</span>,t+<span class="number">1</span>);</span><br><span class="line">	<span class="function">VI <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;node&gt; <span class="title">f</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=s[i]-<span class="string">&#x27;0&#x27;</span>,b[i]=t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	f[<span class="number">0</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	f[<span class="number">1</span>]=&#123;a[<span class="number">1</span>]^b[<span class="number">1</span>],<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=&#123;n+n,<span class="number">0</span>&#125;;</span><br><span class="line">		f[i]=f[i]+(f[i<span class="number">-1</span>]+(a[i]^b[i]));</span><br><span class="line">		f[i]=f[i]+(f[i<span class="number">-2</span>]+<span class="number">1</span>+(a[i]^b[i<span class="number">-1</span>])+(a[i<span class="number">-1</span>]^b[i]));</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i]=f[i]+(f[i<span class="number">-3</span>]+<span class="number">2</span>+(a[i]^b[i<span class="number">-2</span>])+(a[i<span class="number">-1</span>]^b[i<span class="number">-1</span>])+(a[i<span class="number">-2</span>]^b[i]));</span><br><span class="line">			f[i]=f[i]+(f[i<span class="number">-3</span>]+<span class="number">2</span>+(a[i<span class="number">-1</span>]^b[i<span class="number">-2</span>])+(a[i]^b[i<span class="number">-1</span>])+(a[i<span class="number">-2</span>]^b[i]));</span><br><span class="line">			f[i]=f[i]+(f[i<span class="number">-3</span>]+<span class="number">2</span>+(a[i]^b[i<span class="number">-2</span>])+(a[i<span class="number">-2</span>]^b[i<span class="number">-1</span>])+(a[i<span class="number">-1</span>]^b[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DEBUG</span>(f[n].cnt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[n].sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-Multigate"><a href="#E-Multigate" class="headerlink" title="E. Multigate"></a>E. Multigate</h2><p>对于某一位，要想最后有 $1$，那么就要让后面不出现 $\text{and  0}$ 的情况，于是修改操作都要尽量往后靠，也就是修改最后面 $k$ 个 $\text{and}$ 。</p>
<p>时间复杂度 $O((q+n)\log a)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> s[<span class="number">30</span>][N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">29</span>)</span><br><span class="line">		ans|=s[i][p][(x&gt;&gt;i)&amp;<span class="number">1</span>]&lt;&lt;i;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="built_in">read</span>(n,m);</span><br><span class="line">	<span class="function">VI <span class="title">a</span><span class="params">(n+<span class="number">2</span>)</span>,<span class="title">t</span><span class="params">(n+<span class="number">2</span>)</span>,vec,<span class="title">b</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(b[i]);</span><br><span class="line">		<span class="keyword">if</span>(!b[i]) vec.<span class="built_in">pb</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">29</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s[j][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		s[j][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			<span class="keyword">if</span>(b[i])</span><br><span class="line">			&#123;</span><br><span class="line">				s[j][i][<span class="number">0</span>]=s[j][i<span class="number">-1</span>][<span class="number">0</span>]|((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">				s[j][i][<span class="number">1</span>]=s[j][i<span class="number">-1</span>][<span class="number">1</span>]|((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				s[j][i][<span class="number">0</span>]=s[j][i<span class="number">-1</span>][<span class="number">0</span>]&amp;((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">				s[j][i][<span class="number">1</span>]=s[j][i<span class="number">-1</span>][<span class="number">1</span>]&amp;((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) t[i]=t[i+<span class="number">1</span>]|a[i];</span><br><span class="line">	<span class="type">int</span> k=vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y;m--;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(y,x);</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=k) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,y|t[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">get</span>(y,vec[k-x<span class="number">-1</span>])|t[vec[k-x<span class="number">-1</span>]+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Angel"><a href="#F-Angel" class="headerlink" title="F. Angel"></a>F. Angel</h2><p>签到，答案为 $2,3,\cdots,n-1,n-1,n-2\cdots,3,2$。</p>
<h2 id="H-Hamster-and-Multiplication"><a href="#H-Hamster-and-Multiplication" class="headerlink" title="H. Hamster and Multiplication"></a>H. Hamster and Multiplication</h2><p>显然 $2^a3^b5^c7^d\le 10^{18}$ 不会很多，大概在几万的水平。</p>
<p>于是用个map记录一下，然后数位DP就好了。</p>
<h2 id="J-Palindrome-Reversion"><a href="#J-Palindrome-Reversion" class="headerlink" title="J. Palindrome Reversion"></a>J. Palindrome Reversion</h2><p>显然，我们先找到第一个 $s_i\neq s_{n-i+1}$ 的点。</p>
<p>那么只会翻转这里面的区间。要使得翻转以后是一个回文串，当且仅当这个串是 $AAB,ABA,BAA$ 类型，其中 $A$ 为任意串，$B$ 为回文串。</p>
<p>哈希判断一下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1004535809</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll base=<span class="number">31</span>;</span><br><span class="line">ll sf[N],sg[N],pw[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_f</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dec</span>(sf[r],sf[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get_g</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Dec</span>(sg[l],sg[r+<span class="number">1</span>]*pw[r-l+<span class="number">1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check_palindrome</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">assert</span>(l&lt;=r);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get_f</span>(l,r)==<span class="built_in">get_g</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sf[i]=<span class="built_in">Add</span>(sf[i<span class="number">-1</span>]*base%mod,s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	sg[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) sg[i]=<span class="built_in">Add</span>(sg[i+<span class="number">1</span>]*base%mod,s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">get_f</span>(<span class="number">1</span>,i)==<span class="built_in">get_f</span>(i+<span class="number">1</span>,i+i)&amp;&amp;<span class="built_in">check_palindrome</span>(i+i+<span class="number">1</span>,n)) <span class="keyword">return</span> &#123;i+<span class="number">1</span>,n&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">get_f</span>(<span class="number">1</span>,i)==<span class="built_in">get_f</span>(n-i+<span class="number">1</span>,n)&amp;&amp;<span class="built_in">check_palindrome</span>(i+<span class="number">1</span>,n-i)) <span class="keyword">return</span> &#123;<span class="number">1</span>,i&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">2</span>) <span class="keyword">if</span>(<span class="built_in">get_f</span>(n-i-i+<span class="number">1</span>,n-i)==<span class="built_in">get_f</span>(n-i+<span class="number">1</span>,n)&amp;&amp;<span class="built_in">check_palindrome</span>(<span class="number">1</span>,n-i-i)) <span class="keyword">return</span> &#123;<span class="number">1</span>,n-i&#125;;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> s[N];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span>(s[i]!=s[n-i+<span class="number">1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">auto</span> ans=<span class="built_in">solve</span>(s+i<span class="number">-1</span>,n-(i<span class="number">-1</span>)*<span class="number">2</span>);</span><br><span class="line">			<span class="keyword">if</span>(ans.fi!=<span class="number">-1</span>) ans.fi+=(i<span class="number">-1</span>),ans.se+=(i<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans.fi,ans.se);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1 1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K-PTT"><a href="#K-PTT" class="headerlink" title="K. PTT"></a>K. PTT</h2><p>按题意照做即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">10000000</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">9800000</span>) <span class="built_in">return</span> (<span class="number">0.0</span>+n<span class="number">-9500000</span>)/<span class="number">300000</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1.0</span>+(<span class="number">0.0</span>+n<span class="number">-9800000</span>)/<span class="number">200000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">		c+=<span class="built_in">calc</span>(n);</span><br><span class="line">		<span class="keyword">if</span>(c&lt;<span class="number">0</span>) c=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.8lf\n&quot;</span>,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="L-Chtholly-and-the-Broken-Chronograph"><a href="#L-Chtholly-and-the-Broken-Chronograph" class="headerlink" title="L. Chtholly and the Broken Chronograph"></a>L. Chtholly and the Broken Chronograph</h2><p>无聊写了个分块。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b[N],s[N],L[N],R[N];</span><br><span class="line">ll su[N],a[N],tag[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	su[i]+=x*siz[i];</span><br><span class="line">	tag[i]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	su[x]=<span class="number">0</span>; siz[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,L[x],R[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i]) a[i]+=tag[x];</span><br><span class="line">		<span class="keyword">if</span>(s[i]) siz[x]++;</span><br><span class="line">		su[x]+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	tag[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,q;</span><br><span class="line">	<span class="built_in">read</span>(n,q);</span><br><span class="line">	<span class="type">int</span> blo_siz=<span class="number">314</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(a[i]);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=i/blo_siz+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">read</span>(s[i]);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!L[b[i]]) L[b[i]]=i;</span><br><span class="line">		R[b[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,b[n]) <span class="built_in">update</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> opt,l,r,x;q--;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">read</span>(opt);</span><br><span class="line">		<span class="keyword">if</span>(opt&lt;=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(x);</span><br><span class="line">			<span class="built_in">update</span>(b[x]);</span><br><span class="line">			s[x]^=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">update</span>(b[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(l,r,x);</span><br><span class="line">			<span class="keyword">if</span>(b[l]==b[r])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(i,l,r) <span class="keyword">if</span>(s[i]) a[i]+=x;</span><br><span class="line">				<span class="built_in">update</span>(b[l]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(i,b[l]+<span class="number">1</span>,b[r]<span class="number">-1</span>) <span class="built_in">add</span>(i,x);</span><br><span class="line">				<span class="built_in">fo</span>(i,l,R[b[l]]) <span class="keyword">if</span>(s[i]) a[i]+=x;</span><br><span class="line">				<span class="built_in">fo</span>(i,L[b[r]],r) <span class="keyword">if</span>(s[i]) a[i]+=x;</span><br><span class="line">				<span class="built_in">update</span>(b[l]); <span class="built_in">update</span>(b[r]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">read</span>(l,r);</span><br><span class="line">			ll sum=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(b[l]==b[r])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(i,l,r) sum+=a[i]+(s[i]?tag[b[i]]:<span class="number">0ll</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(i,b[l]+<span class="number">1</span>,b[r]<span class="number">-1</span>) sum+=su[i];</span><br><span class="line">				<span class="built_in">fo</span>(i,l,R[b[l]]) sum+=a[i]+(s[i]?tag[b[i]]:<span class="number">0ll</span>);</span><br><span class="line">				<span class="built_in">fo</span>(i,L[b[r]],r) sum+=a[i]+(s[i]?tag[b[i]]:<span class="number">0ll</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="M-Super-Star-Spectacle"><a href="#M-Super-Star-Spectacle" class="headerlink" title="M. Super Star Spectacle"></a>M. Super Star Spectacle</h2><p>这题假了。是个论文题，不太会。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">int</span> mx[N],mx2[N],cnt[N],f[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mx[u]=<span class="number">0</span>,mx2[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(v!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			<span class="keyword">if</span>(f[v]&gt;=mx[u])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mx2[u]==mx[u]) cnt[u]++;</span><br><span class="line">				<span class="keyword">else</span> cnt[u]=<span class="number">1</span>;</span><br><span class="line">				mx2[u]=mx[u],mx[u]=f[v];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(f[v]&gt;mx2[u]) mx2[u]=f[v],cnt[u]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(f[v]==mx2[u]) cnt[u]++;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(mx[u]==<span class="number">0</span>) f[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> f[u]=mx[u]+(mx[u]==mx2[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(v!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=mx[u]==f[v]?mx2[u]:mx[u];</span><br><span class="line">			<span class="keyword">if</span>(mx[u]==f[v])</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=<span class="built_in">max</span>(g,mx2[u]);</span><br><span class="line">				<span class="built_in">dfs2</span>(v,u,tmp+(g==mx2[u]||(cnt[u]&gt;<span class="number">1</span>&amp;&amp;g&lt;mx2[u])));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(g&gt;mx[u]) <span class="built_in">dfs2</span>(v,u,g);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(g==mx[u]) <span class="built_in">dfs2</span>(v,u,g+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(mx2[u]==f[v]) <span class="built_in">dfs2</span>(v,u,mx[u]+(mx[u]==mx2[u]&amp;&amp;cnt[u]&gt;<span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(g&gt;=mx[u]) mx2[u]=mx[u],mx[u]=g;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(g&gt;mx2[u]) mx2[u]=g;</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,mx[u]+(mx[u]==mx2[u]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y; <span class="built_in">read</span>(x,y);</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	ans=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>$w=p_u^{a_u\times b_{x_1}\times b_{x_2}\times \cdots \times b_{x_k}}$</p>
<p>如果 $w\bmod p_{x_k}^{a_{x_k}}=0$，那么 $p_u=p_{x_k}$ 且 $a_u\times b_{x_1}\times b_{x_2}\times \cdots \times b_{x_k}\geq a_{x_k}$。</p>
<p>dfs，对于第 $i$ 个点，在 </p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #783 (Div. 1)</title>
    <url>/2022/04/20/Codeforces-Round-783-Div-1/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1667/problems">problems</a></p>
<span id="more"></span>

<h2 id="A-Make-it-Increasing"><a href="#A-Make-it-Increasing" class="headerlink" title="A. Make it Increasing"></a>A. Make it Increasing</h2><p>暴力枚举 $0$ 所在位置，然后贪心。时间复杂度 $O(n^2)$。</p>
<h2 id="B-Optimal-Partition"><a href="#B-Optimal-Partition" class="headerlink" title="B. Optimal Partition"></a>B. Optimal Partition</h2><p>设 $f_i$ 表示前 $i$ 个的最大值。则有 $f_i=\min\{f_j+g(j,i)\}$，其中 $g(j,i)$ 为区间 $[j,i]$ 的价值。</p>
<p>分三种情况，大力线段树即可。时间复杂度 $O(n\log n)$。</p>
<h2 id="C-Half-Queen-Cover"><a href="#C-Half-Queen-Cover" class="headerlink" title="C. Half Queen Cover"></a>C. Half Queen Cover</h2><p><del>永远几乎不会构造题。</del></p>
<p>首先对于一个 $k\times k$ 的矩阵，可以用一条斜线去构造它。如图所示：</p>
<p><img src="Codeforces-Round-783-Div-1%5CC1.png" alt="C1"></p>
<p>之后剩下的没被覆盖的点，再用一条斜线即可覆盖。如图：</p>
<p><img src="Codeforces-Round-783-Div-1%5CC2.png" alt="C2"></p>
<p>于是大概需要 $\frac{2n+1}{3}$ 个就可以了。</p>
<h2 id="D-Edge-Elimination"><a href="#D-Edge-Elimination" class="headerlink" title="D. Edge Elimination"></a>D. Edge Elimination</h2><p>树形DP，设 $f_u$ 表示节点 $u$ 与其父亲的边，需要在父亲节点的度数模 $2$ 的结果为 $f_u$ 时才可以消去。</p>
<p>那么一个节点的所有儿子的 $f_v$ 值的 $0,1$ 个数不能超过一个很小的数。</p>
<p>那么就有对于所有的叶子 $v$，$f_v=1$ （需要父亲的度数为奇数，这样这条边相邻的边就是父亲度数减一了。</p>
<p>根节点特殊，讨论一下即可。其他的点，根据度数奇偶性以及 $f_v$ 的 $0,1$ 个数共四种情况讨论，其他情况则无解。</p>
<p>判断完无解后，构造方案就很容易了，相当于 $0,1,0,1\cdots$ 或 $1,0,1,0\cdots$ 依次弄。</p>
<p>时间复杂度 $O(n)$。</p>
]]></content>
      <categories>
        <category>CF</category>
      </categories>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Tokyo</title>
    <url>/2022/04/07/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Tokyo/</url>
    <content><![CDATA[<p><del>Grand Prix of 998244353</del></p>
<p><a href="https://codeforces.com/gym/102978/problems">cf</a></p>
<span id="more"></span>

<h2 id="A-Ascending-Matrix"><a href="#A-Ascending-Matrix" class="headerlink" title="A. Ascending Matrix"></a>A. Ascending Matrix</h2><p>先不考虑 $a_{r,c}=v$ 的限制。</p>
<p>我们将 $\le i$ 和 $&gt;i$ 的数用一个折线分开，那么这条折线就是一个从 $(m,0)$ 到 $(0,n)$ 的折线，需要使得这 $k-1$ 条折线不互相穿过。</p>
<p>将第 $i$ 条折线向右上平移 $i-1$ 格后，使用LGV引理解决。</p>
<p>考虑原来的问题， $a_{r,c}=v$ 相当于有 $v-1$ 条折线恰好从 $p$ 的左下方（不包含p）经过。</p>
<p>对于第 $v$ 条折线，他最多只能恰好经过 $p$，而在平移后，就是不经过 $p$ 点。</p>
<p>那么新开一个 $x$，表示经过的是下方，而常数表示从 $p$ 的上方经过。</p>
<p>那么LGV引理中的每一项就是一个多项式。答案为这个多项式的 $x^{v-1}$ 的系数。</p>
<p>由于这个矩阵大小为 $k-1$ ，因此行列式最多为 $k-1$ 次的多项式。</p>
<p>拉格朗日插值，插 $k$ 次即可。</p>
<p>时间复杂度 $O(k^4+k^2(n+m))$。</p>
<h2 id="B-Bit-Operation"><a href="#B-Bit-Operation" class="headerlink" title="B. Bit Operation"></a>B. Bit Operation</h2><p>可以将操作变为：每次选择一个数，然后删掉左/右其中一个。</p>
<p>剩下的就很好统计了，时间复杂度 $O(n)$。</p>
<h2 id="D-Do-Use-FFT"><a href="#D-Do-Use-FFT" class="headerlink" title="D. Do Use FFT"></a>D. Do Use FFT</h2><p>设 $F_k(x)=\prod_{i=1}^k(x+B_i)$。</p>
<p>$\forall k\in[1,n]$，需要求 $\sum_{i=1}^nC_iF_k(A_i)$。</p>
<p>我们设 $F_k(x)=f_0+f_1x^1+\cdots+f_kx^k$。</p>
<p>那么答案就是 $\sum_{j=0}^kf_j\sum_{i=1}^nC_iA_i^j$</p>
<p>设 $G(x)=\sum_{i=1}^nC_iA_i^jx^j=\sum_{i=1}^n\frac{C_i}{1-A_ix}$，答案就是 $[x^0]G(x)F_k(\frac{1}{x})$。</p>
<p>$G(x)$ 可通过简单的分治FFT，暴力通分后求出分母和分子，然后对分母求逆即可。</p>
<p>对于 $F_{l,r}(\frac{1}{x})=\prod_{i=l}^r\frac{1+B_ix}{x}$，我们仅需要求出 $[x^{r-l}]G(x)\prod_{i=l}^r(1+B_ix)$。</p>
<p>分治，先求 $[l,mid]$，对于 $[mid+1,r]$ 的答案，可以先求出 $G(x)\prod_{i=l}^{mid}(1+B_ix)$，然后去掉前面 $mid-l+1$ 位，当做除了一个 $x^{mid-l+1}$，然后传参递归处理右边即可。</p>
<p>时间复杂度 $T(n)=2T(\frac{n}{2})+O(n\log n)=O(n\log ^2n)$。</p>
<h2 id="E-Edge-Subsets"><a href="#E-Edge-Subsets" class="headerlink" title="E. Edge Subsets"></a>E. Edge Subsets</h2><p>神仙题。</p>
<p>首先，显然有一个 $n\times 2^B$ 的状压DP做法。</p>
<p>考虑将 $V_i-U_i=A$ 或 $V_i-U_i=B$ 简化。</p>
<p>不妨设 $(A,B)=1$ 且 $A&lt;B$（否则分成 $\gcd(A,B)$ 个图进行处理，然后乘法原理乘起来）。</p>
<p>那么将 $V_i-U_i=B$ 的排成一行。严格地说，将点 $v$ 排在一个网格内，其坐标 $(x,y)$ 满足 $x=\lfloor \frac{v}{B} \rfloor,yA\equiv v\pmod B$。</p>
<p>那么每一行的点都会互相连。$(x,i)$ 连向 $(x,i+1)$ 或 $(x+1,i+1)$，特别地，$(x,B-1)$ 会连向 $(x+1,0)$。</p>
<p>考虑从下往上进行状压DP。与 $O(n\times 2^B)$ 普通状压不同的是，我们需要记录最下面一层的情况。DP的时候看起来需要枚举两层的节点。但实际上可以做一个高维前缀和后就不需要了。时间复杂度是 $O(n\times 4^{\frac{n}{B}})$。</p>
<p>当 $B\le 20$ 时，选择第一种，否则选择第二种，即可得到 $O(n2^{\sqrt{2n}})$ 复杂度的算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,k) (((x)&gt;&gt;(k))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VI vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">if</span>(f) x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="keyword">class</span>... V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;a,V&amp;... b)</span></span>&#123;<span class="built_in">read</span>(a); <span class="built_in">read</span>(b...);&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET int ___;for(read(___);___--;)</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x+=y; (x&lt;mod)?<span class="number">0</span>:x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1030</span>;</span><br><span class="line"><span class="type">int</span> n,m,A,B;</span><br><span class="line">ll f[M*M],g[M*M];</span><br><span class="line">ll h[M*M];</span><br><span class="line"><span class="type">int</span> up[N][N],ri[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">	<span class="type">bool</span> a[N],b[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(y-x==A) a[y]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> b[y]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> S=<span class="number">1</span>&lt;&lt;B;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,S) f[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,S)</span><br><span class="line">				<span class="keyword">if</span>(f[s])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">Add</span>(g[(s&lt;&lt;<span class="number">1</span>)&amp;(S<span class="number">-1</span>)],f[s]);</span><br><span class="line">					<span class="keyword">if</span>(a[i]&amp;&amp;!<span class="built_in">bit</span>(s,A<span class="number">-1</span>)) <span class="built_in">Add</span>(g[((s&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;A)|<span class="number">1</span>)&amp;(S<span class="number">-1</span>)],f[s]);</span><br><span class="line">					<span class="keyword">if</span>(b[i]&amp;&amp;!<span class="built_in">bit</span>(s,B<span class="number">-1</span>)) <span class="built_in">Add</span>(g[(s&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&amp;(S<span class="number">-1</span>)],f[s]);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,S) f[s]=g[s],g[s]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ff</span>(s,<span class="number">0</span>,S) <span class="built_in">Add</span>(ans,f[s]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve2</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> C=(n+B<span class="number">-1</span>)/B;</span><br><span class="line">		<span class="built_in">memset</span>(up,<span class="number">-1</span>,<span class="built_in">sizeof</span>(up));</span><br><span class="line">		<span class="built_in">memset</span>(ri,<span class="number">-1</span>,<span class="built_in">sizeof</span>(ri));</span><br><span class="line">		<span class="built_in">ff</span>(y,<span class="number">0</span>,B)</span><br><span class="line">			<span class="built_in">ff</span>(x,<span class="number">0</span>,C)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> xx=y*A%B,z=x*B+xx;</span><br><span class="line">				up[y][x]=ri[y][x]=<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">if</span>(z+A&lt;n&amp;&amp;a[z+A]) up[y][x]=x+(xx+A&gt;=B);</span><br><span class="line">				<span class="keyword">if</span>(z+B&lt;n&amp;&amp;b[z+B]) ri[y][x]=x+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">auto</span> work = [&amp;](ll *a,<span class="type">int</span> *r) &#123;</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,C<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">if</span>(r[i]!=<span class="number">-1</span>)</span><br><span class="line">					<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">						<span class="keyword">if</span>(!<span class="built_in">bit</span>(s,i)&amp;&amp;!<span class="built_in">bit</span>(s,i+<span class="number">1</span>))</span><br><span class="line">							<span class="built_in">Add</span>(a[s|(<span class="number">3</span>&lt;&lt;i)],a[s]);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C) h[s]=<span class="number">0</span>;</span><br><span class="line">		h[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">work</span>(h,ri[<span class="number">0</span>]);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ff</span>(tt,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C) f[s]=g[s]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">				<span class="keyword">if</span>(h[s]&amp;&amp;((s&amp;tt)==s))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> tmp=tt^s;</span><br><span class="line">					<span class="built_in">ff</span>(i,<span class="number">0</span>,C)</span><br><span class="line">						<span class="keyword">if</span>(<span class="built_in">bit</span>(tmp,i))</span><br><span class="line">							<span class="keyword">if</span>(up[<span class="number">0</span>][i]==<span class="number">-1</span>) &#123;tmp=<span class="number">-1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">					<span class="keyword">if</span>(tmp!=<span class="number">-1</span>) <span class="built_in">Add</span>(f[tmp],h[s]);</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">work</span>(f,ri[<span class="number">1</span>]);</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">1</span>,B<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C) g[s]=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">ff</span>(j,<span class="number">0</span>,C)</span><br><span class="line">					<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">						<span class="keyword">if</span>(!<span class="built_in">bit</span>(s,j))</span><br><span class="line">							<span class="built_in">Add</span>(f[s|(<span class="number">1</span>&lt;&lt;j)],f[s]);</span><br><span class="line">				<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">					<span class="keyword">if</span>(f[s])</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">						<span class="built_in">ff</span>(j,<span class="number">0</span>,C)</span><br><span class="line">						<span class="keyword">if</span>(!<span class="built_in">bit</span>(s,j))</span><br><span class="line">							<span class="keyword">if</span>(up[i][j]==<span class="number">-1</span>||<span class="built_in">bit</span>(tmp,up[i][j])) &#123;tmp=<span class="number">-1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">							<span class="keyword">else</span> tmp|=(<span class="number">1</span>&lt;&lt;up[i][j]);</span><br><span class="line">						<span class="keyword">if</span>(tmp!=<span class="number">-1</span>) <span class="built_in">Add</span>(g[tmp],f[s]);</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="built_in">work</span>(g,ri[i+<span class="number">1</span>]);</span><br><span class="line">				<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C) f[s]=g[s],g[s]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,C<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">if</span>(up[B<span class="number">-1</span>][i]!=<span class="number">-1</span>&amp;&amp;!<span class="built_in">bit</span>(tt,i+<span class="number">1</span>))</span><br><span class="line">					<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C)</span><br><span class="line">						<span class="keyword">if</span>(!<span class="built_in">bit</span>(s,i))</span><br><span class="line">							<span class="built_in">Add</span>(f[s|(<span class="number">1</span>&lt;&lt;i)],f[s]);</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;C) <span class="built_in">Add</span>(ans,f[s]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> B&lt;=<span class="number">20</span>?<span class="built_in">solve1</span>(n):<span class="built_in">solve2</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Graph G[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>(n,m,A,B);</span><br><span class="line">	<span class="keyword">if</span>(A&gt;B) <span class="built_in">swap</span>(A,B);</span><br><span class="line">	<span class="type">int</span> d=__gcd(A,B);</span><br><span class="line">	A/=d; B/=d;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y; <span class="built_in">read</span>(x,y); x--; y--;</span><br><span class="line">		G[x%d].<span class="built_in">add</span>(x/d,y/d);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,d<span class="number">-1</span>) (ans*=G[i].<span class="built_in">solve</span>((n-i<span class="number">-1</span>)/d+<span class="number">1</span>))%=mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-Find-the-LCA"><a href="#F-Find-the-LCA" class="headerlink" title="F. Find the LCA"></a>F. Find the LCA</h2><h2 id="G-Games"><a href="#G-Games" class="headerlink" title="G. Games"></a>G. Games</h2><p>取石子问题的变种。先手必败当且仅当把 $a_i$ 转换成二进制后，二进制每一位相加为 $7$ 的倍数。</p>
<p>也就是在 $n$ 个数里面可重复选择 $k$ 个，看有多少符合上述情况。</p>
<p>定义七进制不进位加法，那么答案相当于求 $[x^0]F^k(x)$。</p>
<p>使用七进制FWT即可，刚好 $7$ 的原根在模 $998244353$ 意义下存在。</p>
<h2 id="H-Harsh-Comments"><a href="#H-Harsh-Comments" class="headerlink" title="H. Harsh Comments"></a>H. Harsh Comments</h2><p>注意到 $a_i$ 很小，也就是总和不超过 $10000$。</p>
<p>最大值不好算，最小值好算。使用Min-Max容斥，有：$E(max(S))=\sum_{T\subseteq S,T\neq \varnothing}(-1)^{|T|-1}E(min(T))$。</p>
<p>计算 $min(T)$，也就是一堆石子里第一次取出 $T$ 内任意一个的概率。这是，$T$ 内的石子就可以合并成一个，总和记为 $sum$。</p>
<p>根据期望的线性性，有 $min(T)=\sum_{i\in B\or i\in {\complement_ST}}\frac{sum}{sum+i}+1$。</p>
<p>这个 $+1$ 在容斥以后就没啥用了。$i\in B$ 的情况也比较容易，在背包里面计算容斥系数即可。对于 $i\in \complement_ST$，此时可以枚举每个 $i$，然后强制 $i$ 不在 $T$ 内时，剩下的 $n-1$ 个点的方案数，这相当于一个回退的背包。</p>
<p>时间复杂度 $O(n^3\log mod)$。假设 $n,m,a$ 同阶。可以通过一些简单的方法优化掉求逆的 $\log mod$。</p>
<h2 id="I-Inverse-Problem"><a href="#I-Inverse-Problem" class="headerlink" title="I. Inverse Problem"></a>I. Inverse Problem</h2><p>注意到，我们只需要考虑 $p$ 的最长递增前缀，后面的不需要管它。</p>
<p>对于该前缀，$(p_i,p_{i+1})$ 内还没确定的数只能放在 $p_i$ 前面，那么一个个放，一直乘起来即可。</p>
<p>时间复杂度 $O(n)$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>2021-2022 ACM-ICPC Latin American Regional Programming Contest</title>
    <url>/2022/04/07/2021-2022-ACM-ICPC-Latin-American-Regional-Programming-Contest/</url>
    <content><![CDATA[<p>[cf]</p>
<span id="more"></span>

<h2 id="A-Ancient-Towers"><a href="#A-Ancient-Towers" class="headerlink" title="A. Ancient Towers"></a>A. Ancient Towers</h2><h2 id="B-Because-Art"><a href="#B-Because-Art" class="headerlink" title="B. Because, Art!"></a>B. Because, Art!</h2><p>考虑最大值如何计算，最小值相当于取负号。</p>
<p>排序后，找到同正同负的下标，按照乘积的大小从大到小排序，假设有 $k$ 对这样的数，那么前 $k$ 个的选法一定是按照顺序来的。剩下 $n-k$ 对一正一负，使用FFT计算即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h2 id="F-Fields-Division"><a href="#F-Fields-Division" class="headerlink" title="F. Fields Division"></a>F. Fields Division</h2><p>删掉 $n$ 个点后，$n-1$ 所在连通块形成的集合即为其中一个集合。</p>
<h2 id="G-Generator-Tree"><a href="#G-Generator-Tree" class="headerlink" title="G. Generator Tree"></a>G. Generator Tree</h2><p>树哈希：$f_u=1+\sum_{v\in son_u}f_v\times prime[siz_v]$。</p>
<p>每棵树，枚举它节点个数的因数 $d$，判断是否能被分解为 $\frac{n}{d}$ 棵同构的树。</p>
<p>若能，那么肯定存在一个大小为 $d$ 的子树，算出其哈希值后，用一个数组标记表示已经算过了，模拟将这个大小为 $d$ 的子树删去，然后继续做即可。</p>
<h2 id="H-Hamilton-The-Musical"><a href="#H-Hamilton-The-Musical" class="headerlink" title="H. Hamilton - The Musical"></a>H. Hamilton - The Musical</h2><p>二分图带权匹配模板。</p>
<h2 id="I-Invested-Money"><a href="#I-Invested-Money" class="headerlink" title="I. Invested Money"></a>I. Invested Money</h2><p>模拟题，找到一个周期即可。</p>
<h2 id="J-Joining-Pairs"><a href="#J-Joining-Pairs" class="headerlink" title="J. Joining Pairs"></a>J. Joining Pairs</h2><p>输出 <code>N</code> 当且仅当存在两对点都在边界上，且交叉。</p>
<h2 id="K-KIARA-is-a-Recursive-Acronym"><a href="#K-KIARA-is-a-Recursive-Acronym" class="headerlink" title="K. KIARA is a Recursive Acronym"></a>K. KIARA is a Recursive Acronym</h2><p>签到题。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Suwon</title>
    <url>/2022/03/31/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Suwon/</url>
    <content><![CDATA[<p>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Suwon 题解。</p>
<span id="more"></span>

<h2 id="A-Another-Tree-Queries-Problem"><a href="#A-Another-Tree-Queries-Problem" class="headerlink" title="A. Another Tree Queries Problem"></a>A. Another Tree Queries Problem</h2><p>以 $1$ 为根，考虑询问中每条边对答案的贡献。</p>
<p>分两种情况：子树和，总和-子树和。</p>
<p>总和-子树和的点出现在 $u$ 到 $1$ 的路径中。</p>
<p>因此答案为 $dep_u\times \sum a_i +\sum sum_u-2\times \sum_{v\in(u,1)}sum_v$，其中 $sum_u$ 表示 $u$ 子树的节点的 $a_i$ 的和。</p>
<p>树剖，用线段树维护 $sum_u$。</p>
<p>对于子树 $u$ 内加 $x$，子树内的点的 $sum$ 各自加上其子树大小 $\times x$，$fa_u$ 到 $1$ 的节点，$sum$ 加上 $siz_u\times x$。</p>
<p>对于链 $(u,v)$ 内加 $x$，链上的点的 $sum$ 加一个公差为 $1$ 的等差数列。可用 $+dep_w$ 维护。$lca_{u,v}$ 到 $1$ 的节点，$sum$ 加上 $(u,v)$ 间点的个数乘以 $x$。</p>
<p>于是用线段树维护，区间加，区间加 $siz_u$，区间加 $dep_u$ 即可。</p>
<p>一堆细节，极其容易写错。。。</p>
<h2 id="B-Best-Meeting-Places"><a href="#B-Best-Meeting-Places" class="headerlink" title="B. Best Meeting Places"></a>B. Best Meeting Places</h2><p>从小到大排序，用并查集维护即可。</p>
<h2 id="C-Colorful-Squares"><a href="#C-Colorful-Squares" class="headerlink" title="C. Colorful Squares"></a>C. Colorful Squares</h2><p>二分答案，扫描线，用线段树维护当前覆盖某个节点的颜色数。</p>
<p>唯一麻烦的是修改，需要确定哪些点需要被修改。</p>
<p>显然，需要修改的是一段区间，对于每个颜色，开一个set记录当前的点，然后通过查找前驱后继找到这个区间。</p>
<p>时间复杂度 $O(n\log^2n)$。</p>
<h2 id="E-Expected-Distance"><a href="#E-Expected-Distance" class="headerlink" title="E. Expected Distance"></a>E. Expected Distance</h2><p>两点距离为 $dis_{1,u}+dis_{1,v}-2\times dis_{1,lca(u,v)}$。</p>
<p>由期望线性性，我们将上面拆成三部分，前两部分的 $dis_{1,i}$ 的期望值可以通过递推计算，设为 $f_i$。</p>
<p>而对于 $u,v(u&lt;v)$ 而言，我们需要求出 $dis_{1,lca(u,v)}$ 的期望值：</p>
<ul>
<li>对于 $v$，选择 $v$ 的一个父亲 $i$，概率为 $\frac{a_i}{\sum_{j=1}^{i-1}a_j}$。</li>
<li>如果 $i=u$，则表示找到了 $lca$，返回 $f_u$。</li>
<li>如果 $i&gt;u$，则令 $u’=u,v’=i$，继续递归。</li>
<li>否则 $i&lt;u$，则令 $u’=i,v’=u$，继续递归。</li>
</ul>
<p>可以发现，$lca(u,v)$ 必须 $\le u$。因此， $dis_{1,lca(u,v)}$ 的期望和 $v$ 没有任何关系。设 $g_u$ 为此时的期望值，则有：$g_u=\frac{a_uf_u+\sum_{j=1}^{u-1}a_jg_j}{\sum_{j=1}^ua_j}$，也可以递推求出。</p>
<p>时间复杂度 $O(n+q)$。</p>
<h2 id="F-Find-the-XOR"><a href="#F-Find-the-XOR" class="headerlink" title="F. Find the XOR"></a>F. Find the XOR</h2><p>首先根据经典结论，两点间的异或和可以看成随便一棵生成树中两点走树边的异或和再异或上若干个环的值。</p>
<p>环的异或值一共有 $m-n+1$ 个，将这些数扔进线性基 $Base$ 里。</p>
<p>设 $f(x),g(x)$ 为 $x$ 经过 $Base$ 后的最小值，最大值。</p>
<p>那么答案就是 $\oplus_{l\le i&lt;j\le r}g(d_i\oplus d_j)$。 我们要想办法将这个 $d_i,d_j$ 拆到外面去，否则就无法快速算了。最大值 $g(x)$ 比较难拆开，那么来看看 $f(x)$。</p>
<p>运用了线性基的若干重要性质：</p>
<ul>
<li>首先，$f(x)\oplus g(x)$ 等于 $Base$ 中能异或出的最大值。考虑用归纳证明即可。那么可以将 $g(x)$ 转换成 $f(x)$ 了。</li>
<li>对于 $f(x)$，有 ：$f(x)\oplus f(y)=f(x\oplus y)$。</li>
</ul>
<p>那么，经过这些转化后就比较简单了。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>2020 Petrozavodsk Winter Camp, Jagiellonian U Contest</title>
    <url>/2022/03/22/2020-Petrozavodsk-Winter-Camp-Jagiellonian-U-Contest/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Belarus</title>
    <url>/2022/03/17/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Belarus/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102956">gym</a></p>
<span id="more"></span>

<h2 id="A-Belarusian-State-University"><a href="#A-Belarusian-State-University" class="headerlink" title="A. Belarusian State University"></a>A. Belarusian State University</h2><p>需要深入理解FWT的本质。</p>
<p>FWT的分治中，是拆开某一位去分治的。</p>
<p>对于每一位的处理，实际上就是相当于处理一种运算关系。</p>
<p>而我们的目标是处理 $2^4=16$ 种二元0/1运算，我们会的只有 $or,and,xor$ 三种。</p>
<p>而我们可以将这个运算转换成取反，固定某个变量的值，以及上面三种常规操作的若干种，从而解决某一位的问题。</p>
<p>分类讨论 $16$ 种情况即可。。</p>
<p>时间复杂度 $O(2^nn)$。</p>
<h2 id="B-Beautiful-Sequence-Unraveling"><a href="#B-Beautiful-Sequence-Unraveling" class="headerlink" title="B. Beautiful Sequence Unraveling"></a>B. Beautiful Sequence Unraveling</h2><h2 id="C-Brave-Seekers-of-Unicorns"><a href="#C-Brave-Seekers-of-Unicorns" class="headerlink" title="C. Brave Seekers of Unicorns"></a>C. Brave Seekers of Unicorns</h2><p>DP，设 $f_i$ 表示序列最后一位为 $i$ 的总方案数。设 $s_i$ 为其前缀和，最终答案为 $s_n$。考虑用所有的方案数减去不合法的，也就是：</p>
<p>$f_i=s_{i-1}-\sum_{k&lt;k\oplus i&lt;i}f_k$。</p>
<p>而对于所有的 $k&lt;k\oplus i&lt;i$，$k$ 的规律是 $k$ 的最高位比 $i$ 小，且该最高位中 $i$ 这一位为 $1$。</p>
<p>然后就是 $O(\log n)$ 个区间和了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h2 id="D-Bank-Security-Unification"><a href="#D-Bank-Security-Unification" class="headerlink" title="D. Bank Security Unification"></a>D. Bank Security Unification</h2><p>设 $f_i$ 表示考虑前 $i$ 个，其中第 $i$ 个必选的最大值，有 $f_i=\max \{f_j+a_j&amp; a_i\}$。</p>
<p>优化，我们只需要对于每一位考虑前边的出现过这一位为 $1$ 的最大下标即可。</p>
<ul>
<li>证明： 设 $a_i&amp;a_j$ 的最大位为 $k$，对于任一更小的 $j’$，且满足 $a_i&amp; a_{j’}$ 最大位为第 $k$ 位，那么显然有 $a_{j’}&amp; a_{i}&lt;2^{k+1}\le a_{j’}&amp; a_j+a_j&amp; a_i$。说明 $i,j’$ 中间多选一个 $j$ 会比较优。</li>
</ul>
<p>时间复杂度 $O(n\log C)$。</p>
<h2 id="E-Brief-Statements-Union"><a href="#E-Brief-Statements-Union" class="headerlink" title="E. Brief Statements Union"></a>E. Brief Statements Union</h2><p>拆位后，变成 $01$ 序列。$and=1$ 的限制相当于表示 $[l_i,r_i]$ 全是 $1$；$and=0$ 的限制表示 $[l_i,r_i]$ 不全为 $1$。</p>
<p>假设 $and=1$ 的都选，差分后，求出有多少个 $and=0$ 的区间全是 $1$。</p>
<p>如果是 $0$ 个，随便删哪个线段均可；</p>
<p>如果是 $1$ 个，可以删掉这个 $and=0$ 的区间；</p>
<p>如果 $&gt;1$ 个，则不能删掉 $and=0$ 的区间；</p>
<p>下面考虑删掉任意一个 $and=1$ 的区间后合法的情况。那么删掉这个区间后合法当且仅当删掉后能满足所有 $and=0$ 的区间的限制。</p>
<p>还是利用每个点被 $and=1$ 的线段覆盖次数的数组，找到所有的只被一条线段覆盖过的点就可以了。</p>
<p>时间复杂度 $O(n\log C)$。</p>
<h2 id="F-Border-Similarity-Undertaking"><a href="#F-Border-Similarity-Undertaking" class="headerlink" title="F. Border Similarity Undertaking"></a>F. Border Similarity Undertaking</h2><p>分治，然后预处理出左右两边的最远距离，以及能遇到的一些最大值。暴力枚举，时间复杂度 $O(nm\log nm)$。</p>
<h2 id="G-Biological-Software-Utilities"><a href="#G-Biological-Software-Utilities" class="headerlink" title="G. Biological Software Utilities"></a>G. Biological Software Utilities</h2><p>不妨设有 $2n$ 个点，如何求有完美匹配的树的个数？</p>
<p>首先枚举 $2n$ 个点的不同的匹配情况，答案是 $\prod_{i=1}^n(2i-1)$。</p>
<p>然后对于每种匹配间进行连边，每次连边有 $4$ 种情况，且需要连成一个 $n$ 个点的树，答案是 $4^{n-1}\times n^{n-2}$。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="H-Bytelandia-States-Union"><a href="#H-Bytelandia-States-Union" class="headerlink" title="H. Bytelandia States Union"></a>H. Bytelandia States Union</h2><p>对于一条路径 $(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)$，它的权值总和为 $x_n^2y_n^2-x_1^2y_1^2+\sum_{i=1}^{n-1}(x_i^2+y_i^2)$。</p>
<p>那么，相当于算 $\sum_{i=1}^n(x_i^2+y_i^2)$ 的最小值。</p>
<p>考虑每次移动，$(x^2+y^2)$ 的变化是 $\pm 2x/2y+1$ 的。</p>
<p>先不妨设 $x_1\le x_n$。</p>
<p>如果 $y_1\geq y_n$，那么显然先一直往下走，然后再往右走最优。</p>
<p>如果 $y_1\le y_n$，那么就从 $(x_1,y_1)$ 一直移动 $x$ 或 $y$ 中的较小值，直到他们相等，$(x_n,y_n)$ 也是如此。经过这样的操作以后，就变成从 $(x_1,x_1)$ 移动到 $(x_n,x_n)$ 了，这个很容易算出最小值。</p>
<p>分类讨论，$O(1)$ 计算，时间复杂度 $O(n)$。</p>
<h2 id="I-Binary-Supersonic-Utahraptors"><a href="#I-Binary-Supersonic-Utahraptors" class="headerlink" title="I. Binary Supersonic Utahraptors"></a>I. Binary Supersonic Utahraptors</h2><p>欺诈题，无论怎么操作，答案不会改变。</p>
<h2 id="J-Burnished-Security-Updates"><a href="#J-Burnished-Security-Updates" class="headerlink" title="J. Burnished Security Updates"></a>J. Burnished Security Updates</h2><p>判断是否是若干连通二分图。</p>
<h2 id="M-Brilliant-Sequence-of-Umbrellas"><a href="#M-Brilliant-Sequence-of-Umbrellas" class="headerlink" title="M. Brilliant Sequence of Umbrellas"></a>M. Brilliant Sequence of Umbrellas</h2><p>我们若构造 $1,1\times 2,2\times 3,3\times 4\cdots$，唯一不满足的是有可能出现隔着两个不互质，比如 $2\times 3,3\times 4$。为了解决这个问题，我们暴力规定隔着两个是互质的。</p>
<p>于是有：$1,2,3,5,7,8,9,11,13,\cdots$，第 $i$ 个数大概是 $\frac{3}{2}i$，这样就可以了。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="N-Best-Solution-Unknown"><a href="#N-Best-Solution-Unknown" class="headerlink" title="N. Best Solution Unknown"></a>N. Best Solution Unknown</h2><p>找到区间的最大值。然后向左右两边递归，记录当前需要到达的最低分即可。</p>
<p>使用单调栈建立笛卡尔树，时间复杂度 $O(n)$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Nizhny Novgorod</title>
    <url>/2022/03/06/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Nizhny-Novgorod/</url>
    <content><![CDATA[<p><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010531">opentrain</a></p>
<span id="more"></span>

<h2 id="A-Assignment-Problem"><a href="#A-Assignment-Problem" class="headerlink" title="A. Assignment Problem"></a>A. Assignment Problem</h2><p>暴力 $m!$ 枚举先后顺序，用 dfs 枚举，即可 $O(m)$ 判断新加的那个是谁。</p>
<p>时间复杂度 $O(m!\times m)$。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h2 id="C-Multiple"><a href="#C-Multiple" class="headerlink" title="C. Multiple?"></a>C. Multiple?</h2><p>答案为 $\varphi(n)\binom{n-1}{k-1}$。</p>
<p>计算组合数数可以直接暴力。</p>
<h2 id="D-Output-Limit-Exceeded"><a href="#D-Output-Limit-Exceeded" class="headerlink" title="D. Output Limit Exceeded"></a>D. Output Limit Exceeded</h2><p>当 $i\leq \frac{n}{2}$，且 $[n-i+1,n]$ 内出现了两个或以上的质数时，答案一定为 $0$。</p>
<p>而当 $i&gt;\frac{n}{2}$ 时，中间会有些重复的部分。我们完全可以让重复的部分一一对应匹配，因为若 $x\rightarrow y,y\rightarrow z$，那么可以变成 $x\rightarrow z,y\rightarrow y$。那么，此时 $i$ 的答案与 $n-i$ 完全相同。</p>
<p>在 $10^{18}$ 内，两个质数相隔的距离不多，那么直接KM或者网络流暴力求出 $0\sim k$ 的答案，其中 $[n-k+1,n]$ 内出现了两个质数，且 $k$ 最小。</p>
<p>使用网络流，时间复杂度 $O(k^{2.5}\log k)$。</p>
<h2 id="E-Smol-Vertex-Cover"><a href="#E-Smol-Vertex-Cover" class="headerlink" title="E. Smol Vertex Cover"></a>E. Smol Vertex Cover</h2><p>先用带花树求出一个一般图最大匹配 $M$。设最小点覆盖所需点数为 $C$。</p>
<p>显然有，$M\le C$，而题目要求 $C\le M+1$。</p>
<ul>
<li>$C=M$</li>
</ul>
<p>对于每条在最大匹配内的边，都有且仅有一个点是选的；对于不在最大匹配内的边的点，两个至少选一个。</p>
<p>有且仅有相当于 $i\oplus j=1$，至少选一个相当于 $i\text{ or }j=1$。2-SAT。</p>
<ul>
<li>$C=M+1$</li>
</ul>
<p>枚举哪个点是必须选择的，然后和 $C=M$ 的情况类似，判断的时候也做一遍 2-SAT即可。</p>
<p>总的时间复杂度 $O(n^3)$。</p>
<h2 id="G-Remove-the-Prime"><a href="#G-Remove-the-Prime" class="headerlink" title="G. Remove the Prime"></a>G. Remove the Prime</h2><p>因式分解后，变成简单的取石子游戏。</p>
<p>Pollard-rho分解即可。</p>
<h2 id="H-Excluded-Min"><a href="#H-Excluded-Min" class="headerlink" title="H. Excluded Min"></a>H. Excluded Min</h2><h2 id="I-Trade"><a href="#I-Trade" class="headerlink" title="I. Trade"></a>I. Trade</h2><p>重要性质：$p_i$ 均不一样。</p>
<p>假设要选某些纪念品，那么一定是将这些纪念品的 $p$ 从大到小排序后依次选择。</p>
<p>那么总的和即为 $\sum_{i=1}^kc_i+(i-1)p_i\le k+\sum_{i=1}^k(i-1)(k-i+1)\le O(\frac{k^3}{6})$，那么最多就选 $O((6S)^{\frac{1}{3}})$ 个物品。</p>
<p>排序，暴力DP。</p>
<h2 id="J-Increasing-or-Decreasing"><a href="#J-Increasing-or-Decreasing" class="headerlink" title="J. Increasing or Decreasing"></a>J. Increasing or Decreasing</h2><p>先对整个序列进行一遍从小到大的排序，然后假设前 $i-1$ 个已经找到，找到 $b_i$ 所在位置，然后看是最大值还是最小值。使用 $n-1$ 次，剩下最后一个不用管它。加上先前的整个排序，刚好使用 $n$ 次。</p>
<p>时间复杂度 $O(n^2\log n)$。</p>
<h2 id="L-Extreme-Wealth"><a href="#L-Extreme-Wealth" class="headerlink" title="L. Extreme Wealth"></a>L. Extreme Wealth</h2><p>答案为 $\frac{2^{a+b}}{\binom{a+b}{a}}$，即 $\frac{2^{a+b}a!b!}{(a+b)!}$。</p>
<p>$a,b$ 小的时候随便算，我们只考虑 $a,b$ 很大的情况。</p>
<p>考虑 $a=b$ ，此时阶乘用斯特林公式近似算。得到 $\frac{2^{a+a}a!a!}{(a+a)!}=\sqrt{\pi a}$。</p>
<p>设答案为 $S(a,b)$，考虑从 $S(a,b-1)$ 推导出 $S(a,b)$，其中 $a&lt;b$，有：</p>
<p>$S(a,b)=\frac{2b}{a+b}S(a,b-1)$。</p>
<p>随着 $b$ 越来越大，$\frac{2b}{a+b}$ 越来越接近 $2$，这样很快就可以超出 $10^9$了，暴力模拟即可。</p>
<h2 id="M-Discrete-Logarithm-is-a-Joke"><a href="#M-Discrete-Logarithm-is-a-Joke" class="headerlink" title="M. Discrete Logarithm is a Joke"></a>M. Discrete Logarithm is a Joke</h2><p>签到题。知道了 $a_{10^6}$ 后，倒推即可。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>一些杂题</title>
    <url>/2022/03/04/%E4%B8%80%E4%BA%9B%E6%9D%82%E9%A2%98/</url>
    <content><![CDATA[<p>一些杂题的题解。</p>
<span id="more"></span>



<h2 id="bzoj3457-Ring"><a href="#bzoj3457-Ring" class="headerlink" title="bzoj3457 Ring"></a>bzoj3457 Ring</h2><p>由Polya定理，答案为 $\frac{\sum_{i=1}^nF(\gcd(n,i))}{n}=\frac{\sum_{d|n}\varphi(d)F(\frac{n}{d})}{n}$。其中 $F(m)$ 为长度为 $m$ 的循环项链上含该字符串 $S$ 的方案数。</p>
<p>$F(m)$ 的计算使用容斥，用 $2^m$ 减去不含 $S$ 的方案。设 $f_{i,j}$ 为当前长度为 $i$，匹配到第 $j$ 位的方案数。</p>
<p>假设最后一位填完后，匹配到字符串第 $i$ 位，那么初始条件为 $f_{0,j}=[i==j]$。答案为 $f_{n,i}$。</p>
<p>$f_i$ 转移到 $f_{i+1}$ 相当于乘以一个矩阵 $A$，其系数可用KMP算出。</p>
<p>先算出 $A^m$，然后枚举 $i$，暴力计算即可。</p>
<p>可以通过预处理 $A^{\sqrt{n}i},A^i$ 降低算 $A^m$ 的复杂度。</p>
<p>时间复杂度 $O(d(n)k^3)$。</p>
<h2 id="bzoj2353-矩形压缩"><a href="#bzoj2353-矩形压缩" class="headerlink" title="bzoj2353 矩形压缩"></a>bzoj2353 矩形压缩</h2><p>先离散化。</p>
<p>显然，这些矩形要越小越好，如果 $A$ 包含 $B$，那么选 $B$ 一定更优。</p>
<p>于是只需要考虑如何找到所有的极小的长方形。</p>
<p>哈希，对每个原来的长方形随机一个值，对长方形内部的整点的权值异或上该值。</p>
<p>对于每个点找到四联通内所有权值相同的点，如果形成的形状是个矩形，则说明找到一个。</p>
<p>剩下的是裸的二分图带权匹配。</p>
]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
  </entry>
  <entry>
    <title>USACO 2022 February Contest</title>
    <url>/2022/03/01/USACO-2022-February-Contest/</url>
    <content><![CDATA[<p>USACO 2022 February Contest Silver and Gold.</p>
<span id="more"></span>

<h1 id="Silver"><a href="#Silver" class="headerlink" title="Silver"></a>Silver</h1><h2 id="Problem-1-Redistributing-Gifts"><a href="#Problem-1-Redistributing-Gifts" class="headerlink" title="Problem 1. Redistributing Gifts"></a>Problem 1. Redistributing Gifts</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>Farmer John有 $n$ 只奶牛，$n$ 个礼物，编号均为 $1\sim n$。现在要给每只奶牛分配一个礼物。</p>
<p>每只奶牛都有一个长度为 $n$ 的排列，表示她的愿望清单。其中第 $i$ 个值表示这只奶牛第 $i$ 想要的礼物。</p>
<p>Farmer John很懒，将第 $i$ 个礼物给了第 $i$ 只奶牛。现在奶牛聚在一起重新分配礼物。一个合法的分配当且仅当对于所有的 $i$，第 $i$ 只奶牛有且仅有一个礼物，且这个礼物的在这个奶牛心目中的排名需不低于这只奶牛原来的礼物（即编号为 $i$ 的礼物）的排名。</p>
<p>你需要对于所有的 $i$，求出所有可能的合法分配中，第 $i$ 只奶牛可能分配到的最想要的礼物。</p>
<p>$n\le 500$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们先假设第 $i$ 个礼物给第 $i$ 只奶牛。</p>
<p>暴力枚举 $i,j$，假设第 $i$ 只奶牛想要第 $j$ 个礼物，如何判断是否可行呢？</p>
<p>我们将第 $j$ 个礼物给了 $i$，那么第 $j$ 只奶牛就没礼物了，他需要找另一个合法的礼物 $x_1$；</p>
<p>我们将第 $x_1$ 个礼物给了 $j$，那么第 $x_1$ 只奶牛就没礼物了，他需要找另一个合法的礼物 $x_2$；</p>
<p>这样一直下去，直到某一只奶牛拿回了礼物 $i$。这样就找到了一个满足条件的合法匹配了。</p>
<p>那么我们新建一个图，若奶牛 $i$ 的愿望清单中礼物 $j$ 的排名比礼物 $i$ 优，则 $i$ 向 $j$ 连一条有向边。</p>
<p> 判断奶牛 $i$ 是否能要礼物 $j$ 相当于判断是否存在一条从 $j$ 到 $i$ 的路径。</p>
<p>Floyd传递闭包，时间复杂度 $O(n^3)$。</p>
<p>可以用bitset继续优化，但是没有必要。</p>
<h2 id="Problem-2-Robot-Instructions"><a href="#Problem-2-Robot-Instructions" class="headerlink" title="Problem 2. Robot Instructions"></a>Problem 2. Robot Instructions</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个向量 $(x_i,y_i)$。对于每个 $k$，问你有多少种从 $n$ 个向量中选出 $k$ 个向量的不同方案，使得这 $k$ 的向量的横纵坐标之和等于 $(x_g,y_g)$。</p>
<p>$n\le 40,|x_i|,|y_i|\le 10^9$。</p>
<p>时限4s，空间512MB。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>$n\le 40$，启发我们将向量尽量平均分成两部分。设分为 $[1,t],[t+1,n]$。</p>
<p>对于前面一半，设 $f_{i,P}$ 表示选择 $i$ 个向量后，坐标之和为 $(x_P,y_P)$ 的方案数。</p>
<p>$P$ 最后只有 $2^t$ 种不同的情况，将 $P$ 哈希即可。</p>
<p>对于后面一半，暴力枚举每个向量选择的情况，假设选了 $j$ 个向量，最终前半部分的坐标应为 $Q$（$Q$ 可以通过用终点坐标减去这 $j$ 个向量求出），那么枚举 $i$，将 $i+j$ 的答案加上 $f_{i,Q}$ 即可。</p>
<p>时间复杂度 $O(2^t+2^{n-t}t)$。</p>
<p>取 $t=\frac{n}{2}$ 就可以过了。</p>
<h2 id="Problem-3-Email-Filing"><a href="#Problem-3-Email-Filing" class="headerlink" title="Problem 3. Email Filing"></a>Problem 3. Email Filing</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>Farmer John 要处理邮件。屏幕左侧是 $m$ 个文件夹，他需要将位于屏幕右侧的 $n$ 封邮件归类进左侧的文件夹中，其中，从上往下第 $i$ 封邮件需要进入左侧从上往下第 $f_i$ 个文件夹中。</p>
<p>由于屏幕大小有限，每次只能看到最多 $k$ 个文件夹，$k$ 封邮件。其中 $k\le \min\{n,m\}$。刚开始时，他看到的是编号为 $1\sim k$ 的文件夹和邮件。他需要上下滚动鼠标滚轮，每次滚动会将位于屏幕最上方的文件夹（或邮件）移出屏幕，而屏幕下方的下面第一个文件夹（或邮件）将出现在屏幕最下方。每个邮件移动完后，邮件的图标将消失，同时下一个（如果有的话）标号的邮件将出现在屏幕上。</p>
<p>不幸的是，这个鼠标的滚轮只能往下滚动。唯一能看到还未处理的邮件的方法是滚到最下面后整理完某个屏幕中的邮件，这时上面第一个未处理的将出现在屏幕中。</p>
<p>你需要告诉Farmer John 能否处理完这批邮件。</p>
<p>$n\le 10^5,m\le 10^4$。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>考虑贪心。设 $mx$ 表示 $f_i$ 的最大值，设当前文件夹的区间为 $[now,now+k-1]$。</p>
<p>首先，需要搞清楚的是，$now$ 是不能减小的，也就是左侧只能一直往下。</p>
<p>设当前在屏幕上方的第一个邮件为 $j$，如果 $f_j\in[mx-k+1,mx]$，则可以跳过 $j$，等最后搞。</p>
<p>否则，对于当前的情况，能整理则整理，也就是处理完当前所有满足 $f_k\in[now,now+k-1]$ 的邮件。</p>
<p>若当前没有一个能整理的，设当前显示的邮件中 $f$ 最小的为 $u$，则有三种情况：</p>
<ul>
<li><p>若 $f_u&lt;now$，那就别想了，永远都搞不了这个 $u$。</p>
</li>
<li><p>移动左侧文件夹，直至 $now+k-1=f_u$；如果这时移动，则必须满足剩下的还未处理的邮件的 $f$ 都必须大于新的 $now$（即 $f_u+1-k$），否则：</p>
</li>
<li><p>先不处理，看看后面的情况，也就是将当前最上方的先去掉。</p>
</li>
</ul>
<p>上述过程可以开若干个set去模拟，并用一个vector顺序记录上方还未处理的邮件。</p>
<p>当右侧到达底部时，只需类似上面的方法，判断能否消完即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h1 id="Gold"><a href="#Gold" class="headerlink" title="Gold"></a>Gold</h1><h2 id="Problem-1-Redistributing-Gifts-1"><a href="#Problem-1-Redistributing-Gifts-1" class="headerlink" title="Problem 1. Redistributing Gifts"></a>Problem 1. Redistributing Gifts</h2><p>设 $g(S)$ 表示在 $S$ 中形成一个合法环的方案数。</p>
<p>设 $f(S)$ 表示在 $S$ 中形成若干个合法环的方案数。</p>
<p>答案为 $f(S)\times f(\complement_US)$。</p>
<p>时间复杂度 $O(2^nn^2)$ 或 $O(3^n)$。</p>
<h2 id="Problem-2-Cow-Camp"><a href="#Problem-2-Cow-Camp" class="headerlink" title="Problem 2. Cow Camp"></a>Problem 2. Cow Camp</h2><p>每次出现恰好 $i$ 个的概率 $P(i)=\frac{\binom{n}{i}}{2^n}$。</p>
<p>考虑递推，设 $f_i$ 表示用 $i$ 次的最大期望，</p>
<p>则有：$f_k=\sum_{i=0}^nP(i)\times \max\{i,f_{k-1}\}$。初始条件 $f_0=0$。</p>
<p>记录 $P(i)$ 前缀和 $s_i$，$iP(i)$ 后缀和 $t_i$ 即可 $O(k)$ 解决。</p>
<p>可以发现，这个东西相当于 $f=s_if+t_{i+1}$ 迭代若干遍，其中 $i=\lfloor f\rfloor$。</p>
<p>而 $i$ 最多是 $n$，那么可以二分出最少迭代次数，使得迭代后 $i$ 将会变化。</p>
<p>迭代 $k$ 次后的 $f$ 为 $s^k\times f+\frac{1-s^k}{1-s}\times t$。</p>
<p>二分+快速幂即可。</p>
<p>时间复杂度 $O(n\log^2 k)$。</p>
<h2 id="Problem-3-Moo-Network"><a href="#Problem-3-Moo-Network" class="headerlink" title="Problem 3. Moo Network"></a>Problem 3. Moo Network</h2><p>贪心可知，对于每个纵坐标，一个点只可能往左/右边第一个连边。</p>
<p>剩下的是最小生成树模板。</p>
<p>时间复杂度 $O(m\log m)$，其中 $m=20n$。</p>
]]></content>
  </entry>
  <entry>
    <title>XXI Open Cup named after E.V. Pankratiev. Grand Prix of Krakow</title>
    <url>/2022/02/25/XXI-Open-Cup-named-after-E-V-Pankratiev-Grand-Prix-of-Krakow/</url>
    <content><![CDATA[<p><a href="http://opentrains.snarknews.info/~ejudge/team.cgi?contest_id=010530">比赛链接</a></p>
<span id="more"></span>

<h3 id="B-Almost-Fair-Cake-Cutting"><a href="#B-Almost-Fair-Cake-Cutting" class="headerlink" title="B. (Almost) Fair Cake-Cutting"></a>B. (Almost) Fair Cake-Cutting</h3><p>当 $n\ge 3$ 时，一定是 $100\%$。</p>
<p>接下来只需解决 $n=1$ 和 $n=2$。</p>
<p>可用半平面交或者大力分类讨论解决。</p>
<h3 id="C-Jellyfish"><a href="#C-Jellyfish" class="headerlink" title="C. Jellyfish"></a>C. Jellyfish</h3><p>要使得对于每个集合满足条件，则在两点的所有简单路径中至少有一条中间没选点。</p>
<ul>
<li><p>贪心，选全部数的叶子结点。</p>
</li>
<li><p>或者在环上选一个点，然后选其余树的叶子结点。</p>
</li>
<li><p>或者在环上选两个点，然后选一边的叶子结点。</p>
</li>
<li><p>或者在环上选三个点。</p>
</li>
</ul>
<p>第二种情况会出现当且仅当存在某个环上节点没子树。</p>
<p>第三种情况会出现当且仅当环上存在某相邻两节点均没子树。</p>
<p>这样就好判断多了。</p>
<h3 id="D-Flat-Organization"><a href="#D-Flat-Organization" class="headerlink" title="D. Flat Organization"></a>D. Flat Organization</h3><p>将竞赛图缩点，然后DP即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h3 id="E-Archer-Vlad"><a href="#E-Archer-Vlad" class="headerlink" title="E. Archer Vlad"></a>E. Archer Vlad</h3><p>设 $v_x=v\cos \alpha,v_y=v\sin \alpha$，</p>
<p>则有：$t=\frac{x}{v_x}$。</p>
<p>而：$v_yt-\frac{1}{2}gt^2\geq y$，即 $x\tan \alpha-\frac{g}{2}\frac{x^2}{v^2\cos^2\alpha}\geq y$。</p>
<p>而 $\frac{1}{\cos ^2\alpha}=1+\tan^2 \alpha$。</p>
<p>变成关于 $\tan \alpha$ 的二次不等式。</p>
<p>解 $n$ 个这样的不等式即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="F-A-Very-Different-Word"><a href="#F-A-Very-Different-Word" class="headerlink" title="F. A Very Different Word"></a>F. A Very Different Word</h3><p>每次字典序加一，加 $26$ 次之后一定出现过 $a\sim z$。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="G-Cactus"><a href="#G-Cactus" class="headerlink" title="G. Cactus"></a>G. Cactus</h3><p>每个点最多在一个环上。那么对于每个环，就只有dfs树中最上的那一个点是确定的。</p>
<p>很容易算出一个长度为 $m$ 的环的方案数。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h3 id="I-GCD-vs-XOR"><a href="#I-GCD-vs-XOR" class="headerlink" title="I. GCD vs. XOR"></a>I. GCD vs. XOR</h3><p>不妨设 $a\geq b$，有：$(a,b)=(a,a-b)\le a-b\le a\oplus b$。</p>
<p>若 $(a,b)=a\oplus b$，则 $(a,a-b)=a-b=a\oplus b$。</p>
<p>那么 $a$ 为 $a-b$ 的倍数，$a&amp;b=b$。</p>
<p>设 $a=k(a-b)$，则 $b=\frac{k-1}{k}a$，那么对于每个 $a$，符合条件的 $b$ 的和一定不超过 $n\log n$。</p>
<p>预处理即可。</p>
<h3 id="J-Civilizations"><a href="#J-Civilizations" class="headerlink" title="J. Civilizations"></a>J. Civilizations</h3><p>这样的 $Ax_i+By_i+Cx_iy_i$ 最大值没办法求。</p>
<p>考虑固定一个，发现周长最多是 $O(n^2)$ 级别的。</p>
<p>也就是最多会有 $\sqrt{O(n^2)}=O(n)$ 种不同的周长。</p>
<p>固定其中一个数后，要求 $(B+Cy_i)x_i$ 的最大值。</p>
<p>用set存，分两种情况讨论。</p>
<p>然后存在当前不同的 $l_p$ ，也可以用set存。</p>
<p>枚举即可。</p>
<p>时间复杂度 $O(n^2+qn)$。</p>
<h3 id="K-We-apologize-for-any-inconvenience"><a href="#K-We-apologize-for-any-inconvenience" class="headerlink" title="K. We apologize for any inconvenience"></a>K. We apologize for any inconvenience</h3><p>离线，将删除变成增加。</p>
<p>考虑增加一个点，以这个点为中介点Floyd一遍即可。</p>
<p>时间复杂度 $O((n+k)^3)$。</p>
<h3 id="M-Social-Justice"><a href="#M-Social-Justice" class="headerlink" title="M. Social Justice"></a>M. Social Justice</h3><p>首先求出最大能留下的人数 $mx$。</p>
<p>可以发现，对于一个集合，删掉最小的那个不会更差。</p>
<p>那么枚举最大值后，二分找到最小值。</p>
<p>对于所有的长度为 $mx$ 的合法区间内的人，都是可以留下的。</p>
<p>剩下的需要判断不在这些区间内的人是否可以，那么就是对于前面的每个区间，都去掉最后一个人并加上当前需要判断的那个，然后看是否可行。</p>
<p>但这样时间复杂度高达 $O(n^2)$。</p>
<p>那么只需对于每个区间计算出删掉最后一个人后加进去的那个人的最小权值，然后求后缀最大值即可。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>数学</tag>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 Huawei ICPC Camp</title>
    <url>/2022/02/09/2022-Huawei-ICPC-Camp/</url>
    <content><![CDATA[<p><a href="https://official.contest.yandex.com/icpc-ptz-shanghai-2022/">链接</a></p>
<span id="more"></span>

<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="C-Survey"><a href="#C-Survey" class="headerlink" title="C. Survey"></a>C. Survey</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定 $m$ 块钱，$n$ 个工人，每个工人需要至少给 $x_i$ 块才会工作。</p>
<p>现需要你将 $m$ 块钱分成 $n$ 份，每份可以是实数，然后随机一个排列使钱与工人配对，问最大的期望会工作的工人数。</p>
<p>$n\le 10^3,m\le 5\times 10^3,0\le x_i\le m$，</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>假设这 $n$ 份钱为 $a_1,a_2,\cdots,a_n$，设 $f(a)$ 表示 $x_i\le a$ 的个数。那么期望工作的工人数为 $\sum_{i=1}^n\frac{f(a_i)}{n}=\frac{\sum_{i=1}^nf(a_i)}{n}$。</p>
<p>DP，设 $f_{j,k}$ 表示已经将钱分了 $j$ 份，总钱数为 $k$ 的最大期望。</p>
<p>暴力转移，时间复杂度 $O(nm^2)$。</p>
<p>考虑优化转移。去掉转移时对 $f$ 没有影响的 $a_i$。考虑将 $a_i$ 从大到小排序，我们现在是将钱分了 $j$ 份，总钱数为 $k$ ，也就是说，对于 $j$ 而言，$k=\sum_{l=1}^ja_l\geq j a_j$，即 $a_j\le \frac{k}{j}$。这样就可以有一个天然的调和级数 $\log$ 了。</p>
<p>时间复杂度 $O(nm\log m)$。</p>
<p>比赛的时候想到了要用调和级数，可是脑子短路了觉得不对，最后乱搞才过掉这题。。。</p>
<h3 id="G-Trans"><a href="#G-Trans" class="headerlink" title="G. Trans"></a>G. Trans</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一个数组 $a_0,a_1,\cdots,a_{2^n-1}$，对于每个 $j\in[0,2^n)$，求 $\sum_{i=0}^{2^n-1}(\text{popcount}(i\text{ and }j)\bmod 2)a_i$。</p>
<p>$n\le 20$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>签到题…FWT的意义是 $FWT_a(j)=\sum_{i=0}^{2^{n}-1}(-1)^{\text{popcount}(i\text{ and }j)}a_i$</p>
<p>那么稍作变换就可以了。</p>
<p>时间复杂度 $O(2^nn)$。</p>
<h3 id="H-Blind-Box"><a href="#H-Blind-Box" class="headerlink" title="H. Blind Box"></a>H. Blind Box</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>求 $\frac{\sum_{1\le x_1\le x_2 \le \cdots\le x_n\le m}\prod x_i}{\sum_{1\le x_1\le x_2 \le \cdots\le x_n\le m}1}$。</p>
<p>$n,m\le 10^5$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>分母简单。</p>
<p>打表发现这东西就是第二类斯特林数。。</p>
<p>考虑第二类斯特林数的意义，将 $a$ 个不同的球分到 $b$ 个相同盒子，每个盒子至少一个的方案数。</p>
<p>考虑依次将 $a$ 个小球放进盒子，那么一共有 $a-b$ 个小球放进去的时候是可以选盒子的，第 $i$ 个这样的小球选的盒子个数是当前已经放过小球的盒子个数，记为 $x_i$，那么总方案数就是 $\sum \prod_{i=1}^{a-b} x_i$。</p>
<p>取 $a-b=n,b=m$，答案为 $S_2(n+m,m)$。</p>
<h3 id="I-EIP1559"><a href="#I-EIP1559" class="headerlink" title="I. EIP1559"></a>I. EIP1559</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>对于数对 $(a,b)$，设 $d=\min(a,b+x)$。</p>
<p>$t$ 次操作，每次增加或删除一个数对，或给你一个 $x$，询问当前数对中的 $d$ 的最大值。</p>
<p>$t,a,b,x\le 10^6$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>设 $f(x)=\min(a,b+x)$，则 $f(x)$ 为一个斜向上45度然后平整的分段函数。</p>
<p>将其分成两段处理，一段是平整的，一段最终要 $+x$ 的。然后线段树找前后缀最大值即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="J-Three-Countries"><a href="#J-Three-Countries" class="headerlink" title="J. Three Countries"></a>J. Three Countries</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定三个圆，求这三个圆所形成的凸包。</p>
<p>$T\le 10^4,1\le x,y,r\le 100$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>先求出所有圆圆的切线的切点，对这些切点求凸包后，逆时针统计凸包上相邻的点是否在同一个圆上，如果是，则轮廓为圆；否则轮廓为直线。</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h2><h3 id="A-Attack-Order"><a href="#A-Attack-Order" class="headerlink" title="A. Attack Order"></a>A. Attack Order</h3><p>排序后贪心即可，签到题。</p>
<h3 id="B-Browsing-The-Collection"><a href="#B-Browsing-The-Collection" class="headerlink" title="B. Browsing The Collection"></a>B. Browsing The Collection</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>$n$ 个长度为 $m$ 的数组排成一个环。</p>
<p>你可以增添或删除一个限制条件，形如数组第 $i$ 个数必须为 $v$。</p>
<p>对于当前位置，你有一个限制条件集合，当前位置的数组满足该条件。</p>
<p>每一步，你可以：</p>
<ul>
<li>向环的顺时针方向走到下一个满足当前所有限制的位置上。</li>
<li>向环的逆时针方向走到下一个满足当前所有限制的位置上。</li>
<li>增加一个限制条件。如果增加完后，当前位置满足限制条件集合，则不动，否则移动到顺时针方向第一个满足所有限制的位置上。</li>
<li>删除一个限制条件，不移动。</li>
</ul>
<p>对于所有的数对 $(i,j)$，求出从 $i$ 出发，初始限制条件为空，到 $j$ 的最少步数。</p>
<p>$n\le 500,m\le 5$。</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>$m$ 很少，考虑对于每个位置，开 $2^m$ 个点，第 $i$ 个点表示在该位置上且当前限制条件状态为 $i$ 的最优步数。</p>
<p>$1,2,4$ 很好表示，最麻烦的是 $3$。</p>
<p>没想那么多，直接暴力连边，从每个位置的 $0$ 号点出发 bfs，然后就过了。</p>
<h3 id="C-Casual-Dancers"><a href="#C-Casual-Dancers" class="headerlink" title="C. Casual Dancers"></a>C. Casual Dancers</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>三个人，初始位置为 $x_1,x_2,x_3$。</p>
<p>$k$ 次移动，每次随机选一个人，$p$ 的概率向右，$1-p$ 的概率向左一步。</p>
<p>问 $k$ 次移动后三人中选两人的距离最大值。</p>
<p>$|x_i|\le 10^5,k\le 2\times 10^5$。</p>
<h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>三个人比较难处理，如果换成两个人那就很简单了。</p>
<p>而三个人的距离可以表示为 $\frac{|x_1-x_2|+|x_1-x_3|+|x_2-x_3|}{2}$。</p>
<p>由期望线性性，即可转为两个人。</p>
<p>那么 $p$ 是多少就没有关系了。</p>
<p>假设开始两人距离为 $0$，预处理计算一下走 $k$ 步后两人距离即可。</p>
<h3 id="D-Diameter-Two"><a href="#D-Diameter-Two" class="headerlink" title="D. Diameter Two"></a>D. Diameter Two</h3><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>构造一个 $n$ 个点的无重边连通图，其中前 $k$ 个点度数为 $1$，后 $n-k$ 个点度数 $\geq 2$，边数最少，且两点最远距离不超过 $2$。</p>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><p>首先，$n=k,n=k-2$ 不行。</p>
<ul>
<li>$k\neq 0$</li>
</ul>
<p>贪心，可知这 $k$ 个点一定都与一个点相连，不妨设为 $k+1$。</p>
<p>那之后为了满足直径不超过 $2$，剩下的点都要和 $k+1$ 连。</p>
<p>为了满足度数 $\geq 2$，剩下的点两两连一条边。</p>
<ul>
<li>$k=0$</li>
</ul>
<p>类似 $k\neq 0$ 的构造，但是 $n=4,5,6$ 时需要特判。</p>
<p>（不会证明为什么 $n&gt;6$ 之后就可以）</p>
<h3 id="G-Gross-LCS"><a href="#G-Gross-LCS" class="headerlink" title="G. Gross LCS"></a>G. Gross LCS</h3><h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>给定序列 $a,b$。定义 $a+x$ 为序列 $a$ 整体加上 $x$。</p>
<p>问 $\sum_{x=-10^{100}}^{10^{100}}LCS(a+x,b)$。</p>
<p>$n,m\le 3000$。</p>
<p>空间限制32MB，时限10s。</p>
<h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><p>首先，有一个奇怪的LCS转成LIS的算法：</p>
<p>将 $a_i$ 一个数换成 $a_i$ 在数组 $b$ 中出现的位置从大到小形成的数组，形成一个新的数列 $c$。对这个数列求LIS就是LCS的长度。</p>
<p>这个算法的复杂度是 $O(m\log n)$ 的，其中 $m=\sum_{x} (\sum[a_i=x])(\sum [b_i=x])$。</p>
<p>回到题目中，假设枚举 $a_i$ 与 $b_j$ 是相配对的，那么 $x=b_j-a_i$。如果能对于每个 $x$，知道哪些 $a_i,b_j$ 是有用的，求这些有用的LCS，用上面的做法，即可做到 $O(n^2\log n)$ 的复杂度。</p>
<p>剩下的问题是，如何做到 $O(n)$ 的空间复杂度。</p>
<p>将 $b$ 数组从小到大排序的数组称为 $b’$。考虑 $x$ 从小到大变化，对于每个 $a_i$，与之配对过的 $b_j$ 在 $b’$ 中是一段前缀。对于每个 $a_i$ ，记录在 $b’$ 中这段前缀的终点，用一个堆来求出当前有用的 $x$ 的最小值即可。</p>
<p>时间复杂度 $O(n^2\log n)$。</p>
<h3 id="H-Junk-or-Joy"><a href="#H-Junk-or-Joy" class="headerlink" title="H. Junk or Joy"></a>H. Junk or Joy</h3><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>$T$ 组询问，每次给定 $k$，问满足 $n^2-k\times p^m=1$ 的 $(n,p,m)$ 三元组的方案数。其中 $p$ 为质数。</p>
<p>$T\le 100,k\le 10^9$</p>
<h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><p>移项，因式分解得：$(n-1)(n+1)=k\times p^m$，</p>
<ul>
<li>$p\neq 2$，设 $k=k_0\times p^t$，则 $n-1,n+1$ 中最多有一个是 $p$ 的倍数。不妨设是 $n-1$，则 $n-1=x\times p^{t+m},n+1=\frac{k_0}{x}$，随便做。</li>
<li>$p\geq 2$，则 $(n-1),(n+1)$ 中的一个的 $2$ 次幂至多为 $1$。设 $k=k_0\times 2^t$，不妨设 $(n-1)=2\times x$，其中 $x$ 为奇数，则 $n+1=2(x+1)$，即 $x(x+1)=k\times 2^{m-2}=k_0\times 2^{t+m-2}$。分解 $k_0$ 质因数即可。 </li>
</ul>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Global Round 14[CF1515]</title>
    <url>/2021/12/19/Codeforces-Global-Round-14-CF1515/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/contest/1515/problems">CF</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-Phoenix-and-Gold"><a href="#A-Phoenix-and-Gold" class="headerlink" title="A. Phoenix and Gold"></a>A. Phoenix and Gold</h3><p>因为每个数不相等，从小到大排序，遇到相等的，看是否能和后面的交换。不能交换则一定不行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> n,x,a[<span class="number">29349</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=a[i];</span><br><span class="line">		<span class="keyword">if</span>(sum==x) &#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;x)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp+=a[i];</span><br><span class="line">				<span class="keyword">if</span>(tmp==x) &#123;<span class="built_in">swap</span>(a[i],a[i+<span class="number">1</span>]); <span class="keyword">break</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i]); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-Phoenix-and-Puzzle"><a href="#B-Phoenix-and-Puzzle" class="headerlink" title="B. Phoenix and Puzzle"></a>B. Phoenix and Puzzle</h3><p>考虑直角边和斜边形成的正方形，即假设其直角边长为 $1$，则正方形个数 $n$ 要满足：</p>
<p>$\frac{n}{2}=x^2$ 或 $\frac{n}{2}=(\sqrt{2}x)^2$。</p>
<p>随便判断。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=<span class="built_in">sqrt</span>(x);</span><br><span class="line">	<span class="keyword">return</span> y*y==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;<span class="built_in">check</span>(n/<span class="number">2</span>)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;<span class="built_in">check</span>(n/<span class="number">4</span>)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Phoenix-and-Towers"><a href="#C-Phoenix-and-Towers" class="headerlink" title="C. Phoenix and Towers"></a>C. Phoenix and Towers</h3><p>由于 $1\le h_i\le x$，那么每次选当前最小的塔就可以保证他们的差不超过 $x$ 了。</p>
<p>用一个堆维护即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id; ll x;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.x==B.x?A.id&lt;B.id:A.x&gt;B.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> n,m,x,ans[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) q.<span class="built_in">push</span>((node)&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>();</span><br><span class="line">			node now=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			ans[i]=now.id;</span><br><span class="line">			now.x+=x;</span><br><span class="line">			q.<span class="built_in">push</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) q.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-Phoenix-and-Socks"><a href="#D-Phoenix-and-Socks" class="headerlink" title="D. Phoenix and Socks"></a>D. Phoenix and Socks</h3><p>显然，相同颜色的先进行配对。</p>
<p>接下来，不妨设配对完后剩下的左袜子比较多。</p>
<p>那么就先用左袜子变成右袜子与相同颜色的配对。注意不能使左袜子比右袜子少了。</p>
<p>剩下的随便做。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line"><span class="type">int</span> le[N],ri[N],a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); l=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) le[i]=ri[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,l) le[a[i]=<span class="built_in">read</span>()]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,r) ri[a[i+l]=<span class="built_in">read</span>()]++;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=<span class="built_in">min</span>(le[i],ri[i]);</span><br><span class="line">			le[i]-=tmp; ri[i]-=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t1+=le[i],t2+=ri[i];</span><br><span class="line">		<span class="keyword">if</span>(t1&gt;=t2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,l)</span><br><span class="line">				<span class="keyword">if</span>(le[a[i]]&gt;=<span class="number">2</span>&amp;&amp;t1&gt;t2)</span><br><span class="line">				&#123;</span><br><span class="line">					le[a[i]]-=<span class="number">2</span>;</span><br><span class="line">					ans++;</span><br><span class="line">					t1-=<span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			ans+=(t1-t2)/<span class="number">2</span>+(t1+t2)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(i,l+<span class="number">1</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(ri[a[i]]&gt;=<span class="number">2</span>&amp;&amp;t2&gt;t1)</span><br><span class="line">				&#123;</span><br><span class="line">					ri[a[i]]-=<span class="number">2</span>;</span><br><span class="line">					ans++;</span><br><span class="line">					t2-=<span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			ans+=(t2-t1)/<span class="number">2</span>+(t1+t2)/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-Phoenix-and-Computers"><a href="#E-Phoenix-and-Computers" class="headerlink" title="E. Phoenix and Computers"></a>E. Phoenix and Computers</h3><p>这个连续段DP的思路有点妙。</p>
<p>我们设 $f_{i,j}$ 表示已经填了 $i$ 个数，且共有 $j$ 段距离&gt;1的连续段，<strong>每相邻两段的距离不确定</strong>时的方案数。</p>
<p>转移分5种情况讨论即可。很好写。</p>
<p>时间复杂度 $O(n^2)$。</p>
<p>也可以像题解那样，算出不自动打开的方案数，然后设 $f_{i,j}$ 为打开前 $i$ 个数，且自动打开 $j$ 个的方案数。但这样的复杂度就是 $O(n^3)$ 的了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x+=y; x=(x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"></span><br><span class="line">ll f[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); mod=<span class="built_in">read</span>();</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	ll tmp;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp=f[i][j];</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>+<span class="number">2</span>*j&lt;=n) <span class="built_in">add</span>(f[i+<span class="number">1</span>][j+<span class="number">1</span>],tmp*(j+<span class="number">1</span>)%mod);</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">1</span>+<span class="number">2</span>*(j<span class="number">-1</span>)&lt;=n) <span class="built_in">add</span>(f[i+<span class="number">1</span>][j],tmp*<span class="number">2</span>*j%mod);</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">2</span>+<span class="number">2</span>*(j<span class="number">-1</span>)&lt;=n) <span class="built_in">add</span>(f[i+<span class="number">2</span>][j],tmp*<span class="number">2</span>*j%mod);</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=<span class="number">2</span>&amp;&amp;i+<span class="number">2</span>+<span class="number">2</span>*(j<span class="number">-2</span>)&lt;=n) <span class="built_in">add</span>(f[i+<span class="number">2</span>][j<span class="number">-1</span>],tmp*<span class="number">2</span>*(j<span class="number">-1</span>)%mod);</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=<span class="number">2</span>&amp;&amp;i+<span class="number">3</span>+<span class="number">2</span>*(j<span class="number">-2</span>)&lt;=n) <span class="built_in">add</span>(f[i+<span class="number">3</span>][j<span class="number">-1</span>],tmp*(j<span class="number">-1</span>)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-Phoenix-and-Earthquake"><a href="#F-Phoenix-and-Earthquake" class="headerlink" title="F. Phoenix and Earthquake"></a>F. Phoenix and Earthquake</h3><p>有一个十分牛逼的性质：任意一棵生成树，若 $\sum_{i=1}^na_i\geq (n-1)x$，那么一定可以。</p>
<p>考虑构造，对于某个子树 $u$ 以及其儿子 $v$，如果 $a_u+a_v&gt;x$，那么直接操作。否则等后面再操作。若 $a_u+a_v\le x$，那么 $a_v\le x$，那么 $\sum_{i=1}^na_i-a_v\geq (n-2)x$，据归纳法可知，删掉 $v$ 以后还存在一个解。</p>
<p>然后一个dfs就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="type">int</span> n,m,x,ans[N],l,r;</span><br><span class="line"><span class="type">int</span> ver[N],head[N],val[N],ne[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u,val[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!pre) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[u]&gt;=x)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[++l]=now;</span><br><span class="line">		a[pre]+=a[u]-x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ans[r--]=now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">	sum=<span class="number">-1ll</span>*(n<span class="number">-1</span>)*x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),sum+=a[i];</span><br><span class="line">	<span class="keyword">if</span>(sum&lt;<span class="number">0</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>(),i);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	l=<span class="number">0</span>; r=n<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-Phoenix-and-Odometers"><a href="#G-Phoenix-and-Odometers" class="headerlink" title="G. Phoenix and Odometers"></a>G. Phoenix and Odometers</h3><p>显然，$a$ 能走的点必在 $a$ 在内的强联通分量里。</p>
<p>而如果存在从 $u$ 走到 $v$ 的距离为 $l\pmod p$ 的路径，那么必存在 $v$ 到 $u$ 的距离为 $-l\pmod p$ 的路径，因为存在经过 $u,v$ 的环，从 $v$ 开始走这个环 $p-1$ 次，再走到 $u$ ，就可以了。</p>
<p>而显然，如果有两个环，环长分别为 $a,b$，那么 $\gcd(a,b)$ 能走出来。</p>
<p>那么算出来 $a$ 所在强联通分量所有环的环长的 $\gcd$ 即可。</p>
<p>在Kosaraju过程中，记录点到根节点距离，可以算出来。</p>
<p>时间复杂度 $O(n\log m)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> y,v;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; adj[N],adk[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dfn;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="type">int</span> bel[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[e.y])</span><br><span class="line">			<span class="built_in">dfs1</span>(e.y,u);</span><br><span class="line">	dfn.<span class="built_in">pb</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> e:adk[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[e.y])</span><br><span class="line">		&#123;</span><br><span class="line">			f[e.y]=f[u]+e.v;</span><br><span class="line">			bel[e.y]=bel[u];</span><br><span class="line">			<span class="built_in">dfs2</span>(e.y,u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(bel[e.y]==bel[u])</span><br><span class="line">			g[bel[u]]=__gcd(g[bel[u]],f[u]+e.v-f[e.y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); z=<span class="built_in">read</span>();</span><br><span class="line">		adj[x].<span class="built_in">pb</span>((edge)&#123;y,z&#125;);</span><br><span class="line">		adk[y].<span class="built_in">pb</span>((edge)&#123;x,z&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs1</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(dfn));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:dfn)</span><br><span class="line">	<span class="keyword">if</span>(!vis[i])</span><br><span class="line">	&#123;</span><br><span class="line">		bel[i]=++cnt;</span><br><span class="line">		<span class="built_in">dfs2</span>(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ll a,s,x;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		a=bel[<span class="built_in">read</span>()]; s=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">		s=(x-s)%x;</span><br><span class="line">		x=__gcd(x,g[a]);</span><br><span class="line">		<span class="built_in">puts</span>((s%x==<span class="number">0</span>)?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="H-Phoenix-and-Bits"><a href="#H-Phoenix-and-Bits" class="headerlink" title="H. Phoenix and Bits"></a>H. Phoenix and Bits</h3><p>And操作可以看做是Xor和Or操作的结合。于是我们只需要考虑Xor和Or操作即可。</p>
<p>Xor操作直接在Trie里打标记。</p>
<p>Or操作发现有时候会合并一些节点的左右儿子，有时候相当于打Xor标记。并且，合并左右儿子的时间复杂度不超过 $log^2n$ 。</p>
<p>如何判断什么时候打Xor标记呢？当且仅当Or操作中的数只存在某些位置为 $1$，且该节点中的数在这一位上均为 $0$。</p>
<p>那么记一下节点内所有值的Or，以及取反后的Or就好了。</p>
<p>对于区间操作，我们可以类似平衡树和线段树分裂的操作就可以了。</p>
<p>时间复杂度 $O(n\log^2m)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1.3e7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> W=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> ch[M][<span class="number">2</span>],s[M],ta[M],to[M],tx[M],rt,cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	s[u]=s[ch[u][<span class="number">0</span>]]+s[ch[u][<span class="number">1</span>]];</span><br><span class="line">	ta[u]=ta[ch[u][<span class="number">0</span>]]|ta[ch[u][<span class="number">1</span>]];</span><br><span class="line">	to[u]=to[ch[u][<span class="number">0</span>]]|to[ch[u][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushxor</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>((t&gt;&gt;dep)&amp;<span class="number">1</span>) <span class="built_in">swap</span>(ch[u][<span class="number">0</span>],ch[u][<span class="number">1</span>]);</span><br><span class="line">	tx[u]^=t;</span><br><span class="line">	<span class="type">int</span> tta=ta[u],tto=to[u];</span><br><span class="line">	to[u]=(tto&amp;(W^t))|(tta&amp;t);</span><br><span class="line">	ta[u]=(tta&amp;(W^t))|(tto&amp;t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u||!tx[u]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">pushxor</span>(ch[u][<span class="number">0</span>],dep<span class="number">-1</span>,tx[u]);</span><br><span class="line">	<span class="built_in">pushxor</span>(ch[u][<span class="number">1</span>],dep<span class="number">-1</span>,tx[u]);</span><br><span class="line">	tx[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> dep,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) u=++cnt;</span><br><span class="line">	<span class="keyword">if</span>(dep&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s[u]=<span class="number">1</span>;</span><br><span class="line">		tx[u]=<span class="number">0</span>;</span><br><span class="line">		to[u]=t;</span><br><span class="line">		ta[u]=W^t;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> c=(t&gt;&gt;dep)&amp;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ins</span>(ch[u][c],dep<span class="number">-1</span>,t);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> dep,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||R&lt;l||r&lt;L) &#123;y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;y=x; x=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(x,dep);</span><br><span class="line">	y=++cnt;</span><br><span class="line">	<span class="built_in">split</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],dep<span class="number">-1</span>,l,mid,L,R);</span><br><span class="line">	<span class="built_in">split</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],dep<span class="number">-1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	<span class="built_in">pushup</span>(x); <span class="built_in">pushup</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">	<span class="built_in">pushdown</span>(x,dep);<span class="built_in">pushdown</span>(y,dep);</span><br><span class="line">	ch[x][<span class="number">0</span>]=<span class="built_in">merge</span>(ch[x][<span class="number">0</span>],ch[y][<span class="number">0</span>],dep<span class="number">-1</span>);</span><br><span class="line">	ch[x][<span class="number">1</span>]=<span class="built_in">merge</span>(ch[x][<span class="number">1</span>],ch[y][<span class="number">1</span>],dep<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">pushup</span>(x);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dep,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> tmp=t&amp;ta[u];</span><br><span class="line">	<span class="keyword">if</span>((tmp&amp;to[u])==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushxor</span>(u,dep,tmp);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(u,dep);</span><br><span class="line">	<span class="keyword">if</span>((t&gt;&gt;dep)&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushxor</span>(ch[u][<span class="number">0</span>],dep<span class="number">-1</span>,(<span class="number">1</span>&lt;&lt;dep));</span><br><span class="line">		ch[u][<span class="number">1</span>]=<span class="built_in">merge</span>(ch[u][<span class="number">0</span>],ch[u][<span class="number">1</span>],dep<span class="number">-1</span>);</span><br><span class="line">		ch[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">update</span>(ch[u][<span class="number">0</span>],dep<span class="number">-1</span>,t);</span><br><span class="line">	<span class="built_in">update</span>(ch[u][<span class="number">1</span>],dep<span class="number">-1</span>,t);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">ins</span>(rt,<span class="number">19</span>,<span class="built_in">read</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> opt,l,r,x,k;q--;)</span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">read</span>(); l=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">		k=<span class="number">0</span>; <span class="built_in">split</span>(rt,k,<span class="number">19</span>,<span class="number">0</span>,W,l,r);</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(opt==<span class="number">3</span>) <span class="built_in">pushxor</span>(k,<span class="number">19</span>,x);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) <span class="built_in">update</span>(k,<span class="number">19</span>,x);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				x^=W;</span><br><span class="line">				<span class="built_in">pushxor</span>(k,<span class="number">19</span>,W);</span><br><span class="line">				<span class="built_in">update</span>(k,<span class="number">19</span>,x);</span><br><span class="line">				<span class="built_in">pushxor</span>(k,<span class="number">19</span>,W);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rt=<span class="built_in">merge</span>(rt,k,<span class="number">19</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>Trie</tag>
        <tag>数论</tag>
        <tag>堆</tag>
        <tag>连续段DP</tag>
        <tag>强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 ICPC 南京站</title>
    <url>/2021/12/05/2021-ICPC-%E5%8D%97%E4%BA%AC%E7%AB%99/</url>
    <content><![CDATA[<p>2021ICPC<del>南京</del>难金站。</p>
<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><span id="more"></span>

<h2 id="游记？"><a href="#游记？" class="headerlink" title="游记？"></a>游记？</h2><p>能在难金站拿金还是很满意啦。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>看了眼知乎，发现原来自己碰上了诸神黄昏。。</p>
<p>考了习思想，啥都不会。</p>
<p>睡不着。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>两点钟才睡着，然后一直半睡半醒的状态到7点半。</p>
<p>起来后，室内体测，胖了好多，坐位体前屈都压不下去了。。</p>
<p>回宿舍瘫到9点45，然后去吃早餐。</p>
<p>11点比赛。</p>
<p>meaningful上来就发现A是签到，然后靠着巨快的手速拿到一血。</p>
<p>接着我简单告诉了meaningful M题题意，然后去看其他题。CRH380BL-2339一直在想D。期间发现J看来十分好做。</p>
<p>然后meaningful就会M了，我想了想后也会了。15min的时候交了1发然后WA。然后我突然想到 $n=1$ 要特判，加了以后就过了。</p>
<p>然后meaningful就把C秒了，我写了个线性最大子段和顺利的1A了。</p>
<p>接着开始写J，我天真的写了个dfs，结果十分显然的T了。</p>
<p>接着换CRH380BL-2339上，但是有点想错了，导致一直WA。而我在旁边想了好一会儿四元环计数发现不太会容斥，然后跃跃欲试想要把J加一个记忆化，以及和他们一起思考D题，结果发现完全帮不上忙。</p>
<p>最终J加了个记忆化立刻就过了，然后meaningful写了个H也1A了。</p>
<p>然后他们继续想D，我去退了一下E题的式子。</p>
<p>很快发现E题只需要维护前缀平方和的历史和，前缀平方和，前缀和等等的值就可以了，然后分类讨论画了三种情况，写了三个 $5\times 5$ 的矩阵就会了。</p>
<p>在我边打E的时候，D题也快有结果了。打到一半，D题改了一个位置就过了。E连着MLE两发，发现是5e4给我写成了5e5。。改了之后发现TLE了。</p>
<p>然后就疯狂的卡常时间，卡了好久，在meaningful的强烈建议下造了个极限数据，发现本地要跑8s…并不是很会优化复杂度。结果CRH380BL-2339一语惊醒梦中人，将矩阵乘法里遇到0就不乘法的优化加了上去就A了。</p>
<p>在全队的注视下meaningful很快写完了I，调了一会儿直接1A。</p>
<p>此时是286分钟，发现我们已经稳Au了，然后就再次开始了愉快的评价题目环节。</p>
<p>出来以后发现是Rank14，本赛季打得最好的一次。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>分四种情况讨论即可。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>设 $s_{l,r}(x)$ 表示 $x$ 在 $[l,r]$ 的出现次数。那么就是枚举 $x$，然后选择一段区间，使得 $s_{1,n}(x)+(s_{l,r}(x-k)-s_{l,r}(x))$ 最大。</p>
<p>记 $s_i=[a_i=x-k]-[a_i=x]$，然后分开跑最大子段和。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>考虑进行完第 $i$ 轮操作之后，前面 $[1,i]$ 已经有序了。那么几乎所有的位置的贡献就是前面比他大的数有多少个，剩下的贡献有两次，最大的一次。</p>
<p>按照这个情况分类讨论就好了，有亿点细节。时间复杂度 $O(n\log n)$。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>比赛时做法：维护前缀平方和的历史和，前缀平方和，前缀和等等的值就可以了，然后分类讨论，写三个 $5\times 5$ 的矩阵。</p>
<p>不用前缀和去做会方便很多，矩阵非常好看，还只用 $4\times 4$ 的矩阵。</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>简单树形DP，维护一下两种转移。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>队友做的，回去了看一下，真的好简单啊，这榜也太歪了。。</p>
<p>从后往前DP一下，遇到一个转折点分两种情况都取其最大值就好了。</p>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>发现只用前两种操作，那么 $a-b$ 的值不变；用第三种的话，$a-b$ 除以一个质数 $p$。</p>
<p>那么最后 $a-b$ 变到 $1$，答案就出来了。因此，直接记 $f(a,b)$ 表示 $(a,b)$ 到最终结果的最小步数。</p>
<p><strong>有这么一个性质：对于一个数 $x$，有若干整数 $a_1,a_2,\cdots,a_n$，用不同的顺序，不管上取整还是下取整去除 $x$，最终结果最多只有两种。</strong></p>
<p>那这样对于某个特定的 $a-b$ 的因子 $d$ 而言，满足条件的 $(a,b)$ 最多只有几种，因此有用的 $f(a,b)$ 的个数为 $O(d(a-b))$。直接上记忆化就好了。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>当 $n\geq 2$ 时，相当于给每个数选一个加还是减，至少有一个减，一个加。</p>
<p>当 $n=1$ 时，特判一下。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>思维题</tag>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 ICPC 上海站</title>
    <url>/2021/12/02/2021-ICPC-%E4%B8%8A%E6%B5%B7%E7%AB%99/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/103446/problems">链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="B-Strange-Permutations"><a href="#B-Strange-Permutations" class="headerlink" title="B. Strange Permutations"></a>B. Strange Permutations</h3><p>一个长度为 $n$ 的置换形成了若干个有向环，那么在上面填排列后，环中边上相邻的点的数不能为 $i-&gt;i+1$。</p>
<p>直接枚举比较难，考虑容斥，记 $f(k)$ 表示选择了 $k$ 条边，使得每条边都满足 $i-&gt;i+1$ 的方案数，那么剩下 $n-k$ 个可以随便选，也就是 $(n-k)!$，答案就是 $\sum_{i=0}^n(-1)^if(i)(n-i)!$。</p>
<p>考虑 $f(i)$ 的求法，注意到一个整环不可能把所有边都选上以外，其他都可以。那么答案就是 $[x^i]\sum ((x+1)^{k_i}-x^{k_i})$。</p>
<p>分治FFT即可。</p>
<h3 id="C-Strange-Matrices"><a href="#C-Strange-Matrices" class="headerlink" title="C. Strange Matrices"></a>C. Strange Matrices</h3><p>$n,m\le 8$，考虑轮廓线DP，对于每个点，会有三种状态：什么事都没有的，需要这一行给它的，需要同一列中的下面点给它的。那么DP时记录一下本行当前的状态，以及当前 $m$ 个数的状态就可以了。</p>
<p>时间复杂度 $O(nm3^{10})$。</p>
<h3 id="D-Strange-Fractions"><a href="#D-Strange-Fractions" class="headerlink" title="D. Strange Fractions"></a>D. Strange Fractions</h3><p>可以发现，若 $(a,b)=1$，则 $(a^2+b^2,ab)=1$。那么 $p=a^2+b^2,q=ab$。随便做。</p>
<p>证明：$(a,b)=1$，则 $(a+b,a)=(a+b,b)=1$，则 $(a+b,ab)=1$，则 $(a^2+b^2,ab)=((a+b)^2,ab)=1$。</p>
<h3 id="E-Strange-Integers"><a href="#E-Strange-Integers" class="headerlink" title="E. Strange Integers"></a>E. Strange Integers</h3><p>排序以后贪心即可。</p>
<h3 id="G-Edge-Groups"><a href="#G-Edge-Groups" class="headerlink" title="G. Edge Groups"></a>G. Edge Groups</h3><p>简单树形DP。</p>
<h3 id="H-Life-is-a-Game"><a href="#H-Life-is-a-Game" class="headerlink" title="H. Life is a Game"></a>H. Life is a Game</h3><p>Kruskal重构树+树上倍增。</p>
<h3 id="I-Steadily-Growing-Steam"><a href="#I-Steadily-Growing-Steam" class="headerlink" title="I. Steadily Growing Steam"></a>I. Steadily Growing Steam</h3><p>简单DP，设 $f_{i,j,k}$ 表示处理到第 $i$ 个时，用了 $j$ 次，差值为 $k$ 的最大值。</p>
<h3 id="J-Two-Binary-Strings-Problem"><a href="#J-Two-Binary-Strings-Problem" class="headerlink" title="J. Two Binary Strings Problem"></a>J. Two Binary Strings Problem</h3><p>记 $s_i$ 表示前缀和，$f(l,r)=1$ 当且仅当 $2s_r-r&gt;2s_{l-1}-(l-1)$。</p>
<p>记 $t_i=2s_i-i$，按照 $t_i$ 排序，从小到大枚举，每次用bitset处理一下即可。</p>
<p>注意 $t_i=0$ 时的特判。</p>
<h3 id="K-Circle-of-Life"><a href="#K-Circle-of-Life" class="headerlink" title="K. Circle of Life"></a>K. Circle of Life</h3><p>打表找规律题。</p>
<h3 id="M-Harmony-in-Harmony"><a href="#M-Harmony-in-Harmony" class="headerlink" title="M. Harmony in Harmony"></a>M. Harmony in Harmony</h3><p>神仙结论题，不太会…</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>容斥原理</tag>
        <tag>数论</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 ICPC 沈阳站</title>
    <url>/2021/11/27/2021-ICPC-%E6%B2%88%E9%98%B3%E7%AB%99/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/gym/103427/problems">题目链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>枚举每一个位，枚举每个连通块对应选的是什么时最优，求个和即可。在枚举时可判断是否合法。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>签到题。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>暴力即可。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>线图上的图匹配相当于原图中相邻两边的匹配。</p>
<p>性质一：一个有偶数条边的树可以匹配完。</p>
<p>证明：从最深叶子结点选择两条边，变成一个子问题。</p>
<p>性质二：一个有偶数条边的连通图可以完全匹配。</p>
<p>证明：相当于dfs树中加上若干条返祖边，在叶子结点选边匹配的时候优先选返祖边即可。</p>
<p>那么只剩下边为奇数的情况。显然如果删掉某条边后不改变图连通性，那么就可以删掉该边，否则该边为割边，删掉后需要满足两边边数均为偶数即可。这些均可在求割边时找出。</p>
<p>时间复杂度 $O(n+m)$。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>将 $a,b,c,d$ 视为未知数。四个 $az_i+b=w_i(cz_i+d)$ 转换为线性齐次方程组。</p>
<p>由克拉默法则： $a,b,c,d$ 有非零解当且仅当：</p>
<p>$$\begin{vmatrix}<br>z_1 &amp; 1 &amp; w_1z_1 &amp; w_1\\<br>z_2 &amp; 1 &amp; w_2z_2 &amp; w_2\\<br>z_3 &amp; 1 &amp; w_3z_3 &amp; w_3\\<br>z_0 &amp; 1 &amp; f(z_0)z_0 &amp; f(z_0)<br>\end{vmatrix}= 0$$</p>
<p>直接解出 $f(z_0)$ 即可。</p>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>将询问的两个数的每一位的差算出来，组成一个新的数 $x$。</p>
<p>然后预处理出 $0$ 到 $x$ 的距离即可。</p>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>设假设树上至少有 $i$ 对节点选择了的方案数为 $f(i)$，那么答案为 $\sum_{i=0}^n(-1)^if(i)\frac{(2(n-i))!}{(n-i)!2^{n-i}}$。 </p>
<p>求 $f(i)$ 用树形背包即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><p>对反串建立SAM，对parent-tree中每个节点的边按字典序进行排序以后，相当于求一个前缀最大值。</p>
<p>时间复杂度 $O(n\sum)$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>容斥原理</tag>
        <tag>双连通分量</tag>
        <tag>SAM</tag>
        <tag>模拟</tag>
        <tag>状压DP</tag>
        <tag>线性代数</tag>
        <tag>bfs</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 CCPC 威海站</title>
    <url>/2021/11/21/2021-CCPC-%E5%A8%81%E6%B5%B7%E7%AB%99/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/gym/103428/problems">链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-Goodbye-Ziyin"><a href="#A-Goodbye-Ziyin" class="headerlink" title="A. Goodbye, Ziyin!"></a>A. Goodbye, Ziyin!</h3><p>签到题，二叉树必须满足每个点的度数 $\le 3$，且根节点度数 $\le 2$，判断一下即可。</p>
<h3 id="C-Assign-or-Multiply"><a href="#C-Assign-or-Multiply" class="headerlink" title="C. Assign or Multiply"></a>C. Assign or Multiply</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定 $m$ 个操作，每个操作形如给 $x$ 赋值给 $a_i$，或给 $x$ 乘上 $a_i$。</p>
<p>任意安排这些操作的顺序，问有多少个 $i$ 满足 $i\in[0,p-1]$ 使得不存在某种操作顺序，使 $x\bmod p$ 最终值为 $i$。</p>
<p>$x$ 的初始值为 $1$。</p>
<p>$m\le10^6,3\le p\le 2\times 10^5,p\in \mathbb{P}$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>因为有赋值操作，那么相当于在赋值操作中选择一个，然后在乘法操作中选择若干个，问最后的值可以是多少。（注意，如果没有赋值操作，那么直接输出 $p-1$。）</p>
<p>由于 $p$ 为奇质数，我们求出它的原根 $g$，将乘法转化为加法。</p>
<p>考场中想到用bitset，但是应该是过不了的。</p>
<p>考虑每次操作，相当于找到所有 $bit_i=1,bit_{(i+x)\bmod p}=0$ 的 $i$，并把 $bit_{(i+x)\bmod p}$ 设为 $1$。</p>
<p>考虑 $i$ 向 $(i+x)\bmod p$ 连边，这样就形成了若干个环，环中 $1-&gt;0$ 和 $0-&gt;1$ 的个数显然是相等的。也就是说，如果能快速找到所有的 $bit_i\neq bit_{(i+x)\bmod p}$ 就可以了。</p>
<p>从小到大枚举，二分+树状数组找到第一个 $i$ 即可，此处可以用哈希判断一下。</p>
<p>时间复杂度 $O(n\log ^2q)$。</p>
<h3 id="D-Period"><a href="#D-Period" class="headerlink" title="D. Period"></a>D. Period</h3><p>周期与border是等价的，枚举原串的border，假设长度为 $i$，那么 $[i+1,n-i]$ 中都可以产生 $1$ 的贡献。</p>
<p>kmp，然后差分一下即可。</p>
<h3 id="E-CHASE"><a href="#E-CHASE" class="headerlink" title="E. CHASE!"></a>E. CHASE!</h3><p>设 $f_i$ 表示最多选择  $i$ 次的期望。</p>
<p>设当且选出来的和为 $X$，若 $X\geq f_{i-1}$ 时不重新选，否则重新选。</p>
<p>则有：$f_i=E(X&gt;\lfloor f_{i-1}\rfloor)+f_{i-1}P(X\le \lfloor f_{i-1}\rfloor )$</p>
<p>计算 $E,P$ 可用ntt预处理，也可暴力two-pointer计算。</p>
<h3 id="F-Stone"><a href="#F-Stone" class="headerlink" title="F. Stone"></a>F. Stone</h3><p>神仙题。</p>
<p>考虑如果出现了奇数，那么先手将 $s$ 取奇数，将所有的奇数变成偶数。这样就赢了，且赢的方案数为(最小的奇数+1)/2。</p>
<p>否则，如果全是偶数，且 $s$ 为奇数，那么先手必败。因此 $s$ 必须为偶数，那么 $a_i$ 全都除去 $2$，就又变回来原来的问题了。</p>
<h3 id="G-Desserts"><a href="#G-Desserts" class="headerlink" title="G. Desserts"></a>G. Desserts</h3><p>就因为在这道题上自己的失误错失Au…</p>
<p>给定 $n$ 个数 $a_i$，满足 $\sum_{i=1}^na_i\le 10^5$。记 $f(x)=\prod_{i=1}^n\binom{a_i}{x}$，对于 $i\in [1,m]$，求 $f(i)$。</p>
<p>一开始就直接开始莽多点求值，结果发现旁边的人过了才反应过来。</p>
<p>分块，对于小于等于 $\sqrt{10^5}$ 的记录有多少个，对于大于 $\sqrt{10^5}$ 的直接暴力枚举即可。</p>
<p>时间复杂度 $O(n\sqrt{n})$。</p>
<h3 id="H-city-safety"><a href="#H-city-safety" class="headerlink" title="H. city safety"></a>H. city safety</h3><p>套用最大权闭合子图的套路，先全选，然后建出图求最小割即可。</p>
<p>用前缀和的思想，可以将边数优化到 $O(n^2)$ 级别。</p>
<h3 id="I-Distance"><a href="#I-Distance" class="headerlink" title="I. Distance"></a>I. Distance</h3><p>显然可以对每个质数分开来统计：</p>
<p>我们枚举质数 $p$，其贡献为：$2\times p\sum_{p^c\le n}\lfloor \frac{n}{p^c}\rfloor(n-\lfloor \frac{n}{p^c}\rfloor)$。乘 $2$ 是因为不妨假设的 $i$ 中 $p$ 的次数比 $j$ 小。</p>
<p>对于 $c\geq 2$ 的情况，显然有 $p\le \sqrt{n}$，暴力枚举 $\sqrt{n}$ 以内质数即可。</p>
<p>对于 $c=1$，其对答案贡献经过整除分块后，需要计算 $\frac{n}{i}$ 以内的质数的和。这显然是Min25筛的前一部分。</p>
<p>时间复杂度 $O(\frac{n^{\frac{3}{4}}}{\log n})$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="type">int</span> sqr;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> id1[N],id2[N]; ll w[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt,pri[N];</span><br><span class="line">ll s1[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;pri[++cnt]=i;s1[cnt]=<span class="built_in">Add</span>(s1[cnt<span class="number">-1</span>],i);&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;(ll)i*pri[j]&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(ll _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (_n&lt;=sqr)?id1[_n]:id2[n/_n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="built_in">init_prime</span>(sqr);</span><br><span class="line">	ll l=<span class="number">1</span>,r;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=n/(n/l);</span><br><span class="line">		w[++m]=n/l;</span><br><span class="line">		s[m]=<span class="built_in">Mul</span>((w[m]+<span class="number">1</span>)%mod,w[m]%mod)*inv2%mod<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(w[m]&lt;=sqr) id1[w[m]]=m;</span><br><span class="line">		<span class="keyword">else</span> id2[r]=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		ll k=<span class="number">1ll</span>*pri[i]*pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;k&lt;=w[j];j++)</span><br><span class="line">			s[j]=<span class="built_in">Dec</span>(s[j],<span class="built_in">Mul</span>(pri[i],<span class="built_in">Dec</span>(s[<span class="built_in">id</span>(w[j]/pri[i])],s1[i<span class="number">-1</span>])));</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>,now,sum;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		now=<span class="number">1ll</span>*pri[i]*pri[i]; sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;now&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum=<span class="built_in">Add</span>(sum,(n/now)%mod*((n-(n/now))%mod)%mod);</span><br><span class="line">			now=now*pri[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,sum*pri[i]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(l=<span class="number">1</span>;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=n/(n/l);</span><br><span class="line">		sum=(n/l)%mod*((n-(n/l))%mod)%mod;</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="built_in">Dec</span>(s[<span class="built_in">id</span>(r)],s[<span class="built_in">id</span>(l<span class="number">-1</span>)])*sum%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*<span class="number">2</span>%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="J-Circular-Billiard-Table"><a href="#J-Circular-Billiard-Table" class="headerlink" title="J. Circular Billiard Table"></a>J. Circular Billiard Table</h3><p>签到题，算一算gcd即可。</p>
<h3 id="K-Tiny-Stars"><a href="#K-Tiny-Stars" class="headerlink" title="K. Tiny Stars"></a>K. Tiny Stars</h3><p>考虑 $i-&gt;\frac{a}{i}-&gt;i$，但是这样的花费是 $16n$ 的，行不通。</p>
<p>考虑减少一点 $i-&gt;\frac{a}{i}$，可以发现：$i-&gt;\frac{a}{i}-&gt;\frac{1}{i}-&gt;ai-&gt;i$。</p>
<p>此时的花费为 $4n+\frac{(14+1)n}{2}=11.5n$，可以通过。</p>
<p>那么怎么能在不知道 $a$ 的情况下顺利连成上述情况呢？</p>
<p>考虑原根，将乘除转化为加减，设 $g^t=a$，有 $g^i-&gt;g^{t-i}-&gt;g^{n-1-i}$。</p>
<p>易知 $i,n-1-i$ 同奇偶，那么只要 $i$ 与 $t-i$ 不同奇偶性就可以了。</p>
<p>即 $t$ 为奇数，显然有 $\frac{1}{2}$ 的概率可以成功。</p>
<h3 id="M-810975"><a href="#M-810975" class="headerlink" title="M. 810975"></a>M. 810975</h3><p>容斥，考虑算出 $\le k$ 的答案即可。</p>
<p> 考虑 $n-m$ 个 $0$ 将线段分成 $n-m+1$ 段，每一段的长度不超过 $k$。总和为 $m$，那么相当于求 $x_1+x_2+\cdots+x_{n-m+1}=m,x_i\in [0,k]$ 的方案数。</p>
<p>两种办法：</p>
<ul>
<li>考虑生成函数，即求 $<a href="1+x+\cdots+x^k">x^m</a>^{n-m+1}$。用快速幂或者等比数列求和。</li>
<li>容斥，考虑至少 $i$ 个 $x$ 违反了 $[0,k]$ 的限制即可。</li>
</ul>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
        <tag>数论</tag>
        <tag>树状数组</tag>
        <tag>概率</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 CCPC 桂林站</title>
    <url>/2021/11/17/2021-CCPC-%E6%A1%82%E6%9E%97%E7%AB%99/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/103409/">gym</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-Hero-Named-Magnus"><a href="#A-Hero-Named-Magnus" class="headerlink" title="A. Hero Named Magnus"></a>A. <a href="https://codeforces.com/gym/103409/problem/A">Hero Named Magnus</a></h3><p>输出 $2x-1$。</p>
<h3 id="B-A-Plus-B-Problem"><a href="#B-A-Plus-B-Problem" class="headerlink" title="B. A Plus B Problem"></a>B. <a href="https://codeforces.com/gym/103409/problem/B">A Plus B Problem</a></h3><p>直接模拟加法即可。</p>
<p>使用线段树二分或者二分+线段树找到第一个 $9$ 或者 $0$ 即可。</p>
<p>使用线段树二分，时间复杂度 $O(n\log n)$。</p>
<h3 id="C-AC-Automaton"><a href="#C-AC-Automaton" class="headerlink" title="C. AC Automaton"></a>C. <a href="https://codeforces.com/gym/103409/problem/C">AC Automaton</a></h3><p>好毒瘤啊，不会。</p>
<h3 id="D-Assumption-is-All-You-Need"><a href="#D-Assumption-is-All-You-Need" class="headerlink" title="D. Assumption is All You Need"></a>D. <a href="https://codeforces.com/gym/103409/problem/D">Assumption is All You Need</a></h3><p>注意到，从小到大将数移到原来的位置后，就可以当做这个数字消失，也就是不再管它的位置。</p>
<p>大概是因为按照从小到大，没有归位的数都可以跨过去。</p>
<p>那么直接模拟即可。时间复杂度 $O(n^2)$。</p>
<h3 id="E-Buy-and-Delete"><a href="#E-Buy-and-Delete" class="headerlink" title="E. Buy and Delete"></a>E. <a href="https://codeforces.com/gym/103409/problem/E">Buy and Delete</a></h3><p>最多只可能删除两次。</p>
<p>一次删掉 $x&lt;y$ 的，另一次删掉 $x&gt;y$ 的。</p>
<p>那么找到最小环即可。</p>
<p>时间复杂度 $O(nm\log n)$。</p>
<h3 id="F-Illuminations-II"><a href="#F-Illuminations-II" class="headerlink" title="F. Illuminations II"></a>F. <a href="https://codeforces.com/gym/103409/problem/F">Illuminations II</a></h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>大凸包里包着小凸包，从大凸包的周长上任意选择一点作为光源，问小凸包期望被照亮的长度。</p>
<p>$n,m\le 2\times 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>考虑反面，枚举小凸包的每一条边，看大凸包中有多长的线中的点能照到这条边。</p>
<p>这相当于求一条直线切一个凸包，问切成两部分后在直线右侧的长度和。</p>
<p>扫描线，维护直线切到凸包中的两条线段即可。</p>
<p>注意几乎平行的线段可能会有精度问题，判断点关于线的位置时需要注意。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line"><span class="type">const</span> db inf=<span class="number">1e20</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(db x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">sqr</span><span class="params">(db x)</span></span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">Point</span>()&#123;x=y=<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">Point</span>(db _x,db _y)&#123;x=_x,y=_y;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%Lf%Lf&quot;</span>,&amp;x,&amp;y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(A.x-B.x)==<span class="number">0</span>&amp;&amp;<span class="built_in">sgn</span>(A.y-B.y)==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(A.x-B.x)==<span class="number">0</span>?<span class="built_in">sgn</span>(A.y-B.y)&lt;<span class="number">0</span>:A.x&lt;B.x;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span>+(Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x+B.x,A.y+B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span>-(Point A,Point B)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x-B.x,A.y-B.y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span>*(Point A,db k)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x*k,A.y*k);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Point <span class="keyword">operator</span>/(Point A,db k)&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(A.x/k,A.y/k);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span>^(Point A,Point B)&#123;<span class="keyword">return</span> A.x*B.y-A.y*B.x;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span>*(Point A,Point B)&#123;<span class="keyword">return</span> A.x*B.x+A.y*B.y;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len2</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqr</span>(x)+<span class="built_in">sqr</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">len2</span>());&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">angle</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y,x);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">	Point s,e;</span><br><span class="line">	<span class="built_in">Line</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">Line</span>(Point _s,Point _e)&#123;s=_s,e=_e;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span></span>&#123;<span class="keyword">if</span>(e&lt;s) <span class="built_in">swap</span>(e,s);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Line A,Line B)&#123;<span class="keyword">return</span> A.s==B.s&amp;&amp;A.e==B.e;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">len</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (e-s).<span class="built_in">len</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">relation</span><span class="params">(Point p)</span><span class="comment">//1-&gt;left,2-&gt;right,3-&gt;on it.</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> c=<span class="built_in">sgn</span>((p-s)^(e-s));</span><br><span class="line">		<span class="keyword">return</span> !c?<span class="number">3</span>:(<span class="number">1</span>+(c&gt;<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">parallel</span><span class="params">(Line v)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sgn</span>((e-s)^(v.e-v.s))==<span class="number">0</span>;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">linecrossline</span><span class="params">(Line v)</span><span class="comment">//0 parallel,1 same,2 inter</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((*<span class="keyword">this</span>).<span class="built_in">parallel</span>(v)) <span class="keyword">return</span> v.<span class="built_in">relation</span>(s)==<span class="number">3</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">Point <span class="title">Intersection</span><span class="params">(Line v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		db a1=(v.e-v.s)^(s-v.s);</span><br><span class="line">		db a2=(v.e-v.s)^(e-v.s);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Point</span>((s.x*a2-e.x*a1)/(a2-a1),(s.y*a2-e.y*a1)/(a2-a1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">Point a[N],b[N];</span><br><span class="line">db sum,s[N];</span><br><span class="line">Line li[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r) <span class="keyword">return</span> s[r<span class="number">-1</span>]-s[l];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> s[n<span class="number">-1</span>]-s[l]+(r?s[r<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) a[i].<span class="built_in">input</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m) b[i].<span class="built_in">input</span>();</span><br><span class="line">	Line now=<span class="built_in">Line</span>(b[<span class="number">0</span>],b[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) li[i]=<span class="built_in">Line</span>(a[i],a[(i+<span class="number">1</span>)%n]),sum+=li[i].<span class="built_in">len</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) s[i]=li[i].<span class="built_in">len</span>()+(i?s[i<span class="number">-1</span>]:<span class="number">0.0</span>);</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(now.<span class="built_in">relation</span>(a[i])==<span class="number">1</span>&amp;&amp;now.<span class="built_in">relation</span>(a[(i+<span class="number">1</span>)%n])!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			l=i; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(now.<span class="built_in">relation</span>(a[i])==<span class="number">2</span>&amp;&amp;now.<span class="built_in">relation</span>(a[(i+<span class="number">1</span>)%n])!=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			r=i; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	db ans=(<span class="built_in">ask</span>(l,r)+(now.<span class="built_in">Intersection</span>(li[l])-a[(l+<span class="number">1</span>)%n]).<span class="built_in">len</span>()+(now.<span class="built_in">Intersection</span>(li[r])-a[r]).<span class="built_in">len</span>())/sum*now.<span class="built_in">len</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		now=<span class="built_in">Line</span>(b[i],b[(i+<span class="number">1</span>)%m]);</span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">			<span class="keyword">if</span>(now.<span class="built_in">relation</span>(a[l])!=<span class="number">2</span>&amp;&amp;now.<span class="built_in">relation</span>(a[(l+<span class="number">1</span>)%n])!=<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				l=(l+<span class="number">1</span>)%n;</span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">			<span class="keyword">if</span>(now.<span class="built_in">relation</span>(a[r])!=<span class="number">1</span>&amp;&amp;now.<span class="built_in">relation</span>(a[(r+<span class="number">1</span>)%n])!=<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r=(r+<span class="number">1</span>)%n;</span><br><span class="line">		ans+=(<span class="built_in">ask</span>(l,r)+(now.<span class="built_in">Intersection</span>(li[l])-a[(l+<span class="number">1</span>)%n]).<span class="built_in">len</span>()+(now.<span class="built_in">Intersection</span>(li[r])-a[r]).<span class="built_in">len</span>())/sum*now.<span class="built_in">len</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.12Lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-Occupy-the-Cities"><a href="#G-Occupy-the-Cities" class="headerlink" title="G. Occupy the Cities"></a>G. <a href="https://codeforces.com/gym/103409/problem/G">Occupy the Cities</a></h3><p>一个比较好写的方法是：二分，然后贪心判断是否可行。</p>
<h3 id="I-PTSD"><a href="#I-PTSD" class="headerlink" title="I. PTSD"></a>I. <a href="https://codeforces.com/gym/103409/problem/I">PTSD</a></h3><p>从后往前贪心，看能否找到一个更大的去匹配即可。</p>
<h3 id="J-Suffix-Automaton"><a href="#J-Suffix-Automaton" class="headerlink" title="J. Suffix Automaton"></a>J. <a href="https://codeforces.com/gym/103409/problem/J">Suffix Automaton</a></h3><h4 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h4><p>对反串建立SAM，每个节点的贡献是 $[len_{fa_x}+1,len_x]$。</p>
<p>为了满足字典序，我们找出每个点相对于父节点第一个多出来的字符，这个就相当于是原串的某个前缀再加一个字符。对于树中每个点，按照这个字符进行排序，就能按照字典序的要求来了。</p>
<p>找原串中第一个出现的字符串相当于找反串最后一次出现的字符串，在parent-tree中进行一遍dfs就可以找到right集合中最大的那个数。</p>
<h4 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h4><p>每个点的贡献是 $[height_x+1,n-sa_x+1]$。</p>
<p>SA本身就满足字典序。</p>
<p>找原串中第一个出现的字符串可以通过倍增找到。</p>
<p>对于以上两个算法，剩下的就是找到答案。</p>
<p>对询问离线，然后对若干条线段在数轴上从左到右扫描线，变成若干次单点修改，查找第 $k$ 小的值。用线段树维护即可。</p>
<p>时间复杂度 $O(n\sum+n\log n)$ 或 $O(n\log n)$。</p>
<h3 id="K-Tax"><a href="#K-Tax" class="headerlink" title="K.Tax"></a>K.<a href="https://codeforces.com/gym/103409/problem/K">Tax</a></h3><p>建出最短路图后，直接dfs即可。</p>
<p>时间复杂度 $O(x^{\frac{n}{x}})$。</p>
<p>设 $f(x)=x^{\frac{n}{x}}$，则 $\ln f(x)=\frac{n}{x}\ln x$，$\frac{f’(x)}{f(x)}=n\times \frac{1-\ln x}{x^2}$。</p>
<p>易知 $x$ 取 $e$ 时，$f(x)$ 取得最大值。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>SAM</tag>
        <tag>计算几何</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 CCPC 广州站</title>
    <url>/2021/11/14/2021-CCPC-%E5%B9%BF%E5%B7%9E%E7%AB%99/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://codeforces.com/gym/103415/problems">gym</a></p>
<span id="more"></span>

<h2 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h2><p>第一次参加CCPC~</p>
<h3 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h3><p>热身赛。</p>
<p>T1是ICPC网络赛第二场原题。</p>
<p>T2简单模拟。</p>
<p>T3是个奇怪（没给数据范围）的计算几何。</p>
<p>第14min的时候切完了前两题。然后听到队友说了个三分套三分，就上去写了。很快写完交了一发，TLE，发现是三分次数太多，调小三分次数后变成了WA。</p>
<p>想着精度有可能不够，然后把第二个三分变成了 $O(1)$，并改了一个错误后，结果还是WA。</p>
<p>然后一直想办法调，造了几组极限数据，发现会被几乎平行的情况给卡掉。</p>
<p>一直到比赛结束也没有过，发现鸿蒙队交了将近50发，也没过。</p>
<p>晚上困得要死，10点没到就去睡觉啦。</p>
<h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>7点15起了床。突然想起昨天忘记给机器调Python了。</p>
<p>于是随便吃了三个包子，就去到小机房，把Python给下载了。</p>
<p>比赛开始前手机的前置摄像头突然用不了了，但是电脑里面的二维码也已经没了，没有办法拍照。</p>
<p>于是采用了手机拍手机的策略，在开始前4min搞定了。</p>
<p>先开了H，发现是个构造，然后复杂地分了好多类，WA了三发之后在39min过了。</p>
<p>然后看完了K题，觉得挺可做的。接着看到队友在讨论I，突然觉得是个找规律题，于是我花了2min敲了个暴力，发现输出 $6\times 2^{n-3}$ 就好了，然后在49min的时候过了I。</p>
<p>接下来的C一直WA，WA了三发之后发现读错题了。。原来项链是个环状的结构。。然后改了之后也一直WA。</p>
<p>于是我去想有点思路的K。发现只要先容斥一下，把大于等于改成小于，这样就可以枚举lcm，从而枚举gcd了，然后之后就变成选定 $[1,m]$ 内的 $n$ 个数，问gcd=i,lcm=j的方案数了。这个也可以容斥做。</p>
<p>在封榜前大概0.5h开始写，写着写着发现第二个容斥复杂度太大过不去，想了想发现这个容斥可以分开做。</p>
<p>然后再随便想了想第一个容斥，发现用个莫反就可以做了。</p>
<p>于是在封榜前写完，交了一发，发现又T了。</p>
<p>试了一个极限数据，发现大概要用4s。将n的快速幂预处理后，WA了一发，在237min过了K。</p>
<p>接着去推F，搞来搞去完全不知道 $\sum_{i=1}^n \prod_{i\neq j}\frac{1+f_i-f_if_j}{f_i-f_j}$ 有何意义的时候，抬头一看，发现C被队友改了以后过了。。。通过手算F发现，$n=3$ 的答案竟然是 $2$，然后打了个表发现，这个式子竟然与 $f$ 没有关系。。。于是在280min的时候把F也过了。</p>
<p>封榜结束后的40min连过3题，直接让我们队从铁牌区飞到了金牌区。。。</p>
<p>23个Au，5题末尾，排在第22，倒数第二个Au。</p>
<p>颁奖Ag的时候看到没有我们，还是挺激动的哈哈哈。</p>
<p>这题出的太奇怪了。尤其是F这种逆推回去然后出成题的。。。还有0.5s时限的C，都不知在卡些什么。所以说总体体验一般。</p>
<p>Anyway，大学的第一场XCPC就还算圆满啦。</p>
<p>下星期的威海加油~</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-Math-Ball"><a href="#A-Math-Ball" class="headerlink" title="A. Math Ball"></a>A. Math Ball</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定 $n$ 个多项式 $F_j(x)=\sum_{i=0}i^{c_j}x_i$。</p>
<p>求 $\prod_{j=1}^n F_j(x)$ 的前 $W$ 项系数和。</p>
<p>$W\le 10^{18},n,\sum c_j\le 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>对于幂次比较小的，可以考虑将幂用第二类斯特林数展开转成下降幂：</p>
<p>$i^c=\sum_{j=1}^c\begin{Bmatrix}<br>c\\<br>j<br>\end{Bmatrix}i^{\underline{j}}$，</p>
<p>那么有：</p>
<p>$$F_j(x)=\sum_{i=0}\sum_{j=1}^{c}\begin{Bmatrix}<br>c\\<br>j<br>\end{Bmatrix}j!\binom{i}{j}x^i=\sum_{j=1}^c\begin{Bmatrix}<br>c\\<br>j<br>\end{Bmatrix}j!\sum_{i=0}\binom{i}{j}x^i\=\sum_{j=1}^c\begin{Bmatrix}<br>c\\<br>j<br>\end{Bmatrix}j!\frac{(1-x)^{c-j}x^j}{(1-x)^{c+1}}$$</p>
<p>答案就是 $[x^W]\frac{\prod_{k=1}^n(\sum_{j=1}^{c_k}S_2(c_k,j)j!(1-x)^{c_k-j}x^j)}{(1-x)^{\sum (c_k+1)}+1}$</p>
<p>对于分子中连乘的每一项，是一个 $c_k$ 次多项式，将 $(1-x)^{c_k-j}$ 通过二项式定理暴力展开，并预处理一行第二类斯特林数后，使用一次卷积即可算出。</p>
<p>设分子为 $F(x)$，$s=\sum_{k=1}^n(c_k+1)$。</p>
<p>则答案为 ：$[x^W]\frac{F}{(1-x)^{s+1}}$，根据 $\frac{1}{(1-x)^{s+1}}$ 的组合意义，答案相当于 $F$ 的某个系数乘上组合数之和。</p>
<p>将组合数转成下降幂除以一个阶乘的形式计算即可。</p>
<p>时间复杂度 $O(n\log ^2n)$。</p>
<h3 id="C-Necklace"><a href="#C-Necklace" class="headerlink" title="C. Necklace"></a>C. Necklace</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一个长度为 $n$ 的环形的项链，上面有 $m$ 个特殊点，现在用 $m$ 段区间恰好覆盖这个项链，使得每个区间中有且只有一个项链。问这些区间的长度的最大值最小是多少。</p>
<p>$m\le 10^6,n\le 10^{18}$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>显然二分，重点在判断上。</p>
<p>找到长度最小的那个区间的右端点，考虑转一圈后是否可行，如果是无法覆盖到最后一个，那么一定不行；如果是无法覆盖整个 $n$，那么将起点改为由此时到达最右的端点+1开始，再转一圈，如果此时不行，那么就一定不行。</p>
<p>时间复杂度 $O(m\log n)$。</p>
<h3 id="F-Cactus"><a href="#F-Cactus" class="headerlink" title="F. Cactus"></a>F. Cactus</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>设 $f_n$ 表示总点数为 $n$ 的，允许重边的，有标号的连通仙人掌的个数。</p>
<p>求 $\sum_{i=1}^n \prod_{i\neq j}\frac{1+f_i-f_if_j}{f_i-f_j}$ 对 $998244353$ 取模后的结果。</p>
<p>$n\le 3\times 10^5$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>这玩意儿竟然跟 $f_i$ 无关。。。</p>
<p>答案即为 $fib_n$。</p>
<p>关于证明，它鸽了。</p>
<h3 id="G-Slope"><a href="#G-Slope" class="headerlink" title="G. Slope"></a>G. Slope</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定 $n$ 个点 $(x_i,y_i)$，横坐标互不相同。</p>
<p>$m$ 次询问一个二维平面中平行于坐标轴的矩形，问在矩形内的点中 $\frac{|x_i-x_j|}{|y_i-y_j|}$ 的最小值。</p>
<p>$n\le 7000,m\le 7\times 10^5$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>其实这题并不难啊。。</p>
<p>只考虑横坐标，那么就是一个简单的莫队。</p>
<p>再考虑纵坐标，最小值只有可能在相邻的纵坐标中取得，那么用线段树维护最小值，合并的时候记录临界的点即可。</p>
<p>莫队分块大小取 $\frac{n^2}{m}$，时间复杂度 $O(n\sqrt{m}\log n)$。</p>
<h3 id="H-Three-Integers"><a href="#H-Three-Integers" class="headerlink" title="H. Three Integers"></a>H. Three Integers</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定 $a,b,c$，求出一组 $x,y,z$，满足 $x\bmod y=a,y\bmod z=b,z\bmod x=c$，或判定无解。</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>不妨设 $a\geq b\geq c$。</p>
<p>当 $abc\neq 0$ 时，若 $a=b=c$ 则无解，否则， $(x,y,z)=(a,a+c+b,a+c)$ 为一组可行解。</p>
<p>当 $abc=0$ 时，若 $a=b=c=0$，则 $(1,1,1)$ 为一组解；若 $b=c=0$，则 $(a,2a,2a)$ 为一组解；若 $c=0$，则 $(a,2a+b,2a)$ 为一组解。</p>
<p>时间复杂度 $O(1)$。</p>
<h3 id="I-Pudding-Store"><a href="#I-Pudding-Store" class="headerlink" title="I. Pudding Store"></a>I. Pudding Store</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>多次询问有多少个长度为 $n$ 的排列的前缀和的两倍均为为 $i$ 的倍数。</p>
<p>$n\le 10^9$。</p>
<h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>打表可知，当 $n\le 2$ 时答案为 $n$，否则为 $6\times 2^{n-3}$ 。</p>
<h3 id="K-Magus-Night"><a href="#K-Magus-Night" class="headerlink" title="K. Magus Night"></a>K. Magus Night</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>问所有长度为 $n$ 的数组 $a$ 的 $\prod_{i=1}^n a_i$ 的和，满足 $1\le a_i \le m$ 且 $a_i$ 为整数，$\gcd(a_1,a_2,\cdots,a_n)\le q$，且 $\text{lcm}(a_1,a_2,\cdots,a_n)\geq p$。</p>
<p>$1\le n \le 10^9,1\le p,q\le m\le 2\times 10^5$。</p>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><p>$\text{lcm}$ 一定为 $\gcd$ 的倍数。因此，我们可以枚举 $\text{lcm}$ 后，枚举其因数作为 $\gcd$。</p>
<p>但是题目里是 $\text{lcm}(a_1,a_2,\cdots,a_n)\geq p$，不好枚举，于是容斥一下，撇开 $\text{lcm}$ 的限制后，统计出 $\gcd(a_1,a_2,\cdots,a_n)\le q$ 的答案，那么就可以转换为枚举一个较小的 $\text{lcm}$ 了。</p>
<p>枚举lcm,gcd是 $O(m\log m)$ 的，然后根据乘法分配律，分开质因子去统计答案。对于每个质因子的答案，也可以容斥去做。</p>
<p>需要预处理某些数的 $n$ 次幂。</p>
<p>第一个容斥中，统计 $\gcd(a_1,a_2,\cdots,a_n)\le q$ 的答案使用简单莫反即可。</p>
<p>时间复杂度应该是两个 log 的。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>分治</tag>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>组合数学</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 Jiangxi Provincial Collegiate Programming Contest</title>
    <url>/2021/11/11/2021-Jiangxi-Provincial-Collegiate-Programming-Contest/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/103366/problems">题目链接</a></p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="A-Mio-visits-ACGN-Exhibition"><a href="#A-Mio-visits-ACGN-Exhibition" class="headerlink" title="A. Mio visits ACGN Exhibition"></a>A. Mio visits ACGN Exhibition</h3><p>设 $f_{i,j,k}$ 表示到达 $(i,j)$ 时用了 $k$ 个 $0$ 的方案数，最终将结果就是 $\sum_i f_{n,m,i}$。</p>
<p>滚动数组优化空间即可。</p>
<p>时间复杂度 $O(n^3)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y;<span class="keyword">return</span> x&gt;=mod?x-mod:x;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">503</span>;</span><br><span class="line"><span class="type">int</span> n,m,p,q;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line">ll f[<span class="number">2</span>][N][N+N];</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); p=<span class="built_in">read</span>(); q=n+m<span class="number">-1</span>-<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">			a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	d=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		d=<span class="number">1</span>-d;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">fo</span>(k,<span class="number">0</span>,n+m) f[d][j][k]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">fo</span>(k,<span class="number">0</span>,n+m) f[d][j][k+(!a[i][j])]=<span class="built_in">Add</span>(f[d][j<span class="number">-1</span>][k],f[<span class="number">1</span>-d][j][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,p,q) ans=<span class="built_in">Add</span>(ans,f[d][m][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-Continued-Fraction"><a href="#B-Continued-Fraction" class="headerlink" title="B. Continued Fraction"></a>B. Continued Fraction</h3><p>直接模拟欧几里得过程即可。</p>
<p>写到一半才看到 $\gcd(x,y)=1$ 的条件。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>();</span><br><span class="line">		vec.<span class="built_in">clear</span>(); vec.<span class="built_in">pb</span>(x/y);</span><br><span class="line">		x%=y; <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">for</span>(;y;)</span><br><span class="line">		&#123;</span><br><span class="line">			vec.<span class="built_in">pb</span>(x/y);</span><br><span class="line">			x%=y;</span><br><span class="line">			<span class="built_in">swap</span>(x,y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v:vec) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Crystal-Caves"><a href="#C-Crystal-Caves" class="headerlink" title="C. Crystal Caves"></a>C. Crystal Caves</h3><p>有一个重要的性质：每一层只会选择它的两个端点中的一个。</p>
<p>从后往前进行DP，设 $f_{i,j}$ 表示考虑到第 $i$ 层时，$[i,n]$ 层中有 $j$ 个用了左边时，第 $i\sim n$ 层对答案的贡献的最小值。</p>
<p>那么只需要算第 $i$ 层的贡献即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h3 id="D-Character-Distance"><a href="#D-Character-Distance" class="headerlink" title="D. Character Distance"></a>D. Character Distance</h3><p><del>构造题好麻烦。。。</del></p>
<p>首先特判掉存在只出现一次的数，这时候只需要排序后输出就好了。</p>
<p>显然最优的方案只有可能是选出一种数，然后剩下的排序。</p>
<p>假设选择了 $x$，那么就会有两种情况：</p>
<ol>
<li><p>从 $x$ 的开头 $i$ 开始选，后面的数足够多，能选上，也就是 $i+(num-1)\times d\le n$。</p>
</li>
<li><p>不满足第一种的条件时，只能让 $x$ 的开头往后延。</p>
</li>
</ol>
<p>对于两种情况，我们贪心的从后面开始选，显然开头的位置是越大越好的。</p>
<p>对两种方法，取字典序最小的就可以了。</p>
<h3 id="E-The-Legend-of-God-Flukehn-in-Eastern"><a href="#E-The-Legend-of-God-Flukehn-in-Eastern" class="headerlink" title="E. The Legend of God Flukehn in Eastern"></a>E. The Legend of God Flukehn in Eastern</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>在一二维平面上 $n$ 个卒子，每次你能且仅能选择一个往下走一步。</p>
<p>将军初始在 $(0,0)$ 上，每次必须选择上左下右，上左，上右六个方向中的一个走一格。</p>
<p>任意时刻将军与卒子在同一格，则卒子被吃掉。你和将军轮流走，你先走。</p>
<p>问走最优策略时，将军最多能吃多少个卒子。</p>
<p>$n\le 10^6$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>大毒瘤题。</p>
<p>三人用了差不多1h分析性质：</p>
<ol>
<li>设卒子相对于将军形成的向量为 $(x,y)$，则当且仅当 $y&lt;|x|$ 时卒子能走掉。</li>
</ol>
<p>证明：显然。</p>
<ol start="2">
<li>最多只能保留一个卒子。</li>
</ol>
<p>证明：当只剩下两个卒子时，先走到其中一个卒子的列中，如果此时该卒子在将军上方，那么能吃掉其中一个，否则一直追着这个卒子，直到第二个卒子满足性质1的条件为止。</p>
<ol start="3">
<li>如果能吃完所有卒子，那么一定是按 $y$ 从小到大的顺序吃的。</li>
</ol>
<p>证明：显然。</p>
<ol start="4">
<li>对于某个时刻，如果有任何一个卒子满足性质一，那么它就能走掉。</li>
</ol>
<p>证明：显然。</p>
<ol start="5">
<li>对于两个卒子 $i,j$ （不妨设 $y_i\le y_j$），若存在某个时刻使得 $y_j-y_i&lt;|x_j-x_i|$，且 $|x_j-x_i|&gt;1$，那么其中一个可以走掉。</li>
</ol>
<p>证明：根据性质3，将军要先去吃 $y$ 比较小的卒子，再它吃掉这个卒子后，另外一个卒子一定满足性质 $1$。</p>
<ol start="6">
<li>对于两个卒子 $i,j$ （不妨设 $y_i\le y_j$），若在初始时刻使得 $y_j-y_i-y_i&lt;|x_j-x_i|$，且 $|x_j-x_i|&gt;1$，那么其中一个可以走掉。</li>
</ol>
<p>根据性质5，任何两个 $|x_j-x_i|&gt;1$ 的卒子，如果想要保住卒子 $j$，那么就需要在将军吃掉 $i$ 之前，$j$ 一直往下，直到 $i,j$ 满足性质5为止。而将军吃掉卒子 $i$ <strong>大概</strong>需要花费 $y_i$ 步，也就是 $j$ 能走 $y_i$ 步向下。（这里的大概是因为需要下方的点不满足性质7才可以）</p>
<ol start="7">
<li>对于两个卒子 $i,j$ 满足 $|x_j-x_i|=1$ ， $y_j-y_i-y_i\le 0$ 且存在第三者 $k$ 使得 $x_i\neq x_k,x_j\neq x_k$，且 $y_k\geq y_i$， 那么这三个的其中一个可以走掉。</li>
</ol>
<p>如果没有第三者，这两个卒子一定走不掉，因为可以先吃完 $k$ 再去吃 $i,j$（这里 $k,i$ 或 $k,j$ 均不满足性质6，否则可以溜掉）。否则显然可以走掉。</p>
<p>综上，根据如上性质，我们只需要判断：</p>
<ol>
<li><p>是否存在一个卒子 $i$，使得 $y_i&lt;|x_i|$。</p>
</li>
<li><p>是否存在两个卒子 $i,j$，使得 $y_i\le y_j,y_j-2y_i &lt; |x_j-x_i|,1 &lt; |x_j-x_i|$。</p>
</li>
<li><p>是否存在三个卒子 $i,j,k$，使得 $y_i\le y_j,y_i\le y_k,y_j-2y_i &lt; 1 = |x_j-x_i|,x_i\neq x_k,x_j\neq x_k$。</p>
</li>
</ol>
<p>代码过于丑陋就不放了。。。</p>
<h3 id="F-Four-Column-Hanoi-Tower"><a href="#F-Four-Column-Hanoi-Tower" class="headerlink" title="F. Four Column Hanoi Tower"></a>F. Four Column Hanoi Tower</h3><p>设 $f_i$ 表示4座塔的答案，$g_i$ 表示3座塔的答案。</p>
<p>那么就有：$f_i=\min(2f_k+g_{n-k}),f_1=1$ 以及 $g_i=2g_{i-1}+1,g_1=1$。</p>
<p>然后打个表，发现前几项为 $1,3,5,9,13,17,25,33,41,49,\cdots$。一阶差分为 $2,2,4,4,4,8,8,8,8,\cdots$。</p>
<p>直接上 Python 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">now = cnt = <span class="number">2</span></span><br><span class="line">las = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10001</span>):</span><br><span class="line">	las = las+<span class="number">1</span></span><br><span class="line">	a.append(a[-<span class="number">1</span>]+now)</span><br><span class="line">	<span class="keyword">if</span> las == cnt:</span><br><span class="line">		cnt = cnt+<span class="number">1</span></span><br><span class="line">		las = <span class="number">0</span></span><br><span class="line">		now = now+now</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">	<span class="built_in">print</span>(a[<span class="built_in">int</span>(<span class="built_in">input</span>())])</span><br></pre></td></tr></table></figure>

<h3 id="G-Magic-Number-Group"><a href="#G-Magic-Number-Group" class="headerlink" title="G. Magic Number Group"></a>G. Magic Number Group</h3><p>对每个数分解质因数后，剩下的是区间众数。每个位置最多挂上 $7$ 个数。</p>
<p>直接使用莫队即可。时间复杂度 $O(7n\sqrt{n})$。</p>
<p>有点小卡常。</p>
<h3 id="H-Hearthstone-So-Easy"><a href="#H-Hearthstone-So-Easy" class="headerlink" title="H. Hearthstone So Easy"></a>H. Hearthstone So Easy</h3><p>只有三种情况：</p>
<ol>
<li>$n=1$，A直接死了。</li>
<li>A能在第一次干剩B到最多一滴血，A赢。</li>
<li>否则B赢。</li>
</ol>
<h3 id="I-Homework"><a href="#I-Homework" class="headerlink" title="I. Homework"></a>I. Homework</h3><p>换根DP即可。</p>
<h3 id="J-LRU"><a href="#J-LRU" class="headerlink" title="J. LRU"></a>J. LRU</h3><p>显然满足二分性，于是二分后，然后随便判断。可以做到 $O(n\log n)$。</p>
<h3 id="K-Many-Littles-Make-a-Mickle"><a href="#K-Many-Littles-Make-a-Mickle" class="headerlink" title="K. Many Littles Make a Mickle"></a>K. Many Littles Make a Mickle</h3><p>输出 $m\sum_{i=1}^ni^2$。</p>
<h3 id="L-It-Rains-Again"><a href="#L-It-Rains-Again" class="headerlink" title="L. It Rains Again"></a>L. It Rains Again</h3><p>线段投影到 $x$ 轴，然后随便做。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>思维题</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>代数余子式的求法</title>
    <url>/2021/11/05/%E4%BB%A3%E6%95%B0%E4%BD%99%E5%AD%90%E5%BC%8F%E7%9A%84%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定一个 $n$ 阶方阵 $A$:</p>
<p>$A=\begin{bmatrix}<br>a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\<br>a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,n}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>a_{n,1} &amp; a_{n,2} &amp; \cdots &amp; a_{n,n}<br>\end{bmatrix}$</p>
<p>记 $M_{i,j}$ 为矩阵 $A$ 去掉第 $i$ 行和第 $j$ 列后的矩阵或其行列式，$A_{i,j}=(-1)^{i+j}M_{i,j}$，即代数余子式。</p>
<p>求所有的代数余子式 $A_{i,j}$。</p>
<p>$n\le 500$。</p>
<span id="more"></span>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>记 $r(A)$ 表示矩阵 $A$ 的秩。</p>
<h3 id="一些思路"><a href="#一些思路" class="headerlink" title="一些思路"></a>一些思路</h3><p><del>一个显然的做法，暴力计算每个代数余子式，时间复杂度 $O(n^5)$。</del></p>
<p>考虑线性代数里的知识：若 $r(A)=n$，则有 $A ^ {-1} = \frac { A^* }{|A|} $，其中： $A^*=\begin{bmatrix}<br>A_{1,1} &amp; A_{2,1} &amp; \cdots &amp; A_{n,1} \\<br>A_{1,2} &amp; A_{2,2} &amp; \cdots &amp; A_{n,2}\\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>A_{1,n} &amp; A_{2,n} &amp; \cdots &amp; A_{n,n}<br>\end{bmatrix}$ ，即 $A$ 的伴随矩阵。</p>
<p>那么当矩阵行列式不为 $0$ 时，通过一次求逆和求行列式即可求出所有的代数余子式。</p>
<p>若 $r(A)\neq n$ 呢？</p>
<p>如果 $r(A)\le n-2$，则说明，任何一个 $n-1$ 阶余子式均为 $0$，于是 $A^*$ 为 $0$ 矩阵。</p>
<p>因此，剩下的只需考虑 $r(A)=n-1$ 时的情况。</p>
<h3 id="r-A-n-1-时"><a href="#r-A-n-1-时" class="headerlink" title="$r(A)=n-1$ 时"></a>$r(A)=n-1$ 时</h3><p>因 $A$ 不为满秩矩阵，因此行向量是线性相关的。</p>
<p>即对于向量 $v_i=(a_{i,1},a_{i,2},\cdots,a_{i,n})$，存在不全为 $0$ 的数 $p_i$ ，使得 $\sum_{i=1}^mp_iv_i=0$。找到一个不为 $0$ 的 $p_r$。</p>
<p>考虑矩阵：$M_{i,c}$ 和 $M_{r,c}$。其中 $i&lt;r$。</p>
<p>我们将 $M_{i,c}$ 中第 $r-1$ 行插到第 $i-1$ 行的后面去后的矩阵称为 $M ‘ <em>{i,c}$，那么 $|M ‘ _{i,c}|=(-1)^{r-i-1}|M</em>{i,c}|$。</p>
<p>显然，这个 $M’_ {i,c }$ 与 $M_{r,c}$ 只有在第 $i$ 行上是不同的。</p>
<p>设矩阵 $M’$ 为 $M ‘ <em>{i,c}$ 和 $M</em>{r,c}$ 的矩阵中第 $i$ 行的数分别乘上 $p_r$ 或 $p_i$ 相加后，其他行不变的结果。</p>
<p>由行列式性质：$|M ‘ |=p_r(-1)^{r-i-1}|M_{i,c}|+p_i|M_{r,c}|$。</p>
<p>将 $M’$ 中其他行 $j$ 乘上 $p_j$ 后，加到第 $i$ 行中去，则根据 $\sum p_iv_i=0$，第 $i$ 行的结果全为 $0$。因此，$|M’|=0$。</p>
<p>因此：$p_r(-1)^{r-i}|M_{i,c}|=p_i|M_{r,c}|$。</p>
<p>化简可得：$(-1)^{i+c}|M_{i,c}|=\frac{p_i}{p_r}(-1)^{r+c}|M_{r,c}|$。</p>
<p>即：$A_{i,c}=\frac{p_i}{p_r}A_{r,c}$。</p>
<p>当 $i&gt;r$ 时，同理可得上述结果。</p>
<p>当为列向量时，设 $\sum q_{i}v_i=0$。那么同理有：$A_{r,j}=\frac{q_j}{q_c}A_{r,c}$。</p>
<p>在第一个式子中取 $c=j$，联立两式可得：$A_{i,j}=\frac{p_iq_j}{p_rq_c} A_{r,c}$。</p>
<p>于是，只需求出 $p,q$ 和一个 $A_{r,c}$ ，即可求出所有的代数余子式了。</p>
<p>求 $p,q$ 相当于求解齐次线性方程组，$A_{r,c}$ 相当于求一代数余子式。时间复杂度均为 $O(n^3)$。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">502</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	ll a[N][N];</span><br><span class="line">	<span class="built_in">matrix</span>()&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Mat&#123;</span><br><span class="line">	<span class="type">static</span> ll a[N][N],b[N][N+N],c[N][N],d[N][N];</span><br><span class="line">	<span class="type">static</span> matrix B,C;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">det</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		ll d=<span class="number">1</span>,iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=i;</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n) <span class="keyword">if</span>(a[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) &#123;<span class="built_in">fo</span>(j,i,n) <span class="built_in">swap</span>(a[k][j],a[i][j]); d=(mod-d)%mod;&#125;</span><br><span class="line">			<span class="keyword">if</span>(!a[i][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			iv=<span class="built_in">Pow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=a[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n) a[j][k]=<span class="built_in">Dec</span>(a[j][k],a[i][k]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">			d=d*a[i][i]%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> matrix <span class="title">inv</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) b[i][j+n]=<span class="number">0</span>,b[i][j]=A.a[i][j];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i][i+n]=<span class="number">1</span>;</span><br><span class="line">		ll iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=n+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n) <span class="keyword">if</span>(b[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) <span class="built_in">fo</span>(j,<span class="number">1</span>,n+n) <span class="built_in">swap</span>(b[i][j],b[k][j]);</span><br><span class="line">			iv=<span class="built_in">Pow</span>(b[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=b[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n+n) b[j][k]=<span class="built_in">Dec</span>(b[j][k],b[i][k]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			iv=<span class="built_in">Pow</span>(b[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n+n) b[i][j]=b[i][j]*iv%mod;</span><br><span class="line">			<span class="built_in">fd</span>(j,i<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span>(b[j][i])</span><br><span class="line">				&#123;</span><br><span class="line">					tmp=b[j][i];</span><br><span class="line">					<span class="built_in">fo</span>(k,i,n+n) b[j][k]=<span class="built_in">Dec</span>(b[j][k],b[i][k]*tmp%mod);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		B.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) B.a[i][j]=b[i][j+n];</span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">r</span><span class="params">(<span class="type">const</span> matrix A,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		<span class="type">int</span> d=<span class="number">0</span>;</span><br><span class="line">		ll iv,tmp;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=n+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,i,n) <span class="keyword">if</span>(a[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">if</span>(k==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			d++;</span><br><span class="line">			<span class="keyword">if</span>(k!=i) <span class="built_in">fo</span>(j,i,n) <span class="built_in">swap</span>(a[i][j],a[k][j]);</span><br><span class="line">			iv=<span class="built_in">Pow</span>(a[i][i],mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				tmp=a[j][i]*iv%mod;</span><br><span class="line">				<span class="built_in">fo</span>(k,i,n) a[j][k]=<span class="built_in">Dec</span>(a[j][k],tmp*a[i][k]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">static</span> ll v[N],w[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ins</span><span class="params">(ll *v,<span class="type">int</span> n,<span class="type">int</span> id,ll *ans)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) w[i]=<span class="number">0</span>;</span><br><span class="line">		w[id]=<span class="number">1</span>;</span><br><span class="line">		ll tmp;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(v[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!c[i][i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">fd</span>(j,i,<span class="number">1</span>) c[i][j]=v[j];</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">1</span>,n) d[i][j]=w[j];</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				tmp=<span class="built_in">Pow</span>(c[i][i],mod<span class="number">-2</span>)*v[i]%mod;</span><br><span class="line">				<span class="built_in">fd</span>(j,i,<span class="number">1</span>) v[j]=<span class="built_in">Dec</span>(v[j],c[i][j]*tmp%mod);</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">1</span>,n) w[j]=<span class="built_in">Dec</span>(w[j],d[i][j]*tmp%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans[i]=w[i];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_G</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n,ll *p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=A.a[i][j];</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c)); <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,n) v[j]=a[j][i];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ins</span>(v,n,i,p)) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> matrix <span class="title">solve</span><span class="params">(<span class="type">const</span> matrix &amp;A,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> rank=<span class="built_in">r</span>(A,n);</span><br><span class="line">		<span class="keyword">if</span>(rank == n)</span><br><span class="line">		&#123;</span><br><span class="line">			ll d=<span class="built_in">det</span>(A,n);</span><br><span class="line">			B=<span class="built_in">inv</span>(A,n);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) C.a[i][j]=B.a[j][i]*d%mod;</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(rank &lt;= n<span class="number">-2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			C.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">static</span> ll p[N],q[N];</span><br><span class="line">			<span class="built_in">get_G</span>(A,n,q);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) B.a[j][i]=A.a[i][j];</span><br><span class="line">			<span class="built_in">get_G</span>(B,n,p);</span><br><span class="line">			<span class="type">int</span> c=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(q[i]) &#123;c=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(p[i]) &#123;r=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(i!=r)</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">						<span class="keyword">if</span>(j!=c)</span><br><span class="line">							B.a[i-(i&gt;r)][j-(j&gt;c)]=A.a[i][j];</span><br><span class="line">			ll d=<span class="built_in">det</span>(B,n<span class="number">-1</span>);</span><br><span class="line">			C.a[r][c]=((r+c)%<span class="number">2</span>==<span class="number">1</span>)?(mod-d)%mod:d;</span><br><span class="line">			ll iv=<span class="built_in">Pow</span>(q[c]*p[r]%mod,mod<span class="number">-2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">					C.a[i][j]=C.a[r][c]*iv%mod*p[i]%mod*q[j]%mod;</span><br><span class="line">			<span class="keyword">return</span> C;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Mat::solve;</span><br><span class="line"></span><br><span class="line">matrix A,B;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) A.a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">		B=<span class="built_in">solve</span>(A,n);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,((i+j)%<span class="number">2</span>==<span class="number">1</span>)?(mod-B.a[i][j])%mod:B.a[i][j]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>行列式</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 ICPC Shanghai Site</title>
    <url>/2021/10/27/2020-ICPC-Shanghai-Site/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/102900/problems">题目链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="B-Mine-Sweeper-II"><a href="#B-Mine-Sweeper-II" class="headerlink" title="B. Mine Sweeper II"></a>B. Mine Sweeper II</h3><p>$\frac{nm}{2}$ 这个限制启发我们，如果将原图所有的点的情况反转，那么可以发现总和是一样的。</p>
<p>那么就可以了。</p>
<h3 id="C-Sum-of-Log"><a href="#C-Sum-of-Log" class="headerlink" title="C. Sum of Log"></a>C. Sum of Log</h3><p>考虑数位DP，设 $f_{i,j_1,j_2,k}$ 表示考虑到第 $i$ 位，第一，二个数是否打破限制，前面是否都还为 $0$ 的总和。</p>
<p>时间复杂度 $O(T\log n)$。</p>
<h3 id="D-Walker"><a href="#D-Walker" class="headerlink" title="D. Walker"></a>D. Walker</h3><p>二分，算出左，右两边的人在 $mid$ 时间内最远能到哪个位置。</p>
<p>注意，当两个人位置一样的时候，你不知道哪个人在左边，所以需要两边都算。（否则会得到一发罚时）</p>
<h3 id="E-The-Journey-of-Geor-Autumn"><a href="#E-The-Journey-of-Geor-Autumn" class="headerlink" title="E. The Journey of Geor Autumn"></a>E. The Journey of Geor Autumn</h3><p>要使得 $a_i&gt;\min(a_{i-k},a_{i-k+1},\cdots,a_{i-1})$，最难处理的是 $1$。</p>
<p>显然，$1$ 要放在前 $k$ 个位置中的一个，假设为 $i$，那么变成 $n-i$ 的一个子问题。</p>
<p>设总方案数为 $f_n$，有DP式：$f_n=\sum_{i=1}^{\min(n,k)}\frac{n-1}{i-1}\times (i-1)!\times f_{n-i}$</p>
<p>化简后，前缀和优化即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="G-Fibonacci"><a href="#G-Fibonacci" class="headerlink" title="G. Fibonacci"></a>G. Fibonacci</h3><p>除了前两个，以后都是奇偶相间。签到题。</p>
<h3 id="H-Rice-Arrangement"><a href="#H-Rice-Arrangement" class="headerlink" title="H. Rice Arrangement"></a>H. Rice Arrangement</h3><p>显然第 $i$ 个人一定对应着第 $(i+j)\bmod m$ 个菜。</p>
<p>暴力枚举 $j$，设往左转了 $x$ 个，那么往右转的度数 $y$ 也能算出来，用 $x+y+\min(x,y)$ 对答案去最小值。</p>
<p>排序即可。</p>
<p>时间复杂度 $O(m^2\log m)$。</p>
<h3 id="I-Sky-Garden"><a href="#I-Sky-Garden" class="headerlink" title="I. Sky Garden"></a>I. Sky Garden</h3><p>这题花的时间有点多，需要静下时间来写写式子才行。</p>
<p>主要看圆上两个点 $(\cos\frac{2\pi i}{2m},\sin\frac{2\pi i}{2m})$ 和 $(\cos\frac{2\pi j}{2m},\sin\frac{2\pi j}{2m})$ 间的弦长与 $2$ 谁大。</p>
<p>算出来之后，理论上就可以 $O(1)$ 计算了。</p>
<h3 id="K-Traveling-Merchant"><a href="#K-Traveling-Merchant" class="headerlink" title="K. Traveling Merchant"></a>K. Traveling Merchant</h3><p>如果找到一条颜色相间的<strong>简单</strong>路径，再找到一条边，使得该边的端点为该路径终点和路径上的一条边，那么就一直走这个环，就找到答案了。</p>
<p>将同色边拿出来，将异色边建出一个图。</p>
<p>每次询问一个同色边 $(u,v)$，问异色图中是否存在依次经过 $0,u,v$ 或 $9,v,u$ 的简单路径。</p>
<p>建出异色图的 dfs 树。</p>
<p>分三种情况：</p>
<ol>
<li><p>$u=0$ 或 $v=0$，则两点在异色图中连通即可。</p>
</li>
<li><p>$\text{lca}(u,v)=u$ 或 $v$，那么与 $0$ 连通即可。</p>
</li>
<li><p>当不满足上述情况时，设 $w=\text{lca}(u,v)$，我们要不经过 $w$ ，到达其中一个点（不妨为 $u$），然后从这个点回去 $w$，再去走到另外一个点 $v$。</p>
</li>
</ol>
<p>这相当于从 $fa_w$ 到 $u$ 有两条点不重复的路径，即在同一个点双上。</p>
<p>时间复杂度 $O(n\log n)$，主要在lca上。</p>
<p><del>过了之后发现自己写的是边双。。。这都能过</del></p>
<h3 id="L-Traveling-in-the-Grid-World"><a href="#L-Traveling-in-the-Grid-World" class="headerlink" title="L. Traveling in the Grid World"></a>L. Traveling in the Grid World</h3><p>首先，一个非常显然的结论是，最多只可能选择一个中转点。</p>
<p>当 $\gcd(n,m)=1$ 时，不需要选中转点。</p>
<p>否则这个中转点一定在 $y=\frac{m}{n}x$ 附近，且不在上面。</p>
<p>枚举即可。</p>
<h3 id="M-Gitignore"><a href="#M-Gitignore" class="headerlink" title="M. Gitignore"></a>M. Gitignore</h3><p>签到题，用map维护字符串建出树，树形DP即可。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>贪心</tag>
        <tag>思维题</tag>
        <tag>二分</tag>
        <tag>双连通分量</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>2021CCPC网络赛-重赛</title>
    <url>/2021/10/21/2021CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B-%E9%87%8D%E8%B5%9B/</url>
    <content><![CDATA[<p>这次CCPC重赛总算打得好一点了。</p>
<p>可惜最后差一题1012没能做出来。</p>
<p>以后无论何时（尤其是WA的时候）还是要仔细分析队友的做法有没有细节上的问题。</p>
<span id="more"></span>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://acm.hdu.edu.cn/contest/problems?cid=1038">比赛链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h3><p>直接暴力判断即可。</p>
<p>注意一些边界条件。</p>
<h3 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h3><p>队友写了个Miller-Rabin结果T了。</p>
<p>然后我让他打了个表，发现大于等于 $2$ 后都是 $0$。</p>
<p>赛后发现十分显然，两个相邻奇质数的平均数一定不是质数。</p>
<h3 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h3><p>走一圈之后，$x$ 所加的值是固定的，设为 $s$。</p>
<p>根据 $\text{sgn}(n)$，分三种情况讨论即可。</p>
<h3 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h3><p>直接DP即可，然后乘上后面2的 $a$ 的个数次幂。</p>
<h3 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h3><p>假题。。。</p>
<h3 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h3>]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2020 ICPC Asia Macau Regional Contest</title>
    <url>/2021/10/20/The-2020-ICPC-Asia-Macau-Regional-Contest/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/103119">题目链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="A-Accelerator"><a href="#A-Accelerator" class="headerlink" title="A.Accelerator"></a>A.Accelerator</h3><p>对于一个长度为 $k$ 的数组，方案数是确定的，为 $k!(n-k)!$。问题转换成对于每个 $k$，从 $n$ 个数里选择 $k$ 个的乘积之和。</p>
<p>显然为 $[x^k]\prod_{i=1}^n(a_ix+1)$。</p>
<p>分治FFT即可。</p>
<p>15min从开始想到写完，速度还行。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">ll W[M];</span><br><span class="line"><span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				w=W[i+k]*a[i+j+k]%mod;</span><br><span class="line">				a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w);</span><br><span class="line">				a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]*w%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,a[N];</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		Poly B; B.<span class="built_in">clear</span>();</span><br><span class="line">		B.<span class="built_in">pb</span>(<span class="number">1</span>); B.<span class="built_in">pb</span>(a[l]);</span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">solve</span>(l,mid)*<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">ll inv[N],fac[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">Poly A;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">100000</span>);</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">		A=<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,A[i]*fac[i]%mod*fac[n-i]%mod);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*inv[n]%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-Boring-Problem"><a href="#B-Boring-Problem" class="headerlink" title="B.Boring Problem"></a>B.Boring Problem</h3><p>一个显然的做法是：建出AC自动机以后在上面dp，由于有后效性，需要使用高斯消元，时间复杂度 $O((nm)^3)$，没有办法通过。</p>
<p>考虑使用主元法。设 $dep_u$ 表示节点 $u$ 在Trie中的深度。设 $F(x)=0$ 为节点 $x$ 的一个方程。那么有：</p>
<p>$F(x)=1+\sum_{i=1}^kp_iF(ne_{x,i})$。</p>
<p>对于每个方程，可以发现，有些 $ne_{x,i}$ 的深度是大于 $x$ 的，此时 $ne_{x,i}$ 必为 $x$ 在原 Trie中的儿子。</p>
<p>考虑从上往下bfs，每遇到一个 $x$ 时，$ne_{x,i}$ 的深度小于等于 $x$ 的点的方程已经知道了。记 $ne_{x,i}$ 深度大于 $x$ 的个数为 $k$，我们新增 $k-1$ 个未知数，用这 $k-1$ 个未知数和 $F(x)$ 表示出剩下的那一个，这样就刚好有叶子结点个数+1个未知数和方程，就可以解出来了。</p>
<p>时间复杂度 $O(n^3+nm^2k)$。</p>
<h3 id="C-Club-Assignment"><a href="#C-Club-Assignment" class="headerlink" title="C.Club Assignment"></a>C.Club Assignment</h3><p>建出Trie，在Trie上dfs，看什么时候能取到答案。</p>
<p>设 $siz_i$ 表示节点 $i$ 的子树中有多少个数，$dep_i$ 表示$i$ 子树的高度。如果 $siz_{i}\geq 3$，则说明这里面当中一定有两个数在一个集合里，则说明答案至多为 $2^{dep-1}-1$。</p>
<p>于是，如果两个儿子的其中一个的 $siz\geq 3$，那么答案一定在子树内出现，而不用考虑当前子树。</p>
<p>剩下的就是两个子树的 $siz\le 2$，总个数不超过 $4$ 个，暴力枚举集合即可。</p>
<h3 id="D-Artifacts"><a href="#D-Artifacts" class="headerlink" title="D.Artifacts"></a>D.Artifacts</h3><p>简单模拟。</p>
<h3 id="E-Mountain"><a href="#E-Mountain" class="headerlink" title="E.Mountain"></a>E.Mountain</h3><p>大毒瘤计算几何+DP。</p>
<p>或许是自己的实现太拉胯了。。。</p>
<p>对于 $[i,i+1]$ 部分，能覆盖这一段的只有在 $[i-w+1,i+w]$ 区间当中的点。</p>
<p>设 $f_{i,j,s}$ 表示考虑到前 $i$ 点，选了 $j$ 个，前 $2w$ 个点（包括自己）选择的情况为 $s$，只统计到 $[i-w,i-w+1]$ 段的最大值。</p>
<p>那么转移就是枚举上一种的情况，枚举第 $i$ 个点的选择情况，然后得到新的状态 $s_1$，统计出在 $s_1$ 状态下，$[i-w,i-w+1]$ 有多少被覆盖到，设为 $g_{i-w,s_1}$，然后转移就比较简单了。</p>
<p>很容易出错的是这个 $g_{i,j}$ 的计算。训练时没有考虑到覆盖部分并不是一个连续的段，而有可能会分成若干段。那么对于每个选择的点，会有一个覆盖区间，将这些区间的左右端点排序后，扫描线维护一下这个括号序列，然后对于一段覆盖的 $[l,r]$，用基础计算几何知识算出覆盖的面积即可。</p>
<p>时间复杂度 $O(n\times(n+w\log w)\times 2^{2w})$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line">db f[N+<span class="number">20</span>][N][(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)+<span class="number">5</span>];</span><br><span class="line">db g[N+<span class="number">20</span>][<span class="number">1</span>&lt;&lt;<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> n,w,h,m,a[N+<span class="number">20</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x&gt;=<span class="number">2</span>*w+<span class="number">1</span>)&amp;&amp;(x&lt;=n+<span class="number">2</span>*w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&gt;=<span class="number">2</span>*w&amp;&amp;x&lt;=n+<span class="number">2</span>*w;&#125;</span><br><span class="line"><span class="type">int</span> mx,mi;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;<span class="number">0</span>) l=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=mx) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mi)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=mi)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0.0</span>+r-l;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">if</span>(r&gt;=mx)</span><br><span class="line">				<span class="built_in">return</span> (<span class="number">0.0</span>+mx-l+mi-l)/<span class="number">2.</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				x=(<span class="number">0.0</span>+mx-r)/(<span class="number">0.0</span>+mx-mi);</span><br><span class="line">				<span class="keyword">return</span> (<span class="number">0.0</span>+mx-l+mi-l)/<span class="number">2.</span>-x*(mx-r)/<span class="number">2.</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(r&gt;=mx)</span><br><span class="line">		&#123;</span><br><span class="line">			x=(<span class="number">0.0</span>+mx-l)/(<span class="number">0.0</span>+mx-mi);</span><br><span class="line">			<span class="keyword">return</span> x*(mx-l)/<span class="number">2.</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=(<span class="number">0.0</span>+mx-r)/(mx-mi);</span><br><span class="line">			y=(<span class="number">0.0</span>+mx-l)/(mx-mi);</span><br><span class="line">			<span class="keyword">return</span> (x+y)*(r-l)/<span class="number">2.</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,id;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (A.x!=B.x)?A.x&lt;B.x:A.id&lt;B.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node st[<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,now=<span class="number">0</span>;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>*w,n+<span class="number">2</span>*w)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(s,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			mx=<span class="built_in">max</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">			mi=<span class="built_in">min</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">			<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">			top=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">ff</span>(j,<span class="number">0</span>,w&lt;&lt;<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;s)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(i+w-j))</span><br><span class="line">					&#123;</span><br><span class="line">						st[++top]=(node)&#123;a[i+w-j]-h,<span class="number">0</span>&#125;;</span><br><span class="line">						st[++top]=(node)&#123;a[i+w-j]+h,<span class="number">1</span>&#125;;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>&#123;flag=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag||s==<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				g[i][s]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">sort</span>(st+<span class="number">1</span>,st+top+<span class="number">1</span>);</span><br><span class="line">			<span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">			now=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">1</span>,top)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(st[k].id==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					now++;</span><br><span class="line">					<span class="keyword">if</span>(now==<span class="number">1</span>) pre=st[k].x;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> now--;</span><br><span class="line">				<span class="keyword">if</span>(!now)</span><br><span class="line">					g[i][s]+=<span class="built_in">calc</span>(pre,st[k].x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t=(<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*w<span class="number">-1</span>))<span class="number">-1</span>,s1;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n+<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,m)</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,tot)</span><br><span class="line">				f[i][j][s]=<span class="number">-100000000000.00</span>;</span><br><span class="line">	f[<span class="number">2</span>*w][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>*w+<span class="number">1</span>,n+<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,m)</span><br><span class="line">			<span class="built_in">ff</span>(s,<span class="number">0</span>,tot)</span><br><span class="line">			&#123;</span><br><span class="line">				s1=((s&amp;t)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(f[i<span class="number">-1</span>][j][s]&gt;=<span class="number">0</span>)</span><br><span class="line">					f[i][j][s1]=<span class="built_in">max</span>(f[i][j][s1],f[i<span class="number">-1</span>][j][s]+g[i-w][s1]);</span><br><span class="line">				s1++;</span><br><span class="line">				<span class="keyword">if</span>(j&amp;&amp;f[i<span class="number">-1</span>][j<span class="number">-1</span>][s]&gt;=<span class="number">0</span>&amp;&amp;i&lt;=m+(w&lt;&lt;<span class="number">1</span>))</span><br><span class="line">					f[i][j][s1]=<span class="built_in">max</span>(f[i][j][s1],f[i<span class="number">-1</span>][j<span class="number">-1</span>][s]+g[i-w][s1]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>,f[n+<span class="number">2</span>][i][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); w=<span class="built_in">read</span>(); h=<span class="built_in">read</span>();</span><br><span class="line">	tot=<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*w);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i+<span class="number">2</span>*w]=<span class="built_in">read</span>();</span><br><span class="line">	m=n+<span class="number">4</span>*w;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">solve</span>(m,n,w);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-Fixing-Networks"><a href="#F-Fixing-Networks" class="headerlink" title="F.Fixing Networks"></a>F.Fixing Networks</h3><p>构造题。</p>
<p>除去特殊情况后，剩下的每次用 $d+1$ 个点形成的完全图去用掉一个颜色。最后剩下 $m=n-(d+1)(c-1)$ 个点，需要每个点的度数为 $d$，且图连通。</p>
<p>那么对于 $d$ 为偶数的情况，每个点 $i$ 向 $(i+j)\bmod m(j\le \frac{d}{2})$ 连边。</p>
<p>$d$ 为奇数也同理，每个点多连一条边即可。</p>
<h3 id="G-Game-on-Sequence"><a href="#G-Game-on-Sequence" class="headerlink" title="G.Game on Sequence"></a>G.Game on Sequence</h3><p>设 $f_i$ 表示从 $i$ 开始是否必胜。</p>
<p>那么对于所有的 $j$ 满足题意，只要有一个 $f_j=0$，那么 $f_i=1$，否则 $f_i=0$。</p>
<p>对于一个 $i,j$，满足 $i&lt;j$ 且 $a_i=a_j$，那么 $f_i$ 必定为 $1$：</p>
<ol>
<li><p>若 $f_j=0$，显然 $f_i=1$。</p>
</li>
<li><p>若 $f_j=1$，那么存在一个 $k$，使得 $j$ 能到 $k$ 且 $f_k=0$，那么这个 $i$ 也能到 $k$，因此 $f_i=1$。</p>
</li>
</ol>
<p>于是设 $las_i$ 表示 $a_j=i$ 的最大的下标 $j$，若 $i\neq las_{a_i}$，那么 $f_i=1$，</p>
<p>否则暴力枚举剩下的情况。</p>
<p>时间复杂度 $O(na\log a)$。</p>
<h3 id="H-Fly-Me-To-The-Moon"><a href="#H-Fly-Me-To-The-Moon" class="headerlink" title="H.Fly Me To The Moon"></a>H.Fly Me To The Moon</h3><p>留坑…</p>
<h3 id="I-Nim-Cheater"><a href="#I-Nim-Cheater" class="headerlink" title="I.Nim Cheater"></a>I.Nim Cheater</h3><p>设 $f_{u,i}$ 表示点 $u$ 的路径中，异或和为 $i$ 的最大值。</p>
<p>方程为 $f_{u,i}=f_{fa_u,i\bigoplus a_u}+val_u$。</p>
<p>为了使空间比较小，可以用如下性质：</p>
<p>重链剖分后，每个点到根节点的路径中，遇到到轻链的个数不超过 $\log_2 n$。</p>
<p>于是，设 $f’_{dep,i}$ 表示当前点到树上路径中，遇到轻链个数为 $dep$ 时的DP值。</p>
<p>类似于树上启发式合并，我们先走轻链，走完后全部清空。然后走重链，走重链时 $dep$ 不更新。</p>
<p>这样就能保证空间复杂度为 $O(n+a\log n)$ 了。</p>
<h3 id="J-Jewel-Grab"><a href="#J-Jewel-Grab" class="headerlink" title="J.Jewel Grab"></a>J.Jewel Grab</h3><p>设 $pre_x$ 表示 $x$ 前第一个颜色相同的下标。</p>
<p>那也就是找到最大的 $r$，使得 $\sum_{i=l}^r [pre_i\geq l]\le k$。</p>
<p>由于 $k\le 10$ 的限制，考虑每次暴力找到最大的下标 $r$ 满足大于等于当前的下标 $now$ 且 $[now,r]$ 间的 $pre$ 均小于 $l$。</p>
<p>线段树二分找到这个 $r$。</p>
<p>然后还需动态维护 $pre$ 数组，以及需要对每个颜色维护最大值，以确定需要跳过哪些数。</p>
<p>时间复杂度 $O(nk\log n)$。</p>
<p>代码巨长。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line"><span class="type">int</span> n,m,pre[N],val[N],col[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line"><span class="type">int</span> mi[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll sum[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum[u]=sum[lc]+sum[rc];</span><br><span class="line">	mi[u]=<span class="built_in">max</span>(mi[lc],mi[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		mi[u]=pre[l]; sum[u]=val[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		mi[u]=pre[l]; sum[u]=val[l]; <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=mid) <span class="built_in">update</span>(ls,p);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">update</span>(rs,p);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> sum[u];</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) ans+=<span class="built_in">ask</span>(ls,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  ans+=<span class="built_in">ask</span>(rs,L,R);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(mi[lc]&gt;=s&amp;&amp;p&lt;=mid) ans=<span class="built_in">query</span>(ls,p,s);</span><br><span class="line">	<span class="keyword">if</span>(ans!=<span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">if</span>(mi[rc]&gt;=s) ans=<span class="built_in">query</span>(rs,p,s);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	val[x]=v;</span><br><span class="line">	<span class="keyword">auto</span> it=s[col[x]].<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	<span class="keyword">auto</span> it2=it;</span><br><span class="line">	it--;</span><br><span class="line">	it2++;</span><br><span class="line">	<span class="keyword">if</span>(it2!=s[col[x]].<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		y=(*it2); pre[y]=(*it);</span><br><span class="line">		<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	s[col[x]].<span class="built_in">erase</span>(x);</span><br><span class="line">	col[x]=c;</span><br><span class="line">	s[col[x]].<span class="built_in">insert</span>(x);</span><br><span class="line">	it2=it=s[col[x]].<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	it2--;</span><br><span class="line">	pre[x]=(*it2);</span><br><span class="line">	<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,x);</span><br><span class="line">	it++;</span><br><span class="line">	<span class="keyword">if</span>(it!=s[col[x]].<span class="built_in">end</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		y=(*it); pre[y]=x;</span><br><span class="line">		<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tag[N],bel[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(tag,<span class="number">-1</span>,<span class="built_in">sizeof</span>(tag));</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) s[i].<span class="built_in">insert</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		col[i]=<span class="built_in">read</span>(),val[i]=<span class="built_in">read</span>();</span><br><span class="line">		pre[i]=*(--s[col[i]].<span class="built_in">end</span>());</span><br><span class="line">		s[col[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> opt,l,x,k,y,c,v;m--;)</span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); c=<span class="built_in">read</span>(); v=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">change</span>(x,c,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">			<span class="type">int</span> now=l,r;</span><br><span class="line">			<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">			ll ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(;k&gt;=<span class="number">0</span>&amp;&amp;now&lt;=n;k--)</span><br><span class="line">			&#123;</span><br><span class="line">				r=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,now,l);</span><br><span class="line">				<span class="built_in">assert</span>(r&lt;=n);</span><br><span class="line">				<span class="keyword">if</span>(r==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,now,n);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(now&lt;r) ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,now,r<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">if</span>(k&lt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">				c=col[r];</span><br><span class="line">				<span class="keyword">if</span>(tag[c]!=m)</span><br><span class="line">				&#123;</span><br><span class="line">					tag[c]=m;</span><br><span class="line">					bel[c]=pre[r];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(val[r]&gt;val[bel[c]])</span><br><span class="line">				&#123;</span><br><span class="line">					ans-=val[bel[c]];</span><br><span class="line">					ans+=val[r];</span><br><span class="line">					bel[c]=r;</span><br><span class="line">				&#125;</span><br><span class="line">				now=r+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K-Candy-Ads"><a href="#K-Candy-Ads" class="headerlink" title="K.Candy Ads"></a>K.Candy Ads</h3><p>大毒瘤题。</p>
<p>2-SAT模型，关键是如何建图。</p>
<p>用bitset存下哪两个广告间有可能重复。</p>
<p>用Kosaraju算法跑出SCC，关键是如何快速跳过已选过的点。</p>
<p>再开两个bitset，存下 $2n$ 个点中哪些点已经遍历过了。</p>
<p>超级无敌卡空间，只能开得下 $50000\times 50000$ 的bitset。</p>
<p>过于毒瘤，并不想写代码。。。</p>
<h3 id="L-Random-Permutation"><a href="#L-Random-Permutation" class="headerlink" title="L.Random Permutation"></a>L.Random Permutation</h3><p>简单数学题，答案为 $\frac{(n!)^2}{n^n}$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>计算几何</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>最小树形图</title>
    <url>/2021/09/23/%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<p>最小树形图的一些总结。</p>
<span id="more"></span>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>给定一个 $n$ 个点 $m$ 条边的带边权的有向图，给定一个根 $rt$，问一棵以 $rt$ 为根的外向生成树的边权和的最小值。</p>
<p>$n\le 100,m\le 10^4$。</p>
<p>$n\le 10^5,m\le 5\times 10^5$。</p>
<h2 id="朱-刘算法"><a href="#朱-刘算法" class="headerlink" title="朱-刘算法"></a>朱-刘算法</h2><p>除根节点 $rt$ 外，对于其他所有的点 $u$，记 $in[u]$ 连向 $u$ 的边中最短的边的权值，$pre[u]$ 为这条边的入点。</p>
<p>如果这些边不构成环，那么直接选这些边就是答案了。</p>
<p>如果构成环，考虑将一个环缩成一个点，变成一个子问题。</p>
<p>用反悔贪心，对于环内的点形成的边全部删掉，新建一个节点 $w$，对于环上的每个点 $v$，对于原图所有的边 $(u,v,z)$，其中 $u$ 不在环上，将这条边改成 $(u,w,z-in[v])$。</p>
<p>然后将环中所有的 $in[v]$ 都加进答案 $ans$ 里。然后考虑新图的答案。</p>
<p>如果遇到某个 $rt$ 外的点没有入边，则无解。</p>
<p>每次图至少减少一个点，每次的时间复杂度为 $O(n+m)=O(m)$。时间复杂度 $O(nm)$。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>这个优化是Tarjan提出的，能将算法优化到 $O(n+m\log m)$。</p>
<p>考虑将朱-刘算法的步骤改一下，变成每次加一条边进去，答案加上这条边的权值，这条边的出点为上一次加进去的入点。直到碰到已加入的点为止。如果成环则处理这个环，否则不处理。</p>
<p>重复上面的过程，直到所有点都被标记过，用并查集维护每个点在新图中被合并成哪个点。</p>
<p>考虑处理一个环会发生什么，将所有边扔进去出点中形成一个集合，相当于删掉这个集合中的一个，剩下的同时减去一个值，然后合并，且会查询最小值。</p>
<p>这个显然可以用带懒惰删除的和整体加标记的可并小根堆维护。</p>
<p>时间复杂度 $O(m\log m)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>需要注意的是，处理完环后，可并堆中维护的节点信息会改变，查询最小值时需要用并查集更新找到当前连着的真正的点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> val,v,id;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.val&gt;B.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">	node v[N];</span><br><span class="line">	<span class="type">int</span> dis[N],ls[N],rs[N],tag[N];</span><br><span class="line">	<span class="type">bool</span> del[N];</span><br><span class="line">	<span class="type">int</span> rt[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u) tag[u]+=t,v[u].val+=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushtag</span>(ls[u],tag[u]);</span><br><span class="line">		<span class="built_in">pushtag</span>(rs[u],tag[u]);</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="keyword">if</span>(v[x].val&gt;v[y].val) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">pushtag</span>(y,-tag[x]);</span><br><span class="line">		rs[x]=<span class="built_in">merge</span>(rs[x],y);</span><br><span class="line">		<span class="keyword">if</span>(dis[ls[x]]&lt;dis[rs[x]]) <span class="built_in">swap</span>(ls[x],rs[x]);</span><br><span class="line">		dis[x]=dis[rs[x]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">pushdown</span>(x);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">merge</span>(ls[x],rs[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> va,<span class="type">int</span> id,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		v[id]=(node)&#123;va,to,id&#125;;</span><br><span class="line">		rt[y]=<span class="built_in">merge</span>(rt[y],id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> v)</span> </span>&#123;<span class="built_in">pushtag</span>(id,-v);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> node <span class="title">top</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;rt[u]&amp;&amp;<span class="built_in">find</span>(v[rt[u]].v)==u;) rt[u]=<span class="built_in">pop</span>(rt[u]);</span><br><span class="line">		<span class="keyword">if</span>(!rt[u]) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);&#125;</span><br><span class="line">		v[rt[u]].v=<span class="built_in">find</span>(v[rt[u]].v);</span><br><span class="line">		<span class="keyword">return</span> v[rt[u]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Heap h;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u=<span class="built_in">find</span>(u); v=<span class="built_in">find</span>(v);</span><br><span class="line">	<span class="keyword">if</span>(u==v) <span class="keyword">return</span>;</span><br><span class="line">	h.rt[v]=h.<span class="built_in">merge</span>(h.rt[u],h.rt[v]),fa[u]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,rt,pre[N],bel[N];</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); rt=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">read</span>();</span><br><span class="line">		h.<span class="built_in">ins</span>(y,z,i,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt=n;</span><br><span class="line">	node now;</span><br><span class="line">	bel[rt]=rt;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n&lt;&lt;<span class="number">1</span>) fa[i]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=i;</span><br><span class="line">		<span class="keyword">for</span>(;!bel[j];)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(!bel[j]) bel[j]=i,now=h.<span class="built_in">top</span>(j),ans+=now.val,j=now.v;</span><br><span class="line">			<span class="keyword">if</span>(bel[j]!=i) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(;bel[j]!=<span class="number">-1</span>;) bel[j]=<span class="number">-1</span>,j=pre[j]=(now=h.<span class="built_in">top</span>(j)).v,h.<span class="built_in">dec</span>(now.id,now.val);</span><br><span class="line">			++cnt;</span><br><span class="line">			<span class="keyword">for</span>(;bel[j]!=i;) bel[j]=i,<span class="built_in">Union</span>(j,cnt),j=pre[j];</span><br><span class="line">			j=cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>最小树形图</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC 2019-2020 North-Western Russia Regional Contest</title>
    <url>/2021/09/18/ICPC-2019-2020-North-Western-Russia-Regional-Contest/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/102411/attachments/download/9664/statements.pdf">题目链接</a></p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="A-Accurate-Movement"><a href="#A-Accurate-Movement" class="headerlink" title="A. Accurate Movement"></a>A. Accurate Movement</h3><p>模拟即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> a,b,n,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a=<span class="built_in">read</span>(); b=<span class="built_in">read</span>(); n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> d=b-a;</span><br><span class="line">	<span class="keyword">for</span>(;b&lt;n;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a&lt;n) a=b,ans++;</span><br><span class="line">		b+=d,ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a&lt;n) a=b,ans++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B-Bad-Treap"><a href="#B-Bad-Treap" class="headerlink" title="B. Bad Treap"></a>B. Bad Treap</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>找出 $n$ 个在 <code>int</code> 范围内的整数，满足</p>
<p>$a_i&lt;a_{i+1}$ 且 $\sin(a_i)&lt;\sin(a_{i+1})$。</p>
<p>$n\le 50000$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>设 $a_i=k(i+b)$，那也就是要找一个整数 $k$，使得 $k&gt;2\omega \pi$ 且 $k-2\omega \pi$ 的值尽量小。</p>
<p>打表发现，$k=710$ 效果很好。</p>
<h3 id="C-Cross-Stitch"><a href="#C-Cross-Stitch" class="headerlink" title="C. Cross-Stitch"></a>C. Cross-Stitch</h3><p>答案下界显然是 $4n-1$，其中 $n$ 为 <code>X</code> 的个数。</p>
<p>可以发现，每个 <code>X</code> 中距离为 $1$ 的情况只需要用到竖着的两条。因为只用竖着的两条，最终可以回到本身这个节点，也可以去到原节点同一列的节点上。</p>
<p>建出图后，跑个有限制的欧拉回路就可以了。</p>
<p>比赛的时候忘在dfs里加限制了。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">600000</span>;</span><br><span class="line"><span class="type">int</span> n,m,st[N],top;</span><br><span class="line"><span class="type">int</span> ver[N],ne[N],head[N],tot=<span class="number">1</span>,n1,n2;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y*n1+z*n2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> las)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> &amp;i=head[u];i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]&amp;&amp;(las==<span class="number">-1</span>||((u/n2)!=(ver[i]/n2)||(las!=ver[i]/n2))))</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(ver[i],(u/n2)==(ver[i]/n2)?ver[i]/n2:<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	st[++top]=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pr</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x%=n2;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x/n1,x%n1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">print</span>(k<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(st[k]-st[k<span class="number">-1</span>])!=n2)</span><br><span class="line">		<span class="built_in">pr</span>(st[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">swap</span>(n,m);</span><br><span class="line">	n1=(<span class="built_in">max</span>(n,m)+<span class="number">5</span>); n2=(<span class="built_in">max</span>(n,m)+<span class="number">5</span>)*(<span class="built_in">max</span>(n,m)+<span class="number">5</span>);</span><br><span class="line">	<span class="type">int</span> xx=<span class="number">-1</span>,yy=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">			<span class="keyword">if</span>(s[j]==<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">					<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">						<span class="built_in">add</span>(<span class="built_in">id</span>(i-a,j-b,<span class="number">0</span>),<span class="built_in">id</span>(i-a,j-b,<span class="number">1</span>));</span><br><span class="line">				<span class="built_in">add</span>(<span class="built_in">id</span>(i<span class="number">-1</span>,j,<span class="number">1</span>),<span class="built_in">id</span>(i,j,<span class="number">1</span>));</span><br><span class="line">				<span class="built_in">add</span>(<span class="built_in">id</span>(i<span class="number">-1</span>,j<span class="number">-1</span>,<span class="number">1</span>),<span class="built_in">id</span>(i,j<span class="number">-1</span>,<span class="number">1</span>));</span><br><span class="line">				<span class="built_in">add</span>(<span class="built_in">id</span>(i<span class="number">-1</span>,j<span class="number">-1</span>,<span class="number">0</span>),<span class="built_in">id</span>(i,j,<span class="number">0</span>));</span><br><span class="line">				<span class="built_in">add</span>(<span class="built_in">id</span>(i<span class="number">-1</span>,j,<span class="number">0</span>),<span class="built_in">id</span>(i,j<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">				xx=i; yy=j;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(xx==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum*<span class="number">4</span><span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="built_in">id</span>(xx,yy,<span class="number">0</span>),<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">print</span>(top);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-Double-Palindrome"><a href="#D-Double-Palindrome" class="headerlink" title="D. Double Palindrome"></a>D. Double Palindrome</h3><p>看来长时间没看，Border和回文理论有些忘了，在这写下证明吧QAQ。</p>
<h4 id="一些证明"><a href="#一些证明" class="headerlink" title="一些证明"></a>一些证明</h4><p><strong>引理1(Weak Periodicity Lemma)：对一字符串 $s$，若 $p,q$ 为 $s$ 的周期，且 $p+q\le |s|$，则 $\gcd(p,q)$ 为 $s$ 的周期。</strong></p>
<p>证明：</p>
<p>不妨设 $p\geq q$。设 $d=p-q$。</p>
<p>由 $p,q$ 为 $s$ 的周期，可知：$s_i=s_{i+p}(i\le |s|-p),s_i=s_{i+q}(i\le |s|-q)$。</p>
<p>当 $i&gt; |q|$ 时，$s_i=s_{i-q}=s_{i-q+p}=s_{i+d}$。</p>
<p>当 $i\le |s|-p$ 时，$s_i=s_{i+p}=s_{i+p-q}=s_{i+d}$。</p>
<p>因此 $d=p-q$ 为 $s$ 的一个周期。</p>
<p>由辗转相除法，$\gcd(p,q)$ 为 $s$ 的周期。</p>
<p>证毕。</p>
<p>注意：真正的周期引理的限制条件可改为 $p+q-\gcd(p,q)\le |s|$。</p>
<p><strong>引理2：若一字符串 $s$ 可以表示成至少两种不同的非空双回文划分，则字符串 $s$ 为整周期串。</strong></p>
<p>证明：</p>
<p>记 $s[l,r]$ 表示字符串 $s$ 从第 $l$ 到第 $r$ 位形成的子串。</p>
<p>设 $s$ 的两种非空双回文划分为：$s[1,x]+s[x+1,|s|],s[1,y]+s[y+1,|s|]$，其中 $1\le x &lt; y &lt; |s|$，且 $s[1,x],s[x+1,s],s[1,y],s[y+1,|s|]$ 均为回文串。</p>
<p>可以发现，$y-x$ 和 $|s|-(y-x)$ 均为 $s$ 的周期，</p>
<p>由引理一，$\gcd(y-x,|s|-(y-x))=\gcd(y-x,|s|)$ 也为 $s$ 的周期。</p>
<p>而 $\gcd(y-x,|s|)|s$，证毕。</p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>用前 $k$ 个小写字符，组成长度至多为 $n$ 的字符串。</p>
<p>问有多少个串是弱双回文划分。</p>
<p>$n\le 10^5$，</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>首先，设一个 $g(n)$ 表示暴力划分的双回文的种类数。</p>
<p>$g(n)=\sum_{i=1}^nk^{\lfloor \frac{i+1}{2}\rfloor}k^{\lfloor \frac{n-i+1}{2}\rfloor}$。</p>
<p>这样统计显然会算重，而多的自然是能被两种及以上划分的字符串。</p>
<p>由引理二，这样的字符串为整周期串。</p>
<p>于是，我们统计字符串的时候只统计只有一种划分的字符串，设长度为 $i$ 的合法字符串个数为 $f(i)$，那么答案就是 $\sum_{i=1}^nf(i)\lfloor \frac{n}{i} \rfloor$。</p>
<p>考虑求出 $f(n)$，用 $g(n)$ 减去不合法的方案，枚举整周期串的最小正周期 $i$，那么复制 $\frac{n}{i}$ 倍后形成的串就在 $g(n)$ 中算了 $\frac{n}{i}$ 次，减去即可。$f(n)=g(n)-\sum_{i\neq n,i|n} f(i)\frac{n}{i}$。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll f[<span class="number">100010</span>],g[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		f[i]=g[i]=<span class="built_in">Add</span>(<span class="built_in">Mul</span>(i/<span class="number">2</span>,<span class="built_in">Pow</span>(k,(i+<span class="number">1</span>)/<span class="number">2</span>)),<span class="built_in">Mul</span>((i+<span class="number">1</span>)/<span class="number">2</span>,<span class="built_in">Pow</span>(k,(i+<span class="number">2</span>)/<span class="number">2</span>)));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">2</span>,n/i)</span><br><span class="line">			f[i*j]=<span class="built_in">Dec</span>(f[i*j],f[i]*j%mod);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,f[i]*(n/i)%mod);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-Equidistant"><a href="#E-Equidistant" class="headerlink" title="E. Equidistant"></a>E. Equidistant</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>一棵树，给定 $m$ 个点，问是否存在一个点，使得该点到另外 $m$ 个点的距离相同。</p>
<p>$n,m\le 2\times 10^5$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>$m$ 个点一起bfs即可。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t[N],vis[N],d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(t[u]==m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;YES\n%d&quot;</span>,u);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!d[v]||d[v]==d[u]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">				t[v]+=t[u];</span><br><span class="line">				<span class="keyword">if</span>(!vis[v])</span><br><span class="line">				&#123;</span><br><span class="line">					vis[v]=<span class="number">1</span>; q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),q.<span class="built_in">push</span>(x),vis[x]=<span class="number">1</span>,d[x]=<span class="number">1</span>,t[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="H-High-Load-Database"><a href="#H-High-Load-Database" class="headerlink" title="H. High Load Database"></a>H. High Load Database</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一个数组，将数组分为若干段连续的子段，使得每个子段之和不超过 $k$。</p>
<p>$m$ 次询问，每次询问给定 $k$，问最少的段数。</p>
<p>$n\le 2\times 10^5,q\le 10^5,\sum a_i\le 10^6,a_i\geq 1$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>$\sum a_i\le 10^6$，可以发现对于每个 $k$，如果暴力用二分求出答案，时间复杂度大概是 $O(\frac{n}{k}\log n)$。</p>
<p>因此，通过记忆化的方法，$q$ 次询问总的最坏的复杂度就是 $O(n\log q\log n)$。</p>
<h3 id="J-Just-the-Last-Digit"><a href="#J-Just-the-Last-Digit" class="headerlink" title="J. Just the Last Digit"></a>J. Just the Last Digit</h3><p>从小到大枚举 $i$，枚举 $j$，然后判断 $i,j$ 是否有边相连。</p>
<p>判断的方法是算出除 $(i,j)$ 边外 $i$ 到 $j$ 路径条数模 $10$ 后的结果即可。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h3 id="L-Lengths-and-Periods"><a href="#L-Lengths-and-Periods" class="headerlink" title="L. Lengths and Periods"></a>L. Lengths and Periods</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>对一字符串 $|s|$，设 $\alpha$ 为最大的 $\frac{|s|}{|t|}$，使得 $t$ 为 $s$ 的周期。</p>
<p>给定一字符串，问该字符串的子串最大的 $\alpha$ 是多少。</p>
<p>$|s|\le 2\times 10^5$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>题目所求转换为：</p>
<p>选择任意两个后缀 $i,j(i&lt;j)$，求出 $lcp(i,j)$，求 $\frac{lcp(i,j)+(j-i)}{j-i}$ 的最大值。</p>
<p>于是可以建出 SA，求出height数组，然后启发式合并即可。</p>
<p>时间复杂度 $O(n\log ^2n)$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>容斥原理</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-2020 ICPC Asia Hong Kong Regional Contest</title>
    <url>/2021/09/15/2019-2020-ICPC-Asia-Hong-Kong-Regional-Contest/</url>
    <content><![CDATA[<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p><a href="https://codeforces.com/gym/102452/problems">CF链接</a></p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="A-Axis-of-Symmetry"><a href="#A-Axis-of-Symmetry" class="headerlink" title="A. Axis of Symmetry"></a>A. Axis of Symmetry</h3><p>显然，对称轴最多只有4条。且这四条可以很容易算出来。</p>
<p>如何判断是否轴对称？只需要将在重合的边删掉就可以了。</p>
<h3 id="B-Binary-Tree"><a href="#B-Binary-Tree" class="headerlink" title="B. Binary Tree"></a>B. Binary Tree</h3><p>一棵满二叉树的节点个数定为奇数。</p>
<p>因此节点总数为偶数的情况必定会转移至奇数，反之亦然。</p>
<p>于是判断奇偶性即可。</p>
<h3 id="C-Constructing-Ranches"><a href="#C-Constructing-Ranches" class="headerlink" title="C. Constructing Ranches"></a>C. Constructing Ranches</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一棵树，带点权。求有多少条路径，满足以路径中所有点权作为长度的线段，能在平面内形成一个多边形。</p>
<p>$n\le 2\times 10^5,value_i\le 10^9$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>一堆数能形成多边形的充要条件是 $\sum a_i &gt; 2\max\{a_i\}$。</p>
<p>点分治，用容斥的方法统计答案。</p>
<p>按照最大值从小到大排序，枚举一条路径 $a$，然后看有多少个在这个之前的 $b$ 满足 $len_a+len_b&gt;2max_a$。</p>
<p>这个可以离散化后二分+树状数组查询。</p>
<p>时间复杂度 $O(n\log ^2n)$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">	<span class="type">int</span> n,tim;</span><br><span class="line">	<span class="type">int</span> t[N],b[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x++;</span><br><span class="line">		<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">			<span class="keyword">if</span>(t[x]!=tim) t[x]=tim,b[x]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> b[x]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x++;</span><br><span class="line">		<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))</span><br><span class="line">			<span class="keyword">if</span>(t[x]==tim)</span><br><span class="line">				s+=b[x];</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> BIT::ask;</span><br><span class="line"><span class="keyword">using</span> BIT::add;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> siz[N],mx[N],val[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> S,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; mx[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v]&amp;&amp;v!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">getroot</span>(v,S,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[u],S-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(mx[rt]&gt;mx[u]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	<span class="type">int</span> mx; ll d;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> line &amp;A,<span class="type">const</span> line &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.mx&lt;B.mx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;line&gt; vec;</span><br><span class="line">vector&lt;ll&gt; num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll s,<span class="type">int</span> mx,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec.<span class="built_in">pb</span>((line)&#123;mx,s&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v]&amp;&amp;v!=pre)</span><br><span class="line">			<span class="built_in">dfs</span>(v,s+val[v],<span class="built_in">max</span>(mx,val[v]),u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,ll s,<span class="type">int</span> mx,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	vec.<span class="built_in">clear</span>(); num.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(u,val[u],<span class="built_in">max</span>(mx,val[u]),<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec) num.<span class="built_in">pb</span>(v.d);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(num));</span><br><span class="line">	num.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(num))-num.<span class="built_in">begin</span>());</span><br><span class="line">	BIT::tim++; BIT::n=num.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=<span class="built_in">ask</span>(<span class="built_in">upper_bound</span>(<span class="built_in">all</span>(num),<span class="number">2ll</span>*v.mx-v.d-s)-num.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="built_in">add</span>(<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(num),v.d)-num.<span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	ans+=sum*opt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(u,-val[u],<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v])</span><br><span class="line">			<span class="built_in">solve</span>(v,val[u],val[u],<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> si=siz[v]&gt;siz[u]?S-siz[u]:siz[v];</span><br><span class="line">			rt=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">getroot</span>(v,si,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">divide</span>(rt,si);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) vis[i]=siz[i]=mx[i]=<span class="number">0</span>,adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) val[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">		mx[<span class="number">0</span>]=<span class="number">1e9</span>; rt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">getroot</span>(<span class="number">1</span>,n,<span class="number">0</span>); <span class="built_in">divide</span>(rt,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-Defining-Labels"><a href="#D-Defining-Labels" class="headerlink" title="D. Defining Labels"></a>D. Defining Labels</h3><p>签到题。转换进制就可以了。</p>
<h3 id="E-Erasing-Numbers"><a href="#E-Erasing-Numbers" class="headerlink" title="E. Erasing Numbers"></a>E. Erasing Numbers</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一长度为奇数的排列，每次能在相邻三个数中删去三个数中的最大与最小值。</p>
<p>对于每个 $i$，问能否通过某种删除方式使得最后剩下的数在原数组中下标为 $i$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>枚举第 $i$ 个数，将小于 $i$ 的看成 <code>0</code>，大于 $i$ 个的看成 <code>1</code>，自己看成 <code>X</code>。</p>
<p>对于 <code>X</code> 处，不能含有两个 <code>1</code> 或 <code>0</code>。</p>
<p>假设在 <code>X</code> 处删完后，还将剩下若干个 <code>1</code> 或若干个 <code>0</code>。</p>
<p>于是大胆猜测能剩下 <code>X</code> 的当且仅当存在一种方法使得删一些东西后 <code>1</code> 和 <code>0</code> 个数相同。</p>
<p>显然连续三个相同的可以满足。</p>
<p>但可以发现，<code>00100</code> 这样也是可以的。</p>
<p>于是，对于一个连续的序列，|<code>0</code> 的个数 - <code>1</code> 的个数| 大于等于 $3$ 时，可以让差值减少 $2$。</p>
<p>用 <code>X</code> 将序列分成两半，分开处理，用类似求最大子段和的形式去做即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<p>显然可以做到 $O(n)$。</p>
<h3 id="G-Game-Design"><a href="#G-Game-Design" class="headerlink" title="G. Game Design"></a>G. Game Design</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>对于一棵有根树，每个叶子结点中一个怪物。每个点 $i$ 可以设置一个塔，价格为 $a_i$，覆盖 $i$ 中子树的所有怪物。</p>
<p>一种方案为某种设置塔的方案，使得覆盖所有怪物。方案的价值为塔的价值之和。</p>
<p>构造出一棵树，使得取到最小价值的方案数恰为 $k$。</p>
<p>$k\le 10^9$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>设 $f(T)$ 表示树 $T$ 的最小价值，$g(T)$ 表示树 $T$ 取得最小价值的方案数。</p>
<p>那么将 $T_1,T_2$ 合并，得到一个方案数为 $g(T_1)\times g(T_2)$ 的操作是：建立一个新的根节点，权值为 $f(T_1)+f(T_2)+1$，根节点连向 $T_1,T_2$。</p>
<p>但是，仅有乘法操作是不够的，考虑加法操作：新建一个根节点，权值为 $f(T)$，将根节点与 $T$ 的根节点相连，就得到了一个方案数为 $g(T)+1$ 的树。</p>
<p>记录 $f(T)$  的值，传下当前需要的 $g(T)$ 值，分治处理。</p>
<p>时间复杂度 $O(\log k)$。</p>
<h3 id="I-Incoming-Asteroids"><a href="#I-Incoming-Asteroids" class="headerlink" title="I. Incoming Asteroids"></a>I. Incoming Asteroids</h3><p>鸽巢原理，如果最终要变为 $0$，那么至少有其中一个要得到 $\lceil \frac{y}{k}\rceil$。</p>
<p>开若干个 set 记录当前的值。每次若有成员满足超过了 $\lceil \frac{y}{k}\rceil$，$y$ 至少变成原来的 $\frac{2}{3}$。</p>
<p>时间复杂度 $O(m\log n\log y)$。</p>
<h3 id="J-Junior-Mathematician"><a href="#J-Junior-Mathematician" class="headerlink" title="J. Junior Mathematician"></a>J. Junior Mathematician</h3><p>数位DP模板。。</p>
<h3 id="K-Key-Project"><a href="#K-Key-Project" class="headerlink" title="K. Key Project"></a>K. Key Project</h3><p>贪心，模拟费用流，时间复杂度 $O(nm)$。</p>
]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>模拟费用流</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-2019 ACM-ICPC, Asia Shenyang Regional Contest</title>
    <url>/2021/09/08/2018-2019-ACM-ICPC-Asia-Shenyang-Regional-Contest/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/gym/101955/">比赛</a></p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个人可能注册多个账号，一个人的主账号最多能对应 $2$ 个副账号。</p>
<p>副账号名与主账号名能配对当且仅当其最长公共子串之长等于主副账号长度的较小值。</p>
<p>给定 $n$ 个长度上限为 $10$ 的主账号名，$m$ 个长度上限为 $10$ 的副账号名。</p>
<p>问有多少种配对的情况。两种配对方案不同当且仅当存在某个副账号对应的主账号不同。</p>
<p>保证所有账号名均不相同。</p>
<p>$T\le 100,n,m\le 1000$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>建出Trie树以后，配对关系变为祖先关系。</p>
<p>考虑Trie上进行树形DP，设 $f_{u,a,b}$ 表示考虑到子树 $u$ 的时候，子树中有 $a$ 个主账号要与上面的匹配，有 $b$ 个副账号要与上面的主账号匹配的方案数。答案显然为 $f_{root,0,0}$。</p>
<p>显然当 $a\le 10,b\le 20$ 时，$f$ 值才有意义。</p>
<p>考虑 $f$ 的转移，相当于是一个二维的树形背包，然后合并完子树后再单独考虑根节点的贡献。</p>
<p>由于树形背包的性质，时间复杂度 $O(T\times 10\times 10\times 20\times (n+m))$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ADD</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x+=y; (x&lt;mod)?<span class="number">0</span>:x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> ne[N][S];</span><br><span class="line"><span class="type">int</span> f[N][M][M],g[M][M],tp[N],siz;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,siz)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">25</span>) ne[i][j]=<span class="number">0</span>;</span><br><span class="line">		tp[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	siz=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),u=<span class="number">1</span>,c;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!ne[u][c]) ne[u][c]=++siz;</span><br><span class="line">		u=ne[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	tp[u]=opt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>) <span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>) f[u][a][b]=<span class="number">0</span>;</span><br><span class="line">	f[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(t,<span class="number">0</span>,<span class="number">25</span>)</span><br><span class="line">	<span class="keyword">if</span>(ne[u][t])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=ne[u][t];</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">				<span class="keyword">if</span>(f[u][a][b])</span><br><span class="line">					<span class="built_in">fo</span>(c,<span class="number">0</span>,<span class="number">10</span>-a)</span><br><span class="line">						<span class="built_in">fo</span>(d,<span class="number">0</span>,<span class="number">20</span>-b)</span><br><span class="line">							<span class="keyword">if</span>(f[v][c][d])</span><br><span class="line">								<span class="built_in">ADD</span>(g[a+c][b+d],<span class="built_in">Mul</span>(f[u][a][b],f[v][c][d]));</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>) <span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>) f[u][a][b]=g[a][b],g[a][b]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tp[u]==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">			<span class="keyword">if</span>(f[u][a][b])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ADD</span>(g[a][b],f[u][a][b]);</span><br><span class="line">				<span class="keyword">if</span>(a&lt;=<span class="number">9</span>) <span class="built_in">ADD</span>(g[a+<span class="number">1</span>][b],f[u][a][b]);</span><br><span class="line">				<span class="keyword">if</span>(a&lt;=<span class="number">8</span>) <span class="built_in">ADD</span>(g[a+<span class="number">2</span>][b],<span class="built_in">Mul</span>((mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,f[u][a][b]));</span><br><span class="line">				<span class="keyword">if</span>(b&gt;=<span class="number">1</span>) <span class="built_in">ADD</span>(g[a][b<span class="number">-1</span>],<span class="built_in">Mul</span>(b,f[u][a][b]));</span><br><span class="line">				<span class="keyword">if</span>(b&gt;=<span class="number">2</span>) <span class="built_in">ADD</span>(g[a][b<span class="number">-2</span>],<span class="built_in">Mul</span>(b*(b<span class="number">-1</span>)/<span class="number">2</span>,f[u][a][b]));</span><br><span class="line">				<span class="keyword">if</span>(b&gt;=<span class="number">1</span>&amp;&amp;a&lt;=<span class="number">9</span>) <span class="built_in">ADD</span>(g[a+<span class="number">1</span>][b<span class="number">-1</span>],<span class="built_in">Mul</span>(b,f[u][a][b]));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">				f[u][a][b]=g[a][b],g[a][b]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tp[u]==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">			<span class="keyword">if</span>(f[u][a][b])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ADD</span>(g[a][b],f[u][a][b]);</span><br><span class="line">				<span class="keyword">if</span>(a&gt;=<span class="number">1</span>) <span class="built_in">ADD</span>(g[a<span class="number">-1</span>][b],<span class="built_in">Mul</span>(a,f[u][a][b]));</span><br><span class="line">				<span class="keyword">if</span>(b&lt;=<span class="number">19</span>) <span class="built_in">ADD</span>(g[a][b+<span class="number">1</span>],f[u][a][b]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(a,<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">			<span class="built_in">fo</span>(b,<span class="number">0</span>,<span class="number">20</span>)</span><br><span class="line">				f[u][a][b]=g[a][b],g[a][b]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>,___);</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">ins</span>(s,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">ins</span>(s,<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>做过的题，竟然还能调这么久。</p>
<p>到最后发现是一个智障错误，也是十分无语。</p>
<p>每个随机变量中总有一个概率最大的，记这个最大的是 $a_i$，那么选到其他概率都不会超过 $\frac{1}{2}$。</p>
<p>题目要求的精度是 $10^{-9}$，那么进行 $30$ 多次之后就会变成 $0$，也就是失配不会超过 $30$ 次。</p>
<p>发现时间卡得有点紧，不能使用 $O(\log |s|)$ 的Hash+二分。</p>
<p>考虑后缀数组，可以 $O(1)$ 查询。</p>
<p>发现需要查询区间的乘积，然而这是小数，由于精度的原因不能使用前缀积。</p>
<p>两种方法：</p>
<ol start="0">
<li>线段树，应该过不了。</li>
<li>猫树。</li>
<li>先取对数然后再取指数，使用前缀和。</li>
</ol>
<p>时间复杂度 $O(n(\log n+30))$。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>这里写的是猫树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">8.4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	l2[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SuffixArray&#123;</span><br><span class="line">	<span class="type">int</span> base[N],t[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> height[N&lt;&lt;<span class="number">1</span>],sa[N&lt;&lt;<span class="number">1</span>],rk[N&lt;&lt;<span class="number">1</span>],f[N][K],len;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t[x]==t[y]&amp;&amp;t[x+k]==t[y+k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SA</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		len=n; a[n+<span class="number">1</span>]=m+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=i,rk[i]=a[i];</span><br><span class="line">		<span class="built_in">rsort</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">			<span class="built_in">rsort</span>(n,p);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">			rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">			<span class="keyword">for</span>(j=sa[rk[i]<span class="number">-1</span>],(k?(k--):<span class="number">0</span>);a[i+k]==a[j+k];k++);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i];</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,K<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) t[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask_sa</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x=rk[x]; y=rk[y];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x++;</span><br><span class="line">		<span class="type">int</span> k=l2[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SuffixArray::ask_sa;</span><br><span class="line"><span class="type">int</span> a[N],n,m;</span><br><span class="line"><span class="type">int</span> l[N],r[N];</span><br><span class="line">db w[N][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">namespace</span> CatTree&#123;</span><br><span class="line">	db a[N],s[K][N];</span><br><span class="line">	<span class="type">int</span> len,pos[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r)</span><br><span class="line">		&#123;</span><br><span class="line">			pos[l]=u; <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		s[d][mid]=a[mid]; s[d][mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">fd</span>(i,mid<span class="number">-1</span>,l) s[d][i]=s[d][i+<span class="number">1</span>]*a[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,mid+<span class="number">2</span>,r) s[d][i]=s[d][i<span class="number">-1</span>]*a[i];</span><br><span class="line">		<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid,d+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=w[i][b[i]-l[i]];</span><br><span class="line">		len=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;len&lt;n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,n+<span class="number">1</span>,len) a[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,len,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> <span class="number">1.</span>;</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> a[x];</span><br><span class="line">		<span class="type">int</span> d=l2[pos[x]]-l2[pos[x]^pos[y]];</span><br><span class="line">		<span class="keyword">return</span> s[d][x]*s[d][y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> CatTree::ask;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">8.4e5</span>);</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,___);</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		<span class="type">int</span> id;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			l[i]=<span class="built_in">read</span>(),r[i]=<span class="built_in">read</span>();</span><br><span class="line">			id=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,r[i]-l[i])</span><br><span class="line">			&#123;</span><br><span class="line">				w[i][j]=((db)<span class="built_in">read</span>())*(<span class="number">1e-9</span>);</span><br><span class="line">				<span class="keyword">if</span>(w[i][id]&lt;=w[i][j]) id=j;</span><br><span class="line">			&#125;</span><br><span class="line">			a[i]=id+l[i];</span><br><span class="line">		&#125;</span><br><span class="line">		a[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) a[n+<span class="number">1</span>+i]=<span class="built_in">read</span>();</span><br><span class="line">		CatTree::<span class="built_in">build</span>(a,n);</span><br><span class="line">		SuffixArray::<span class="built_in">SA</span>(a,n+m+<span class="number">1</span>,n+<span class="number">2</span>);</span><br><span class="line">		<span class="type">int</span> le,ri,len;</span><br><span class="line">		db ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n-m+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="number">1</span>;</span><br><span class="line">			le=i,ri=n+<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">for</span>(;ri&lt;=n+m+<span class="number">1</span>&amp;&amp;ans&gt;<span class="number">1e-10</span>;)</span><br><span class="line">			&#123;</span><br><span class="line">				len=<span class="built_in">ask_sa</span>(le,ri);</span><br><span class="line">				ans*=<span class="built_in">ask</span>(le,le+len<span class="number">-1</span>);</span><br><span class="line">				le=le+len; ri=ri+len;</span><br><span class="line">				<span class="keyword">if</span>(ri&lt;=n+m+<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(l[le]&lt;=a[ri]&amp;&amp;a[ri]&lt;=r[le])</span><br><span class="line">						ans*=w[le][a[ri]-l[le]];</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						ans=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				le++,ri++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans&lt;=<span class="number">1e-10</span>) ans=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+m+<span class="number">1</span>) a[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>问有多少个 $1\sim n$ 的排列，使得插入排序进行了 $k$ 轮以后，该排列的最长上升子序列至少为 $n-1$。</p>
<p>$n\le 50,k\le 50$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>考虑前 $k$ 个位置是否形成一个 $1\sim k$ 的排列，若不是，则只有一个 $k+1\sim n$ 的数在位置 $1\sim k$ 内。</p>
<p>分两种情况讨论。</p>
<p>答案为 $k!(1+(n-k)\times (n-k-1)+k\times (n-k))=k!((n-k)\times (n-1)+1)$。</p>
<p>时间复杂度 $O(k)$，当然可以优化到 $O(\frac{\sqrt{k}}{\log k})$，不过没有必要。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给定一棵带边权的树，$m$ 次询问，问给每条边边权加了 $k$ 后，树的直径长度。</p>
<p>$n,m\le 2\times 10^5$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>这题是CF1019E的弱化版。</p>
<p>考虑1019E的题目：每条边有边权 $a,b$，每次询问边权变为 $ak+b$ 后的直径。</p>
<p>和树的路径有关，考虑分治。</p>
<p>但点分治的不好之处在于分成了大于等于 $2$ 的分治结构，在处理最值等问题而不是方案数的时候会有点复杂。</p>
<p>考虑边分治，为了使得两点间的信息不变，可以这样重构原树：</p>
<p><img src="/2018-2019-ACM-ICPC-Asia-Shenyang-Regional-Contest/D.png" alt="rebuild"></p>
<p>（之前的边分治重构写得太丑了）</p>
<p>边分治后，假设已经统计出所有的可能的答案，形如 $(a,b)$ 的形式。</p>
<p>我们需要使 $ak+b$ 最大，那就是用一个斜率为 $-k$ 的直线去切这些点集，使得纵截距最大。</p>
<p>于是建一个上凸包即可。</p>
<p>下面考虑，经过边分治后变成了两个子结构，统计经过所选分治中心的 $(a,b)$：</p>
<p>相当于有两个集合，每个集合上为 $(a,b)$，需要算出 $(a,b)+(c,d)$ 的上凸包。</p>
<p>显然就是闵科夫斯基和。</p>
<p>注意归并排序的时候需要注意不能越界！！！（已经死过很多遍了…，记得写全条件）</p>
<p>时间复杂度 $O(n\log ^2n+m\log n\log \log n)$。 </p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">400010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; adj[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ne[N&lt;&lt;<span class="number">1</span>],ver[N&lt;&lt;<span class="number">1</span>],a[N&lt;&lt;<span class="number">1</span>],b[N&lt;&lt;<span class="number">1</span>],head[N],tot;</span><br><span class="line"><span class="type">bool</span> vis[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> _a,<span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; a[tot]=_a; b[tot]=_b; ne[tot]=head[x]; head[x]=tot; vis[tot]=<span class="number">0</span>;</span><br><span class="line">	ver[++tot]=x; a[tot]=_a; b[tot]=_b; ne[tot]=head[y]; head[y]=tot; vis[tot]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">re_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; vec;</span><br><span class="line">	vec.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(v.fi!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">re_dfs</span>(v.fi,u);</span><br><span class="line">			vec.<span class="built_in">pb</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(vec.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">add</span>(u,vec[<span class="number">0</span>].fi,<span class="number">1</span>,vec[<span class="number">0</span>].se);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> las=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec)</span><br><span class="line">	&#123;</span><br><span class="line">		++cnt;</span><br><span class="line">		<span class="built_in">add</span>(las,cnt,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">add</span>(cnt,v.fi,<span class="number">1</span>,v.se);</span><br><span class="line">		las=cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> &amp;n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot=<span class="number">1</span>;</span><br><span class="line">	cnt=n;</span><br><span class="line">	<span class="built_in">re_dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	n=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u1,u2,now,mi,id;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]&amp;&amp;(v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">max</span>(siz[v],now-siz[v])&lt;mi)</span><br><span class="line">			&#123;</span><br><span class="line">				mi=<span class="built_in">max</span>(siz[v],now-siz[v]);</span><br><span class="line">				u1=v; u2=u; id=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	ll a,b;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.a==B.a) <span class="keyword">return</span> A.b&lt;B.b;</span><br><span class="line">		<span class="keyword">return</span> A.a&lt;B.a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span>-(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.a-B.a,A.b-B.b&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span>+(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.a+B.a,A.b+B.b&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.a==B.a&amp;&amp;A.b==B.b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">cross</span><span class="params">(P A,P B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.a*B.b-B.a*A.b;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;P&gt; v1,v2,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;P&gt; &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> vector&lt;P&gt; B;</span><br><span class="line">	B.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(A));</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(A))-A.<span class="built_in">begin</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:A)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(B.<span class="built_in">size</span>()&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">cross</span>(B[B.<span class="built_in">size</span>()<span class="number">-1</span>]-B[B.<span class="built_in">size</span>()<span class="number">-2</span>],x-B[B.<span class="built_in">size</span>()<span class="number">-2</span>])&gt;<span class="number">0</span>) B.<span class="built_in">pop_back</span>();</span><br><span class="line">		B.<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	A=B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;P&gt; &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">DEBUG</span>(A.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:A) cerr&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;x.a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;x.b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;P&gt; &amp;A,vector&lt;P&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">build</span>(A); <span class="built_in">build</span>(B);</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>||j&lt;B.<span class="built_in">size</span>()<span class="number">-1</span>;)</span><br><span class="line">	&#123;</span><br><span class="line">		s.<span class="built_in">pb</span>((P)&#123;A[i]+B[j]&#125;);</span><br><span class="line">		<span class="keyword">if</span>(j&lt;B.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;(i==A.<span class="built_in">size</span>()<span class="number">-1</span>||<span class="built_in">cross</span>(B[j+<span class="number">1</span>]-B[j],A[i+<span class="number">1</span>]-A[i])&lt;<span class="number">0</span>))</span><br><span class="line">			j++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			i++;</span><br><span class="line">	&#125;</span><br><span class="line">	s.<span class="built_in">pb</span>(A[i]+B[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,ll aa,ll bb,vector&lt;P&gt; &amp;V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	V.<span class="built_in">pb</span>((P)&#123;aa,bb&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]&amp;&amp;(v=ver[i])!=pre)</span><br><span class="line">			<span class="built_in">dfs2</span>(v,u,aa+a[i],bb+b[i],V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> si)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(si&lt;=<span class="number">1</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">	now=si; u1=u2=<span class="number">0</span>; mi=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(u,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> s1=siz[u1],s2=si-siz[u1],u3=u2;</span><br><span class="line">	vis[id]=vis[id^<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	v1.<span class="built_in">clear</span>(); v2.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">dfs2</span>(u1,u2,a[id],b[id],v1);</span><br><span class="line">	<span class="built_in">dfs2</span>(u2,u1,<span class="number">0</span>,<span class="number">0</span>,v2);</span><br><span class="line">	<span class="built_in">merge</span>(v1,v2);</span><br><span class="line">	<span class="built_in">divide</span>(u1,s1);</span><br><span class="line">	<span class="built_in">divide</span>(u3,s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s[x].b-s[x].a*k&gt;s[y].b-s[y].a*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,___);</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		s.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); z=<span class="built_in">read</span>();</span><br><span class="line">			adj[x].<span class="built_in">pb</span>(<span class="built_in">mp</span>(y,z)); adj[y].<span class="built_in">pb</span>(<span class="built_in">mp</span>(x,z));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">rebuild</span>(n);</span><br><span class="line">		<span class="built_in">divide</span>(<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">build</span>(s);</span><br><span class="line">		<span class="type">int</span> l,r,mid;</span><br><span class="line">		ll k;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			k=-<span class="built_in">read</span>();</span><br><span class="line">			l=<span class="number">1</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">			&#123;</span><br><span class="line">				mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(mid<span class="number">-1</span>,mid,k)) r=mid<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			l--;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,s[l].b-s[l].a*k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) adj[i].<span class="built_in">clear</span>(),head[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定二维平面上 $n$ 个点的坐标及颜色，有以下三种操作：</p>
<ul>
<li>修改一点的坐标。</li>
<li>修改一点的颜色。</li>
<li>询问在编号为 $[l,r]$ 的点中，选择两个颜色不同的点的曼哈顿距离的最大值。</li>
</ul>
<p>$n,m\le 10^5,\sum n,\sum m\le 5\times 10^5$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>先考虑所有颜色相同，如何求一堆点的曼哈顿距离的最大值。</p>
<p>考虑经典的套路，将 $(x,y)$ 变为 $(x+y,x-y)$，转换为切比雪夫距离，即 $\max\{|x_1-x_2|,|y_1-y_2|\}$。</p>
<p>这样做的好处是将曼哈顿距离的二维转换成一维。</p>
<p>那么一堆颜色相同的点的距离的就是 $\max\{|x_{max}-x_{min}|,|y_{max}-y_{min}|\}$。</p>
<p>加入了颜色不相同的限制也十分无聊，记录最值，最值颜色，不同于最值颜色的次值即可。</p>
<p>时间复杂度 $O(n+m\log n)$，有大概12的常数。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>这题的思路有点妙~</p>
<h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定一个有向无环图，点权，对于任意点均满足后继点的点权比该点小。</p>
<p>从某个点出发，选择三条长度至少为 $1$ 的，互不相同的，点权单调下降的路径，其价值为这三条路径的终点的权值之和。</p>
<p>对于每个 $k$，问有多少个由三条路径形成的集合，使得价值为 $k$。</p>
<p>$T\le 5,n\le 10000,m\le 30000,w\le 400$。</p>
<p>时限 6s。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>三条路径互不相同，可以容斥做。</p>
<p>考虑DP，设生成函数 $F_{i,j}$ 表示从 $i$ 出发，经过的所有点 $v$ 的 $x^{value_v\times j}$ 之和。</p>
<p>看起来答案就是 $[x^k]\frac{\sum_{i=1}^nF_{i,1}^3}{6}$。</p>
<p>但是，有两条路径重复，三条路径都重复的情况会被统计到，需要减去。</p>
<p>算一下容斥系数，发现答案就是 $[x^k]\frac{\sum F_{i,1}^3-3\sum F_{i,2}F_{i,1}+2\sum F_{i,3}}{6}$。</p>
<p>直接爆算，用拆系数FFT暴力，时间复杂度 $O(Tmw\log w)$，常数还巨大，显然过不了。</p>
<p>考虑最终的这个多项式，是一个 $3w$ 次的多项式。次数较小，考虑插值。</p>
<p>将 $0\sim 3w$ 代进多项式的 $x$ 中进行计算，然后再拉格朗日插值，算出最终多项式的系数就可以了。</p>
<p>时间复杂度 $O(T(n+m+w)w)$。</p>
<p>拉格朗日插值时可以将 $\prod_{i=0}^{3w}(x-i)$ 的系数暴力算出，然后暴力除一个 $(x-i)$。</p>
<p>由于有个地方用了快速幂，导致程序是卡着时间过的。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> W=<span class="number">1203</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> value[N],deg[N],id[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> n,m,w,cnt;</span><br><span class="line">ll f[N][<span class="number">3</span>][W],a[W],g[W],h[W],ans[W],inv[W],pw[W][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,W) inv[i]=<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>);</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); w=<span class="built_in">read</span>()*<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) value[i]=<span class="built_in">read</span>(),adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>();</span><br><span class="line">			adj[x].<span class="built_in">pb</span>(y);</span><br><span class="line">			deg[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			id[++cnt]=u;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">			&#123;</span><br><span class="line">				deg[v]--;</span><br><span class="line">				<span class="keyword">if</span>(!deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,w) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) pw[i][j]=<span class="built_in">Pow</span>(i,value[j]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,w+<span class="number">1</span>) a[i]=g[i]=ans[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fd</span>(t,n,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			u=id[t];</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">0</span>,w)</span><br><span class="line">					f[u][i<span class="number">-1</span>][j]=<span class="built_in">Pow</span>(pw[j][u],i);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">				<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">0</span>,w)</span><br><span class="line">						f[u][i][j]=<span class="built_in">Add</span>(f[u][i][j],f[v][i][j]);</span><br><span class="line">			ll sum;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,w)</span><br><span class="line">			&#123;</span><br><span class="line">				sum=(f[u][<span class="number">0</span>][j]*f[u][<span class="number">0</span>][j]%mod*f[u][<span class="number">0</span>][j]<span class="number">-3ll</span>*f[u][<span class="number">0</span>][j]*f[u][<span class="number">1</span>][j]+<span class="number">2ll</span>*f[u][<span class="number">2</span>][j]);</span><br><span class="line">				a[j]=<span class="built_in">Add</span>(a[j],(sum%mod+mod)%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i+<span class="number">1</span>) h[j]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i)</span><br><span class="line">				h[j]=<span class="built_in">Add</span>(h[j],(mod-i)*g[j]%mod),</span><br><span class="line">				h[j+<span class="number">1</span>]=<span class="built_in">Add</span>(h[j+<span class="number">1</span>],g[j]);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i+<span class="number">1</span>) g[j]=h[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,w)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,w+<span class="number">1</span>) h[j]=g[j];</span><br><span class="line">			<span class="built_in">fd</span>(j,w,<span class="number">1</span>) h[j]=<span class="built_in">Add</span>(h[j],h[j+<span class="number">1</span>]*i%mod);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) a[i]=a[i]*inv[i-j]%mod;</span><br><span class="line">			<span class="built_in">fo</span>(j,i+<span class="number">1</span>,w) a[i]=a[i]*(mod-inv[j-i])%mod;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,w) ans[j]=<span class="built_in">Add</span>(ans[j],h[j+<span class="number">1</span>]*a[i]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:&quot;</span>,___);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,w) <span class="built_in">printf</span>(<span class="string">&quot; %lld&quot;</span>,inv[<span class="number">6</span>]*ans[i]%mod);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>每次对一个二维平面有四种操作：</p>
<ol>
<li>加入一个点 $(x,y)$ ，权值为 $w$。</li>
<li>删除一个点。</li>
<li>将与 $(x,y)$ 欧几里得距离为 $\sqrt{k}$ 的存在的点的权值加上 $w$。</li>
<li>求与 $(x,y)$ 欧几里得距离为 $\sqrt{k}$ 的存在的点的权值之和。</li>
</ol>
<p>$m\le 2\times 10^5,k\le 10^7$。</p>
<p>时限12s。</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>与一个点欧几里得距离为 $\sqrt{k}$ 的点很少，最多大概是 $48\times 4$ 。</p>
<p>用vector记录，然后暴力。</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><p>不会。。。</p>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>之前做过的一道FWT。</p>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><p>签到题。定义一些变量或者数组，求用去的MB数向上取整的结果。</p>
<h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>给定 $T\le 1000$ 组数据，每组数据三个数 $n,m,k$，求 $n$ 个人的约瑟夫环游戏（每数到第 $k$ 个人，该人出局）中第 $m$ 个出局的人的编号。</p>
<p>$\sum \min\{m,k\}\le 2\times 10^6$</p>
<h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>先来看看最经典的约瑟夫环问题如何解决：</p>
<p><strong>求 $n$ 个人的约瑟夫环游戏（每数到第 $k$ 个人，该人出局）中最后一个出局的人的编号。</strong></p>
<p>设 $f(n)$ 表示有 $n$ 个人时最后出局的编号。考虑第一次走了 $k$ 步后，就变成了 $n-1$ 的子问题，因此有：</p>
<p>$f(n)=(k+f(n-1))\bmod n,f(1)=0$。</p>
<p>那么，类似于上面的定义，设 $f(n,m)$ 表示 $n$ 个人时，第 $m$ 个出局的编号。</p>
<p>类似地，有：</p>
<p>$f(n,m)=(k+f(n-1,m-1))\bmod n,f(n,1)=(k-1)\bmod n$。</p>
<p>于是，如果 $m\le 2\times 10^6$ ，那么直接根据 $f$ 的定义，就可以求出来了。</p>
<p>对于 $k\le 2\times 10^6$，可以发现，$f(n,m)$ 的定义中 $k+f(n-1,m-1)$ 超过 $n$ 的次数大概是 $O(k)$ 次的，那么假设计算到 $f(n’,m’)$，设加了 $t$ 次后，依然小于那时候的 $n$，则有：</p>
<p>$f(n’,m’)+kt&lt;n’+t$；</p>
<p>解得：$t&lt;\frac{n’-f(n’,m’)}{k-1}$。</p>
<p>于是，特判掉 $k=1$，然后就可以计算了。</p>
<p>可以不分类，直接写成第二种形式就可以了。</p>
<p>时间复杂度 $O(\sum\min\{m,k\})$。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>$n$ 个多项式 $F_i(x)=(1+x^{b_i}+x^{2b_i}+\cdots + x^{a_ib_i})$，</p>
<p>$m$ 次询问 $\prod_{i=l}^rF_i(x)$ 的前 $c$ 项和。</p>
<p>强制在线。</p>
<p>$n,m\le 10000,a_i,b_i,c\le 1000$。</p>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><p>$F_i(x)=(1+x^{b_i}+x^{2b_i}+\cdots + x^{a_ib_i})=\frac{1-x^{(a_i+1)b_i}}{1-x}$。</p>
<p>那么 $F_{i}(x)^{-1}=\frac{1-x}{1-x^{(a_i+1)b_i}}$。</p>
<p>于是 $\prod_{i=l}^rF_i(x)=\frac{\prod_{i=1}^rF_i(x)}{\prod_{i=1}^{l-1}F_i(x)}$。</p>
<p>于是只需计算 $F_i(x)$ 的前缀积以及 $F_i(x)$ 的逆的前缀积。</p>
<p>于是变成两种操作：</p>
<ol>
<li><p>对一多项式乘上 $(1-x^w)$。</p>
<p>暴力即可。</p>
</li>
<li><p>对一多项式除去 $(1-x^w)$。</p>
<p>就是相当于 $1$ 的操作倒过来，也可以 $O(c)$ 去做。</p>
</li>
</ol>
<p>算出前缀积后，要算两个前缀积的乘积的前 $c$ 项，这个也可以 $O(c)$ 做。</p>
<p>时间复杂度 $O((n+m)c)$。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ADD</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x+=y; (x&lt;mod)?<span class="number">0</span>:x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10005</span>;</span><br><span class="line">ll f[M][N],g[M][N],tmp[N];</span><br><span class="line"><span class="type">int</span> n,m,c;</span><br><span class="line"><span class="type">int</span> a[M],b[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); c=<span class="number">1000</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,c) f[<span class="number">0</span>][i]=g[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">		f[<span class="number">0</span>][<span class="number">0</span>]=g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i]=<span class="built_in">read</span>(); b[i]=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c) tmp[j]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j+(a[i]+<span class="number">1</span>)*b[i]&lt;=c)</span><br><span class="line">					tmp[j+(<span class="number">1</span>+a[i])*b[i]]=<span class="built_in">Dec</span>(tmp[j+(<span class="number">1</span>+a[i])*b[i]],f[i<span class="number">-1</span>][j]);</span><br><span class="line">				<span class="built_in">ADD</span>(tmp[j],f[i<span class="number">-1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=b[i])	<span class="built_in">ADD</span>(tmp[j],tmp[j-b[i]]);</span><br><span class="line">				f[i][j]=tmp[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c) tmp[j]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fd</span>(j,c,<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j+b[i]&lt;=c) tmp[j+b[i]]=<span class="built_in">Dec</span>(tmp[j+b[i]],g[i<span class="number">-1</span>][j]);</span><br><span class="line">				tmp[j]=<span class="built_in">Add</span>(tmp[j],g[i<span class="number">-1</span>][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> w=(a[i]+<span class="number">1</span>)*b[i];</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c-w) <span class="built_in">ADD</span>(tmp[j+w],tmp[j]);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,c) g[i][j]=tmp[j],tmp[j]=<span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=<span class="number">0</span>,s,s2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,___);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l,r;m--;)</span><br><span class="line">		&#123;</span><br><span class="line">			l=(<span class="built_in">read</span>()+ans)%n+<span class="number">1</span>,r=(<span class="built_in">read</span>()+ans)%n+<span class="number">1</span>; c=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">			l--;</span><br><span class="line">			s=s2=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,c) <span class="built_in">ADD</span>(s2,f[r][i]);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,c)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ADD</span>(s,s2*g[l][i]%mod);</span><br><span class="line">				s2=<span class="built_in">Dec</span>(s2,f[r][c-i]);</span><br><span class="line">			&#125;</span><br><span class="line">			ans=s%mod;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Trie</tag>
        <tag>背包</tag>
        <tag>后缀数组</tag>
        <tag>猫树</tag>
        <tag>分治</tag>
        <tag>边分治</tag>
        <tag>闵科夫斯基和</tag>
        <tag>拉格朗日插值</tag>
        <tag>多项式</tag>
        <tag>容斥原理</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>多点求值</title>
    <url>/2021/09/02/%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一 $n$ 次多项式 $f(x)$，$m$ 个值 $x_1,x_2,\cdots,x_m$，求出 $f(x_i)$ 的值对 $998244353$ 取模后的结果。</p>
<p>$n,m\le 64000$。</p>
<span id="more"></span>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>最经典的多点求值。</p>
<p>设 $P_{l,r}(x)=\prod_{i=l}^r(x-x_i)$。</p>
<p>设 $k=\lfloor \frac{m}{2} \rfloor$，显然有 $\forall i\in [1,k],P_{1,k}(x_i)=0,\forall i\in[k+1,m],P_{m+1,n}(x_i)=0$。</p>
<p>对于 $i\in [1,k]$，考虑多项式 $f(x)$ 表示成 $D(x)P_{1,k}(x)+R(x)$ 的形式（其中 $deg_R&lt;deg_{P_{1,k}}$），那么有 $\forall i\in [1,k],f(x_i)=R(x_i)$。</p>
<p>于是，经过一次多项式取模，将其转换为 $\frac{k}{2}$ 的子问题。</p>
<p>那么先分治，预处理出所有分治结构中的 $P(x)$，然后再来一次分治，每次递归时将当前多项式对 $P_{l,r}$ 取模。</p>
<p>到 $l=r$ 时，$[x^0]P_{l,l}(x)$ 就是答案了。</p>
<p>时间复杂度 $T(n)=2T(\frac{n}{2})+O(n\log n)$，由主定理得，$T(n)=O(n\log ^2n)$。</p>
<p>空间复杂度 $O(n\log n)$。</p>
<p>这样做不仅需要写多项式取模，而且常数较大。</p>
<h3 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>定义差卷积 $\text{Mul}^T(A,B)<em>i=\sum</em>{j}A_{i+j}\times B_j$。</p>
<p>显然有如下性质：</p>
<p>$\text{Mul}^T(A,B\times C)=\text{Mul}^T(\text{Mul}^T(A,B),C)$。</p>
<p>可以发现， $f(x_0)=\sum_{i=0}^nf_ix_0^i=[x^0]\text{Mul}^T(f,\frac{1}{1-x_0x})$。</p>
<p>于是，考虑算出 $P_{l,r}=\prod_{i=l}^r(1-x_ix)$，先计算 $G=\text{Mul}^T(f,\frac{1}{P_{1,m}})$。</p>
<p>然后分治，递归时维护当前的 $G$，下传到 $[l,mid]$ 时，新的 $G$ 则为 $\text{Mul}^T(G,P_{mid+1,r})$。下传到 $[mid+1,r]$ 同理。</p>
<p>于是就做完了，时间复杂度也为 $O(n\log ^2n)$。</p>
<p>但是这个只需要写到多项式求逆，不需要再写多项式取模，常数少了 $\frac{1}{2}$。</p>
<p>发现计算差卷积时可以运用FFT计算循环卷积，这样常数又减少了约 $\frac{1}{3}$。</p>
<p>最后大概的时间是算法一的 $\frac{1}{3}$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line">ll W[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> R[M];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">				a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">				a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">	<span class="keyword">if</span>(t^<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">	A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*k%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">	Poly g,h;</span><br><span class="line">	g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">	<span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">		<span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">		<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">	<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">64005</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc ((u&lt;&lt;1)|1)</span></span><br><span class="line">Poly P[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll ans[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">MulT</span><span class="params">(Poly A,Poly B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	B.<span class="built_in">clear</span>();</span><br><span class="line">	len--;</span><br><span class="line">	<span class="built_in">fo</span>(i,m<span class="number">-1</span>,n+m<span class="number">-2</span>) B.<span class="built_in">pb</span>(A[i&amp;len]);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		P[u].<span class="built_in">pb</span>(<span class="number">1</span>); P[u].<span class="built_in">pb</span>(<span class="built_in">Dec</span>(<span class="number">0</span>,a[l]));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">	P[u]=P[lc]*P[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(ans[l]=A[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid,<span class="built_in">MulT</span>(A,P[rc])); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r,<span class="built_in">MulT</span>(A,P[lc]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">Poly F,G;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">max</span>(n,m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) F.<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">	F.<span class="built_in">resize</span>(n+k+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">	F=<span class="built_in">MulT</span>(F,(~P[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k,F);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest</title>
    <url>/2021/09/01/2017-2018-ACM-ICPC-Asia-Tsukuba-Regional-Contest/</url>
    <content><![CDATA[<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p><a href="https://codeforces.com/gym/101986">链接</a></p>
<span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>设 $f_{i,0/1}$ 表示填满前 $i$ 行时，最上面一行是白/黑的方案数。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p>由于 $m\leq 16$，那么总方案数最多为 $\frac{\binom{16}{8}8!}{2^8}=2027025$。</p>
<p>于是直接爆搜，由于时限10s，那么暴力 $O(m^2)$ 判断都可以。</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>还没看。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>设 $f_i$ 表示考虑到前 $i$ 个时的最小操作次数。</p>
<p>$f_i=\min\{f_j+g(j+1,i)\}$，其中 $g(l,r)$ 表示 $[l,r]$ 最小需要的操作次数，也就是 $t[l,r]$ 中不同的连续段数+1的一半。单调队列或线段树优化即可。</p>
<p>时间复杂度 $O(n)$ 或 $O(n\log n)$。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p>从 $1,2$ 分别跑一次原图，反图最短路，建出从 $1$ 开始的，能到 $2$ 的最短路图，边反向后是否令最短路减小很好判断，是否增大则需要根据该边是否为最短路图中从 $1$ 到 $2$ 的必经路。</p>
<p>预处理出这些边即可。</p>
<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p>最大值直接跑二分图匹配即可。</p>
<p>最小值的话很像一个最小割的形式，同一时刻，如果选了一个 $X$，那么 $Y$ 那边就不必选。也就是说，若出现了 $X,Y$ 中两个任务的时间重叠，那么就连一条边，然后相当于最小割。</p>
<p>但是时间可能分配不够，于是就相当于每个时间有一个节点容量一，然后 $s$ 连向 $X$，$X$ 连向时间点，时间点连向 $Y$，$Y$ 连向 $t$，就可以做最小割了。</p>
<h2 id="K"><a href="#K" class="headerlink" title="K"></a>K</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$ 个点 $m$ 条边的无向连通图，求出简单环的个数。</p>
<p>$n-1\le m \le n-15$。</p>
<p>$3 \le n \le 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然先dfs建出一棵树，而非树边是不会出现横叉边的。</p>
<p>最多只有 $m-(n-1)\le 16$ 条非树边。</p>
<p>暴力枚举每条非树边是否进行选择，若选择一条边 $(x,y)$ 则可看做为在树中从 $x$ 走到 $y$。</p>
<p>若能走出一个环，必要条件是每条边都必须经过偶数次。</p>
<p>那么判断是否可行时统计出树中每条边的经过的次数，若出现了奇数次，则该树边一定要选上。</p>
<p>最后形成一个边的集合，判断这个边集是否是个简单环就可以了。</p>
<p>于是写一个虚树即可。</p>
<p>注意最后判断边是否形成简单环时要注意，有些点是没有边出去的，这些也是可以的。</p>
<p>时间复杂度 $O(2^{m-n}\times (m-n)\log n+n\log n)$，也可以优化并去掉一个log，但是会没有必要。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>打了我快1h…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200020</span>;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> dep[N],dfn[N],tim;</span><br><span class="line">	<span class="type">int</span> f[N][<span class="number">19</span>];</span><br><span class="line">	<span class="type">int</span> sum;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;edge&gt; e;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x==y) &#123;sum++; <span class="keyword">return</span>;&#125;</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfn[u]=++tim; dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">		f[u][<span class="number">0</span>]=pre;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">18</span>) f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v==pre)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dfn[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dfn[v]&lt;dfn[u]) e.<span class="built_in">pb</span>((edge)&#123;u,v&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(dep[f[y][i]]&gt;=dep[x]) y=f[y][i];</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">		<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; _adj[N];</span><br><span class="line">	vector&lt;edge&gt; ed;</span><br><span class="line">	<span class="type">void</span> _add(<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		_adj[x].<span class="built_in">pb</span>(y); _adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> rt;</span><br><span class="line">	<span class="type">int</span> st[N],top,now;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rt=a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:a) rt=<span class="built_in">lca</span>(rt,v);</span><br><span class="line">		a.<span class="built_in">pb</span>(rt);</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(a),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">		a.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(a))-a.<span class="built_in">begin</span>());</span><br><span class="line">		top=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(top)</span><br><span class="line">			&#123;</span><br><span class="line">				y=<span class="built_in">lca</span>(x,st[top]);</span><br><span class="line">				<span class="keyword">if</span>(y!=st[top])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(;top&gt;=<span class="number">2</span>&amp;&amp;dep[st[top<span class="number">-1</span>]]&gt;=dep[y];top--) _add(st[top],st[top<span class="number">-1</span>]);</span><br><span class="line">					<span class="keyword">if</span>(st[top]!=y) _add(st[top],y),st[top]=y;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(st[top]!=x) st[++top]=x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(top) <span class="keyword">for</span>(;--top;) _add(st[top],st[top+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; V;</span><br><span class="line">	<span class="type">int</span> w[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		V.<span class="built_in">pb</span>(u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:_adj[u])</span><br><span class="line">			<span class="keyword">if</span>(v!=pre)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">				w[u]^=w[v];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(w[u]&amp;&amp;u!=rt) ed.<span class="built_in">pb</span>((edge)&#123;u,pre&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">clr</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:_adj[u]) <span class="keyword">if</span>(v!=pre) <span class="built_in">clr</span>(v,u);</span><br><span class="line">		_adj[u].<span class="built_in">clear</span>(); w[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> vis[N],deg[N];</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> __add(<span class="type">int</span> x,<span class="type">int</span> y)</span><br><span class="line">	&#123;</span><br><span class="line">		_adj[x].<span class="built_in">pb</span>(y); _adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">		deg[x]++; deg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> ans;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!ans) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(vis[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(vis[u]!=tim) ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[u]=tim;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:_adj[u])</span><br><span class="line">			<span class="keyword">if</span>(v!=pre) <span class="built_in">dfs3</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:ed) __add(x.x,x.y);</span><br><span class="line">		tim=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:V) <span class="keyword">if</span>(deg[x]&amp;&amp;deg[x]!=<span class="number">2</span>) &#123;ans=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:V) vis[x]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:V)</span><br><span class="line">			<span class="keyword">if</span>(deg[x])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!vis[x]) tim++,<span class="built_in">dfs3</span>(x,<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tim&gt;=<span class="number">2</span>) ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x:V) _adj[x].<span class="built_in">clear</span>(),vis[x]=deg[x]=<span class="number">0</span>;</span><br><span class="line">		V.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> m=e.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>(dep[e[i].x]&gt;dep[e[i].y]) <span class="built_in">swap</span>(e[i].x,e[i].y);</span><br><span class="line">		<span class="type">bool</span> flag;</span><br><span class="line">		<span class="built_in">ff</span>(s,<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;m))</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">			a.<span class="built_in">clear</span>(); ed.<span class="built_in">clear</span>(); V.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s) a.<span class="built_in">pb</span>(e[i].x),a.<span class="built_in">pb</span>(e[i].y),ed.<span class="built_in">pb</span>((edge)&#123;e[i].x,e[i].y&#125;);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:a) <span class="keyword">if</span>(!dfn[x])</span><br><span class="line">			&#123;</span><br><span class="line">				flag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">build</span>(a);</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s) w[e[i].y]^=<span class="number">1</span>,w[e[i].x]^=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs2</span>(rt,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">clr</span>(rt,<span class="number">0</span>);</span><br><span class="line">			sum+=<span class="built_in">check</span>();</span><br><span class="line">			rt=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) Graph::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Graph::<span class="built_in">solve</span>(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>网络流</tag>
        <tag>虚树</tag>
      </tags>
  </entry>
  <entry>
    <title>常系数线性齐次递推</title>
    <url>/2021/08/31/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>给定一递推式：$f_n=\sum_{i=1}^{k}a_if_{n-i}$，其中 $a_1,a_2,\cdots,a_k$ 为常实数，并给定 $f_0,f_1,\cdots, f_{k-1}$。</p>
<p>求 $f_n$。</p>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>设 ：</p>
<p>$$V_i=\begin{bmatrix}<br>f_i\\<br>f_{i+1}\\<br>\vdots\\<br>f_{i+k-1}<br>\end{bmatrix},M=\begin{bmatrix}<br>0 &amp; 1 &amp; 0 &amp; \cdots \\<br>0 &amp; 0 &amp; \ddots &amp; \vdots \\<br>0 &amp; 0 &amp; \cdots &amp; 1 \<br>a_k &amp; a_{k-1} &amp; \cdots &amp; a_1<br>\end{bmatrix}$$</p>
<p>，则有：$V_{i+1}=M\times  V_i$。</p>
<p>若要计算 $f_n$，可计算 $V_n=M^n\times V_0$。</p>
<p>利用矩阵乘法，算出 $M^n$，时间复杂度 $O(k^3\log n)$。</p>
<h3 id="利用特征方程与多项式"><a href="#利用特征方程与多项式" class="headerlink" title="利用特征方程与多项式"></a>利用特征方程与多项式</h3><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>我们现在是要求 $M^n$。</p>
<p>设 $f(x)=x^n$。</p>
<p>若能找到一个多项式 $g$，使得 $g(M)=0$，那么就可以将 $f(x)$ 表示成 $A(x)g(x)+B(x)$ 了，其中 $B(x)$ 的次数小于 $g(x)$ 的次数。然后求 $f(M)$ 就相当于求 $B(M)$。</p>
<p>$g(x)$ 可取矩阵 $M$ 的特征方程 $\Gamma (x)=\text{det}(Ix-M)$，其中 $I$ 为单位矩阵，$\text{det}(A)$ 表示 $A$ 的行列式。</p>
<p>因为根据Cayley-Hamilton定理， $\Gamma (M)=0$。</p>
<p>而 $M$ 矩阵十分特殊，根据归纳等方法可证明：$\Gamma (x)=\text{det}(Ix-M)=x^k-\sum_{i=1}^ka_ix_{k-i}$。</p>
<p>显然有 $x^nV_0=f(x)V_0$，当 $x=M$ 时，</p>
<p>$x^nV_0=f(x)V_0=B(x)V_0=\sum_{i=0}^{k-1}x^ib_iV_0$。</p>
<p>将 $x$ 换成 $M$：</p>
<p>$V_n=M^nV_0=\sum_{i=0}^{k-1}b_iM^iV_0=\sum_{i=0}^{k-1}b_iV_i$。</p>
<p>取出 $V$ 中的第一行，有 ：</p>
<p>$f_n=\sum_{i=0}^{k-1}b_if_i$。</p>
<p>因此，只需求出所有的 $b_i$ 即可，也就是求出 $B(x)$。</p>
<p>由上面的推导，$B(x)=f(x)\bmod \Gamma (x)$。</p>
<p>由于 $f(x)=x^n$，考虑倍增，然后边乘边对 $g$ 取模。</p>
<p>暴力多项式乘法及取模，时间复杂度 $O(k^2\log n)$。</p>
<p>用FFT优化，时间复杂度 $O(k\log k\log n)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>多项式取模：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line">ll W[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> R[M];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">				a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">				a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">	<span class="keyword">if</span>(t^<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">	A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*k%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">	Poly g,h;</span><br><span class="line">	g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">	<span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">		<span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">		<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">	<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Ln</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	A=<span class="built_in">jf</span>((~A)*<span class="built_in">df</span>(A));</span><br><span class="line">	A.<span class="built_in">resize</span>(n); <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Exp</span><span class="params">(<span class="type">const</span> Poly &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1</span>; <span class="keyword">for</span>(;n&lt;A.<span class="built_in">size</span>();n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	Poly B,C,D; B.<span class="built_in">clear</span>(); B.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=B; C.<span class="built_in">resize</span>(m); D=A; D.<span class="built_in">resize</span>(m);</span><br><span class="line">		C=D-<span class="built_in">Ln</span>(C); C[<span class="number">0</span>]=<span class="built_in">Add</span>(C[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">		B=B*C; B.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()); <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ^(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!A.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	ll tmp=A[<span class="number">0</span>],w=<span class="built_in">Pow</span>(tmp,k);</span><br><span class="line">	tmp=<span class="built_in">Pow</span>(tmp,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*tmp%mod;</span><br><span class="line">	A=<span class="built_in">Exp</span>(<span class="built_in">Ln</span>(A)*k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*w%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Cos</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)+<span class="built_in">Exp</span>(A*(mod-w4)))*((mod+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sin</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)-<span class="built_in">Exp</span>(A*(mod-w4)))*(<span class="built_in">Pow</span>(w4,mod<span class="number">-2</span>)*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sqrt</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly C,D,<span class="built_in">B</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	C.<span class="built_in">clear</span>(); D.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">4</span>;(l&gt;&gt;<span class="number">2</span>)&lt;n;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=A; C.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		D=B; D.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>); D=(~D);</span><br><span class="line">		C.<span class="built_in">resize</span>(l); D.<span class="built_in">resize</span>(l);</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">1</span>); <span class="built_in">ntt</span>(D,l,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,l) C[i]=C[i]*D[i]%mod;</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">-1</span>);</span><br><span class="line">		B.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,(l&gt;&gt;<span class="number">1</span>)) B[i]=<span class="built_in">Add</span>(C[i],B[i])*((mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>/(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>,deg=A.<span class="built_in">size</span>()-B.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A)); <span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;=deg;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); B=~B; B.<span class="built_in">resize</span>(deg);</span><br><span class="line">	A=A*B; A.<span class="built_in">resize</span>(deg);</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>%(<span class="type">const</span> Poly &amp;A,<span class="type">const</span> Poly &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;B.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	Poly C=A-(A/B)*B;</span><br><span class="line">	C.<span class="built_in">resize</span>(B.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Pow</span><span class="params">(Poly A,ll n,Poly M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly B=A; n--;</span><br><span class="line">	<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,A=(A*A)%M) <span class="keyword">if</span>(n&amp;<span class="number">1ll</span>) B=(B*A)%M;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[M],f[M];</span><br><span class="line">Poly A,G;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) G.<span class="built_in">pb</span>((mod+mod-a[k-i+<span class="number">1</span>])%mod);</span><br><span class="line">	G.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">pb</span>(<span class="number">0</span>); A.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	A=<span class="built_in">Pow</span>(A,n,G);</span><br><span class="line">	ll ans=<span class="number">0</span>,x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,k<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=(mod+mod+<span class="built_in">read</span>())%mod;</span><br><span class="line">		ans+=f[i]*A[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="另一种方法"><a href="#另一种方法" class="headerlink" title="另一种方法"></a>另一种方法</h3><p>还有一种时间复杂度也是 $O(k\log k \log n)$ 的做法，不过常数很小。<a href="https://arxiv.org/pdf/2008.08822.pdf">详见</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>线性代数</tag>
        <tag>常系数线性齐次递推</tag>
      </tags>
  </entry>
  <entry>
    <title>Deltix Round, Summer 2021[CF1556]</title>
    <url>/2021/08/30/Deltix-Round-Summer-2021-CF1556/</url>
    <content><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://codeforces.com/contest/1556">比赛链接</a></p>
<span id="more"></span>

<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>rating：${\color{Yellow} 2162-&gt;2147}$。</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>两个初始为 $0$ 的数 $a,b$，可执行以下三种操作：</p>
<ul>
<li>选择一个正整数 $k$，$a+=k,b+=k$；</li>
<li>选择一个正整数 $k$，$a-=k,b+=k$；</li>
<li>选择一个正整数 $k$，$a+=k,b-=k$；</li>
</ul>
<p>问 $(a,b)$ 变成 $(c,d)$ 的最小操作次数。</p>
<p>$c,d\geq 0$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>显然若 $c+d\equiv 1\pmod 2$，那么无论如何也无法变成。</p>
<p>否则，由于 $c,d\geq 0$，若 $c=d$，则只需一次操作，否则需要两次。</p>
<p>注意 $(0,0)$ 的特判。</p>
<p>时间复杂度 $O(1)$。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定一个序列，每次可以交换相邻的两个数，问最少的操作次数使得两两相邻数奇偶性不同。</p>
<p>$n\le 10^5$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>设 $cnt=\sum_{i=1}^n[a_i\equiv 1\pmod 2]$，若 $cnt&gt; \lceil \frac{n}{2} \rceil$ 或 $cnt &lt; \lfloor \frac{n}{2} \rfloor$，则一定不行。</p>
<p>否则，枚举第一个数的奇偶性，之后依次交替，记录当前向右的第一个奇数与偶数，然后计算。</p>
<p>初始化最值一定要设大一点！！！</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给定一个长度为 $n$ 的序列，若 $i$ 为奇数，则表示跟着有 $a_i$ 个左括号；若 $i$ 为偶数，则表示跟着有 $a_i$ 个右括号。</p>
<p>形成一个长度为 $\sum a_i$ 的括号字符串，问有多少 $[l,r]$ 满足 $S[l,r]$ 为合法的括号序列。</p>
<p>$n\le 10^3,a_i\le 10^9$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>枚举 $l$ 所在的位置 $i$，然后从小到大枚举 $r$ 所在的位置 $j$，$O(1)$ 判断是否合法并计算即可。</p>
<p>时间复杂度 $O(n^2)$，应该可以优化到一个log或者线性。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>交互题。</p>
<p>给定 $n,k$，有一个长度为 $n$ 的非负整数数组 $a_1,a_2\cdots a_n$，最多询问一共 $2n$ 次两个不同下标的数的与/或，使得能求出数组 $a$ 的第 $k$ 小。</p>
<p>$n\geq 3$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>显然，因为 $a+b=a &amp; b+a | b$，我们花 $2n-2$ 次，求出 $a_1+a_i(i\geq 2)$。</p>
<p>之后再花 $2$ 次，求出 $a_2+a_3$。然后就可以解得 $a_1$，剩下的 $a_i$ 也全部求出来了。</p>
<p>找第 $k$ 小用 <code>nth_element</code>。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>对于两个数组 $a,b$，每次操作可以选择偶数个不同的下标，从小到大排好序后，排名为奇数的下标的 $a$ 加一，偶数的下标的 $b$ 减一。</p>
<p>给定两个数组，多次询问某个区间 $[l,r]$，问只在该区间进行上述操作，最少的操作次数使得区间内 $a_i=b_i$。</p>
<p>$n,q$ 在 $10^5$ 级别。</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>设 $c_i=a_i-b_i$，如果 $\sum_{i=l}^rc_i\neq 0$ 则无解。</p>
<p>如果出现某个 $j$，使得 $\sum_{i=l}^jc_i &gt; 0$ 也无解。</p>
<p>否则，最少的操作次数就是 $\sum_{i=l}^j c_i$ 的最小值取个相反数。</p>
<p>于是，记录 $c$ 前缀和 $s$，每次相当于询问 $s$ 的某个值，$s$ 的区间最大值，$s$ 的区间最小值。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>对于一个图，如何判断有哪些人赢呢？</p>
<p>强连通分量缩点，又因为是竞赛图，因此只有一个入度为 $0$ 的连通分量，且里面的人会赢。</p>
<p>设 $f_S$ 表示只有集合 $S$ 中的人赢的概率，那么答案就是 $\sum |S|f_S$。</p>
<p>设 $g_S$ 表示 $S$ 中的人两两可达的概率，$h_{S,T}$ 表示集合 $S$ 中的人都赢了 $T$ 中的所有人的概率。</p>
<p>那么 $f_S=g_S\times h_{S,\complement_{U}^{S}}$。</p>
<p>$g_S$ 的计算考虑补集转换，则有 $g_S=1-\sum_{T\subset S,|T|\neq 0}g_T\times h_{T,S-T}$。</p>
<p>枚举子集，暴力 $O(n^2)$ 计算 $h$，时间复杂度 $O({3^n}n^2)$，无法通过。</p>
<p>考虑预处理，优化计算 $h$ 的方法，很容易做到 $O({3^n}n)$。</p>
<p>于是就做完了。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;N;</span><br><span class="line">ll a[N],beat[N][N],w[N][M],f[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">G</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;x) ans=<span class="built_in">Mul</span>(ans,w[i][y]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) <span class="built_in">ff</span>(j,<span class="number">0</span>,n) beat[i][j]=a[i]*<span class="built_in">Pow</span>(a[i]+a[j],mod<span class="number">-2</span>)%mod;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			w[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">ff</span>(k,<span class="number">0</span>,n)</span><br><span class="line">				<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;k)&amp;j)</span><br><span class="line">					w[i][j]=<span class="built_in">Mul</span>(w[i][j],beat[i][k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ff</span>(s,<span class="number">0</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		f[s]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!s) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=s&amp;(s<span class="number">-1</span>);t;t=(t<span class="number">-1</span>)&amp;s)</span><br><span class="line">			f[s]=<span class="built_in">Dec</span>(f[s],f[t]*<span class="built_in">G</span>(t,s^t)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> cnt;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,n) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i) cnt++;</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="number">1ll</span>*cnt*f[i]%mod*<span class="built_in">G</span>(i,(m<span class="number">-1</span>)^i)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>枚举子集</tag>
      </tags>
  </entry>
  <entry>
    <title>Tournament[2018-2019 ACM-ICPC, Asia Nanjing Regional Contest, B]</title>
    <url>/2021/08/23/Tournament-2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-B/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/gym/101981/attachments/download/7891/20182019-acmicpc-asia-nanjing-regional-contest-en.pdf">B题</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑DP，设 $f_{i,j}$ 表示考虑到第 $i$ 个点，$1\sim i$ 中一共放了 $j$ 个的最小答案。</p>
<p>$O(n^3)$ 转移，答案即为 $f_{n,k}$。</p>
<p>看到必须放 $k$ 个，可想到wqs二分，打表可知 $f_{n,*}$ 是凸的。</p>
<p>于是二分一个 $x$，让每次放一个则额外加多 $x$ 的贡献，DP时记录去最小值的时候最多放了多少个，找到放 $k$ 个的答案。</p>
<p>这样做的好处是将DP的第二维的限制给去掉了。</p>
<p>但是这个DP还是 $O(n^2)$ 的。</p>
<p>打表发现他有决策单调性，于是写个决策单调性优化DP就可以了。</p>
<p>时间复杂度是两个log的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line">ll a[N],s[N];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	l--;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s[r]+s[l]-s[(l+r)&gt;&gt;<span class="number">1</span>]-s[(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">g</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f[l]+<span class="built_in">calc</span>(l+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll X=<span class="built_in">g</span>(x,r),Y=<span class="built_in">g</span>(y,r);</span><br><span class="line">	<span class="keyword">if</span>(X!=Y) <span class="keyword">return</span> X&gt;Y;</span><br><span class="line">	<span class="keyword">return</span> h[x]&gt;h[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> le[N],bel[N],top,st;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(st&gt;top) <span class="keyword">return</span> n;</span><br><span class="line">	<span class="type">int</span> l=le[top],r=n,mid;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(bel[top],i,mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>; h[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	le[<span class="number">1</span>]=<span class="number">1</span>; bel[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	st=top=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(st&lt;top&amp;&amp;i==le[st+<span class="number">1</span>]) st++;</span><br><span class="line">		f[i]=<span class="built_in">g</span>(bel[st],i)+x; h[i]=h[bel[st]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;top&gt;=st&amp;&amp;<span class="built_in">check</span>(bel[top],i,le[top]);) top--;</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">find</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(tmp&lt;=n) ++top,le[top]=tmp,bel[top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==k) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">	ll l=<span class="number">0</span>,r=<span class="number">3e15</span>,mid,tmp,ans=<span class="number">9e18</span>;</span><br><span class="line">	<span class="type">int</span> now=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;l+<span class="number">1</span>&lt;r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		tmp=<span class="built_in">calc</span>(mid);</span><br><span class="line">		<span class="keyword">if</span>(h[n]&lt;=k) r=mid,ans=tmp<span class="number">-1ll</span>*h[n]*mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp=<span class="built_in">calc</span>(r);</span><br><span class="line">	ans=tmp<span class="number">-1ll</span>*k*r;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>wqs二分</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校8</title>
    <url>/2021/08/13/hdu2021%E5%A4%9A%E6%A0%A18/</url>
    <content><![CDATA[<p><a href="https://acm.hdu.edu.cn/contests/contest_show.php?cid=992">比赛链接</a></p>
<span id="more"></span>

<h2 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h2><p>随便口胡一波。</p>
<p>设 $f_{i,j,k,flag,limit}$ 表示考虑到第 $i$ 位，当前前缀为 $x$ 为 $j$，最后为 $k$ 的方案数，然后dp一下就好了。</p>
<h2 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>暂时还不会其他的又快又好写的做法。</p>
<p><del>自己的垃圾做法写了我快1.5h</del></p>
<p>设 $f_{i,j}$ 表示考虑到第 $i$ 个，一共花了 $j$ 个硬币的方案数。</p>
<p>一行状态只跟前两行状态有关，于是需要记录一下第 $i$ 行和第 $i-1$ 行的答案，并用普通生成函数表示。</p>
<p>考虑倍增，如何从 $n$ 的状态（指记录了 $n$ 和 $n-1$ 行）转移到更小的状态上。</p>
<p>不妨设 $n$ 为偶数（否则 $O(m)$ 推一遍让 $m$ 变成 $m-1$），</p>
<p>考虑将 $n$ 个分成两半，两边各有 $\frac{n}{2}$ 个。考虑左边的最右端如何选择，是自已单独组成一个，是与右边的组合，还是与左边的组合，分成三种情况讨论，设 $\frac{n}{2}-1$ 的生成函数为 $C$， $\frac{n}{2}-2$ 的生成函数为 $D$， 那么 $n$ 的答案就是 $C\times C,C\times D,D\times D$ 乘上一些常多项式后加起来。</p>
<p>$n-1$ 的同理。</p>
<p>于是 $n$ 的状态可以转换成 $\frac{n}{2}-1$ 的状态。</p>
<p>倍增+FFT即可。时间复杂度 $O(m\log m\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line">ll W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">    A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Mul</span>(A[i],k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">    B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,Poly &amp;A,Poly &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A.<span class="built_in">resize</span>(<span class="number">1</span>); A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		B.<span class="built_in">resize</span>(<span class="number">3</span>); B[<span class="number">0</span>]=<span class="number">1</span>; B[<span class="number">1</span>]=<span class="number">1</span>; B[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A.<span class="built_in">resize</span>(<span class="number">3</span>); A[<span class="number">0</span>]=A[<span class="number">1</span>]=A[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">		B.<span class="built_in">resize</span>(<span class="number">5</span>); B[<span class="number">0</span>]=<span class="number">1</span>; B[<span class="number">1</span>]=<span class="number">3</span>; B[<span class="number">2</span>]=<span class="number">5</span>; B[<span class="number">3</span>]=<span class="number">3</span>; B[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Poly C,D,E;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>((n<span class="number">-2</span>)/<span class="number">2</span>,C,D);</span><br><span class="line">		E=C*D; C=C*C; D=D*D;</span><br><span class="line">		B.<span class="built_in">clear</span>(); A.<span class="built_in">clear</span>();</span><br><span class="line">		B.<span class="built_in">resize</span>(m+<span class="number">8</span>); A.<span class="built_in">resize</span>(m+<span class="number">8</span>);</span><br><span class="line">		E.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">		C.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">		D.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			B[i]+=D[i];</span><br><span class="line">			B[i+<span class="number">1</span>]+=D[i]*<span class="number">3</span>+E[i]*<span class="number">2</span>;</span><br><span class="line">			B[i+<span class="number">2</span>]+=D[i]*<span class="number">5</span>+E[i]*<span class="number">6</span>+C[i];</span><br><span class="line">			B[i+<span class="number">3</span>]+=D[i]*<span class="number">3</span>+E[i]*<span class="number">8</span>+C[i]*<span class="number">4</span>;</span><br><span class="line">			B[i+<span class="number">4</span>]+=D[i]+E[i]*<span class="number">6</span>+C[i]*<span class="number">6</span>;</span><br><span class="line">			B[i+<span class="number">5</span>]+=E[i]*<span class="number">2</span>+C[i]*<span class="number">4</span>;</span><br><span class="line">			B[i+<span class="number">6</span>]+=C[i];</span><br><span class="line">			A[i]+=D[i];</span><br><span class="line">			A[i+<span class="number">1</span>]+=D[i]+E[i]*<span class="number">2</span>;</span><br><span class="line">			A[i+<span class="number">2</span>]+=D[i]+E[i]*<span class="number">4</span>;</span><br><span class="line">			A[i+<span class="number">3</span>]+=E[i]*<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) A[i]%=mod,B[i]%=mod;</span><br><span class="line">		B.<span class="built_in">resize</span>(m+<span class="number">1</span>); A.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(n<span class="number">-1</span>,C,D);</span><br><span class="line">		B.<span class="built_in">clear</span>();</span><br><span class="line">		B.<span class="built_in">resize</span>(m+<span class="number">5</span>);</span><br><span class="line">		C.<span class="built_in">resize</span>(m+<span class="number">1</span>); D.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			B[i]+=D[i]; B[i+<span class="number">1</span>]+=D[i]; B[i+<span class="number">2</span>]+=D[i];</span><br><span class="line">			B[i+<span class="number">1</span>]+=C[i]; B[i+<span class="number">2</span>]+=(C[i]*<span class="number">2</span>); B[i+<span class="number">3</span>]+=C[i];</span><br><span class="line">		&#125;</span><br><span class="line">		B.<span class="built_in">resize</span>(m+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) B[i]%=mod;</span><br><span class="line">		A=D;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	Poly A[<span class="number">2</span>];</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		A[<span class="number">0</span>].<span class="built_in">clear</span>(); A[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">dfs</span>(n,A[<span class="number">0</span>],A[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,A[<span class="number">1</span>][i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h2><p>Prim模板题。</p>
<h2 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h2><p>简单博弈论模板题。</p>
<h2 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h2><p>求两圆相交的面积，余弦定理搞一搞即可。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>FFT</tag>
        <tag>计算几何</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校7</title>
    <url>/2021/08/11/hdu2021%E5%A4%9A%E6%A0%A17/</url>
    <content><![CDATA[<p><a href="https://acm.hdu.edu.cn/contests/contest_show.php?cid=990">链接</a></p>
<span id="more"></span>

<h2 id="1011"><a href="#1011" class="headerlink" title="1011"></a>1011</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一序列 $a_1,a_2\cdots a_n$，求子序列的和的乘积对 $998244353$ 取模后的结果。</p>
<p>保证 $\sum a_i\le 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>只需求出有多少个子序列满足子序列和等于 $x$ 的，设为 $b_x$。答案即为 $\prod_{i=1}^{10^5}i^{b_i}$。</p>
<p>而 $b_m$ 显然等于 $[x^m]\prod_{i=1}^n(1+x^{a_i})$。</p>
<p>分治FFT即可。</p>
<p>但是 $b_m$ 是在模 $\varphi(998244353)=998244352$ 意义下的，于是需要使用拆系数FFT。</p>
<p>拆系数FFT详见<a href="https://ouqingliang.gitee.io/FFT/#%E4%BB%BB%E6%84%8F%E6%A8%A1%E6%95%B0FFT">链接</a>。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mo=<span class="number">998244352</span>;</span><br><span class="line"></span><br><span class="line">db pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">P</span>(db _x=<span class="number">0</span>,db _y=<span class="number">0</span>) &#123;x=_x,y=_y;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> +(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x+B.x,A.y+B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> -(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x-B.x,A.y-B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> *(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> /(<span class="type">const</span> P&amp;A,<span class="type">const</span> db &amp;x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x/x,A.y/x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">P <span class="title">conj</span><span class="params">(P A)</span> </span>&#123;<span class="keyword">return</span> (P)&#123;A.x,-A.y&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">P W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">			W[i+j]=(P)&#123;<span class="built_in">cos</span>(pi*j/i),<span class="built_in">sin</span>(pi*j/i)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;P&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(P *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	P w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k],</span><br><span class="line">				a[i+j+k]=a[j+k]-w,</span><br><span class="line">				a[j+k]=a[j+k]+w;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]+B[i];</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Real(A) ((ll)floor(A.x+0.5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Imag(A) ((ll)floor(A.y+0.5))</span></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> Poly C,D;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	C.<span class="built_in">resize</span>(len); D.<span class="built_in">resize</span>(len); A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(P)&#123;<span class="built_in">Real</span>(A[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(A[i])&gt;&gt;<span class="number">15</span>&#125;,D[i]=(P)&#123;<span class="built_in">Real</span>(B[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(B[i])&gt;&gt;<span class="number">15</span>&#125;;</span><br><span class="line">	<span class="built_in">ntt</span>(C,len,<span class="number">1</span>); <span class="built_in">ntt</span>(D,len,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len)</span><br><span class="line">	&#123;</span><br><span class="line">		P d4,d0,d1,d2,d3;</span><br><span class="line">		j=(len-i)&amp;(len<span class="number">-1</span>);</span><br><span class="line">		d4=<span class="built_in">conj</span>(C[j]);</span><br><span class="line">		d0=(d4+C[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>);</span><br><span class="line">		d1=(d4-C[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">		d4=<span class="built_in">conj</span>(D[j]);</span><br><span class="line">		d2=(d4+D[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>);</span><br><span class="line">		d3=(d4-D[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">		A[i]=d0*d2+d1*d3*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		B[i]=d0*d3+d1*d2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(<span class="built_in">Real</span>(A[i]) + (<span class="built_in">Imag</span>(A[i]) % mo &lt;&lt; <span class="number">30</span>) + (<span class="built_in">Real</span>(B[i]) % mo &lt;&lt; <span class="number">15</span>))%mo;</span><br><span class="line">	C.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">Poly A;</span><br><span class="line"><span class="type">int</span> n,sum;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		Poly B;</span><br><span class="line">		B.<span class="built_in">resize</span>(a[l]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,a[l]) B[i]=<span class="number">0</span>;</span><br><span class="line">		B[<span class="number">0</span>]=<span class="number">1</span>; B[a[l]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> B;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">solve</span>(l,mid)*<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=(a[i]=<span class="built_in">read</span>());</span><br><span class="line">		<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(a[i]==<span class="number">0</span>) &#123;flag=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)&#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		A=<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">		ll ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,sum) ans=ans*<span class="built_in">Pow</span>(i,<span class="built_in">Real</span>(A[i]))%mod;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 BUPT Welcome Wagon 题目集锦</title>
    <url>/2021/08/04/2021-BUPT-Welcome-Wagon-%E9%A2%98%E7%9B%AE%E9%9B%86%E9%94%A6/</url>
    <content><![CDATA[<p><a href="https://vjudge.ppsucxtt.cn/contest#category=all&running=0&title=bupt%20welcome&owner=">比赛链接</a></p>
<span id="more"></span>

<h2 id="Contest-2"><a href="#Contest-2" class="headerlink" title="Contest 2"></a>Contest 2</h2><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>构造出一个树，使得直径数量恰为 $k$，且节点数最少。</p>
<p>多次询问。</p>
<p>$q,n\le 500$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>考虑树的重心，分类讨论：</p>
<ul>
<li><p>重心在边上，左边挂 $x$ 个点，右边挂 $y$ 个点，此时能构造出 $x\times y$ 的形式，总点数 $x+y+2$。</p>
</li>
<li><p>重心在点上，且为是菊花图的形式，此时能构造出 $x*(x-1)$ 的形式，总点数 $x+1$。</p>
</li>
<li><p>重心在点上，但不为菊花图。可以发现，若以重心为根，最优方案中重心的若干子树一定是一个菊花图的形式（也就是连一个点，然后这个点连出去若干条边）。若对于每个子树中，叶节点个数为 $a_i$，则能构造出 $\sum_{1\le i &lt; j\le m}a_ia_j$。总点数为 $1+m+\sum a_i$。</p>
</li>
</ul>
<p>前两种都非常好求，对于第三种，考虑DP，设 $f_{i,j}$ 表示构造出总数为 $i$ 的方案，且 $\sum a_k=j$ 时的最小点数。初始时 $f_{0,i}=2+i$。</p>
<p>枚举下一个子树选什么，类似背包的转移，并记录从上一个位置方便输出方案。</p>
<p>三种做法取一个最小值。</p>
<p>时间复杂度 $O(n^2\log n+q\log n)$。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定 $n$ 个物品，重量为 $a_i$，价值为 $w_i$。</p>
<p>$m$ 次询问，每次给定一个 $q_i$，求选出若干物品（可重复选）使得物品重量之和为 $q_i$，且价值和最小。</p>
<p>输出价值和对 $10^9+7$ 取模后的结果。</p>
<p>$n\le 100,a_i\le 100,m\le 10^6,q_i\le 10^{18}$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>显然是个完全背包，但是 $q_i$ 极大。</p>
<p>设 $c=\max_{i=1}^n \{a_i\}$。</p>
<p>如果存在某个数组 $b$ 表示每个物品取出的次数，使得 $q=\sum_{i=1}^na_ib_i$。那么对于每个 $j$，都可以通过调整 $b$，使得存在 $\sum_{i=1}^na_ib’<em>i=q$ 且 $\sum</em>{i\neq j}a_ib’_i&lt; n a_j^2$。</p>
<p>证明：若 $b’_i\geq a_j$，则可以将 $b’_i$ 减去 $a_j$。</p>
<p>也就是说，最终的 $b’<em>i$ 都是小于 $a_j$ 的。那么 $\sum</em>{i\neq j}a_ib’<em>i&lt;\sum</em>{i=1,i\neq j}^na_ia_j \leq n c^2$。</p>
<p>可以发现，$nc^2$ 是 $10^6$ 级别的。</p>
<p>当 $q_i$ 大过 $nc^2$ 时，通过贪心，找到 $\frac{w_i}{a_i}$ 的最小值，一直选这个，直到 $q_i&lt;nc^2$，然后通过预处理 $nc^2$ 以内的背包来找到最小值。</p>
<p>时间复杂度 $O(n^2c^2+q)$。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给定 $7\times n$ 的网格，你需要在上面填进 $k$ 个L型的网格（共3个格子），以及 $7n-3k$ 个 $1\times 1$ 的格子。</p>
<p>有 $m$ 个格子不能填 $1\times 1$ 的格子进去。问合法的方案数对 $10^9+33$ 取模后结果。</p>
<p>$n\le 100,7n-20\le 3k\le 7n,m\le 7n$。时限4s。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p><del>口胡一下，还没写。</del></p>
<p>设 $f_{i,j,k}$ 表示搞到第 $i$ 列且第 $i$ 列目前的状态（是否填了格子进去）为 $j$，一共用了 $k$ 个 $1\times 1$ 的方案数。</p>
<p>时间复杂度 $O(2^{14}nk’^2)$，其中 $k’=7n-3k$。</p>
<h2 id="Contest-3"><a href="#Contest-3" class="headerlink" title="Contest 3"></a>Contest 3</h2><h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><h4 id="题源"><a href="#题源" class="headerlink" title="题源"></a>题源</h4><p><a href="https://www.codechef.com/problems/F2NDMAX">F2NDMAX</a></p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>首先，对于每个连通块，只有一个入度为 $0$ 的点。只有这个点以及只与这个点相连的点才有可能成为第二大的。</p>
<p>于是其他点可以完全删掉。剩下 $m$ 个类似于菊花图的东西。</p>
<p>而这 $m$ 个连通块至少要通过 $m-1$ 次询问才能确定谁最大，从而确定次大值。</p>
<p>贪心，维护菊花图的大小，从小到大将最小的两个大小为 $x,y$ 的菊花合并为 $y+1$ 即可。</p>
<p>时间复杂度 $O(\sum (n+m))$。</p>
<h3 id="G-1"><a href="#G-1" class="headerlink" title="G"></a>G</h3><h4 id="题源-1"><a href="#题源-1" class="headerlink" title="题源"></a>题源</h4><p><a href="https://www.codechef.com/problems/ANGKILL">Angry Killjee</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定一个字符串 $|S|$，对于每个 $i(1\le i \le |S|)$，求出其某个长度为 $i$ 的子串的出现次数的最大值。</p>
<p>$|S|\le 2\times 10^5$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p><del>搞完题意发现有点简单，不管了</del></p>
<p>直接建出SAM，拓扑排序后对每个节点算出出现次数，SAM中的一个节点代表的是若干长度连续的字符串。然后求个后缀最大值就可以了。</p>
<p>时间复杂度 $O(|S|\Sigma )$。</p>
<p>SA做法？</p>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定一个 $n\times m$ 的格子。格子上写着 $0\sim 9$ 的数字，在上面任选起点，上下左右可多次经过同一个格子地走行程一个数字。问最小的无法走出的正整数。</p>
<p>$n,m\le 100$。</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>设这个最小的正整数位数为 $x$，需要满足 $nm\times 4^{x-1}\geq 10^x$，解得 $x\le 8$。</p>
<p>于是只需最多走 $8$ 次，然后判断即可。</p>
<p>时间复杂度 $O(nm\times 4^{7})$。</p>
<h2 id="Contest-4"><a href="#Contest-4" class="headerlink" title="Contest 4"></a>Contest 4</h2><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>定义与两个字符串 $S,T$ 相关的函数 $f(S,T)$ 为它们最长公共子串的长度。</p>
<p>给定 $n$ 个字符串，多次询问两个字符串间的 $f$ 值。</p>
<p>$n\le 50000,q\le 10^5,\sum |s_i|\le 10^5$。</p>
<h4 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4><p>如何求 $f$ ？</p>
<p>对于某个串建出SAM后，另一个串在上面跑匹配即可。</p>
<p>每次询问都去建出后缀自动机？</p>
<p>显然不可能。</p>
<p>设字符串总长为 $k$ 。考虑设定阈值 $L$，并对询问离线。</p>
<p>对于 $|s_i|$ 都 大于 $ L$ 的询问一共最多只有 $\frac{k^2}{L^2}$ 种。找到匹配时暴力跑SAM，时间复杂度 $O(\frac{k^2}{L})$。</p>
<p>对于存在 $|s_i|&lt;L$ 的询问，用短串在长串的SAM上匹配。这样每个串只用建一次SAM，每次询问都要花短串长度的时间。时间复杂度 $O(mL)$。</p>
<p>取 $L=\sqrt{k}$，时间复杂度 $O(k^{1.5}+mk^{0.5})$。</p>
<h3 id="G-2"><a href="#G-2" class="headerlink" title="G"></a>G</h3><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>给定 $n(n \le 3\times 10^6)$，问 $\sin(x)+\sin(y)+\sin(z)$ 的最大值，其中 $x,y,z$ 均为正整数且 $x+y+z=n$。</p>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><p>显然先把 $z$ 换了，变成求 $\sin(x)+\sin(y)+\sin(n-(x+y))$ 的最大值。</p>
<p>第三个 $\sin$ 中的 $x+y$ 启发我们对 $\sin(x)+\sin(y)$ 进行和差化积的变换：</p>
<p>$$<br>\sin(x)+\sin(y)=2\sin(\frac{x+y}{2})\cos(\frac{x-y}{2})<br>$$</p>
<p>枚举 $x+y=k$，变成求 $\cos(\frac{k-2y}{2})$ 的最大值。</p>
<p>对 $k$ 的奇偶性分类讨论，作前缀最大值即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="Contest-5"><a href="#Contest-5" class="headerlink" title="Contest 5"></a>Contest 5</h2><h3 id="G-3"><a href="#G-3" class="headerlink" title="G"></a>G</h3><h4 id="题源-2"><a href="#题源-2" class="headerlink" title="题源"></a>题源</h4><p>Codeforces570D</p>
<h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>一棵以 $1$ 为根的有根树，每个节点上有一个小写字母。</p>
<p>多次询问某个子树中，将所有深度 $=k$ 的节点的字母，是否能通过随意组合形成回文串？</p>
<p>$n,q\le 5\times 10^5$。</p>
<h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><p>首先一定要解决的问题是：如何判断若干字母是否能形成回文串？</p>
<p>显然，这个问题等价于最多有一个字母的出现次数为奇数。</p>
<p>于是，用二进制的某一位表示每个字母的出现次数模二的结果，变成若干个数异或后，判断是否是 $2^i$ 或 $0$。</p>
<p>对树：算出dfs序，以及每个子树的节点的dfs序区间。</p>
<p>对于每一层，开一个vector，按dfs序存节点进去。</p>
<p>每次询问二分找到相应层数对应的dfs序区间，通过预处理出前缀异或和 $O(1)$ 判断能否组成回文串。</p>
<p>时间复杂度 $O((n+q)\log n)$。</p>
<h3 id="H-1"><a href="#H-1" class="headerlink" title="H"></a>H</h3><h4 id="题源-3"><a href="#题源-3" class="headerlink" title="题源"></a>题源</h4><p>Codeforces704B</p>
<h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4><p>$n$ 个点排成一列，从 $s$ 出发，到 $t$ 结束，每个点必须且只经过一次。</p>
<p>从 $i$ 到 $j$ 的花费为：</p>
<ul>
<li>若 $i&gt;j$ ，则为 $x_j-x_i+d_i+a_i$；</li>
<li>若 $i&lt;j$ ，则为 $x_i-x_j+c_i+b_j$ 。</li>
</ul>
<p>求最小花费。</p>
<p>$n\le 5000$。</p>
<h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><p><del>有一种超级厉害的贪心方法，可是不会啊QAQ。</del></p>
<p>考虑<del>十分经典的</del>DP，设 $f_{i,j}$ 表示考虑前 $i$ 个点时，向右伸出去多少条链时的最小花费。</p>
<p>但这个链是有方向的呀，难道不用处理方向吗？</p>
<p>是的没错，就是不用处理，因为不同方向的链的数量的差不会超过 $2$，且这个差跟起点终点有很大关系。</p>
<p>于是只需要考虑每个点如何转移。</p>
<p>有四种情况：</p>
<ul>
<li>合并一条出去和另一条回来的链。</li>
<li>多出一条出去和回来的两条链。</li>
<li>延伸一条出去的链。</li>
<li>延伸一条回来的链。</li>
</ul>
<p>大力分类讨论，并注意特殊情况即可。</p>
<p>起点终点需要特判。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,s,t;</span><br><span class="line"></span><br><span class="line">ll x[N],a[N],b[N],c[N],d[N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chk</span><span class="params">(ll &amp;x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">min</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); s=<span class="built_in">read</span>(); t=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) x[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(j,(i==<span class="number">1</span>)?<span class="number">0</span>:<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">if</span>(f[i<span class="number">-1</span>][j]&lt;inf)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j+<span class="number">1</span>&lt;=n) <span class="built_in">chk</span>(f[i][j+<span class="number">1</span>],f[i<span class="number">-1</span>][j]+(b[i]-x[i]));</span><br><span class="line">				<span class="keyword">if</span>(j) <span class="built_in">chk</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]+(a[i]+x[i]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i==s)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j) <span class="built_in">chk</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]+(c[i]+x[i]));</span><br><span class="line">				<span class="keyword">if</span>(j+<span class="number">1</span>&lt;=n) <span class="built_in">chk</span>(f[i][j+<span class="number">1</span>],f[i<span class="number">-1</span>][j]+(d[i]-x[i]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i!=s&amp;&amp;i!=t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(j<span class="number">-2</span>&gt;=<span class="number">0</span>) <span class="built_in">chk</span>(f[i][j<span class="number">-2</span>],f[i<span class="number">-1</span>][j]+x[i]+x[i]+a[i]+c[i]);</span><br><span class="line">				<span class="keyword">if</span>(j+<span class="number">2</span>&lt;=n) <span class="built_in">chk</span>(f[i][j+<span class="number">2</span>],f[i<span class="number">-1</span>][j]-x[i]-x[i]+b[i]+d[i]);</span><br><span class="line">				<span class="keyword">if</span>(j<span class="number">-2</span>&gt;=<span class="number">0</span>||i&gt;s) <span class="built_in">chk</span>(f[i][j],f[i<span class="number">-1</span>][j]+d[i]+a[i]);</span><br><span class="line">				<span class="keyword">if</span>(j<span class="number">-2</span>&gt;=<span class="number">0</span>||i&gt;t) <span class="built_in">chk</span>(f[i][j],f[i<span class="number">-1</span>][j]+c[i]+b[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><h4 id="题源-4"><a href="#题源-4" class="headerlink" title="题源"></a>题源</h4><p>Codeforces286E</p>
<h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>给定 $n$ 个数 $a_1,a_2,\cdots a_n$，以及 $m$ 。求一个长度最小的序列 $b_1,b_2,\cdots,b_k$，使得对于每个 $a_i$，都能在序列中找到若干个数（能多次选同一个数）相加等于它；且从 $b$ 中选出若干个加起来不超过 $m$ 的数（能多次选同一个数），这些数的和在 $a_i$ 中。</p>
<p>若无解，输出 $-1$。</p>
<p>$n,m,a_i\le 10^6$。</p>
<h4 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h4><p>将 $a$ 从小到大排序后可以发现，$b$ 中一定要有 $a$ 最小的那个数。</p>
<p>如果有 $a_i$ 等于若干 $b$ 的和，则这里面最小的 $b_i$ 一定是某个 $a$。那么 $a_i-b_{min}$ 也就是其他 $b$ 的和也要是某个 $a_i$，否则就违反了限制。</p>
<p>因此，$b_i$ 中全是 $a$ 序列中的数。显然，将整个 $a$ 序列全选上去最有可能有解。</p>
<p>如何判断无解？也就是存在某两个 $i,j$ 使得 $a_i+a_j$ 不在序列 $a$ 中？</p>
<p>FFT搞一搞即可。</p>
<p>如何找到最优解？</p>
<p>显然，如果对于某个 $a_k$，使得不存在 $a_i+a_j=a_k$ 的，这个 $a_k$ 就要选了。</p>
<p>于是就做完了，只需跑一遍FFT。</p>
<p>时间复杂度 $O(n+m\log m)$。</p>
<h2 id="Contest-6"><a href="#Contest-6" class="headerlink" title="Contest 6"></a>Contest 6</h2><h3 id="I-1"><a href="#I-1" class="headerlink" title="I"></a>I</h3><h4 id="题源-5"><a href="#题源-5" class="headerlink" title="题源"></a>题源</h4><p><a href="https://vjudge.ppsucxtt.cn/problem/CodeForces-908D/origin">CodeForces - 908D</a></p>
<h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><p>空字符串，每次有 $p$ 概率在后面加一个 <code>a</code>，有 $1-p$ 概率加一个 <code>b</code>，问第一次 <code>ab</code> 出现该字符串的子序列中次数 $\geq k$ 的期望时间，对 $10^9+7$ 取模。</p>
<p>$k\le 1000$。</p>
<h4 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h4><p>设 $f_{i,j}$ 表示字符串中一共 $i$ 个 <code>a</code>，且 <code>ab</code> 出现了 $j$ 次时的概率。</p>
<p>DP一下即可。</p>
<p>边界条件为 $i+j\geq k$，此时再加一个 <code>b</code>就会超过 $k$ 个，于是求个等比数列什么的就可以了。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h2 id="Contest-8"><a href="#Contest-8" class="headerlink" title="Contest 8"></a>Contest 8</h2><h3 id="H-2"><a href="#H-2" class="headerlink" title="H"></a>H</h3><h4 id="题源-6"><a href="#题源-6" class="headerlink" title="题源"></a>题源</h4><p><a href="https://vjudge.ppsucxtt.cn/problem/LibreOJ-6621/origin">LibreOJ - 6621</a></p>
<h4 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h4><p>显然，第一个人只会选一个话题。</p>
<p>枚举选了哪个话题，然后看有哪些话题能被这个话题所到达。</p>
<p>传递闭包。</p>
<p>时间复杂度 $O(\frac{n^3}{w})$。</p>
<h2 id="Contest-9"><a href="#Contest-9" class="headerlink" title="Contest 9"></a>Contest 9</h2><p>2019ICPC南京站。</p>
<h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><h4 id="题源-7"><a href="#题源-7" class="headerlink" title="题源"></a>题源</h4><p><a href="https://nanti.jisuanke.com/t/42396">Chessboard</a></p>
<h4 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h4><p>显然，最近的距离就是曼哈顿距离。</p>
<p>考虑现在已经走完了一个 $a\times b$ 大小的矩形，且当前位置在矩形的顶点上。</p>
<p>由于题目的限制，可以知道此时如果在当前的位置走出去一个，开出了新的一行或一列，那么之后就一定要马上填完这一行或一列，否则就不合法了。</p>
<p>于是相当于从一个 $1\times 1$ 的矩阵向外扩展到 $n\times m$。每次可以使行数或列数+1，问方案数。</p>
<p>答案即为 $4\times \binom{n+m-2}{n-1}$。乘 $4$ 是因为刚开始有四个方向。</p>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><h4 id="题源-8"><a href="#题源-8" class="headerlink" title="题源"></a>题源</h4><p><a href="https://nanti.jisuanke.com/t/42404">Spy</a></p>
<h4 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h4><p>KM算法模板题，然而刚开始写了个假的 $O(n^4)$ 的KM，需要用bfs才能保证其正确性。</p>
<h2 id="Contest-10"><a href="#Contest-10" class="headerlink" title="Contest 10"></a>Contest 10</h2><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><p>给出字符串 $s,t$，求满足 $1\le i \le j \le |s|,1\le k \le |t|,j-i+1 &gt; k$，且 $s[i,j]+t[1,k]$ 为为回文串的 $(i,j,k)$ 对数。</p>
<p>$1\le |t| \le |s| \le 10^6$。</p>
<h4 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h4><p>由于 $j-i+1 &gt; k$，有 $s[i+k,j]$ 是回文串。</p>
<p>于是枚举 $i+k$ 的位置 $l$，变成统计有多少个 $x$ 满足 $s[x,l-1]$ 的反串为 $t$ 的前缀，有多少个 $y$ 满足 $s[l,y]$ 为回文串。</p>
<p>分成两部分，第一部分是扩展KMP模板，也可以二分+hash或SAM或SA；第二部分是manacher模板，也可以二分+hash或PAM。</p>
<p>大概可以有 $4\times 3=12$ 种不同的做法。</p>
<h3 id="F-1"><a href="#F-1" class="headerlink" title="F"></a>F</h3><p>详见：<a href="/2021/08/23/Tournament-2018-2019-ACM-ICPC-Asia-Nanjing-Regional-Contest-B/" title="“Tournament”">“Tournament”</a></p>
<h2 id="Contest-12"><a href="#Contest-12" class="headerlink" title="Contest 12"></a>Contest 12</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>给定 $L,R,k$，求最大的 $j-i+1$，使得 $L\le i \le j \le R$，且 $[i,j]$ 间的整数的异或和 $\le k$。</p>
<p>$T\le 5\times 10^5,L,R\le 10^{18}$。</p>
<h4 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h4><p>显然，$4x,4x+1,4x+2,4x+3$ 的异或和为 $0$。</p>
<p>于是整 $4$ 的倍数段的都可以。剩下的暴力枚举就可以了。</p>
<p>时间复杂度 $O(16T)$。</p>
<h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>给定 $[L,R]$，判断是否满足 $\frac{\sum_{i=L}^{R}[i\in \mathbb{P}]}{R-L+1}&lt;\frac{1}{3}$。</p>
<p>$T\le 100,L,R\le 10^9$。</p>
<h4 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h4><p>$n$ 以内质数个数约为 $\frac{n}{\ln n}$ 级别。当 $[L,R]$ 越大，越难满足。</p>
<p>于是当 $R-L+1\geq K$ 的时候直接输出 <code>No</code>，剩下的用区间筛判断一下就好。</p>
<p>$K$ 取 $10^4$ 就可以了。</p>
<p>或许也可以直接跑Min-25筛？</p>
<h3 id="E-1"><a href="#E-1" class="headerlink" title="E"></a>E</h3><h4 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h4><p>求最大的 $i$，满足 $X^i\prod_{j=1}^na_j!$ 为 $Y!$ 的约数。</p>
<p>$\sum a_i\le Y \le 10^{18},X\le 10^{18}$。</p>
<h4 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h4><p>对 $X$ 进行质因数分解后，对每个质因数的项 $p^k$，算出最大的 $x$，满足 $p^x|\frac{Y!}{\prod_{i=1}^n a_i!}$。那么答案就是 $\min(\lfloor \frac{x}{k} \rfloor)$。</p>
<p>$x$ 十分容易算，于是只需要写个Pollard-rho就好了。</p>
<h3 id="F-2"><a href="#F-2" class="headerlink" title="F"></a>F</h3><p>直接打表。</p>
<p>打表时间复杂度 $O(200\times 10^8)$。</p>
<h3 id="H-3"><a href="#H-3" class="headerlink" title="H"></a>H</h3><h4 id="题意-15"><a href="#题意-15" class="headerlink" title="题意"></a>题意</h4><p>给定一序列，支持单点修改，查询区间的子集的mex，即最小的正整数 $x$，使得不存在在某个区间中选出若干个数的和为 $x$。</p>
<p>$n,q\le 2\times 10^5$，数为正整数。</p>
<h4 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h4><p>假设对于某个区间，如何计算这个mex呢？</p>
<p>显然，看区间的mex能否为 $1$，统计出所有 $\le 1$ 的数的和，假设为 $x$，若 $x\geq 1$，则统计所有 $\le x+1$ 的数的和，然后一直下去。</p>
<p>每次统计，$x$ 至少乘二。于是只需求区间小于等于某个数的和。</p>
<p>由于有单点修改，只需写一个树状数组套线段树。</p>
<p>时间复杂度 $O(n\log ^2n+q\log ^3n)$。</p>
<h3 id="J-1"><a href="#J-1" class="headerlink" title="J"></a>J</h3><h4 id="题意-16"><a href="#题意-16" class="headerlink" title="题意"></a>题意</h4><p>给定一个 $n$ 个点的完全无向图，将所有的边分成 $n-1$ 条路径，每个边恰在一条路径内，第 $i$ 条路径经过的边数为 $i-1$。</p>
<p>$n\le 10^3$。</p>
<h4 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h4><p>当时人傻掉了，以为 $n$ 个点的完全图都存在欧拉路。</p>
<p>当 $n$ 为奇数时，存在欧拉路。</p>
<p>当 $n$ 为偶数时，不存在欧拉路。</p>
<p>最麻烦的显然是长度最长的那些路径。</p>
<p>观察 $n=4$ 时可以发现，$n-1$ 和 $n-2$ 的路径可以通过 $n,n-1$ 号点及其与其他点相连的边的搞出来，然后变成一个 $n-2$ 的子问题。</p>
<p>发现当 $n&gt;4$ 时，$n,n-1$ 号点相连的边一共有 $2(n-2)+1=2n-3$ 条，恰好就是 $(n-1)+(n-2)$，而且也能构造出来。</p>
<p>于是就做完了。</p>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><p>Trie上建SAM模板，然后来个parent-tree上倍增定位字符串。注意建SAM一定要bfs建，不然会被卡成 $O(n^2)$。</p>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><h4 id="题意-17"><a href="#题意-17" class="headerlink" title="题意"></a>题意</h4><p>给定一棵有根树，求每棵子树的所有重心。</p>
<p>$n\le 2\times 10^5$。</p>
<h4 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h4><p>重心的若干性质：</p>
<ul>
<li>将两棵树拼起来，新树的重心必然是两棵原来的树的重心的最短路径上。</li>
<li>对于一棵树，其重心一定是自己，或在其重儿子中。</li>
<li>若割掉某个点后，剩下的子树中存在一个大小超过原树的一半，则该点一定不是重心。</li>
</ul>
<p>于是树剖，考虑重儿子的重心往上跳，直到成为子树的重心。是否继续往上则根据第三条性质。</p>
<p>时间复杂度 $O(n)$。注意可能有多个重心，需要特判。</p>
<p>一棵树存在多个重心当且仅当删掉某条边后树分裂成两棵且大小一样。</p>
<h2 id="Contest-15"><a href="#Contest-15" class="headerlink" title="Contest 15"></a>Contest 15</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><h4 id="题意-18"><a href="#题意-18" class="headerlink" title="题意"></a>题意</h4><p>将 $1\sim n^2$ 填进 $n\times n$ 的矩阵内，记 $|S|=|\{a_1,a_2,\cdots,a_n\}\or \{1,2,\cdots,n\}|$，其中 $a_i$ 为矩阵第 $i$ 行的最小值。求所有矩阵的 $|S|$ 的和。</p>
<p>$n\le 5000$。</p>
<h4 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h4><p>记 $f_i$ 表示 $i$ 这个数对 $\sum |S|$ 的贡献，即有多少个矩阵满足某一行的最小值为 $i$。</p>
<p>显然有：$f_i=n^2\binom{n^2-n}{i-1}(i-1)!(n^2-i)!$ 。</p>
<p>时间复杂度 $O(n^2+Tn)$。</p>
<h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p>树形DP模板。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>线段树模板题。</p>
<h3 id="E-2"><a href="#E-2" class="headerlink" title="E"></a>E</h3><p>$6n$ 即为答案。</p>
<h3 id="G-4"><a href="#G-4" class="headerlink" title="G"></a>G</h3><p>如果不能填格子，那么显然一定要在前 $i$ 个格子中滑下且这 $i$ 个格子都已经有球。枚举合法方案中最小的下标 $i$ 满足第 $i$ 个格子没有球。那么，前 $i$ 个格子都要有数，且后面的 $n-1-i$ 个格子随便乱放。</p>
<p>设 $g_{i,j}$ 表示长度为 $i-1$ 的格子随便乱放 $j$ 个，没有一个滑下的方案数。</p>
<p>设 $f_{i,j}$ 表示长度为 $i$ 的格子放了 $j$ 个，$1\sim i$ 的格子都放了球的方案数。</p>
<p>需要求出 $f,g$ ，还需要一个 $h_i$ 表示 $i$ 个格子放 $i$ 个球，且没有滑下的方案数。</p>
<p>$f,g$ 的转移枚举第一段，然后转移。</p>
<p>时间复杂度 $O(n^3)-O(n)$。</p>
<p>显然 $f,g$ 的转移是一个卷积的形式，可优化到 $O(n^2\log n)-O(n)$，但完全没必要。</p>
<h3 id="H-4"><a href="#H-4" class="headerlink" title="H"></a>H</h3><p>显然奇数一定不行。</p>
<p>那么操作就变成 $\times 2,/2,+1,-1$。</p>
<p>利用快速幂的思想，算出从 $1$ 出发向下走的步数 $x$，以及向右走的步数 $y$，</p>
<p>开始先向下走一步变成 $2$，之后每向下一步或向右一步都会 $\times 2$ 变成 $4$，需要经过某些转换转变回 $2$。</p>
<p>显然某种兜一圈的方法可以完成这个操作。</p>
<p>于是就做完了，最多不会超过 $197\times 5+1=986$ 次操作。</p>
<h3 id="I-2"><a href="#I-2" class="headerlink" title="I"></a>I</h3><p>签到题。</p>
<h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><p>边权从大到小排序，然后并查集按秩合并。</p>
<h3 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h3><p>模拟即可。</p>
<h2 id="Contest-18"><a href="#Contest-18" class="headerlink" title="Contest 18"></a>Contest 18</h2><a href="/2021/09/08/2018-2019-ACM-ICPC-Asia-Shenyang-Regional-Contest/" title="“ICPC2018沈阳”">“ICPC2018沈阳”</a>]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>SAM</tag>
        <tag>扩展KMP</tag>
        <tag>manacher</tag>
        <tag>FFT</tag>
        <tag>树状数组</tag>
        <tag>KM算法</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校4</title>
    <url>/2021/07/29/hdu2021%E5%A4%9A%E6%A0%A14/</url>
    <content><![CDATA[<p><a href="https://acm.hdu.edu.cn/contests/contest_show.php?cid=987">比赛链接</a></p>
<span id="more"></span>

<h3 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h3><p>签到题，给出的项除了常数以外都是不收敛的。</p>
<p>于是判断有 $x$ 的项是否为 $0$ 即可。</p>
<h3 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h3><p>签到题，暴力枚举起始点，用桶记录个数即可。</p>
<p>也可套用点分治做法做到 $O(n\log n)$。</p>
<h3 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>求所有长度为 $n$ 的01字符串的最短循环节的出现次数。</p>
<p>$n\le 10^9,\sum n\le 10^{10}$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>设 $g_n$ 表示答案，$f_i$ 表示最小循环节长度为 $i$ 的字符串个数。</p>
<p>有：$g_n=\sum_{i=1}^n\left \lfloor \frac{n}{i} \right \rfloor f_i$。</p>
<p>考虑 $f_i$ 如何求：</p>
<p>当 $m\le \frac{n}{2}$ 时，$2^m=\sum_{i|m} f_i$。</p>
<p>而当 $m&gt;\frac{n}{2}$ 后，上式就不成立了。因为周期引理不再适用。</p>
<p>但可以发现，此时的 $\left \lfloor \frac{n}{i} \right \rfloor=1$ ，于是我们还是通过补集转换，转去算 $2^n-\sum_{i=1}^{\left \lfloor \frac{n}{2} \right \rfloor} f_i$ 。</p>
<p>于是有 $g_n=2^n+\sum _{i=1}^{\frac{n}{2}}(\left \lfloor \frac{n}{i} \right \rfloor -1)f_i$。</p>
<p>整除分块，又因为有 $2^n=f * 1$，杜教筛筛出 $f_i$ 的前缀和即可。发现跑一次算 $f_i$ 前缀和的杜教筛就能算出整除分块里的所有的前缀和。</p>
<p>这里记录一下杜教筛的过程：若有积性函数 $f$，要算 $f$ 的前缀和 $S_n=\sum_{i=1}^nf_i$找到另外两个积性函数 $h,g$ 使得 $h=f * g$。</p>
<p>$$<br>\sum_{i=1}^n h_i=\sum_{i=1}^n \sum_{j|i} f(j)g(\frac{i}{j})\<br>=\sum_{i=1}^n g_i \sum_{j=1}^{\left \lfloor \frac{n}{i} \right \rfloor} f_i\<br>=\sum_{i=1}^n g_i S_{\left \lfloor \frac{n}{i} \right \rfloor}<br>$$</p>
<p>于是就可以了。</p>
<p>需要预处理 $O(n^{\frac{2}{3}})$ 前的 $f_i$ 的前缀和。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N+<span class="number">3</span>],f[N+<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll nw=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		nw=(nw*<span class="number">2</span>)%mod;</span><br><span class="line">		f[i]=<span class="built_in">Dec</span>(nw,f[i]);</span><br><span class="line">		s[i]=<span class="built_in">Add</span>(s[i<span class="number">-1</span>],f[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j+=i)</span><br><span class="line">			f[j]=<span class="built_in">Add</span>(f[j],f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,n2,tot;</span><br><span class="line">ll a[<span class="number">300000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&lt;=n2?x:tot-n/x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc_g</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="built_in">id</span>(m)]!=<span class="number">-1</span>) <span class="keyword">return</span> a[<span class="built_in">id</span>(m)];</span><br><span class="line">	ll ans=<span class="built_in">Dec</span>(<span class="built_in">Pow</span>(<span class="number">2</span>,(m+<span class="number">1</span>)),<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>,r;l&lt;=m;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=m/(m/l);</span><br><span class="line">		ans=<span class="built_in">Dec</span>(ans,<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*<span class="built_in">calc_g</span>(m/l)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[<span class="built_in">id</span>(m)]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc_f</span><span class="params">(<span class="type">int</span> _n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=_n; n2=<span class="built_in">sqrt</span>(n+<span class="number">0.3</span>); tot=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=n/(n/l);</span><br><span class="line">		a[tot++]=((r&lt;=N)?s[r]:<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m=n/<span class="number">2</span>;</span><br><span class="line">	ll ans=<span class="built_in">Pow</span>(<span class="number">2</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>,r;l&lt;=m;l=r+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		r=<span class="built_in">min</span>(m,n/(n/l));</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="number">1ll</span>*(n/l<span class="number">-1</span>)*(<span class="built_in">calc_g</span>(r)-<span class="built_in">calc_g</span>(l<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">1e6</span>);</span><br><span class="line">	<span class="function">CASET <span class="title">printf</span><span class="params">(<span class="string">&quot;%lld\n&quot;</span>,calc_f(read()))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给出一个由小写字母组成的字符串 $S$，及每个字符的权值。一个串的价值为其每个字符的权值之和。</p>
<p>求 $S$ 所有不同的子串中，价值为第 $k$ 小的价值是多少。没有则输出 $-1$。</p>
<p>两个子串相同当且仅当他们长度相同且对应每一位字符均相等。</p>
<p>$n\le 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>真的是，好久不写，都忘了SAM的性质了。</p>
<p>二分答案，建出SAM后，每个节点对应着 $len_i-len_{fa_i}$ 个子串。且长度连续，均为当中最长串的后缀。</p>
<p>于是在每个节点里面再二分一次找到串的个数就好了。</p>
<p>注意！需要记录SAM中每个串的终止位置！即right集合当中的任意一个即可。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],fa[N],len[N],las,siz,idx[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=siz;i++) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),fa[i]=len[i]=<span class="number">0</span>;</span><br><span class="line">		las=siz=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> cur=++siz;</span><br><span class="line">		idx[cur]=id+<span class="number">1</span>;</span><br><span class="line">		len[cur]=len[las]+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> p=las;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> clone=++siz;</span><br><span class="line">				len[clone]=len[p]+<span class="number">1</span>; idx[clone]=idx[q];</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				fa[clone]=fa[q];</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">				fa[cur]=fa[q]=clone;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,sum[N],val[<span class="number">30</span>];</span><br><span class="line">ll k;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> L[N],R[N],id[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ss=<span class="number">0</span>;</span><br><span class="line">	m=SAM::siz;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,SAM::siz) id[i]=SAM::idx[i],L[i]=SAM::len[SAM::fa[i]]+<span class="number">1</span>,R[i]=SAM::len[i],ss+=SAM::len[i]-SAM::len[SAM::fa[i]];</span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ss=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,m) <span class="keyword">if</span>(sum[id[i]]-sum[id[i]-L[i]]&lt;=x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l=L[i],r=R[i],mid;</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(sum[id[i]]-sum[id[i]-mid]&lt;=x) l=mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ss+=(r-L[i]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); cin&gt;&gt;k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">		SAM::<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,<span class="built_in">strlen</span>(s)) SAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">25</span>) val[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">get</span>()&lt;k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum[i]=sum[i<span class="number">-1</span>]+val[s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=n*<span class="number">100</span>,mid;</span><br><span class="line">		<span class="keyword">for</span>(;l+<span class="number">1</span>&lt;r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(mid)&gt;=k) r=mid;</span><br><span class="line">			<span class="keyword">else</span> l=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>$n\times m$ 的网格图，从 $(1,1)$ 开始，每次能往上或往右走一格，走到 $(n,m)$。有 $k$ 个点不能经过。问有可能走到的格子有多少个。</p>
<p>$n,m,k\le 10^5$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>补集转换，变为求哪些格子走不到。</p>
<p>对于一条斜向上的线段，不能走的格子将形成一个直角三角形或等腰梯形。</p>
<p>考虑斜着的扫描线，这样相当于是若干条不相交的线段组成。随着扫描线的右移，中间的线段长度将集体 $-1$，两端的线段有可能不减。</p>
<p>用链表维护这些线段，插入一个点时判断能否与左右两端的线段合并，或本身就在线段里面。</p>
<p>线段长度减一的话暴力枚举链表中的每一个元素即可，长度减到 $0$ 后将其删除。</p>
<p>这样做的复杂度是对的，因为线段原始的总长不会超过 $k$。</p>
<p>时间复杂度 $O(n+m+k)$。不知为何跑得很慢。</p>
<h4 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">node p[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	<span class="type">int</span> y,len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">line s[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k,L[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[x].y&gt;p[y].y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">		ll ans=<span class="number">1ll</span>*n*m;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+m) adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n+m+<span class="number">1</span>) L[i]=R[i]=<span class="number">0</span>;</span><br><span class="line">		R[<span class="number">0</span>]=n+m+<span class="number">1</span>; L[n+m+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>(),<span class="built_in">add</span>(p[i].x+p[i].y,i);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n+m) <span class="built_in">sort</span>(<span class="built_in">all</span>(adj[i]),cmp);</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=R[<span class="number">0</span>];j!=n+m+<span class="number">1</span>;j=R[j])</span><br><span class="line">			&#123;</span><br><span class="line">				s[j].len--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(R[<span class="number">0</span>]!=n+m+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				u=R[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">if</span>(s[u].y==i<span class="number">-2</span>&amp;&amp;i&lt;=m+<span class="number">1</span>) s[u].len++,s[u].y=i<span class="number">-1</span>;</span><br><span class="line">				u=L[n+m+<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span>(s[u].y==s[u].len+<span class="number">1</span>&amp;&amp;i&lt;=n+<span class="number">1</span>) s[u].len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=R[<span class="number">0</span>];j!=n+m+<span class="number">1</span>;j=R[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[j].len==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					L[R[j]]=L[j];</span><br><span class="line">					R[L[j]]=R[j];</span><br><span class="line">					j=L[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> j=R[<span class="number">0</span>];</span><br><span class="line">			s[<span class="number">0</span>].y=<span class="number">1000000000</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(;j!=n+m+<span class="number">1</span>&amp;&amp;s[j].y&gt;=p[v].y;j=R[j]);</span><br><span class="line">				j=L[j]; k=R[j];</span><br><span class="line">				<span class="keyword">if</span>(!j)</span><br><span class="line">				&#123;</span><br><span class="line">					s[v].y=p[v].y; s[v].len=<span class="number">1</span>;</span><br><span class="line">					R[<span class="number">0</span>]=L[k]=v;</span><br><span class="line">					L[v]=<span class="number">0</span>; R[v]=k;</span><br><span class="line">					j=v;</span><br><span class="line">					<span class="keyword">if</span>(k==n+m+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(s[j].y-s[j].len+<span class="number">1</span>&lt;=p[v].y)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(s[j].y-s[j].len==p[v].y) s[j].len++;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							s[v].y=p[v].y; s[v].len=<span class="number">1</span>;</span><br><span class="line">							R[j]=L[k]=v;</span><br><span class="line">							L[v]=j; R[v]=k;</span><br><span class="line">							j=v;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(k!=n+m+<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(s[j].y-s[j].len==s[k].y)</span><br><span class="line">					&#123;</span><br><span class="line">						s[j].len+=s[k].len;</span><br><span class="line">						<span class="type">int</span> t=R[k];</span><br><span class="line">						L[t]=j; R[j]=t;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">			ll k=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=R[<span class="number">0</span>];j!=n+m+<span class="number">1</span>;j=R[j]) ans-=s[j].len,k+=s[j].len;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>数论</tag>
        <tag>SAM</tag>
        <tag>杜教筛</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校3</title>
    <url>/2021/07/27/hdu2021%E5%A4%9A%E6%A0%A13/</url>
    <content><![CDATA[<p><a href="https://acm.hdu.edu.cn/search.php?field=problem&key=2021%A1%B0MINIEYE%B1%AD%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A83%A3%A9&source=1&searchmode=source">链接</a></p>
<span id="more"></span>

<h3 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一棵树，有点权 $p_i$。</p>
<p>$q$ 次询问，每次询问给定从 $u$ 到 $v$ 的有向路径，以及权值 $k$。从 $u$ 到 $v$ 依次选择点权 $p_i$，若 $k\geq p_i$，则 $k$ 变为 $k-p_i$。输出最后的 $k$。</p>
<p>$n,q\le 10^5,p_i\le 10^9,\sum n,\sum q\le 8\times 10^5$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>离线，然后树剖，将每条路径分成向上和向下共 $O(\log n)$ 条dfs序连续的段。变成序列上的操作。</p>
<p>用平衡树维护每个询问的当前答案。</p>
<p>每次遇到一个数 $p_i$，需要将平衡树内 $\geq p_i$ 的数都减去 $p_i$。</p>
<p>这个是平衡树的经典操作，分成 $[0,k - 1],[k,2k-1],\left [2k,+\infty \right )$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">    <span class="type">int</span> son[N][<span class="number">2</span>],val[N],siz[N],rnd[N],tag[N],fa[N],rt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		rt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) son[i][<span class="number">0</span>]=son[i][<span class="number">1</span>]=val[i]=tag[i]=fa[i]=<span class="number">0</span>,siz[i]=<span class="number">1</span>,rnd[i]=<span class="built_in">rand</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		siz[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">0</span>]) siz[u]+=siz[son[u][<span class="number">0</span>]],fa[son[u][<span class="number">0</span>]]=u;</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">1</span>]) siz[u]+=siz[son[u][<span class="number">1</span>]],fa[son[u][<span class="number">1</span>]]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u||!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">0</span>]) tag[son[u][<span class="number">0</span>]]+=tag[u],val[son[u][<span class="number">0</span>]]-=tag[u];</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">1</span>]) tag[son[u][<span class="number">1</span>]]+=tag[u],val[son[u][<span class="number">1</span>]]-=tag[u];</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="built_in">pushdown</span>(x); <span class="built_in">pushdown</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;son[x][<span class="number">1</span>]=<span class="built_in">merge</span>(son[x][<span class="number">1</span>],y); <span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">        <span class="keyword">else</span>              &#123;son[y][<span class="number">0</span>]=<span class="built_in">merge</span>(x,son[y][<span class="number">0</span>]); <span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split_val</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(val[u]&lt;=k) x=u,<span class="built_in">split_val</span>(son[x][<span class="number">1</span>],k,son[x][<span class="number">1</span>],y);</span><br><span class="line">        <span class="keyword">else</span> y=u,<span class="built_in">split_val</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split_siz</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=siz[son[u][<span class="number">0</span>]]) y=u,<span class="built_in">split_siz</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> x=u,<span class="built_in">split_siz</span>(son[x][<span class="number">1</span>],k-siz[son[u][<span class="number">0</span>]]<span class="number">-1</span>,son[x][<span class="number">1</span>],y);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x,y,z,ans;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		val[id]=v; tag[id]=<span class="number">0</span>; son[id][<span class="number">0</span>]=son[id][<span class="number">1</span>]=fa[id]=<span class="number">0</span>; siz[id]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">split_val</span>(rt,v,x,y);</span><br><span class="line">        rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,id),y);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">int</span> st[<span class="number">1000</span>],top;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> si=<span class="number">1</span>,u;</span><br><span class="line">		<span class="keyword">if</span>(son[x][<span class="number">0</span>]) si+=siz[son[x][<span class="number">0</span>]];</span><br><span class="line">		fa[rt]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(top=<span class="number">0</span>;fa[x];x=fa[x]) st[++top]=x;</span><br><span class="line">		<span class="keyword">for</span>(;top;top--)</span><br><span class="line">		&#123;</span><br><span class="line">			u=st[top];</span><br><span class="line">			<span class="built_in">pushdown</span>(fa[u]);</span><br><span class="line">			<span class="keyword">if</span>(son[fa[u]][<span class="number">1</span>]==u)</span><br><span class="line">				si+=siz[son[fa[u]][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> si;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> &amp;v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> si=<span class="built_in">push</span>(id);</span><br><span class="line">        <span class="built_in">split_siz</span>(rt,si<span class="number">-1</span>,x,y);</span><br><span class="line">        <span class="built_in">split_siz</span>(y,<span class="number">1</span>,y,z);</span><br><span class="line">		v=val[y];</span><br><span class="line">		fa[id]=<span class="number">0</span>;</span><br><span class="line">        rt=<span class="built_in">merge</span>(x,z);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">0</span>],k),son[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(son[u][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[u][<span class="number">1</span>],k),son[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">		val[u]-=k;</span><br><span class="line">		<span class="type">int</span> w,e;</span><br><span class="line">		<span class="built_in">split_val</span>(rt,val[u],w,e);</span><br><span class="line">		rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(w,u),e);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split_val</span>(rt,k<span class="number">-1</span>,x,y);</span><br><span class="line">		<span class="built_in">split_val</span>(y,<span class="number">2</span>*k<span class="number">-1</span>,y,z);</span><br><span class="line">		<span class="keyword">if</span>(z) tag[z]+=k,val[z]-=k;</span><br><span class="line">		rt=x;</span><br><span class="line">		<span class="built_in">dfs</span>(y,k);</span><br><span class="line">		rt=<span class="built_in">merge</span>(rt,z);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q,val[N];</span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N],fa[N],top[N],son[N],dep[N],dfn[N],tim,_dfn[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u]=dep[pre]+<span class="number">1</span>; fa[u]=pre; siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top[u]=tp;</span><br><span class="line">	dfn[u]=++tim;</span><br><span class="line">	_dfn[tim]=u;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],tp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!top[v=ver[i]])</span><br><span class="line">			<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;top[x]!=top[y];x=fa[top[x]])</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; op[<span class="number">2</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;top[x]!=top[y];)</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&gt;dep[top[y]])</span><br><span class="line">			op[<span class="number">0</span>][dfn[x]].<span class="built_in">pb</span>(id),op[<span class="number">0</span>][dfn[top[x]]<span class="number">-1</span>].<span class="built_in">pb</span>(id),x=fa[top[x]];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			op[<span class="number">1</span>][dfn[top[y]]].<span class="built_in">pb</span>(id),op[<span class="number">1</span>][dfn[y]+<span class="number">1</span>].<span class="built_in">pb</span>(id),y=fa[top[y]];</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y]) op[<span class="number">0</span>][dfn[x]].<span class="built_in">pb</span>(id),op[<span class="number">0</span>][dfn[y]<span class="number">-1</span>].<span class="built_in">pb</span>(id);</span><br><span class="line">	<span class="keyword">else</span> op[<span class="number">1</span>][dfn[x]].<span class="built_in">pb</span>(id),op[<span class="number">1</span>][dfn[y]+<span class="number">1</span>].<span class="built_in">pb</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		tim=tot=<span class="number">0</span>;</span><br><span class="line">		n=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) head[i]=son[i]=fa[i]=dep[i]=top[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) val[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n+<span class="number">1</span>) op[<span class="number">0</span>][i].<span class="built_in">clear</span>(),op[<span class="number">1</span>][i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> x,y,z,k;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,q)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">get</span>(x,y,i);</span><br><span class="line">			ans[i]=<span class="built_in">read</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		Treap::<span class="built_in">init</span>(q);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,q) in[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ff</span>(j,<span class="number">0</span>,op[<span class="number">0</span>][i].<span class="built_in">size</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				k=op[<span class="number">0</span>][i][j];</span><br><span class="line">				<span class="keyword">if</span>(in[k])</span><br><span class="line">				&#123;</span><br><span class="line">					Treap::<span class="built_in">del</span>(k,ans[k]);</span><br><span class="line">					in[k]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Treap::<span class="built_in">ins</span>(k,ans[k]);</span><br><span class="line">					in[k]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			Treap::<span class="built_in">work</span>(val[_dfn[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		Treap::<span class="built_in">init</span>(q);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,q) in[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ff</span>(j,<span class="number">0</span>,op[<span class="number">1</span>][i].<span class="built_in">size</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				k=op[<span class="number">1</span>][i][j];</span><br><span class="line">				<span class="keyword">if</span>(in[k])</span><br><span class="line">				&#123;</span><br><span class="line">					Treap::<span class="built_in">del</span>(k,ans[k]);</span><br><span class="line">					in[k]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					Treap::<span class="built_in">ins</span>(k,ans[k]);</span><br><span class="line">					in[k]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			Treap::<span class="built_in">work</span>(val[_dfn[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,q) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定两个十进制的数字串 $S,T$，均有通配字符‘*’，对于每个 $i(0\le i \le |T|)$，问若能至多失配 $i$ 次，字符串 $S$ 中长度为 $T$ 的子串有多少个能与之匹配。</p>
<p>$|T|\le |S|\le 2\times 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>含通配字符的通常可以用FFT去进行解决。设 $f_i$ 表示 $S[i,i+|T|-1]$ 与 $T$ 匹配的次数，算出 $f_i$ 即可。</p>
<p>这里将每个数字 $k$ 分开考虑，设 $a_i=[S_i==k],b_i=[T_i==k]$，对于该字符，$S[j,j+|T|-1]$ 与 $T$ 匹配的次数为 $\sum_{i=0}^{|T|-1}a_{i+j}b_i$。</p>
<p>将 $b_i$ 反串，然后FFT即可。</p>
<p>但是，对于通配字符，它们在每个数字中都会被统计到，统计多了 $10-1=9$ 次，于是再做一次跟通配字符相关的FFT，减去其 $9$ 倍的贡献即可。</p>
<p>时间复杂度 $O(11n\log n)$。</p>
<h3 id="1006"><a href="#1006" class="headerlink" title="1006"></a>1006</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>$n$ 个工人，$n$ 件物品要加工。第 $i$ 个人加工 $j$ 物品能获得 $a_i+b_j$ 的收益。</p>
<p>每个人只能加工最多一个物品，每个物品最多只能被一个人加工。</p>
<p>$m$ 条限制，每条限制形如 $i$ 工人不能加工 $j$ 物品。</p>
<p>对于每个 $i$，问加工 $i$ 个物品所能获得的最大收益，或者判断不可行。</p>
<p>$n\le 4000,m\le 10000$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>显然是一个费用流的模型。</p>
<p>建立源点 $S$ ，向工人连边权为 $1$，费用为 $a_i$ 的边。</p>
<p>建立汇点 $T$，物品向 $T$ 连边权为 $1$，费用为 $b_i$ 的边。</p>
<p>工人向能加工的物品连一条边权为 $1$，费用为 $0$ 的边。</p>
<p>然后每次将权值加 $1$，跑费用流。</p>
<p>但是这样的边数是 $O(n^2)$ 的。</p>
<p>考虑一共 $n$ 次找增广路，每次增广时寻找一条路径，且起点终点都没有用过的点，并且要权值和要最大。</p>
<p>考虑模拟这个过程，但由于这是一个补图，采用在补图上做的经典套路，维护一个链表表示右边还未访问的节点。模拟费用流的过程，左边的节点从大到小开始寻找增广路，每次找到的点要么在原图中有连边，要么在链表中被删去，一次找到所有增广路的时间是 $O(n+m)$ 的。</p>
<p>于是总的时间复杂度 $O(n^2+nm)$。</p>
<h3 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>$n\times n$ 的格子，每个格子有两个值 $a_{i,j},b_{i,j}$。</p>
<p>从 $(1,1)$ 开始，每步往下或往右走，走到 $(n,n)$。</p>
<p>求这样的路径中 $(\sum a_{i,j})\times (\sum b_{i,j})$ 的最大值。</p>
<p>$n\le 100,a_{i,j},b_{i,j} \le 10^6$。</p>
<p>数据随机。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>设 $f_{i,j,k}$ 表示走到 $(i,j)$ ，$\sum a =k$  时 $b_{i,j}$ 的最大值。</p>
<p>对于同一个 $i,j$，若 $k_1\le k_2$ 且 $f_{i,j,k_1}\le f_{i,j,k_2}$，则 $k_1$ 完全没用。</p>
<p>在随机情况下，合法的 $k$ 大概只有几千。</p>
<p>于是复杂度为 $O(n^2k)$。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>LGV引理</title>
    <url>/2021/07/26/LGV%E5%BC%95%E7%90%86/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>LGV引理可以用来解决在DAG上不相交路径的计数。</p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个有向无环图，各 $k$ 个点的集合 $A,B$ 。要求从统计 $n$ 条从 $A_i$ 到 $B_i$ 的路径，每个点至多在一条路径中的方案数 $N$。</p>
<h3 id="LGV引理"><a href="#LGV引理" class="headerlink" title="LGV引理"></a>LGV引理</h3><p>记 $e(u,v)$ 为从点 $u$ 到点 $v$ 的路径方案数，则有：</p>
<p>$$<br>\left | N \right |=\begin{vmatrix}<br>e(A_1,B_1) &amp; e(A_1,B_2) &amp; \cdots &amp; e(A_1,B_n)\\<br>e(A_2,B_1) &amp; e(A_2,B_2) &amp; \cdots &amp; e(A_2,B_n)\\<br>\vdots  &amp; \vdots  &amp; \ddots  &amp; \vdots \\<br>e(A_n,B_1) &amp; e(A_n,B_2) &amp; \cdots &amp; e(A_n,B_n)<br>\end{vmatrix}<br>$$</p>
<h3 id="证明感性理解"><a href="#证明感性理解" class="headerlink" title="证明感性理解"></a><del>证明</del>感性理解</h3><p>$$<br>|N|=\sum_{p_i\in [1,n],p_i\neq p_j}(-1)^{\sigma(p)}\prod_{i=1}^n e（A_i,B_{p_i})<br>$$</p>
<p>假如某种方案出现了相交情况，比如从 $A_1$ 到 $B_i$ 与从 $A_2$ 到 $B_j$ 出现了相交，那么将 $B_i$ 与 $B_j$ 交换后，逆序对个数奇偶性改变，由容斥原理一减一加就没了。</p>
<p>于是求个行列式就好了。</p>
<p>$e$ 数组也可以直接DP算出来。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul>
<li>NOI2021D1T2 模板题</li>
<li><a href="#">Post not found: “[yja]jzoj5606”</a></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校2</title>
    <url>/2021/07/23/hdu2021%E5%A4%9A%E6%A0%A12/</url>
    <content><![CDATA[<p>竟然排到了第12名，学弟们都是神仙啊。</p>
<span id="more"></span>

<h3 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h3><p>签到题，对于边长为 $i$ 的点，答案为 $8(n-i)^3$。</p>
<p>求个和即可。</p>
<h3 id="1002"><a href="#1002" class="headerlink" title="1002"></a>1002</h3><p>简单题，树剖后转换为区间加二次函数，线段树维护即可。</p>
<h3 id="1003"><a href="#1003" class="headerlink" title="1003"></a>1003</h3><h3 id="1004"><a href="#1004" class="headerlink" title="1004"></a>1004</h3><p>也就是多校1的某两题结合起来。。。</p>
<p>离线后将每个点，询问插进Trie里面，Trie中每个节点维护一个线段树。</p>
<p>询问在线段树上查询即可，合并使用线段树合并。</p>
<h3 id="1010"><a href="#1010" class="headerlink" title="1010"></a>1010</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定奇质数 $p$，与整数 $a(1 &lt; a &lt; p)$，长度为 $p-1$ 的序列 $b$ 满足 $b_i&lt;p,b_i\equiv ai\pmod p$。</p>
<p>问序列 $b$ 的逆序对个数模 $2$ 的结果。</p>
<p>$T\le 10^5,p\in \mathbb{P},2 \le a &lt; p &lt; 10^{18}$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>对于一个排列，交换任意两个数后，逆序对奇偶性一定改变。</p>
<p>因此，只需找到最小的 $d$，满足 $a^d\equiv 1\pmod p$，这个 $d$ 显然是 $\varphi(p)=p-1$ 的约数。</p>
<p>之后整个 $b$ 序列就形成了 $\frac{p-1}{d}$ 个环，每个环需要交换 $d-1$ 次。</p>
<p>于是答案即为 $\frac{p-1}{d}(d-1)\bmod 2$。</p>
<p>当且仅当 $d$ 为偶数，且 $d$ 中 $2$ 的次幂与 $p-1$ 中相同时答案为 $1$。</p>
<p>于是只需判断 $a^{\frac{p-1}{2}}$ 在模 $p$ 意义下是否为 $1$ 即可。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2021多校1</title>
    <url>/2021/07/20/hdu2021%E5%A4%9A%E6%A0%A11/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2021%A1%B0MINIEYE%B1%AD%A1%B1%D6%D0%B9%FA%B4%F3%D1%A7%C9%FA%CB%E3%B7%A8%C9%E8%BC%C6%B3%AC%BC%B6%C1%AA%C8%FC%A3%A81%A3%A9&source=1&searchmode=source">链接</a></p>
<span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n$，求 $(n\bmod1)\vee (n\bmod 2)\vee \cdots\vee (n\bmod n)$。</p>
<p>$T\le 5000$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>打表题，可能的答案只能为 $2^k-1$。于是算出 $k$ 即可。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>一个 $2\sim n$ 标记的 $n-1$ 个点形成一个完全无向图，边 $i,j$ 的边权为 $\text{lcm}(i,j)$。求完全图的最小生成树边权和。</p>
<p>$n\le 10^7,T\le 100$。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>构造题，对于 $3\sim n$ 的点，质数则连 $2$，否则随便找个约数连即可。</p>
<p>于是线性筛预处理即可。</p>
<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>一个序列，找到最短的序列使得区间异或和不小于 $k$，输出左端点最小时的情况。</p>
<p>$n\le 10^5,a_i &lt; 2^{30}$。</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>做前缀异或和，然后在Trie上操作即可。</p>
<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>$n$ 个人传球，每次不能传给自己。刚开始在 $1$手上，设第 $x$ 次传球后在 $1$ 手上的情况为 $f_x$，求最小的 $x$ 使得 $f_x\equiv t\pmod {998244353}$。</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>推出 $f_x$ 通项为 $\frac{n-1}{n}(-1)^i+\frac{1}{n}(n-1)^i$。</p>
<p>于是将 $i$ 分开奇偶讨论，BSGS即可。</p>
<p>时间复杂度 $O(T\sqrt{n})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> w=<span class="built_in">sqrt</span>(mod);</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> m1=<span class="number">2333333</span>;</span><br><span class="line">vector&lt;pii&gt; has[m1];</span><br><span class="line"><span class="type">int</span> st[w+<span class="number">5</span>],top;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(ll x,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y=x%m1;</span><br><span class="line">	has[y].<span class="built_in">pb</span>(<span class="built_in">mp</span>(x,id));</span><br><span class="line">	st[++top]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y=x%m1;</span><br><span class="line">	ll ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,(<span class="type">int</span>)has[y].<span class="built_in">size</span>()) <span class="keyword">if</span>(x==has[y][i].fi) ans=<span class="built_in">max</span>(ans,(ll)has[y][i].se);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll a,ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll p=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,w)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">insert</span>(p*a%mod,i);</span><br><span class="line">		(p*=x)%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=inf;</span><br><span class="line">	p=<span class="built_in">Pow</span>(x,w);</span><br><span class="line">	ll t=p;</span><br><span class="line">	ll q;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,w+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		q=<span class="built_in">find</span>(t);</span><br><span class="line">		<span class="keyword">if</span>(q!=<span class="number">-1</span>) ans=<span class="built_in">min</span>(ans,<span class="number">1ll</span>*i*w-q);</span><br><span class="line">		t=t*p%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,top) has[st[i]].<span class="built_in">clear</span>();</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> (ans==inf)?<span class="number">-1</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line">ll n,x,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">1</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">0</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		a=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">		b=a*(n<span class="number">-1</span>)%mod;</span><br><span class="line">		ll t=<span class="built_in">solve</span>((x*n-(n<span class="number">-1</span>)+mod)%mod,<span class="number">1ll</span>*(n<span class="number">-1</span>)*(n<span class="number">-1</span>)%mod);</span><br><span class="line">		<span class="keyword">if</span>(t!=<span class="number">-1</span>) t=t*<span class="number">2</span>;</span><br><span class="line">		ll q=<span class="built_in">solve</span>((x*n+(n<span class="number">-1</span>)+mod)%mod*(n<span class="number">-1</span>)%mod,<span class="number">1ll</span>*(n<span class="number">-1</span>)*(n<span class="number">-1</span>)%mod);</span><br><span class="line">		<span class="keyword">if</span>(q!=<span class="number">-1</span>) q=q*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,q);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(q==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,t);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">min</span>(q,t));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>在一个二维坐标上，存在着 $n$ 个点 $(i,f_i)$。</p>
<p>多次询问某个平行于坐标轴的矩形中的点有多少个不同的横坐标。</p>
<p>$T\le 5$，$n,q\le 10^5$</p>
<h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>记 $a_i$ 表示点 $i$ 坐标向左看到的第一个点的横坐标，没有记为 $0$。</p>
<p>对于一个矩形，差分一下变成一条边在 $x$ 轴上的询问。左右区间为 $[l,r]$，高度为 $h$。</p>
<p>对于每个询问，查询 $l\le i\le r,a_i&lt;l,f_i\le h$ 的个数。</p>
<p>这是一个三位偏序问题，cdq+树状数组即可。时间复杂度 $O(n\log ^2n)$。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>树状数组</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2011]消防</title>
    <url>/2021/06/17/SDOI2011-%E6%B6%88%E9%98%B2/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵树，有边权。选择一条长度不超过 $s$ 的路径，使得所有点到路径的距离最大值最小。</p>
<p>$n\le 3\times 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><p>大力猜结论可知，这条路径一定在树上。</p>
<p>先证明一些性质（设 $d_{x,y}$ 表示两点间距离，$f(l)$ 为树中所有点到路径 $l$ 的最远距离）：</p>
<ul>
<li>性质一：离一个点最远的点必然是一直径的端点。</li>
</ul>
<p>证明：用反证法，讨论三种情况即可。</p>
<ul>
<li>性质二：这条路径必与某条直径相交。</li>
</ul>
<p>证明：反证，假设这样最优的路径 $l_1$ 不在某条直径上，设直径端点为 $x,y$，直径中与 $l_1$ 距离最短的点为 $u$，不妨设 $d_{x,u}\geq d_{y,u}$。设 $l_1$ 中与 $u$ 最近的点为 $v$，显然 $u\not = v$。</p>
<p>由性质一可知，$l_1$ 的点在树中的最远点为 $x$。$u$ 的最远点也为 $x$。</p>
<p>只取 $u$ 这个点成为一条路径 $l_2$，有 $f(l_2)=d_{u,x} &lt; d_{u,x}+d_{u,v}=f(l_1)$。说明 $l_1$ 不为最优路径，与已知矛盾，证毕。</p>
<ul>
<li>性质三：这条路径可以全在某条直径上。</li>
</ul>
<p>证明：由性质二，这条路径与直径相交，设相交部分为 $l_2$，其两端点为 $a,b$。还是运用反证法：设 $l_1$ 的两端点为 $c,d$， 易证 $f(l_2)\le f(l_1)$ 而得出矛盾。</p>
<p>综上，我们只需考虑路径全在直径上的情况。</p>
<p>将一条直径的所有点找出来，按顺序排成一排，共 $m$ 个，记为 $a_i$。设非直径中的所有点到 $a_i$ 距离最大值为 $f_i$，从直径一端到 $a_i$ 的距离为 $s_i$。</p>
<p>那么以 $a_{i},a_{j}(i\le j)$ 为端点的路径，最大值为 $\max\{\max_{i\le k \le j}\{f_k\},s_m-s_j,s_i\}$</p>
<p>随便用个方法（比如单调队列）即可求出最值。</p>
<p>时间复杂度 $O(n)$。</p>
<h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><p>既然要最大值最小，那么就二分吧。</p>
<p>二分一个值 $mid$，看是否存在一条路径使得到所有点的距离都不超过 $mid$。</p>
<p>树形DP，设 $f_i$ 表示 $i$ 的子树内，以 $i$ 为端点的路径中，子树内所有点到该路径的距离均不超过 $mid$ 时，路径的最短长度。设 $g_i$ 表示子树内，经过 $i$ 的路径中，子树内所有点到该路径的距离均不超过 $mid$ 时，路径的最短长度。</p>
<p>随便DP一下就可以了。</p>
<p>时间复杂度 $O(n\log n)$，常数略大。</p>
]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>思维题</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI2013]SAO</title>
    <url>/2021/06/16/HEOI2013-SAO/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4099">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个数排列，有 $n-1$ 个限制，无向后形成一棵树，表示某个数必须排在某个数前面。</p>
<p>求合法方案数。</p>
<p>$n\le 10^3,T\le 10$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>还以为有多难</del></p>
<p>显然是一棵树的形式。</p>
<p>考虑树形DP，设 $f_{i,j}$ 表示子树 $i$ 中的数排在一起后，$i$ 排在第 $j$ 位的方案数。</p>
<p>合并时枚举 $k$，表示子树 $v$ 在合并后有 $k$ 个数排在 $i$ 的前面。</p>
<p>对于子树 $v$，在 $u$ 处合并，显然有：</p>
<p>$f’<em>{u,i+j}+=\sum_k \binom{i+j-1}{i-1}\binom{s_u+s_v-i-j}{s_u-i}f</em>{u,i}f_{v,k}$。</p>
<p>根据这条边的限制，$k$ 的取值是一个区间。</p>
<p>前缀和优化后，时间复杂度 $O(n^2)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1004</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x+=y;</span><br><span class="line">	<span class="keyword">return</span> x&lt;mod?x:x-mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll f[N][N],C[N][N],g[N],tmp[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> ne[N&lt;&lt;<span class="number">1</span>],head[N],ver[N&lt;&lt;<span class="number">1</span>],col[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; col[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; col[tot]=c; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x=head[u],v;x;x=ne[x])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[x])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,siz[v]) tmp[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,siz[v]) tmp[i]=<span class="built_in">Add</span>(tmp[i<span class="number">-1</span>],f[v][i]);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,siz[u]+siz[v]) g[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(col[x]==v)</span><br><span class="line">				<span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u])</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">0</span>,siz[v])</span><br><span class="line">						g[i+j]=<span class="built_in">Add</span>(g[i+j],C[i+j<span class="number">-1</span>][i<span class="number">-1</span>]*C[siz[u]+siz[v]-i-j][siz[u]-i]%mod*f[u][i]%mod*(tmp[siz[v]]-tmp[j]+mod)%mod);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u])</span><br><span class="line">					<span class="built_in">fo</span>(j,<span class="number">0</span>,siz[v])</span><br><span class="line">						g[i+j]=<span class="built_in">Add</span>(g[i+j],C[i+j<span class="number">-1</span>][i<span class="number">-1</span>]*C[siz[u]+siz[v]-i-j][siz[u]-i]%mod*f[u][i]%mod*tmp[j]%mod);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u]) f[u][i]=g[i];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,n) f[i][j]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) head[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,tot) ver[i]=col[i]=ne[i]=<span class="number">0</span>;</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">1000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i) C[i][j]=<span class="built_in">Add</span>(C[i<span class="number">-1</span>][j<span class="number">-1</span>],C[i<span class="number">-1</span>][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="type">int</span> x,y; <span class="type">char</span> sig[<span class="number">4</span>]; ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,sig); y=<span class="built_in">read</span>();</span><br><span class="line">			x++; y++;</span><br><span class="line">			<span class="built_in">add</span>(x,y,sig[<span class="number">0</span>]==<span class="string">&#x27;&lt;&#x27;</span>?x:y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) (ans+=f[<span class="number">1</span>][i])%=mod;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>组合数学</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[JSOI2018]潜入行动</title>
    <url>/2021/06/15/JSOI2018-%E6%BD%9C%E5%85%A5%E8%A1%8C%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P4516">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>刚高考完，好久没做这么水的树形DP了，手有点生qaq。</p>
<p>设 $f_{i,j,k,l}$ 表示以 $i$ 为子树中，用了 $j$ 次监听，$i$ 是否使用监听，$i$ 是否被监听的方案数。</p>
<p>子树在 $i$ 处合并，分情况讨论即可。</p>
<p>注意空间限制，只能开下int。</p>
<p>时间复杂度 $O(nk)$。</p>
<p>证明：对于 $i$ 的儿子 $son$，要与 $i$ 合并，那么时间复杂度为 $O(\min\{siz_i,k\}\times \min\{siz_{son},k\})$。</p>
<p>当 $siz_i,siz_{son}$ 大于 $k$ 时，只有 $\frac{n}{k}$ 个点，总时间复杂度 $O(nk)$。</p>
<p>当 $siz_{son}$ 小于 $k$ 时，考虑 $son$ 子树中的每个点，他一直合并上去时，需要花费的时间不会超过 $k$，总时间复杂度 $O(nk)$。</p>
<p>于是总复杂度还是 $O(nk)$ 。证毕。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">103</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x+=y;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;=mod) <span class="keyword">return</span> x-mod;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*y%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>][<span class="number">2</span>],g[M][<span class="number">2</span>][<span class="number">2</span>],siz[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	f[u][<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(v^pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">min</span>(k,siz[u]);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,l)</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">					<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">						g[i][j][k]=f[u][i][j][k],f[u][i][j][k]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,l)</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(siz[v],k-i))</span><br><span class="line">				&#123;</span><br><span class="line">					f[u][i+j][<span class="number">0</span>][<span class="number">0</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">0</span>][<span class="number">0</span>],<span class="built_in">Mul</span>(g[i][<span class="number">0</span>][<span class="number">0</span>],f[v][j][<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">					f[u][i+j][<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">Mul</span>(g[i][<span class="number">0</span>][<span class="number">1</span>],(f[v][j][<span class="number">0</span>][<span class="number">1</span>]+f[v][j][<span class="number">1</span>][<span class="number">1</span>])));</span><br><span class="line">					f[u][i+j][<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">0</span>][<span class="number">1</span>],<span class="built_in">Mul</span>(g[i][<span class="number">0</span>][<span class="number">0</span>],f[v][j][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">					f[u][i+j][<span class="number">1</span>][<span class="number">0</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">1</span>][<span class="number">0</span>],<span class="built_in">Mul</span>(g[i][<span class="number">1</span>][<span class="number">0</span>],(f[v][j][<span class="number">0</span>][<span class="number">0</span>]+f[v][j][<span class="number">0</span>][<span class="number">1</span>])));</span><br><span class="line">					f[u][i+j][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">Mul</span>(g[i][<span class="number">1</span>][<span class="number">1</span>],(f[v][j][<span class="number">0</span>][<span class="number">0</span>]+f[v][j][<span class="number">0</span>][<span class="number">1</span>])%mod+(f[v][j][<span class="number">1</span>][<span class="number">0</span>]+f[v][j][<span class="number">1</span>][<span class="number">1</span>])%mod));</span><br><span class="line">					f[u][i+j][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">Add</span>(f[u][i+j][<span class="number">1</span>][<span class="number">1</span>],<span class="built_in">Mul</span>(g[i][<span class="number">1</span>][<span class="number">0</span>],(f[v][j][<span class="number">1</span>][<span class="number">0</span>]+f[v][j][<span class="number">1</span>][<span class="number">1</span>])));</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Add</span>(f[<span class="number">1</span>][k][<span class="number">0</span>][<span class="number">1</span>],f[<span class="number">1</span>][k][<span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #703[CF1486]</title>
    <url>/2021/02/19/Codeforces-Round-703-CF1486/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1486/problems">problems’s link</a></p>
<p>退役选手一个无聊的晚上。</p>
<span id="more"></span>

<p>退役半年，手速和思维都降下来了呀。</p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>从前往后贪心，第 $i$ 个位置看是否能把它搞成 $i-1$。</p>
<p>然而因为自己智障还WA了两发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,x,flag;</span><br><span class="line">ll s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); s=<span class="number">0</span>; flag=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(x+s&lt;i) flag=<span class="number">0</span>;</span><br><span class="line">			s=x+s-i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(flag?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>显然 $x,y$ 坐标分开，然后中位数。</p>
<p>3min看完题+写完。（英文水平有所上升）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),b[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> m=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*(b[m+<span class="number">1</span>]-b[m]+<span class="number">1</span>)*(a[m+<span class="number">1</span>]-a[m]+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>交互题。</p>
<p>一开始还以为是个什么难题。</p>
<p>结果发现自己是在打div.2，在打div.2的C。</p>
<p>于是先找出整体次大，然后看最大在哪一边，然后二分即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r||r&gt;n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;? %d %d\n&quot;</span>,l,r);</span><br><span class="line">	<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	<span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">	<span class="keyword">if</span>(l+<span class="number">1</span>==r) <span class="keyword">return</span> l^r^<span class="built_in">ask</span>(l,r);</span><br><span class="line">	<span class="type">int</span> mid=<span class="built_in">ask</span>(l,r);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">ask</span>(mid,r)==mid)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> L=mid+<span class="number">1</span>,R=r,m;</span><br><span class="line">		<span class="keyword">for</span>(;L+<span class="number">1</span>&lt;R;)</span><br><span class="line">		&#123;</span><br><span class="line">			m=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ask</span>(mid,m)==mid) R=m;</span><br><span class="line">			<span class="keyword">else</span> L=m+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(L==R) <span class="keyword">return</span> L;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(L,R);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> L=l,R=mid<span class="number">-1</span>,m;</span><br><span class="line">		<span class="keyword">for</span>(;L+<span class="number">1</span>&lt;R;)</span><br><span class="line">		&#123;</span><br><span class="line">			m=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ask</span>(m,mid)==mid) L=m;</span><br><span class="line">			<span class="keyword">else</span> R=m<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(L==R) <span class="keyword">return</span> L;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">solve</span>(L,R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> ans=<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;! %d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>一眼题。</p>
<p>直接二分答案，然后奇偶分开讨论，顺着扫一遍，用个数据结构维护就好了。这里用set。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> b[N],a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=b[i<span class="number">-1</span>]+(a[i]&gt;=x);</span><br><span class="line">	s[<span class="number">0</span>].<span class="built_in">clear</span>(); s[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n-m+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i&amp;<span class="number">1</span>].<span class="built_in">insert</span>(i<span class="number">-2</span>*b[i<span class="number">-1</span>]);</span><br><span class="line">		j=i+m<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s[j&amp;<span class="number">1</span>].<span class="built_in">lower_bound</span>(<span class="number">-2</span>*b[j]+j+<span class="number">2</span>)!=s[j&amp;<span class="number">1</span>].<span class="built_in">end</span>()) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[!(j&amp;<span class="number">1</span>)].<span class="built_in">lower_bound</span>(<span class="number">-2</span>*b[j]+j+<span class="number">3</span>)!=s[!(j&amp;<span class="number">1</span>)].<span class="built_in">end</span>()) &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=n+<span class="number">1</span>,mid;</span><br><span class="line">	<span class="keyword">for</span>(;l+<span class="number">1</span>&lt;r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>$1\leq w_i\leq 50$，这性质很有用。</p>
<p>于是记 $f_{i,j}$ 表示走到 $i$，上一条边的费用是 $j$ 的最短路。特别地，$f_{i,0}$ 表示走完两条路。</p>
<p>于是dijkstra即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">52</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ver[M],val[M],head[N],ne[M],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N][K];</span><br><span class="line"><span class="type">bool</span> vis[N][K];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y; ll d;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.d&gt;B.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">read</span>(),<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">50</span>) f[i][j]=inf;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>; q.<span class="built_in">push</span>((node)&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		node u=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u.x][u.y]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u.x][u.y]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!u.y)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u.x],v;i;i=ne[i])</span><br><span class="line">			&#123;</span><br><span class="line">				v=ver[i];</span><br><span class="line">				<span class="keyword">if</span>(f[v][val[i]]&gt;f[u.x][<span class="number">0</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					f[v][val[i]]=f[u.x][<span class="number">0</span>];</span><br><span class="line">					q.<span class="built_in">push</span>((node)&#123;v,val[i],f[u.x][<span class="number">0</span>]&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u.x],v;i;i=ne[i])</span><br><span class="line">			&#123;</span><br><span class="line">				v=ver[i];</span><br><span class="line">				<span class="keyword">if</span>(f[v][<span class="number">0</span>]&gt;f[u.x][u.y]+(u.y+val[i])*(u.y+val[i]))</span><br><span class="line">				&#123;</span><br><span class="line">					f[v][<span class="number">0</span>]=f[u.x][u.y]+(u.y+val[i])*(u.y+val[i]);</span><br><span class="line">					q.<span class="built_in">push</span>((node)&#123;v,<span class="number">0</span>,f[v][<span class="number">0</span>]&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ll ans;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i][<span class="number">0</span>]==inf) f[i][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,f[i][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>将 $1$ 作为根。</p>
<p>不难发现，如果两条路径有且仅有一个相交的点，那么肯定是两条路径的lca中的一个。</p>
<p>分两种情况。</p>
<p>1，两条路径lca相同。用总数减去不合法的情况即可。</p>
<p>2，两条路径lca不同。树上差分一下统计一些东西就可以了。</p>
<p>可以做到线性。</p>
<p>懒得写代码了，睡觉去了。</p>
]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>LCA</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title>相似子串[bzoj3230]</title>
    <url>/2020/08/12/%E7%9B%B8%E4%BC%BC%E5%AD%90%E4%B8%B2-bzoj3230/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://darkbzoj.tk/problem/3230">bzoj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>就当是后缀数组复习题啦。</p>
<p>求第 $k$ 小本质不同的字符串除了可以用SAM算之外，也可以用SA求。</p>
<p>具体做法是把后缀按rank排好，那么相邻的两个后缀的贡献就是 $(n-sa_i+1)-height_i$。</p>
<p>作这个东西的前缀和，然后二分就可以找到第 $k$ 小的位置了。</p>
<p>剩下的就是正串反串建SA然后求lcp的事了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">19</span>;</span><br><span class="line"><span class="type">int</span> base[N],t[N],l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t[x]==t[y]&amp;&amp;t[x+k]==t[y+k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SuufixArray</span>&#123;</span><br><span class="line">	<span class="type">int</span> height[N],sa[N],rk[N],f[N][K],len;</span><br><span class="line">	ll sum[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">		len=n; s[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=i,rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rsort</span>(n,<span class="number">128</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p=<span class="number">0</span>;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">			<span class="built_in">rsort</span>(n,p);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">			rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">			<span class="keyword">for</span>(j=sa[rk[i]<span class="number">-1</span>],(k?(k--):<span class="number">0</span>);s[i+k]==s[j+k];k++);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i],sum[i]=sum[i<span class="number">-1</span>]+(n-sa[i]+<span class="number">1</span>)-height[i];</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,K<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> len-x+<span class="number">1</span>;</span><br><span class="line">		x=rk[x]; y=rk[y];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x++;</span><br><span class="line">		<span class="type">int</span> k=l2[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(ll k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;l)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> tmp=<span class="built_in">lower_bound</span>(sum+<span class="number">1</span>,sum+len+<span class="number">1</span>,k)-sum;</span><br><span class="line">		x=sa[tmp];</span><br><span class="line">		l=len-sa[tmp]+<span class="number">1</span>-(sum[tmp]-k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;SA[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="number">1ll</span>*x*x;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	SA[<span class="number">0</span>].<span class="built_in">build</span>(s,n);</span><br><span class="line">	<span class="built_in">reverse</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br><span class="line">	SA[<span class="number">1</span>].<span class="built_in">build</span>(s,n);</span><br><span class="line">	ll sum=SA[<span class="number">0</span>].sum[n];</span><br><span class="line">	ll u,v;</span><br><span class="line">	<span class="type">int</span> x,y,l1,l2,len;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(u&gt;sum||v&gt;sum) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			SA[<span class="number">0</span>].<span class="built_in">calc</span>(u,x,l1);</span><br><span class="line">			SA[<span class="number">0</span>].<span class="built_in">calc</span>(v,y,l2);</span><br><span class="line">			len=<span class="built_in">min</span>(l1,l2);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">sqr</span>(<span class="built_in">min</span>(len,SA[<span class="number">0</span>].<span class="built_in">ask</span>(x,y)))+<span class="built_in">sqr</span>(<span class="built_in">min</span>(len,SA[<span class="number">1</span>].<span class="built_in">ask</span>(n-(x+l1<span class="number">-1</span>)+<span class="number">1</span>,n-(y+l2<span class="number">-1</span>)+<span class="number">1</span>))));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>序列妙妙值[uoj549]</title>
    <url>/2020/08/12/%E5%BA%8F%E5%88%97%E5%A6%99%E5%A6%99%E5%80%BC-uoj549/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://uoj.ac/problem/549">link</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑Dp，设 $f_{j,i}$ 表示考虑选了 $j$ 个非空子序列，选到 $i$ 的最小值。设 $s_i$ 为 $a_i$ 的前缀异或和。</p>
<p>$f_{j,i}=\min_{k\in[0,i-1]}\{f_{j-1,k}+(s_i \text{xor} s_k)\}$。</p>
<p>这时就有几种思路：拆位，Trie，和DP优化。</p>
<p>然后发现拆位和Trie都似乎不太可做的样子，那就只有Dp优化了叭。</p>
<p>看到部分分 $a_i&lt;2^8$，于是我们对于每个 $s_k$，记录 $f_{j-1,k}$ 的最小值，然后更新时 $O(2^8)$ 枚举即可。</p>
<p>于是就获得了60pts的成绩。</p>
<p>考虑满分应该怎么做，这时你发现算答案要 $O(2^{16})$，而更新最小值只需要 $O(1)$。考虑均分这个复杂度。</p>
<p>拆位，将 $s_i$ 拆成前 $8$ 位和后 $8$ 位，分别算贡献。</p>
<p>设 $g_{x,y}$ 表示 $s_i$ 的前 $8$ 位是 $x$，$s_k$ 的后 $8$ 位是 $y$ 时的最小值。</p>
<p>那么就可以做了。</p>
<p>时间复杂度 $O(nk\sqrt{\max a_i})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> f[<span class="number">9</span>][<span class="number">60005</span>],a[<span class="number">60005</span>],g[<span class="number">256</span>][<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=x&gt;&gt;<span class="number">8</span>,z=x&amp;<span class="number">255</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">255</span>) g[i][z]=<span class="built_in">min</span>(g[i][z],((i^y)&lt;&lt;<span class="number">8</span>)+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=x&gt;&gt;<span class="number">8</span>,z=x&amp;<span class="number">255</span>,ans=inf;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">255</span>) ans=<span class="built_in">min</span>(ans,g[y][i]+(i^z));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(ex_seq2);</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=a[i<span class="number">-1</span>]^<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(x,<span class="number">0</span>,<span class="number">255</span>) <span class="built_in">fo</span>(y,<span class="number">0</span>,<span class="number">255</span>) g[x][y]=inf;</span><br><span class="line">		<span class="built_in">fo</span>(i,j,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">update</span>(a[i<span class="number">-1</span>],f[j<span class="number">-1</span>][i<span class="number">-1</span>]);</span><br><span class="line">			f[j][i]=<span class="built_in">min</span>(f[j][i],<span class="built_in">query</span>(a[i]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,k,n) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[k][i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串游戏[bzoj2690]</title>
    <url>/2020/08/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B8%B8%E6%88%8F-bzoj2690/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $N$ 个仅有 小写字母组成的字符串 $a_ i$,每个字符串都有一个权值 $v_i$ ,有 $M$ 次操作，操作分三种：</p>
<ul>
<li><p>Cv x v’:把第x个字符串的权值修改为v’</p>
</li>
<li><p>Cs x a’:把第x个字符串修改成a’</p>
</li>
<li><p>Q:求出当前的最大权字符串集合，使得这个集合中的字符串经过重新排列后满足除最后一个字符串外，前一个字符串是后一个的前缀(两个字符串相同也是前缀关系，也可以一个字符串都不选)</p>
</li>
</ul>
<p>前50%的数据可以接受离线算法，后50%的数据要求在线算法。</p>
<p>$N\le 50000,M\le 10^5$ ，字符串总长 $\le 10^6$。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将这些字符串建成Trie，只考虑权值大于 $0$ 的串，在字符串结尾出放上它的权值。那么答案就是Trie树上某个点到根节点的权值和的最大值。</p>
<p>当可以离线的时候，先把Trie建出来，然后维护每个节点的答案。修改一个字符串权值相当于子树加，修改字符串看成改点权就好了。</p>
<p>当要在线的时候，我们用Treap动态维护dfs序，记录当前的dfs序以及子树大小，考虑加一个字符串后的几种情况就好了。</p>
<p>一道复习Treap和Trie的好题~</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">	<span class="type">int</span> ch[N][<span class="number">2</span>],fa[N],siz[N],rnd[N],rt,tot;</span><br><span class="line">	ll val[N],mx[N],tag[N];</span><br><span class="line">	<span class="type">int</span> tid[N],id[N],len[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,ll x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u) tag[u]+=x,val[u]+=x,mx[u]+=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushid</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u) tid[u]+=s,id[u]+=s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(tag[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pushtag</span>(ch[u][<span class="number">0</span>],tag[u]);</span><br><span class="line">			<span class="built_in">pushtag</span>(ch[u][<span class="number">1</span>],tag[u]);</span><br><span class="line">			tag[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tid[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pushid</span>(ch[u][<span class="number">0</span>],tid[u]);</span><br><span class="line">			<span class="built_in">pushid</span>(ch[u][<span class="number">1</span>],tid[u]);</span><br><span class="line">			tid[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[u]=siz[ch[u][<span class="number">0</span>]]+siz[ch[u][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">		mx[u]=<span class="built_in">max</span>(val[u],<span class="built_in">max</span>(mx[ch[u][<span class="number">0</span>]],mx[ch[u][<span class="number">1</span>]]));</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">0</span>]) fa[ch[u][<span class="number">0</span>]]=u;</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">1</span>]) fa[ch[u][<span class="number">1</span>]]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[u]) <span class="built_in">push</span>(fa[u]);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_siz</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> (<span class="type">void</span>)(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(siz[ch[u][<span class="number">0</span>]]&gt;=k) y=u,<span class="built_in">split_siz</span>(ch[u][<span class="number">0</span>],k,x,ch[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">else</span> x=u,<span class="built_in">split_siz</span>(ch[u][<span class="number">1</span>],k-siz[ch[u][<span class="number">0</span>]]<span class="number">-1</span>,ch[x][<span class="number">1</span>],y);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) &#123;<span class="keyword">return</span> x|y;&#125;</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[y])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pushdown</span>(x); ch[x][<span class="number">1</span>]=<span class="built_in">merge</span>(ch[x][<span class="number">1</span>],y);</span><br><span class="line">			<span class="built_in">pushup</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pushdown</span>(y); ch[y][<span class="number">0</span>]=<span class="built_in">merge</span>(x,ch[y][<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">pushup</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Rank</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">push</span>(x);</span><br><span class="line">		<span class="type">int</span> s=siz[ch[x][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;x;x=fa[x])</span><br><span class="line">			<span class="keyword">if</span>(ch[fa[x]][<span class="number">1</span>]==x)</span><br><span class="line">				s+=siz[ch[fa[x]][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tot=rt=<span class="number">1</span>;</span><br><span class="line">		rnd[<span class="number">1</span>]=<span class="built_in">rand</span>(); siz[<span class="number">1</span>]=<span class="number">1</span>; len[<span class="number">1</span>]=id[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Treap;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ne[N][<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> j,<span class="type">int</span> n,<span class="type">int</span> u,<span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z,c;</span><br><span class="line">	<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="built_in">split_siz</span>(rt,id[u]<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="built_in">split_siz</span>(y,len[u],y,z);</span><br><span class="line">	<span class="type">int</span> now=id[u]+len[u]<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,j,n)</span><br><span class="line">	&#123;</span><br><span class="line">		now++;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		ne[u][c]=++tot;</span><br><span class="line">		u=ne[u][c];</span><br><span class="line">		rnd[u]=<span class="built_in">rand</span>(); mx[u]=val[u]=sum;</span><br><span class="line">		siz[u]=<span class="number">1</span>; ch[u][<span class="number">0</span>]=ch[u][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		id[u]=now; len[u]=n-i;</span><br><span class="line">		y=<span class="built_in">merge</span>(y,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=u;</span><br><span class="line">	u=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,j)</span><br><span class="line">	&#123;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		len[u]+=n-j;</span><br><span class="line">		u=ne[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	rt=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z));</span><br><span class="line">	<span class="built_in">split_siz</span>(rt,<span class="built_in">Rank</span>(tot),x,y);</span><br><span class="line">	<span class="built_in">DEBUG</span>(siz[y]);</span><br><span class="line">	<span class="built_in">pushid</span>(y,n-j);</span><br><span class="line">	rt=<span class="built_in">merge</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> value[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ins_str</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">strlen</span>(s),c,u=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		sum+=value[u];</span><br><span class="line">		<span class="keyword">if</span>(!ne[u][c]) <span class="keyword">return</span> <span class="built_in">work</span>(s,i,n,u,sum);</span><br><span class="line">		u=ne[u][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins_val</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	value[u]+=v;</span><br><span class="line">	<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">split_siz</span>(rt,id[u]<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="built_in">split_siz</span>(y,len[u],y,z);</span><br><span class="line">	<span class="built_in">pushtag</span>(y,v);</span><br><span class="line">	rt=<span class="built_in">merge</span>(x,<span class="built_in">merge</span>(y,z));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> va[N],str_end[N];</span><br><span class="line"><span class="type">int</span> n,m,opt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20030403</span>);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> a[N];</span><br><span class="line">	opt=<span class="built_in">read</span>()<span class="number">-1</span>;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a),str_end[i]=<span class="built_in">ins_str</span>(a);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) va[i]=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">read</span>()),<span class="built_in">ins_val</span>(str_end[i],va[i]);</span><br><span class="line">	<span class="type">int</span> x,v,ans=<span class="number">0</span>; <span class="type">char</span> t[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t);</span><br><span class="line">		<span class="keyword">if</span>(t[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans=mx[rt]);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(t[<span class="number">1</span>]==<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				v=<span class="built_in">read</span>();</span><br><span class="line">				<span class="keyword">if</span>(opt) v=<span class="built_in">min</span>(<span class="number">1000</span>,v+(ans%<span class="number">1000</span>));</span><br><span class="line">				v=<span class="built_in">max</span>(<span class="number">0</span>,v);</span><br><span class="line">				<span class="built_in">ins_val</span>(str_end[x],v-va[x]);</span><br><span class="line">				va[x]=v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ins_val</span>(str_end[x],-va[x]);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a); v=ans%<span class="number">26</span>;</span><br><span class="line">				<span class="keyword">if</span>(opt) <span class="built_in">ff</span>(i,<span class="number">0</span>,<span class="built_in">strlen</span>(a)) a[i]=(a[i]-<span class="string">&#x27;a&#x27;</span>+v)%<span class="number">26</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">				str_end[x]=<span class="built_in">ins_str</span>(a);</span><br><span class="line">				<span class="built_in">ins_val</span>(str_end[x],va[x]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>斗主地[NOI2019]</title>
    <url>/2020/08/11/%E6%96%97%E4%B8%BB%E5%9C%B0-NOI2019/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/3160">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑一次洗牌操作的意义：</p>
<p><del>这样的洗牌是均匀的，因此每种合法方案的概率一样。</del></p>
<p>观察样例可以发现，最终每个位置答案的期望是 $\frac{7}{4},\frac{9}{4},\frac{11}{4},\frac{13}{4}$。这是一个一次函数！</p>
<p>于是经过打表验证，设最后第 $i$ 个位置的答案为 $F(i)$，则 $F$ 是一个不超过二次的函数！</p>
<p>打表程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>(<span class="number">20030403</span>);</span><br><span class="line">n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=i;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m) b[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> T=<span class="number">10000000</span>;</span><br><span class="line"><span class="built_in">fo</span>(ti,<span class="number">1</span>,T)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=a[i],id[i]=i;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">random_shuffle</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(id+<span class="number">1</span>,id+b[j]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">sort</span>(id+b[j]+<span class="number">1</span>,id+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[id[i]]=c[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans[i]+=c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%.3lf &quot;</span>,(db)ans[i]/T);</span><br></pre></td></tr></table></figure>



<p>那么只需要记住 $F(1),F(2),F(3)$ 即可。</p>
<p>那么对于每次洗牌，设第一堆有 $x$ 张牌，拉格朗日插值一下算出 $F(x+1),F(x+2),F(x+3)$，然后用组合数学推超级多种情况以后算出新的 $F(1),F(2),F(3)$ 就好了。</p>
<p>时间复杂度 $O(m+q)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line">ll mod=<span class="number">998244353</span>,inv2,invn,invn2,invn3;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll E1,E2,E3,F1,F2,F3,G1,G2,G3;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> E1;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) <span class="keyword">return</span> E2;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">3</span>) <span class="keyword">return</span> E3;</span><br><span class="line">	<span class="keyword">return</span> (E1*(x<span class="number">-2</span>)%mod*(x<span class="number">-3</span>)%mod*inv2-E2*(x<span class="number">-1</span>)%mod*(x<span class="number">-3</span>)%mod+E3*(x<span class="number">-1</span>)%mod*(x<span class="number">-2</span>)%mod*inv2+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,opt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(landlords);</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); opt=<span class="built_in">read</span>();</span><br><span class="line">	inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>; invn=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>); invn2=<span class="built_in">Pow</span>(<span class="number">1ll</span>*n*(n<span class="number">-1</span>)%mod,mod<span class="number">-2</span>); invn3=<span class="built_in">Pow</span>(<span class="number">1ll</span>*n*(n<span class="number">-1</span>)%mod*(n<span class="number">-2</span>)%mod,mod<span class="number">-2</span>);</span><br><span class="line">	E1=<span class="built_in">Pow</span>(<span class="number">1</span>,opt),E2=<span class="built_in">Pow</span>(<span class="number">2</span>,opt),E3=<span class="built_in">Pow</span>(<span class="number">3</span>,opt);</span><br><span class="line">	ll x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>();</span><br><span class="line">		F1=<span class="built_in">F</span>(x+<span class="number">1</span>); F2=<span class="built_in">F</span>(x+<span class="number">2</span>); F3=<span class="built_in">F</span>(x+<span class="number">3</span>);</span><br><span class="line">		G1=E1; G2=E2; G3=E3;</span><br><span class="line">		E1=(G1*x+F1*(n-x))%mod*invn%mod;</span><br><span class="line">		E2=(G2*x%mod*(x<span class="number">-1</span>)%mod+(G1+F1)*x%mod*(n-x)%mod+F2*(n-x)%mod*(n-x<span class="number">-1</span>)%mod)%mod*invn2%mod;</span><br><span class="line">		E3=(G3*x%mod*(x<span class="number">-1</span>)%mod*(x<span class="number">-2</span>)+(F1+G2+G2)%mod*x%mod*(n-x)%mod*(x<span class="number">-1</span>)+(G1+F2+F2)%mod*x%mod*(n-x)%mod*(n-x<span class="number">-1</span>)+F3*(n-x)%mod*(n-x<span class="number">-1</span>)%mod*(n-x<span class="number">-2</span>))%mod*invn3%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">CASET <span class="title">printf</span><span class="params">(<span class="string">&quot;%lld\n&quot;</span>,F(read()))</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
        <tag>思维题</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏[NOI2017]</title>
    <url>/2020/08/08/%E6%B8%B8%E6%88%8F-NOI2017/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/2305">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>3-SAT？？？</p>
<p>不好意思，那是NP问题。</p>
<p>先不考虑 ‘x’ 的限制。显然每个点有一种情况必定不能选，于是就变成2-SAT了。</p>
<p>于是我们可以 $3^d$ 枚举 x 的每一位必定不选什么，时间复杂度 $O((n+m)3^d)$。</p>
<p>考虑如果存在一个合法方案，那么在是 x 的那一位，你只需要枚举剩下两个的其中一个就好了！</p>
<p>于是直接枚举 x 的每一位是否不选a或b就可以判断是否有满足条件的解了。</p>
<p>时间复杂度 $O((n+m)2^d)$。</p>
<p>tarjan打错两次也是没谁了，看来夜晚是真的不适合我学OI。。。</p>
<p><strong>注意dfs时low[u]=min(low[u],dfn[v])的前提是v还在栈里。</strong></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> tim,scc_cnt,dfn[N],low[N],st[N],top,bel[N];</span><br><span class="line"><span class="type">bool</span> ins[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++tim; ins[u]=<span class="number">1</span>; st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])</span><br><span class="line">			<span class="built_in">dfs</span>(v),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ins[v])</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">	&#123;</span><br><span class="line">		++scc_cnt;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			bel[st[top]]=scc_cnt;</span><br><span class="line">			ins[st[top]]=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">while</span>(st[top--]!=u);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	scc_cnt=tim=top=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) adj[i].<span class="built_in">clear</span>(),dfn[i]=low[i]=bel[i]=ins[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> x[N],y[N],lx[N],ly[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[x]==<span class="number">0</span>) <span class="keyword">return</span> (y==<span class="number">1</span>)?x:x+n;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> (y==<span class="number">0</span>)?x:x+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">other</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;n?x-n:x+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(s[x[i]]!=lx[i])</span><br><span class="line">		&#123;</span><br><span class="line">			u=<span class="built_in">calc</span>(x[i],lx[i]);</span><br><span class="line">			<span class="keyword">if</span>(s[y[i]]==ly[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(u&gt;n) <span class="built_in">add</span>(u,u-n);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">add</span>(u,u+n);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			v=<span class="built_in">calc</span>(y[i],ly[i]);</span><br><span class="line">			<span class="built_in">add</span>(u,v); <span class="built_in">add</span>(<span class="built_in">other</span>(v),<span class="built_in">other</span>(u));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n+n) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(bel[i]==bel[i+n]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(bel[i]&lt;bel[i+n])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="number">2</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[<span class="number">10</span>],d;</span><br><span class="line"><span class="type">char</span> t[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(s[i]==<span class="string">&#x27;x&#x27;</span>) id[d++]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) s[i]-=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x[i]=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t); lx[i]=t[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		y[i]=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t); ly[i]=t[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt_d=<span class="number">1</span>&lt;&lt;d;</span><br><span class="line">	<span class="built_in">ff</span>(sta,<span class="number">0</span>,cnt_d)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,d) s[id[i]]=((sta&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">check</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI赛前总结</title>
    <url>/2020/08/08/NOI%E8%B5%9B%E5%89%8D%E6%A8%A1%E6%8B%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这是在NOI前一个星期的一些总结。</p>
<span id="more"></span>

<h2 id="08-07"><a href="#08-07" class="headerlink" title="08.07"></a>08.07</h2><p>今天发挥的还算可以，最后T3也想到了单调性DP的做法，但是已经来不及了。</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>输出任意一个长度最小的字符串，满足在这个字符串的子串中能找到所有长度为 $l$ 且字符在集合 $c$ 中的串。</p>
<p>手玩一下发现，输出不超过10MB就是大概 $1.2\times 10^7$ 个字符。如果输出的字符串中每个长度为 $l$ 的子串与 $c^l$ 种字符串一一对应，那么得到长度下界为 $c^l+l-1$。</p>
<p>考虑构造，并尝试在构造过程中证明下界是可以到达的。</p>
<p>将 $c^l$ 种字符串看成一个点，对于一个长度为 $l$ 的字符串，将第一位删掉然后在最后一位加上一个字符，形成了一个新的字符串。将这两个字符串连一条有向边。于是需要跑一遍哈密顿路径。</p>
<p>然后这个是NP完全的。</p>
<p>或许尝试一下将每个点只经过一次转换成边之经过一次，这样就只需要跑欧拉路径？</p>
<p>建一个二分图，左边是所有字符集为 $c$，长度为 $l-1$ 的字符串；右边是所有字符集为 $c$，长度为 $l$ 的字符串。当左边的某个字符串在最后加一个点形成右边的一个字符串则它们连一条边；右边的字符串与删掉一位后形成的左边的字符串连一条边。</p>
<p>这样实际上是把点变成了两条边，于是转成了求欧拉路径。</p>
<p>为了证明达到下界，我们来看是否任意的这样的图都存在欧拉路径。</p>
<p>证明很显然，左边的点有 $2c$ 条边，右边的点有 $2$ 条边。于是必定存在。</p>
<p>那么dfs跑一遍，发现栈空间极大无比，搞到了512MB。</p>
<p>于是手写一个栈，发现时间复杂度是 $O(c^{l+1})$ 的，因为每次都需要枚举一遍 $0\cdots c-1$。</p>
<p>于是再加一个当前弧优化之类的东西就可以了。</p>
<p>时间和空间复杂度都是 $O(c^l)$。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>有一个字符串，多次询问区间内的回文子串个数。不同的位置算多个。</p>
<p>$n,m\leq 1.3\times 10^5$。</p>
<p>有一个<del>或许</del>能拿优秀部分分的做法是莫队，每次莫队的端点移动时产生的贡献是固定一个端点，询问另一个端点在一段区间内的回文串个数。这个可以预处理PAM的parents树然后树链剖分or倍增解决。时间复杂度 $O(n\sqrt n\log n)$。</p>
<p>考虑正解，换一种思考方式，用manacher去做。</p>
<p>考虑枚举回文串的中间点，设 $f_i$ 为最长的延伸长度，然后稍微转换一下变成求 $\sum_{i=L}^R\min\{f_i,i-L,R-i\}$。</p>
<p>这个min里面有三个数，考虑将数量变少。将 $[L,R]$ 从中间断开，设 $mid=\frac{L+R}{2}$，那么min里面的东西就变为两个了。</p>
<p>考虑 $[L,mid]$ 如何算（$[mid+1,R]$ 同理），相当于求 $\sum_{i=L}^{mid}\min\{f_i,i-L\}$。</p>
<p>当 $f_i\le i-L$ 时，即 $i-f_i\geq L$。这时需要分别统计符合条件的 $i$ 的 $f_i$，$i$，$1$ 之和。</p>
<p>于是上个可持久化线段树即可。</p>
<p>时间复杂度 $O((n+m)\log n)$。</p>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><a href="/2020/08/07/%E5%BB%BA%E9%80%A0%E8%AE%B0%E8%80%85%E7%AB%99-jzoj4646/" title="建造记者站">建造记者站</a>

<h2 id="08-08"><a href="#08-08" class="headerlink" title="08.08"></a>08.08</h2><p>今天在酒店里做题，用了几个小时做了两题。晚上颓废+NOI原题。</p>
<h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><p><img src="/NOI%E8%B5%9B%E5%89%8D%E6%A8%A1%E6%8B%9F%E6%80%BB%E7%BB%93/0808T1.png" alt="0808T1"></p>
<p>$n,q\leq 10^5$。</p>
<p>权值在边上十分不好做。考虑将贡献扔到点上。</p>
<p>将一条边 $(u,v,w)$ 的贡献扔到点上，令 $val_u,val_v$ 加上 $\frac{w}{2}$。那么如果一个人两个点都选了，贡献刚好是 $w$；否则减一下贡献就是 $0$ 了。</p>
<p>那么题目变成，每次修改两个点的权值。然后将这些权值从大到小排序，在奇数位的贡献为正，偶数位的贡献为负，问贡献和。</p>
<p>由于需要强制在线，那么写个Treap维护一下就好了。</p>
<p>这个Treap需要支持维护将某个特定节点取出来，因此需要维护父亲。</p>
<p>程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">	<span class="type">int</span> siz[N],rnd[N],sum[N],val[N],ch[N][<span class="number">2</span>],fa[N],rt;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(siz[ch[u][<span class="number">0</span>]]&amp;<span class="number">1</span>) sum[u]=sum[ch[u][<span class="number">0</span>]]-val[u]+sum[ch[u][<span class="number">1</span>]];</span><br><span class="line">		<span class="keyword">else</span> sum[u]=sum[ch[u][<span class="number">0</span>]]+val[u]-sum[ch[u][<span class="number">1</span>]];</span><br><span class="line">		siz[u]=siz[ch[u][<span class="number">0</span>]]+siz[ch[u][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">0</span>]) fa[ch[u][<span class="number">0</span>]]=u;</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">1</span>]) fa[ch[u][<span class="number">1</span>]]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y)</span><br><span class="line">		&#123;</span><br><span class="line">			fa[x]=fa[y]=x+y;</span><br><span class="line">			<span class="keyword">return</span> x+y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[y])</span><br><span class="line">		&#123;</span><br><span class="line">			ch[x][<span class="number">1</span>]=<span class="built_in">merge</span>(ch[x][<span class="number">1</span>],y); <span class="built_in">pushup</span>(x); <span class="keyword">return</span> x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ch[y][<span class="number">0</span>]=<span class="built_in">merge</span>(x,ch[y][<span class="number">0</span>]); <span class="built_in">pushup</span>(y); <span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_val</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> (<span class="type">void</span>)(x=y=fa[x]=fa[y]=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(val[u]&gt;=v)</span><br><span class="line">		&#123;</span><br><span class="line">			x=u; <span class="built_in">split_val</span>(ch[u][<span class="number">1</span>],v,ch[x][<span class="number">1</span>],y); <span class="built_in">pushup</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			y=u; <span class="built_in">split_val</span>(ch[u][<span class="number">0</span>],v,x,ch[y][<span class="number">0</span>]); <span class="built_in">pushup</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_siz</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> (<span class="type">void</span>)(x=y=fa[x]=fa[y]=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(k&gt;siz[ch[u][<span class="number">0</span>]])</span><br><span class="line">		&#123;</span><br><span class="line">			x=u; <span class="built_in">split_siz</span>(ch[u][<span class="number">1</span>],k-siz[ch[u][<span class="number">0</span>]]<span class="number">-1</span>,ch[x][<span class="number">1</span>],y); <span class="built_in">pushup</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			y=u; <span class="built_in">split_siz</span>(ch[u][<span class="number">0</span>],k,x,ch[y][<span class="number">0</span>]); <span class="built_in">pushup</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> s=siz[ch[u][<span class="number">0</span>]];</span><br><span class="line">		<span class="keyword">for</span>(;u!=rt;u=fa[u])</span><br><span class="line">			<span class="keyword">if</span>(ch[fa[u]][<span class="number">1</span>]==u)</span><br><span class="line">				s+=siz[ch[fa[u]][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">0</span>]) <span class="built_in">dfs</span>(ch[u][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,val[u]);</span><br><span class="line">		<span class="keyword">if</span>(ch[u][<span class="number">1</span>]) <span class="built_in">dfs</span>(ch[u][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">take</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">split_siz</span>(rt,<span class="built_in">kth</span>(u),x,y);</span><br><span class="line">		<span class="built_in">split_siz</span>(y,<span class="number">1</span>,y,z);</span><br><span class="line">		rt=<span class="built_in">merge</span>(x,z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">take</span>(u);</span><br><span class="line">		val[u]+=v; sum[u]+=v;</span><br><span class="line">		<span class="built_in">split_val</span>(rt,val[u],x,y);</span><br><span class="line">		rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,u),y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dec</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		<span class="built_in">take</span>(u);</span><br><span class="line">		val[u]-=v; sum[u]-=v;</span><br><span class="line">		<span class="built_in">split_val</span>(rt,val[u],x,y);</span><br><span class="line">		rt=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,u),y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Treap;</span><br><span class="line"><span class="type">int</span> n,q,ty,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(round);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20030403</span>);</span><br><span class="line">	n=<span class="built_in">read</span>(); q=<span class="built_in">read</span>(); ty=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) siz[i]=<span class="number">1</span>,rnd[i]=<span class="built_in">rand</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) rt=<span class="built_in">merge</span>(rt,i);</span><br><span class="line">	<span class="type">int</span> opt,x,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(!opt)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>()^(ty*ans);</span><br><span class="line">			<span class="built_in">dec</span>(e[x].x,e[x].z);</span><br><span class="line">			<span class="built_in">dec</span>(e[x].y,e[x].z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			e[cnt].x=<span class="built_in">read</span>()^(ty*ans),e[cnt].y=<span class="built_in">read</span>()^(ty*ans);</span><br><span class="line">			e[cnt].z=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">add</span>(e[cnt].x,e[cnt].z);</span><br><span class="line">			<span class="built_in">add</span>(e[cnt].y,e[cnt].z);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans=(sum[rt]&gt;&gt;<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><p><a href="https://en.wikipedia.org/wiki/Lindström–Gessel–Viennot_lemma">一个叫做Lindström–Gessel–Viennot的引理</a></p>
<p><del>感性</del>证明：</p>
<p>将这些点按横坐标排序后，一共有 $n!$ 种配对方案。考虑上方第 $i$ 个点配对下面第 $p_i$ 个点，那么一个合法的配对方案的必要条件是逆序对个数为 $0$。</p>
<p>现在要求的是不相交的方案，考虑反面，看看相交的方案数是多少。</p>
<p>如果有一种相交的情况，考虑在交点的位置将两条路径反过来。这样做相当于在一个排列中交换了两个位置不同的数，由经典结论，此时逆序对的奇偶性改变。</p>
<p>因此，当有相交的情况时，逆序对为奇数的相交方案=逆序对为偶数的相交方案。</p>
<p>又因为有：逆序对为偶数的所有方案=逆序对为偶数的相交方案+逆序对为 $0$ 的不相交方案，因此得证。</p>
<p>于是如果能求出某两个点配对的方案数，然后高斯消元解行列式就可以了。</p>
<p>枚举第一行的某个点为起点，然后用经典容斥去做DP即可。</p>
<p>时间复杂度 $O(n+m+p^2q+pq^2+p^3)$。</p>
<h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><p>双重积分？格林公式？</p>
<p>不会不会，溜了溜了。</p>
]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>manacher</tag>
        <tag>博弈论</tag>
        <tag>欧拉回路</tag>
        <tag>平衡树</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title>建造记者站[jzoj4646]</title>
    <url>/2020/08/07/%E5%BB%BA%E9%80%A0%E8%AE%B0%E8%80%85%E7%AB%99-jzoj4646/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%BB%BA%E9%80%A0%E8%AE%B0%E8%80%85%E7%AB%99-jzoj4646/problem.png" alt="题面"></p>
<p>$n\leq 20000,m\leq 100$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>考虑DP，设 $f_{k,i}$ 表示选了 $k$ 个记者站时，考虑了前 $i$ 个村庄，第 $i$ 个村庄上有一个记者站的最小花费。</p>
<p>那么有DP式子：$f_{k,i}=\min_{1\le j &lt;i}(f_{k-1,j}+c_i+g_{j,i})$</p>
<p>其中 $g_{j,i}$ 表示，$[j,i]$ 内只有 $i,j$ 两个点被选时，不能被覆盖的点的 $P$ 值的和。</p>
<p>暴力预处理 $g_{l,r}$，暴力计算 $f_{k,i}$，时间复杂度 $O(n^3+n^2m)$，得分30分。</p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p><del>盲猜 $g$ 满足四边形不等式，打表验证。</del></p>
<p>反正最后发现这个DP有决策单调性。</p>
<p>由于 $f$ 的计算和前面的DP值无关，因此考虑分治。</p>
<p>现在的问题转换成如何计算一个 $f_{k,i}$。也就是如果计算 $g_{j,i}$。</p>
<p>不能被覆盖的点 $k$ 当且仅当 $d_j&lt;d_k-r_k,d_k+r_k&lt;d_i$。</p>
<p>于是变成一个三位偏序问题，可用树套树在线解决。</p>
<p>时间复杂度 $O(nm\log^2n)$，常数极大，应该可以有 $70+$ 的样子。</p>
<h4 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h4><p>考虑直接DP做，随着 $i$ 的增加，维护 $f_{k-1,j}+g_{j,i}(1\le j &lt;i)$ 的最小值。</p>
<p>当 $i+1$ 时考虑哪些 $g_{j,i}$ 会变化，如果此时有新的 $d_k+r_k&lt;d_i$ 出现，那么所有满足 $d_j&lt;d_k-r_k$ 的 $j$ 的 $g_{j,i}$ 就会加上 $p_k$。</p>
<p>于是对于每个 $k$，预处理出最大的 $j$ 满足 $d_j&lt;d_k-r_k$ ，记为 $l_k$。然后维护一个堆，DP时每次取出最小的 $d_k+r_k$，判断是否满足条件。如果是，则将 $[1,l_k]$ 的值全部加上 $p_k$ 即可。</p>
<p>用线段树维护区间加区间最值。</p>
<p>时间复杂度 $O(nm\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>这里写的是算法三的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="type">int</span> mi[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	<span class="type">int</span> *g;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r)</span><br><span class="line">		&#123;</span><br><span class="line">			mi[u]=g[l];</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">		mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *f)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		g=f; <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tag[u]+=t; mi[u]+=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushtag</span>(lc,tag[u]); <span class="built_in">pushtag</span>(rc,tag[u]);</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,x);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">add</span>(ls,L,R,x);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R) <span class="built_in">add</span>(rs,L,R,x);</span><br><span class="line">		mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(mi[u]=x,tag[u]=<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		(p&lt;=mid)?<span class="built_in">update</span>(ls,p,x):<span class="built_in">update</span>(rs,p,x);</span><br><span class="line">		mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> mi[u];</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=inf;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) ans=<span class="built_in">min</span>(ans,<span class="built_in">ask</span>(ls,L,R));</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  ans=<span class="built_in">min</span>(ans,<span class="built_in">ask</span>(rs,L,R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,val;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.val==B.val) <span class="keyword">return</span> A.id&lt;B.id;</span><br><span class="line">		<span class="keyword">return</span> A.val&lt;B.val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node u;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> d[N],c[N],r[N],p[N],le[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">103</span>][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">min</span>(n,<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) d[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) c[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) r[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) le[i]=<span class="built_in">lower_bound</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,d[i]-r[i])-d<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		f[<span class="number">1</span>][i]=f[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span>(-u.val&lt;d[i]) f[<span class="number">1</span>][i]+=p[u.id],q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">push</span>((node)&#123;i,-d[i]-r[i]&#125;); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[<span class="number">1</span>][i]+=c[i];</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">2</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		SGT::<span class="built_in">init</span>(n,f[k<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				u=q.<span class="built_in">top</span>();</span><br><span class="line">				<span class="keyword">if</span>(-u.val&lt;d[i])</span><br><span class="line">					SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,le[u.id],p[u.id]),q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i!=<span class="number">1</span>) f[k][i]=SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(f[k][i]&lt;inf)	f[k][i]+=c[i];</span><br><span class="line">			q.<span class="built_in">push</span>((node)&#123;i,-d[i]-r[i]&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,sum;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans+=p[i];</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fd</span>(i,n,k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">				&#123;</span><br><span class="line">					u=q.<span class="built_in">top</span>();</span><br><span class="line">					<span class="keyword">if</span>(d[i]&lt;u.val) sum+=p[u.id],q.<span class="built_in">pop</span>();</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			q.<span class="built_in">push</span>((node)&#123;i,d[i]-r[i]&#125;);</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,sum+f[k][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>分治</tag>
        <tag>线段树</tag>
        <tag>堆</tag>
        <tag>决策单调性</tag>
      </tags>
  </entry>
  <entry>
    <title>Duff in Mafia[CF587D]</title>
    <url>/2020/08/05/Duff-in-Mafia-CF587D/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF587D">luogu</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最小值最大显然先二分，然后变成有些边一定不能选，有些边可以选。</p>
<p>每条可以选的边有选或者不选两种情况。</p>
<p>对于一个点而言：考虑与之相连的所有边，如果其中一条边选了，剩下的所有的边都不能选；考虑与之相连的所有同颜色的边，如果其中一条边没选，剩下的都必须要选。</p>
<p>那么就变成一个2-SAT问题了。将 $m$ 条边看成点，拆点，$i,i’$ 分别表示表示这条边选和不选的情况。</p>
<p>对于必定不能选的边，连边 $(i,i’)$。</p>
<p>对于第一种情况，即考虑所有边的情况：将这些边排成一列，然后连边 $(i,j’)$，其中 $j\not =i$。</p>
<p>第二种情况同理，连 $(i’,j)$。</p>
<p>但是这样做复杂度高达 $O(m^2\log t)$，无法承受。</p>
<p>考虑优化连边——前缀优化（似乎是2-SAT的一种很经典的连边方式？）。</p>
<p>这里只考虑第一种情况，第二种反过来就好了。</p>
<p>将这些边排成一列，设为 $x_i$ 和 $x_i’$。然后新建两列点 $s_i,s_i’$，用下面的方式连边，即可达到同样的效果。</p>
<p><img src="/Duff-in-Mafia-CF587D/Edge.png" alt="Edge"></p>
<p>于是时间复杂度 $O((n+m)\log t)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans,vec[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,col,t;</span><br><span class="line">&#125;e[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt,scc_cnt,bel[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tim,st[N],top;</span><br><span class="line"><span class="type">bool</span> instack[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++tim;</span><br><span class="line">	instack[u]=<span class="number">1</span>; st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) <span class="built_in">dfs</span>(v),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">	<span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">	&#123;</span><br><span class="line">		instack[u]=<span class="number">0</span>; bel[u]=++scc_cnt;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v;u!=st[top--];top)</span><br><span class="line">		&#123;</span><br><span class="line">			v=st[top+<span class="number">1</span>]; instack[v]=<span class="number">0</span>; bel[v]=scc_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	scc_cnt=top=tim=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) bel[i]=instack[i]=dfn[i]=low[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(e[i].t&gt;x) adj[i].<span class="built_in">pb</span>(i+m);</span><br><span class="line">	<span class="built_in">tarjan</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(e[i].t&gt;x) adj[i].<span class="built_in">pop_back</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(bel[i]==bel[i+m]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=v.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt+=<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">add</span>(cnt<span class="number">-1</span>,v[i]); <span class="built_in">add</span>(v[i]+m,cnt);</span><br><span class="line">		<span class="keyword">if</span>(i!=len<span class="number">-1</span>) <span class="built_in">add</span>(v[i+<span class="number">1</span>]+m,cnt<span class="number">-1</span>),<span class="built_in">add</span>(cnt,v[i+<span class="number">1</span>]),<span class="built_in">add</span>(cnt+<span class="number">1</span>,cnt<span class="number">-1</span>),<span class="built_in">add</span>(cnt,cnt+<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		e[i].x=<span class="built_in">read</span>(),e[i].y=<span class="built_in">read</span>(),e[i].col=<span class="built_in">read</span>(),e[i].t=<span class="built_in">read</span>();</span><br><span class="line">		vec[e[i].x].<span class="built_in">pb</span>(i); vec[e[i].y].<span class="built_in">pb</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt=m+m;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	<span class="keyword">if</span>(vec[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(vec[i]),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> e[x].col&lt;e[y].col;&#125;);</span><br><span class="line">		<span class="type">int</span> len=vec[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,len)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt+=<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">add</span>(vec[i][j],cnt<span class="number">-1</span>); <span class="built_in">add</span>(cnt,vec[i][j]+m);</span><br><span class="line">			<span class="keyword">if</span>(j!=len<span class="number">-1</span>) <span class="built_in">add</span>(cnt<span class="number">-1</span>,vec[i][j+<span class="number">1</span>]+m),<span class="built_in">add</span>(vec[i][j+<span class="number">1</span>],cnt),<span class="built_in">add</span>(cnt<span class="number">-1</span>,cnt+<span class="number">1</span>),<span class="built_in">add</span>(cnt+<span class="number">2</span>,cnt); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;j&lt;len;j=k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(v.<span class="built_in">clear</span>();k&lt;len&amp;&amp;e[vec[i][j]].col==e[vec[i][k]].col;k++) v.<span class="built_in">pb</span>(vec[i][k]);</span><br><span class="line">			<span class="built_in">work</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,mid;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) r=<span class="built_in">max</span>(r,e[i].t);</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check</span>(r)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">check</span>(l); ans.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(bel[i]&lt;bel[i+m]) ans.<span class="built_in">pb</span>(i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,l,ans.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x:ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>Number of Binominal Coefficients[CF582D]</title>
    <url>/2020/08/04/Number-of-Binominal-Coefficients-CF582D/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF582D">luogu</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一个组合数能否整除 $p^k$（其中 $p$ 是质数），这个可以算出组合数的含 $p$ 的次幂，然后判断是否大于等于 $k$ 即可。</p>
<p>由kummer定理，$\binom{n+m}{m}$ 的含 $p$ 的次幂等于 $n+m$ 在 $p$ 进制意义下的进位次数。</p>
<p>由于 $\binom{n}{k}=\binom{(n-k)+k}{k}$，那么题目转换成，问有多少对 $0\le a,b\leq A$，且 $a+b$ 进位次数大于等于 $k$。</p>
<p>可以注意到，$\alpha \le 10^9$ 是吓人的。当极限数据 $p=2,A=10^{1000}$ 时，算出最小的 $\alpha$，满足 $p^{\alpha}\geq A$，发现不超过 $3400$。</p>
<p>那么就可以进行数位DP了。</p>
<p>设 $f_{i,j,0/1,0/1}$ 表示从高位到低位考虑到第 $i$ 位，此时（包括 $i-1$ 位进上来的）已经有 $j$ 个进位，第 $i-1$ 位是否进上来第 $i$ 位，数位是否一直取最大值的方案数。</p>
<p>转移分四类大力讨论，算一堆东西即可。</p>
<p>具体见程序。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3405</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll p;</span><br><span class="line"><span class="type">int</span> alpha,x[N],m;</span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[m+<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    ll p1=<span class="number">1ll</span>*(p+<span class="number">1</span>)*p/<span class="number">2</span>%mod,p2=<span class="number">1ll</span>*p*(p<span class="number">-1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">    ll g1,g2,g3,g4;</span><br><span class="line">    <span class="built_in">fd</span>(i,m,<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll x1=<span class="number">1ll</span>*(x[i]+<span class="number">1</span>)*x[i]/<span class="number">2</span>%mod,x2=<span class="number">1ll</span>*x[i]*(x[i]<span class="number">-1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">        ll t1=<span class="number">1ll</span>*x[i]*(p*<span class="number">2</span>-x[i]<span class="number">-1</span>)/<span class="number">2</span>%mod,t2=<span class="number">1ll</span>*x[i]*(p*<span class="number">2</span>-x[i]+<span class="number">1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">0</span>,m)</span><br><span class="line">        &#123;</span><br><span class="line">            g1=f[i+<span class="number">1</span>][j][<span class="number">0</span>][<span class="number">0</span>]; g2=f[i+<span class="number">1</span>][j][<span class="number">0</span>][<span class="number">1</span>]; g3=f[i+<span class="number">1</span>][j][<span class="number">1</span>][<span class="number">0</span>]; g4=f[i+<span class="number">1</span>][j][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            f[i][j][<span class="number">0</span>][<span class="number">0</span>]=(p1*g1+x1*g2+p2*g3+t1*g4)%mod;</span><br><span class="line">            f[i][j][<span class="number">0</span>][<span class="number">1</span>]=(g2*(x[i]+<span class="number">1</span>)+g4*(p-x[i]<span class="number">-1</span>))%mod;</span><br><span class="line">            f[i][j+<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=(p2*g1+x2*g2+p1*g3+t2*g4)%mod;</span><br><span class="line">            f[i][j+<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=(g2*x[i]+g4*(p-x[i]))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,alpha,m) (ans+=f[<span class="number">1</span>][i][<span class="number">0</span>][<span class="number">0</span>]+f[<span class="number">1</span>][i][<span class="number">0</span>][<span class="number">1</span>])%=mod;</span><br><span class="line">    <span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d\n%s&quot;</span>,&amp;p,&amp;alpha,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(alpha&gt;=<span class="number">3400</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>),<span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),a[N];</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=s[n-i+<span class="number">1</span>]<span class="number">-48</span>;</span><br><span class="line">    <span class="keyword">for</span>(;n;)</span><br><span class="line">    &#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=tmp*<span class="number">10</span>+a[i]; a[i]=tmp/p; tmp%=p;</span><br><span class="line">            <span class="keyword">if</span>(i==n&amp;&amp;!a[i]) n--;</span><br><span class="line">        &#125;</span><br><span class="line">        x[++m]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>kummer定理</tag>
      </tags>
  </entry>
  <entry>
    <title>排列计数[luogu5825]</title>
    <url>/2020/08/04/%E6%8E%92%E5%88%97%E8%AE%A1%E6%95%B0-luogu5825/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于所有长度为 $n$ 的排列 $p$，求有 $k$ 个 $i$ 满足 $p_i&lt;p_{i+1}$ 的方案数。</p>
<p>对于所有的 $k$ 都要算。</p>
<p>$n\leq 2\times 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>有一个较为简单的DP，顺次考虑将 $i$ 插入进排列，转移很简单，时间复杂度 $O(n^2)$。</p>
<p>然后你发现做不下去了，考虑至少容斥，设 $F_i$ 为答案，$G_k$ 为至少有 $k$ 个 $i$ 满足条件的方案数。那么最后二项式反演+ntt即可算出 $F$。</p>
<p>考虑钦定了 $k$ 个位置的小于号，然后将连续的小于号的搞成一个连续段，那么将有 $n-k$ 个连续段，且如果知道了段内的数组，那么段内的顺序也是确定的。</p>
<p>假设段的长度为 $x_1,x_2\cdots,x_m$，那么一共有 $\frac{n!}{\prod_{i=1}^m x_i}$ 个贡献，要求满足 $x_i\geq 1$</p>
<p>考虑用生成函数解决：</p>
<p>$$G _ k=[x ^ n]((\sum _ {i=0} \frac{x ^ i}{i!})-1) ^ {n-k}=[x ^ n] (e ^ x-1) ^ {n-k}$$</p>
<p>设 $m=n-k$，则：</p>
<p>$$<a href="e^x-1">x^n</a>^m=\sum_{i=0}^m[x^n]e^{xi}(-1)^{m-i}\binom{m}{i}=\sum_{i=0}^m\frac{i^n}{n!}(-1)^{m-i}\binom{m}{i}$$</p>
<p>搞一个ntt就好了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>懒得搞了，反正很简单。</p>
]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>Tokitsukaze, CSL and Palindrome Game[hdu6791]</title>
    <url>/2020/07/29/Tokitsukaze-CSL-and-Palindrome-Game-hdu6791/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6791">hdu</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于一个字符串 $S$，我们定义 $E(S)$ 为每次在串后面随机一个小写字母，第一次出现该字符串时的期望次数。</p>
<p>给一个长度为 $n$ 的字符串，$q$ 次询问这个字符串中的两个回文子串，谁的 $E(S)$ 大。</p>
<p>$n,q\le 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>考虑，先解决如何计算一个字符串的 $E(S)$。</p>
<p>显然有：$E(S)=\sum_{i=1}^{\infty}P(在i时刻第一次出现S)i$</p>
<p>转换一下得到：$E(S)=\sum_{i=0}^{\infty}P(在i时刻还未出现S)$。</p>
<p>那我们设这么一个字符串集合，表示还未出现S的所有状态，设为 $F$。里面每个字符串有它的出现的概率 $P(F_i)$。</p>
<p>有：$E(S)=\sum P(F_i)$</p>
<p>再设 $G$ 为第一次出现S时的所有状态，同理有 $P(G_i)$。</p>
<p>有：$\sum P(G_i)=1$。</p>
<p>考虑对于 $F$ 集合内的任意一个 $F_i$ ，我们在 $F_i$ 后加上一个 $S$。此时的 $\{F_i+S\}$ 肯定会包含 $G$。除此以外，有可能在还没有加完整个 $S$ 后就已经出现第一次了，这种情况只能是这个 $S$ 的某个前缀是后缀，也就是border。设这个border长度为 $j$，那么需要再后面加 $|S|-j$ 个数。</p>
<p>那么得到：$\sum P(F_i)(\frac{1}{26})^{|S|}=\sum_{长度为j的border}\sum P(G_i)(\frac{1}{26})^{|S|-j}$</p>
<p>同时乘 $(\frac{1}{26})^{|S|}$，由 $\sum P(G_i)=1$ 得到：</p>
<p>$E(S)=\sum_{j=1}^{|S|}[存在长度为j的border]26^j$</p>
<p>还有另一种证明用的是生成函数，参考2018集训队论文。</p>
<h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h4><p>我们将 $E(S)$ 看成 $26$ 进制。那么只需要先比较字符串长度，如果不相等结果就直接出来了。</p>
<p>否则就是比较字典序。</p>
<p>既然是回文子串，就建一个PAM吧！</p>
<p>然后在上面建fail树倍增一下找到询问的字符串。</p>
<p>根据border理论，一个回文串的border也是回文串，对应的刚好就是fail链上的所有长度大于 $0$ 的节点。</p>
<p>那么哈希，然后倍增找到第一个字典序不同的位置即可。</p>
<p>时间复杂度 $O((n+q)\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244853</span>;</span><br><span class="line"><span class="type">const</span> ll base=<span class="number">29</span>;</span><br><span class="line">ll p[N];</span><br><span class="line"><span class="type">int</span> pos[N];</span><br><span class="line"><span class="keyword">namespace</span> PAM&#123;</span><br><span class="line">	<span class="type">int</span> s[N],n;</span><br><span class="line">	<span class="type">int</span> fa[N],ne[N][S],len[N],siz,las;</span><br><span class="line">	<span class="type">int</span> f[N][<span class="number">20</span>];</span><br><span class="line">	ll h[N];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) s[i]=<span class="number">0</span>; s[n=<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,siz) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),fa[i]=len[i]=<span class="number">0</span>,adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		siz=<span class="number">1</span>; las=<span class="number">0</span>;</span><br><span class="line">		fa[<span class="number">0</span>]=<span class="number">1</span>; len[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfail</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;s[n<span class="number">-1</span>-len[x]]!=s[n];x=fa[x]);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[++n]=c;</span><br><span class="line">		<span class="type">int</span> p=<span class="built_in">getfail</span>(las);</span><br><span class="line">		<span class="keyword">if</span>(!ne[p][c])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=++siz,q=<span class="built_in">getfail</span>(fa[p]);</span><br><span class="line">			len[u]=len[p]+<span class="number">2</span>; fa[u]=ne[q][c]; ne[p][c]=u; </span><br><span class="line">		&#125;</span><br><span class="line">		las=ne[p][c];</span><br><span class="line">		<span class="keyword">return</span> las;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pre==<span class="number">-1</span>) h[u]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> h[u]=(h[pre]+(len[u]&lt;=<span class="number">0</span>?<span class="number">0</span>:p[len[u]]))%mod;</span><br><span class="line">		f[u][<span class="number">0</span>]=pre;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">18</span>)</span><br><span class="line">			<span class="keyword">if</span>(f[u][i<span class="number">-1</span>]!=<span class="number">-1</span>)</span><br><span class="line">				f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,siz) <span class="keyword">if</span>(i!=<span class="number">1</span>) adj[fa[i]].<span class="built_in">pb</span>(i);</span><br><span class="line">		<span class="built_in">fo</span>(u,<span class="number">0</span>,siz) <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">18</span>) f[u][i]=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[u][i]!=<span class="number">-1</span>&amp;&amp;len[f[u][i]]&gt;=k) u=f[u][i];</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">jump</span>(pos[y],y-x+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span>(f[x][i]!=<span class="number">-1</span>&amp;&amp;f[y][i]!=<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">if</span>((h[x]-h[f[x][i]]+mod)%mod==(h[y]-h[f[y][i]]+mod)%mod)</span><br><span class="line">					x=f[x][i],y=f[y][i];</span><br><span class="line">		<span class="keyword">if</span>(f[x][<span class="number">0</span>]==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> len[x]&gt;len[y]?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,N) p[i]=p[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		PAM::<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pos[i]=PAM::<span class="built_in">ins</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		PAM::<span class="built_in">work</span>();</span><br><span class="line">		<span class="type">int</span> a,b,c,d,t;</span><br><span class="line">		CASET</span><br><span class="line">		&#123;</span><br><span class="line">			a=<span class="built_in">read</span>(); b=<span class="built_in">read</span>(); c=<span class="built_in">read</span>(); d=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(b-a+<span class="number">1</span>!=d-c+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">puts</span>((b-a+<span class="number">1</span>&gt;d-c+<span class="number">1</span>)?<span class="string">&quot;cslnb&quot;</span>:<span class="string">&quot;sjfnb&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			t=PAM::<span class="built_in">solve</span>(PAM::<span class="built_in">get</span>(a,b),PAM::<span class="built_in">get</span>(c,d));</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;draw&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>((t==<span class="number">1</span>)?<span class="string">&quot;cslnb&quot;</span>:<span class="string">&quot;sjfnb&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>期望</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>一些随机算法</title>
    <url>/2020/07/29/%E4%B8%80%E4%BA%9B%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>这里是一些关于随机<del>乱搞</del>算法的介绍。（待更。。。</p>
<span id="more"></span>

<h3 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h3><p>顾名思义，你可以想象一下蒙上眼睛以后是怎么爬山的。</p>
<p>那就是随机一个当前位置的临近状态，如果这个状态的比当前位置牛逼，那么就移动到这个位置上。</p>
<p>显然，这样的思路很容易陷入局部最优解然后出不来。</p>
<p>解决方案是<del>使用模拟退火</del>多爬几遍。</p>
<h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>英文名：Simulated Annealing。</p>
<p>顾名思义 $\times 2$。<del>你可以想象一下你从愤怒变为冷静的过程。</del></p>
<p>实际上是退火是与物理相关的词，指的是一个高温的晶体冷却时的过程。</p>
<p>跟爬山类似，退火的过程是从当前的状态转移到另一状态，只不过这个转移的过程跟当前的温度之类的是有关系的。可以理解为随机下一状态的范围是与当前温度相关的。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>一开始我们先随机一个状态，以及设定一个初始的温度。然后温度随着迭代的次数增加而降低。</p>
<p>对于每一状态：设当前温度为 $T$，状态为 $x_n$，然后你根据当前温度找到了下一个状态 $x_{n+1}$。</p>
<p>设状态 $x$ 的能量为 $E(x)$。这个能量跟爬山的高度是类似的。</p>
<p>为了不陷入局部最优解，我们需要一个东西来判定。</p>
<p>显然，当 $E(x_{n+1})\geq E(x_n)$ 时，也就是 $x_{n+1}$ 比 $x_n$ 优，我们将当前位置转移到 $E(x_{n+1})$ 上。</p>
<p>那么当 $E(x_{n+1})&lt;E(x_n)$ 时，我们要以一定的概率转移到 $E(x_{n+1})$ 上，以保证不陷入局部最优解。而这个概率我们用 $e^{-\frac{E(x_n)-E(x_{n+1})}{T}}$（我也不知道为什么要用这个）。</p>
<p>最后来看这个温度 $T$ 该怎么降低法。</p>
<p>实际上，一般通过指数式的下降来时限这个温度 $T$ 的下降。即 $T_{n+1}=\lambda T_n$，这个 $\lambda$ 可以随你挑。</p>
<p>如果 $\lambda$ 太大，则容易陷入局部最优解；如果 $\lambda$ 太小，则时间复杂度会增加。具体数值就去调参叭，大概是 $0.99$ 左右的样子。</p>
<p>然后退火退到一定程度，即温度过小的时候就可以结束了。</p>
<h4 id="trick0"><a href="#trick0" class="headerlink" title="trick0"></a>trick0</h4><p>调参，比如 $\lambda$ 的值，退火次数，以及随机种子。</p>
<h4 id="trick1"><a href="#trick1" class="headerlink" title="trick1"></a>trick1</h4><p>跟爬山一样，我们可以退多几次火来增加找到最优解的概率。</p>
<h4 id="trick2"><a href="#trick2" class="headerlink" title="trick2"></a>trick2</h4><p>分块模拟退火，当这个函数的峰有很多很多的时候，往往直接退火也无法找到最优解，这时我们将函数分为连续的一些块，每个快内做一次退火，然后合并。</p>
<h3 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h3><ul>
<li><a href="/2020/07/29/%E6%94%BB%E5%87%BB-JSOI2016/" title="攻击[JSOI2016]">攻击[JSOI2016]</a>
</li>
<li><a href="/2020/07/24/hdu2020%E5%A4%9A%E6%A0%A12/" title="Lead-of-Wisdom">Lead-of-Wisdom</a></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>爬山算法</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击[JSOI2016]</title>
    <url>/2020/07/29/%E6%94%BB%E5%87%BB-JSOI2016/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/2076">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>前 $20\%$ ：$m=2$，暴力判断。</p>
<p>中间 $20\%$：$n=0$，枚举两个点，然后扫描线。</p>
<p>好了，开始搞正解。</p>
<p>发现根本不可做，于是来模拟退火。</p>
<p>退火的能量表示成一个二元组 &lt;点的个数，圆的最大半径&gt;。</p>
<p>要使得点的个数最大，且在点的个数相同时，圆的最大半径最大才行。</p>
<p>然后对于一个点，算这个二元组可以 $O(n+m)$ 算。</p>
<p>那么退火次数可以卡一卡，调一堆参，就过了。</p>
<p>时间复杂度玄学。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pid pair<span class="string">&lt;int,db&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">P</span>(db _x=<span class="number">0</span>,db _y=<span class="number">0</span>)&#123;x=_x; y=_y;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">dis</span><span class="params">(P A,P B)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;db x,y,r;&#125;;</span><br><span class="line">C c[N];</span><br><span class="line">P p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">db R;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Rand</span><span class="params">(db x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*<span class="number">2</span>*((<span class="number">0.0</span>+<span class="built_in">rand</span>())/RAND_MAX)-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pid <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tot=<span class="number">0</span>; db r=R;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) r=<span class="built_in">min</span>(r,<span class="built_in">dis</span>(<span class="built_in">P</span>(x,y),<span class="built_in">P</span>(c[i].x,c[i].y))-c[i].r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>(<span class="built_in">dis</span>(p[i],<span class="built_in">P</span>(x,y))&lt;=r) tot++;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(tot,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">(db x,db y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pid now=<span class="built_in">calc</span>(x,y),mx=now,nex;</span><br><span class="line">	db nx,ny,W;</span><br><span class="line">	<span class="keyword">for</span>(db T=R;T&gt;eps;T*=<span class="number">0.99</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		nx=x+<span class="built_in">Rand</span>(T),ny=y+<span class="built_in">Rand</span>(T);</span><br><span class="line">		nex=<span class="built_in">calc</span>(nx,ny);</span><br><span class="line">		<span class="keyword">if</span>(nex&gt;now) x=nx,y=ny,now=nex;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>(R*(nex.fi==now.fi?nex.se-now.se:nex.fi-now.fi)/T)&gt;((<span class="number">0.0</span>+<span class="built_in">rand</span>())/RAND_MAX)) x=nx,y=ny,now=nex;</span><br><span class="line">		mx=<span class="built_in">max</span>(mx,nex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mx.fi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20030403</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;R;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) cin&gt;&gt;c[i].x&gt;&gt;c[i].y&gt;&gt;c[i].r;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) cin&gt;&gt;p[i].x&gt;&gt;p[i].y;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="built_in">min</span>(<span class="number">100000</span>/m,<span class="number">2000</span>)) ans=<span class="built_in">max</span>(ans,<span class="built_in">solve</span>(<span class="built_in">Rand</span>(R),<span class="built_in">Rand</span>(R)));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展Lucas</title>
    <url>/2020/07/28/%E6%89%A9%E5%B1%95Lucas/</url>
    <content><![CDATA[<p>求 $\binom{n}{m}\bmod p$ 的值。</p>
<p>$m\le n\le 10^{18},p\le 10^7$ </p>
<span id="more"></span>

<p><del>主要是存一个模板。</del></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/P4720">luogu</a></p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>Lucas定理：当 $p$ 是质数时，有 $\binom{n}{m}\equiv \binom{\frac{n}{p}}{\frac{m}{p}}\binom{n\bmod p}{m\bmod p}\pmod p$</p>
<p>那么当 $p$ 不是质数时，是否也能计算呢？</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>如果要算 $\binom{n}{m}\bmod p$，只需要把 $p$ 质因数分解，$p=\sum_{i=1}^mp_i^{a_i}$。</p>
<p>那么对于任意的 $i$，算出 $\binom{n}{m}\bmod p_i^{a_i}$，然后用CRT合并。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>现在只需要算组合数对 $p^k$ 取模的结果。</p>
<p>将 $\binom{n}{m}$ 分解成阶乘形式：$\binom{n}{m}=\frac{n!}{m!(n-m)!}$</p>
<p>那么将阶乘搞成 $p^t\times y$ 的形式（其中 $\gcd(y,p)=1$），跟 $p$ 有关的幂用 $n!$ 的减去 $m!$ 和 $(n-m)!$ 的幂就可以算了。</p>
<p>剩下的 $y$ 是有逆元的，可以直接算。</p>
<h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><p>现在只需要分解 $n!$ 就好了。</p>
<p>我们将 $n!=1\times 2\times \cdots \times n$ 分成几部分。</p>
<p>第一部分是 $p$ 的倍数，分别是 $1p,2p\cdots \left \lfloor \frac{n}{p} \right \rfloor p$，那么可以表示为 $p^{\left \lfloor \frac{n}{p} \right \rfloor}\times (\left \lfloor \frac{n}{p} \right \rfloor)!$。</p>
<p>第二部分则不是 $p$ 的倍数。这一部分构成了一个模 $p^k$ 的循环节。</p>
<p>由于 $p^k$ 不会超过 $10^7$，因此可以预处理这个循环节。</p>
<p>设 $sum_j\equiv \sum_{i=1,i\bmod p\not = 0}^ji\pmod p^k$</p>
<p>然后就变成 $sum_{p^k}$ 的 $\left \lfloor \frac{n}{p} \right \rfloor$ 次幂乘上 $sum_{n\bmod p^k}$。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>预处理的时间为 $O(p^k)$，算一次组合数的复杂度为 $O(\log_pn\times log_2n)$。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>根据不知道是什么定理，$sum_{p^k}$ 要么是 $1$ 要么是 $-1$。</p>
<p>那么算组合数时就省去了快速幂，复杂度变成 $O(\log_2n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y,ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> y?<span class="built_in">gcd</span>(y,x%y):x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="number">1</span>; y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=a/b*x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x,y,d;</span><br><span class="line">	d=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">	<span class="keyword">if</span>(d!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> (x%b+b)%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> pair&lt;ll,ll&gt; <span class="title">excrt</span><span class="params">(<span class="type">int</span> n,ll *c,ll *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll nc=c[<span class="number">1</span>],nm=m[<span class="number">1</span>],d;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		d=<span class="built_in">gcd</span>(m[i],nm);</span><br><span class="line">		<span class="keyword">if</span>((c[i]-nc)%d!=<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">mp</span>(<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">		nc=<span class="built_in">inv</span>(nm/d,m[i]/d)*((c[i]-nc)/d)*nm+nc;</span><br><span class="line">		nm=nm/d*m[i];</span><br><span class="line">		nc=(nc%nm+nm)%nm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">mp</span>(nc,nm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">namespace</span> ExLucas&#123;</span><br><span class="line">	ll sum[M];</span><br><span class="line">	<span class="type">int</span> t,p;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _p,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		p=_p; t=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) t=t*p;</span><br><span class="line">		sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,t) sum[i]=(sum[i<span class="number">-1</span>]*((i%p==<span class="number">0</span>)?<span class="number">1</span>:i))%t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> nq,sq;</span><br><span class="line">	<span class="function">ll <span class="title">fac</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		nq+=n/p;</span><br><span class="line">		<span class="keyword">if</span>(sum[t]==<span class="number">1</span>||(n/t)%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> sum[n%t]*<span class="built_in">fac</span>(n/p)%t;</span><br><span class="line">		<span class="keyword">return</span> (t-sum[n%t]%t*<span class="built_in">fac</span>(n/p)%t)%t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m,<span class="type">int</span> p,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">init</span>(p,k); sq=<span class="number">0</span>;</span><br><span class="line">		ll ans,sum;</span><br><span class="line">		nq=<span class="number">0</span>; ans=<span class="built_in">fac</span>(n); sq+=nq;</span><br><span class="line">		nq=<span class="number">0</span>; sum=<span class="built_in">fac</span>(m); sq-=nq;</span><br><span class="line">		nq=<span class="number">0</span>; sum=sum*<span class="built_in">fac</span>(n-m)%t; sq-=nq;</span><br><span class="line">		<span class="keyword">return</span> ans*<span class="built_in">inv</span>(sum,t)%t*<span class="built_in">Pow</span>(p,sq,t)%t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,mod,q,c[<span class="number">100</span>],mo[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod; q=mod;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=q;i++)</span><br><span class="line">		<span class="keyword">if</span>(q%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(t=<span class="number">0</span>;q%i==<span class="number">0</span>;q/=i) t++;</span><br><span class="line">			++top;</span><br><span class="line">			c[top]=ExLucas::<span class="built_in">C</span>(n,m,i,t);</span><br><span class="line">			mo[top]=ExLucas::t;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(q!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++top;</span><br><span class="line">		c[top]=ExLucas::<span class="built_in">C</span>(n,m,q,<span class="number">1</span>);</span><br><span class="line">		mo[top]=ExLucas::t;</span><br><span class="line">	&#125;</span><br><span class="line">	pair&lt;ll,ll&gt; ans=<span class="built_in">excrt</span>(top,c,mo);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans.fi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>组合数学</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2020多校3</title>
    <url>/2020/07/28/hdu2020%E5%A4%9A%E6%A0%A13/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=881">比赛链接</a></p>
<span id="more"></span>

<h3 id="A-Tokitsukaze-CSL-and-Palindrome-Game"><a href="#A-Tokitsukaze-CSL-and-Palindrome-Game" class="headerlink" title="A. Tokitsukaze,CSL and Palindrome Game"></a>A. Tokitsukaze,CSL and Palindrome Game</h3><a href="/2020/07/29/Tokitsukaze-CSL-and-Palindrome-Game-hdu6791/" title="链接">链接</a>

<h3 id="F-X-Number"><a href="#F-X-Number" class="headerlink" title="F. X Number"></a>F. X Number</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>将一个十进制数进行这样分类：</p>
<ul>
<li><p>统计每个数码的出现次数。</p>
</li>
<li><p>如果出现次数有两个或以上的最大值，则分类为 $10$。</p>
</li>
<li><p>否则，若数码 $d$ 的出现次数最多，则分类为 $d$。</p>
</li>
</ul>
<p>多次询问，求 $[l,r]$ 内的数有多少个分类为 $d$。</p>
<p>$T\le 1000,d\in[0,9],1\le l \le r \le 10^{18}$，时限 $3s$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="比赛时做法"><a href="#比赛时做法" class="headerlink" title="比赛时做法"></a>比赛时做法</h5><p>一道非常显然的数位DP题。</p>
<p>在数位DP打破限制之后，相当于有 $10$ 个变量，此时为 $a_i$。最终为 $a’_i$，要求 $a’_d&gt;a’_i(i\not=d)$。</p>
<p>此时可以在 $a$ 的基础上进行若干次将 $a_i+1$ 的操作，设这个次数为 $k$。</p>
<p>那么枚举 $a_d$ 加了 $j$ 次，然后算出将其他 $a_i$  加 $k’=k-j$ 次后满足的条件的方案数，乘上系数 $\binom{k}{j}$ 即可。</p>
<p>这是对于所有的 $i\not =d$，你可以算出一个次数 $t_i$，表示第 $i$ 个数码最多只能加这么多次。</p>
<p>那么这个方案数就是 $k’![x^{k’}]\prod <em>{d\not=i}(\sum</em>{j=0}^{t_i}\frac{x^j}{j!})$</p>
<p>暴力卷积，时间复杂度 $O(18^2\times 9)$。</p>
<p>时间复杂度 $O(18^4\times 9\times 10 \times T)$，有若干小常数。</p>
<p>跑了大概3s+秒，然后神奇地将卷积数组改成了long double就跑得飞快。</p>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>显然，18的拆分数是很小的，于是我们可以预处理最后的DP，这样就是正解了。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line">ll c[<span class="number">20</span>][<span class="number">20</span>],fac[<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> db f[<span class="number">20</span>],g[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">19</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">			c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">18</span>) fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st[<span class="number">20</span>],top,s[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">18</span>) f[i]=<span class="number">0</span>;</span><br><span class="line">	f[<span class="number">0</span>]=fac[k];</span><br><span class="line">	<span class="built_in">fd</span>(j,<span class="number">9</span>,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(j^d)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(x,<span class="number">0</span>,k)</span><br><span class="line">				<span class="built_in">fo</span>(y,<span class="number">0</span>,<span class="built_in">min</span>(k-x,v-s[j]<span class="number">-1</span>))</span><br><span class="line">					g[x+y]+=f[x]/fac[y];</span><br><span class="line">			<span class="built_in">fo</span>(x,<span class="number">0</span>,k) f[x]=g[x],g[x]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> (ll)(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">9</span>) <span class="keyword">if</span>(i^d) mx=<span class="built_in">max</span>(mx,s[i]);</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,k)</span><br><span class="line">		<span class="keyword">if</span>(s[d]+j&gt;mx)</span><br><span class="line">			ans+=c[k][j]*<span class="built_in">calc</span>(k-j,s[d]+j);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">9</span>) <span class="keyword">if</span>(i^d) mx=<span class="built_in">max</span>(mx,s[i]);</span><br><span class="line">	<span class="keyword">return</span> s[d]&gt;mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">bool</span> limit,<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!limit&amp;&amp;flag) <span class="keyword">return</span> <span class="built_in">work</span>(top-k+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(k&gt;top) <span class="keyword">return</span> <span class="built_in">check</span>();</span><br><span class="line">	<span class="type">int</span> mx=limit?st[k]<span class="number">-1</span>:<span class="number">9</span>;</span><br><span class="line">	<span class="type">bool</span> nex;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,mx) </span><br><span class="line">	&#123;</span><br><span class="line">		nex=flag|(i!=<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(nex) s[i]++;</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(k+<span class="number">1</span>,<span class="number">0</span>,nex);</span><br><span class="line">		<span class="keyword">if</span>(nex) s[i]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(limit)</span><br><span class="line">	&#123;</span><br><span class="line">		s[st[k]]++;</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(k+<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		s[st[k]]--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">9</span>) st[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(top=<span class="number">0</span>;r;st[++top]=r%<span class="number">10</span>,r/=<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">reverse</span>(st+<span class="number">1</span>,st+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="built_in">read</span>(); r=<span class="built_in">read</span>(); d=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2020多校2</title>
    <url>/2020/07/24/hdu2020%E5%A4%9A%E6%A0%A12/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=880">比赛链接</a></p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2020+Multi-University+Training+Contest+2&source=1&searchmode=source">题目链接</a></p>
<span id="more"></span>

<h3 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h3><p>做的时候越来越困，导致一堆那种还算简单的题最后想不到了。</p>
<p>其实也不只是困的原因，更重要的还是当遇到困难的时候真的应该安静下来努力克服，或者重新开会理一遍思路，这样就会快点想到，以免浪费太多没有意义的时间。</p>
<p>比如下面的一道裸费用流题，自己想来想去，先是想了想随机，然后再想DP，这是就应该静下心来，思考自己的方案是不是对的。看到匹配问题的时候就应该一开始就想到网络流类的问题才行。</p>
<h3 id="A-Total-Eclipse"><a href="#A-Total-Eclipse" class="headerlink" title="A. Total Eclipse"></a>A. Total Eclipse</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给你一个无向图，上面每个点有权值 $b_i$。进行若干次操作，每次选择一个连通块，然后将连通块内的 $b_i$ 减去 $1$。问至少多少次操作，使得 $b_i$ 全变为 $0$。</p>
<p>$n\le 10^5,m\le 2\times 10^5$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>这是第一道做出来的题。</p>
<p>显然贪心，每次选择一个极大连通块内 $b_i$ 最小的点，然后将这个连通块的所有点权都减去 $b_i$，然后删掉 $i$ 这个点。</p>
<p>但是我们无法维护删掉后的连通性。</p>
<p>考虑倒着做，那么就只需要维护加点之后的连通性就可以了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">bool</span> bo[N],vis[N];</span><br><span class="line"><span class="type">int</span> a[N],id[N],fa[N],mi[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span>;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	mi[x]=<span class="built_in">min</span>(mi[x],mi[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),id[i]=i,fa[i]=i,mi[i]=a[i],vis[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">		<span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> a[x]&gt;a[y];&#125;);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=id[i]; vis[u]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">			<span class="keyword">if</span>(vis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> w=<span class="built_in">find</span>(v);</span><br><span class="line">				<span class="keyword">if</span>(!bo[w])</span><br><span class="line">				&#123;</span><br><span class="line">					bo[w]=<span class="number">1</span>;</span><br><span class="line">					ans+=mi[w]-a[u];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(vis[v]) bo[<span class="built_in">find</span>(v)]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(vis[v]) <span class="built_in">merge</span>(<span class="built_in">find</span>(v),u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(<span class="built_in">find</span>(i)==i) ans+=mi[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-New-Equipments"><a href="#E-New-Equipments" class="headerlink" title="E. New Equipments"></a>E. New Equipments</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>$n$ 个工人，$m$ 件设备编号 $[1,m]$。第 $i$ 个人选第 $j$ 个设备花费 $a_ij^2+b_ij+c_i$ ，对于每个 $k\in[1,n]$，求在 $n$ 个人里选 $k$ 个和设备配对的最小花费是多少。每个设备最多只能被匹配一个工人。</p>
<p>$T\le 10,n\leq 50,n\le m\le 10^8,b_i^2\geq 4a_ic_i,1\le a_i\le 10,|b_i|\le 10^8,0\le c_i\leq 10^{16}$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>因为 $a_i&gt;0$，所有的二次函数有最下值。因此对于一个工人而言，他肯定会贪心的选择 $-\frac{b_i}{2a_i}$ 附近的设备。</p>
<p>这个附近的设备可以表示成一个长度为 $n$ 的区间。</p>
<p>那么能被选到的设备就最多只有 $n^2$ 个。</p>
<p>那么把工人看成一个点，放在左边；有可能被选上的设备放在右边。</p>
<p>随着 $k$ 递增，每次将费用加 $1$ 就好了。</p>
<p>而费用流的时间复杂度是流量乘上最短路的复杂度。</p>
<p>spfa费用流复杂度为 $O(n^5)$，dijkstra优化的费用流复杂度为 $O(n^4+n^3\log n)=O(n^4)$。常数都较小。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><p>dijkstra优化版本。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> G&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> N 3000</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line">	<span class="type">const</span> ll inf=<span class="number">4e18</span>;</span><br><span class="line">	<span class="type">int</span> s,t,ss;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M];</span><br><span class="line">	ll cost[M];</span><br><span class="line">	<span class="type">int</span> ne[M],head[N],tot;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,ll c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; cost[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; cost[tot]=-c;ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	ll h[N],dis[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,t) head[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++) h[i]=inf;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(h[s]=<span class="number">0</span>,q.<span class="built_in">push</span>(s);!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;h[v=ver[i]]&gt;h[u]+cost[i])</span><br><span class="line">				&#123;</span><br><span class="line">					h[v]=h[u]+cost[i];</span><br><span class="line">					<span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			vis[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> u; ll dis;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)&#123;<span class="keyword">return</span> A.dis&gt;B.dis;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> pv[N],pe[N];</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">		ll co=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++) dis[i]=inf;</span><br><span class="line">			<span class="keyword">for</span>(dis[s]=<span class="number">0</span>,q.<span class="built_in">push</span>((node)&#123;s,dis[s]&#125;);!q.<span class="built_in">empty</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				node now=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">int</span> u=now.u;</span><br><span class="line">				<span class="keyword">if</span>(dis[u]&lt;now.dis) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					v=ver[i];</span><br><span class="line">					<span class="keyword">if</span>(dis[v]+h[v]&gt;dis[u]+h[u]+cost[i])</span><br><span class="line">						dis[v]=dis[u]+h[u]+cost[i]-h[v],</span><br><span class="line">						q.<span class="built_in">push</span>((node)&#123;v,dis[v]&#125;),</span><br><span class="line">						pv[v]=u,pe[v]=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dis[t]==inf) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t;i++) h[i]+=dis[i];</span><br><span class="line">			<span class="type">int</span> tmp=<span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=pv[u]) tmp=<span class="built_in">min</span>(tmp,val[pe[u]]);</span><br><span class="line">			flow+=tmp; co+=h[t]*tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t,i;u!=s;u=pv[u]) i=pe[u],val[i]-=tmp,val[i^<span class="number">1</span>]+=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> co;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(s,ss,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> k=tot<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">spfa</span>(s,t);</span><br><span class="line">		ll sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(((i==n)?<span class="string">&quot;%lld\n&quot;</span>:<span class="string">&quot;%lld &quot;</span>),sum+=<span class="built_in">work</span>());</span><br><span class="line">			val[k]++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> N</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">53</span>;</span><br><span class="line"><span class="type">int</span> n,m,L[N],R[N];</span><br><span class="line">ll a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">F</span><span class="params">(ll x,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*(x*a[j]+b[j])+c[j];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i]=<span class="built_in">read</span>(),b[i]=<span class="built_in">read</span>(),c[i]=<span class="built_in">read</span>();</span><br><span class="line">			ll x=-b[i]/(<span class="number">2ll</span>*a[i]);</span><br><span class="line">			<span class="keyword">if</span>(x&lt;=<span class="number">0</span>) L[i]=<span class="number">1</span>,R[i]=n;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(x&gt;=<span class="number">27</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(x+<span class="number">26</span>&lt;=m) L[i]=x<span class="number">-26</span>,R[i]=x+<span class="number">26</span>;</span><br><span class="line">					<span class="keyword">else</span> L[i]=<span class="built_in">max</span>(<span class="number">1</span>,m-n),R[i]=m;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> L[i]=<span class="number">1</span>,R[i]=n;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,L[i],R[i]) vec.<span class="built_in">pb</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">		vec.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vec))-vec.<span class="built_in">begin</span>());</span><br><span class="line">		G::<span class="built_in">init</span>();</span><br><span class="line">		G::s=<span class="number">0</span>; G::ss=<span class="number">1</span>; G::t=vec.<span class="built_in">size</span>()+n+<span class="number">3</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">fo</span>(j,L[i],R[i])</span><br><span class="line">				G::<span class="built_in">add</span>(i+<span class="number">1</span>,<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(vec),j)-vec.<span class="built_in">begin</span>()+n+<span class="number">2</span>,<span class="number">1</span>,<span class="built_in">F</span>(j,i));</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) G::<span class="built_in">add</span>(G::ss,i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,vec.<span class="built_in">size</span>()) G::<span class="built_in">add</span>(j+n+<span class="number">2</span>,G::t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		G::<span class="built_in">solve</span>(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="F-The-Oculus"><a href="#F-The-Oculus" class="headerlink" title="F. The Oculus"></a>F. The Oculus</h3><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>暴力哈希即可，我这里写了双哈希。</p>
<h4 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod1=<span class="number">998244853</span>;</span><br><span class="line"><span class="type">const</span> ll mod2=<span class="number">2147483647</span>;</span><br><span class="line">ll F[<span class="number">2000005</span>],G[<span class="number">2000005</span>];</span><br><span class="line">map&lt;pair&lt;ll,ll&gt;,<span class="type">int</span>&gt; ma;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F[<span class="number">1</span>]=<span class="number">1</span>; F[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">3</span>,<span class="number">2000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">		F[i]&gt;=mod1?F[i]-=mod1:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	G[<span class="number">1</span>]=<span class="number">1</span>; G[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">3</span>,<span class="number">2000000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		G[i]=G[i<span class="number">-1</span>]+G[i<span class="number">-2</span>];</span><br><span class="line">		G[i]&gt;=mod2?G[i]-=mod2:<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">2000000</span>) ma[<span class="built_in">mp</span>(F[i],G[i])]=i;</span><br><span class="line">	ll n1,n2,m1,m2,k1,k2;</span><br><span class="line">	<span class="type">int</span> n,m,k;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); n1=n2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">read</span>()) (n1=(n1+F[i])%mod1,n2=(n2+G[i])%mod2);</span><br><span class="line">		&#125;</span><br><span class="line">		m=<span class="built_in">read</span>(); m1=m2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">read</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			m1=(m1+F[i])%mod1,m2=(m2+G[i])%mod2;</span><br><span class="line">		&#125;</span><br><span class="line">		k=<span class="built_in">read</span>(); k1=k2=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">read</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			k1=(k1+F[i])%mod1,k2=(k2+G[i])%mod2;</span><br><span class="line">		&#125;</span><br><span class="line">		n1=(n1*m1-k1+mod1)%mod1; n2=(n2*m2-k2+mod2)%mod2;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ma[<span class="built_in">mp</span>(n1,n2)]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-In-Search-of-Gold"><a href="#G-In-Search-of-Gold" class="headerlink" title="G. In Search of Gold"></a>G. In Search of Gold</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>一棵树，边有两种权值 $a_i,b_i$。有 $k$ 条边可以选择 $a_i$，剩下的 $n-1-k$ 可以选择 $b_i$。问这个树的直径的最小值。</p>
<p>$n\leq 20000,k\le 20,\sum n\le 2\times 10^5$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p><strong>刚开始做的时候想到直接DP，结果发现是不太行的。</strong></p>
<p>要使得两点距离的最大值最小，可以二分答案 $mid$。</p>
<p>那么就只需判断所有可能的情况中，是否存在一种方案使得任意两点的距离 $\le mid$。</p>
<p>这样子就可以DP了，设 $f_{i,j}$ 表示以 $i$ 为根的子树中，满足直径 $\le mid$，用了 $j$ 个 $a$ 时，子树内的点离点 $i$ 最大的距离的最小值。</p>
<p>然后 $O(nk^2)$ 转移即可。</p>
<h4 id="程序-3"><a href="#程序-3" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40010</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">4e18</span>;</span><br><span class="line"><span class="type">int</span> ver[N],a[N],b[N],ne[N],head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> _a,<span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; a[tot]=_a; b[tot]=_b; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; a[tot]=_a; b[tot]=_b; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N&gt;&gt;<span class="number">1</span>][<span class="number">22</span>],g[<span class="number">22</span>],mid;</span><br><span class="line"><span class="type">int</span> n,k,siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">0</span>; f[u][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	ll tmp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			<span class="type">int</span> l=<span class="built_in">min</span>(siz[u],k),mi=<span class="built_in">min</span>(k,siz[u]+siz[v])+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,mi) g[j]=inf;</span><br><span class="line">			<span class="built_in">fo</span>(x,<span class="number">0</span>,l)</span><br><span class="line">				<span class="built_in">fo</span>(y,<span class="number">0</span>,<span class="built_in">min</span>(k-x,siz[v]))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(f[u][x]+f[v][y]+a[i]&lt;=mid) g[x+y+<span class="number">1</span>]=<span class="built_in">min</span>(g[x+y+<span class="number">1</span>],<span class="built_in">max</span>(f[u][x],f[v][y]+a[i]));</span><br><span class="line">					<span class="keyword">if</span>(f[u][x]+f[v][y]+b[i]&lt;=mid) g[x+y]=<span class="built_in">min</span>(g[x+y],<span class="built_in">max</span>(f[u][x],f[v][y]+b[i]));</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,mi) f[u][j]=g[j];</span><br><span class="line">			siz[u]+=siz[v]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); tot=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) head[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> x,y,_a,_b;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),_a=<span class="built_in">read</span>(),_b=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">add</span>(x,y,_a,_b);</span><br><span class="line">		&#125;</span><br><span class="line">		ll l=<span class="number">0</span>,r=<span class="number">1000000000ll</span>*n;</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(f[<span class="number">1</span>][k]&lt;=mid) r=mid<span class="number">-1</span>; <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,r+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="I-It’s-All-Squares"><a href="#I-It’s-All-Squares" class="headerlink" title="I. It’s All Squares"></a>I. It’s All Squares</h3><h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>显然地，我们只需考虑平行于坐标轴的矩形内的点，这个矩形最小且完全包住询问的多边形。</p>
<p>那么如何判断某个点是否在一个多边形里面呢？</p>
<p>根据计算几何那套理论，从该点向任意方向引出一条射线，该射线与多边形经过奇数次则在简单多边形内。</p>
<p>对于一个询问，字符串长度为 $4k$，则最多会包住 $k^2$ 个点。</p>
<p>$n,m$ 同阶，那么算一下发现，所有的询问最多包住 $\frac{\sum |S| n}{4}$ 个点，这是可以承受的。</p>
<p>于是暴力就好了。</p>
<h4 id="程序-4"><a href="#程序-4" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">403</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">char</span> s[<span class="number">200005</span>];</span><br><span class="line"><span class="type">bool</span> ans[N][N];</span><br><span class="line"><span class="type">int</span> flag[N*N];</span><br><span class="line"><span class="type">int</span> n,m,q,len,tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m) a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> L,R,U,D,x,y,sum;q;q--)</span><br><span class="line">		&#123;</span><br><span class="line">			tot++;</span><br><span class="line">			L=<span class="number">401</span>,R=<span class="number">0</span>,U=<span class="number">0</span>,D=<span class="number">401</span>,sum=<span class="number">0</span>;</span><br><span class="line">			x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">			len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,len)</span><br><span class="line">			&#123;</span><br><span class="line">				L=<span class="built_in">min</span>(L,x); R=<span class="built_in">max</span>(R,x);</span><br><span class="line">				D=<span class="built_in">min</span>(D,y); U=<span class="built_in">max</span>(U,y);</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) x--;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) x++;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) y--;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) y++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,L,R+<span class="number">1</span>) <span class="built_in">fo</span>(j,D,U+<span class="number">1</span>) ans[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,len)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>) ans[x][y+<span class="number">1</span>]^=<span class="number">1</span>,x--;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>) x++,ans[x][y+<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>) y--;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==<span class="string">&#x27;U&#x27;</span>) y++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(i,L+<span class="number">1</span>,R)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">bool</span> bo=<span class="number">0</span>;</span><br><span class="line">				<span class="built_in">fo</span>(j,D+<span class="number">1</span>,U)</span><br><span class="line">				&#123;</span><br><span class="line">					bo^=ans[i][j];</span><br><span class="line">					<span class="keyword">if</span>(bo)</span><br><span class="line">						<span class="keyword">if</span>(flag[a[i][j]]!=tot) sum++,flag[a[i][j]]=tot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="J-Lead-of-Wisdom"><a href="#J-Lead-of-Wisdom" class="headerlink" title="J. Lead of Wisdom"></a>J. Lead of Wisdom</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>有 $n$ 个东西，每个东西有种类 $t_i$，以及数字 $a_i,b_i,c_i,d_i$。</p>
<p>现在要你选出一个集合 $S$，要求这个集合里有每个种类最多有一个，满足以下式子最大： </p>
<p>$\large (100+\sum_{i\in S}a_i)(100+\sum_{i\in S}b_i)(100+\sum_{i\in S}c_i)(100+\sum_{i\in S}d_i)$ </p>
<p>$T\leq 10,n\leq 50,0\le a_i,b_i,c_i,d_i \le 100$</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><h5 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h5><p>这个东西DP复杂度太高，贪心也不对。</p>
<p>那么就来随机算法吧。</p>
<p>毫无思路，简单粗暴。</p>
<p>我这里写的是爬山。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll a[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line">ll now[<span class="number">4</span>];</span><br><span class="line">vector&lt;node&gt; q[<span class="number">55</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="type">int</span> p[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec)</span><br><span class="line">		p[v]=<span class="built_in">rand</span>()%q[v].<span class="built_in">size</span>();</span><br><span class="line">	ll s[<span class="number">4</span>],ans,cur,ss[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) s[i]=now[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec) <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) s[i]+=q[v][p[v]].a[i];</span><br><span class="line">	ans=s[<span class="number">0</span>]*s[<span class="number">1</span>]*s[<span class="number">2</span>]*s[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> tot=vec.<span class="built_in">size</span>(),j,w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,t=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++,t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;=<span class="number">40</span>) <span class="keyword">break</span>;</span><br><span class="line">		j=vec[<span class="built_in">rand</span>()%tot];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) ss[i]=s[i]-q[j][p[j]].a[i];</span><br><span class="line">		w=<span class="built_in">rand</span>()%q[j].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) ss[i]+=q[j][w].a[i];</span><br><span class="line">		cur=ss[<span class="number">0</span>]*ss[<span class="number">1</span>]*ss[<span class="number">2</span>]*ss[<span class="number">3</span>];</span><br><span class="line">		<span class="keyword">if</span>(cur&gt;ans)</span><br><span class="line">		&#123;</span><br><span class="line">			t=<span class="number">0</span>; </span><br><span class="line">			ans=cur;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) s[i]=ss[i];</span><br><span class="line">			p[j]=w;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,t,a,b,c,d;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) q[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			t=<span class="built_in">read</span>(); a=<span class="built_in">read</span>(); b=<span class="built_in">read</span>(); c=<span class="built_in">read</span>(); d=<span class="built_in">read</span>();</span><br><span class="line">			q[t].<span class="built_in">pb</span>((node)&#123;a,b,c,d&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) now[i]=<span class="number">100</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">		<span class="keyword">if</span>(q[i].<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">3</span>) now[j]+=q[i][<span class="number">0</span>].a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) vec.<span class="built_in">pb</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		ll ans=now[<span class="number">0</span>]*now[<span class="number">1</span>]*now[<span class="number">2</span>]*now[<span class="number">3</span>];</span><br><span class="line">		<span class="built_in">fo</span>(t,<span class="number">1</span>,<span class="number">200</span>) ans=<span class="built_in">max</span>(ans,<span class="built_in">solve</span>());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h5><p>考虑直接暴力，时间复杂度 $O(k^{\frac{n}{k}})$。</p>
<p>我们来分析复杂度，设 $f(x)=x^{\frac{n}{x}} (x &gt; 0)$，我们需要求它的最大值。</p>
<p>对 $f(x)$ 求导，先取 $\ln$ 再 $\exp$ 就容易算了。</p>
<p>解得：$f’(x)=n(1-\ln x)x^2x^{\frac{n}{x}}$ 。</p>
<p>当 $f’(x)=0$ 时，有 $1-\ln x=0$，即 $x=e$。</p>
<p>当 $0&lt;x&lt;e$ 时，$f’(x)&gt;0$，函数单调增。</p>
<p>当 $x&gt;e$ 时，$f’(x)&lt;0$，函数单调减。</p>
<p>也就是说，当 $k$ 取正整数时，$k=2,3$ 时复杂度是最大的，算一下发现这两个都能过。</p>
<p>于是暴力就好了。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>哈希</tag>
        <tag>树形DP</tag>
        <tag>并查集</tag>
        <tag>爬山算法</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Index[hdu6761]</title>
    <url>/2020/07/22/Minimum-Index-hdu6761/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6761">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于给定字符串的每个前缀，求出这个前缀的所有的后缀中字典序最小的编号。</p>
<p>$|s|\leq 10^6,\sum|s|\leq 2\times 10^7$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一看这种题就知道要线性，而SAM和SA之类的都太慢了。</p>
<p>原来是有新的知识没学。。</p>
<p>设 $ans_i$ 表示前缀 $[1,i]$ 的答案。</p>
<p>考虑<a href="/2020/07/22/Lyndon%E5%88%86%E8%A7%A3/" title="Lyndon分解">Lyndon分解</a>的过程。</p>
<p>分若干种情况讨论。</p>
<p>当 $i=j$ 时，表明当前 $[i,k)$ 是一个Lyndon串，那么此时 $ans_{k-1}=i$。</p>
<p>否则 $i\not=j$，这时有：$ans_{k-1}=ans_{j-1}+(k-j)$，因为不会有比这一个周期内更优的答案。</p>
<p>然后就做完了。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line">ll pw[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n,p[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Lyndon</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k;i&lt;=n;)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i]=i;</span><br><span class="line">		<span class="keyword">for</span>(j=i,k=i+<span class="number">1</span>;k&lt;=n&amp;&amp;s[j]&lt;=s[k];k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j) p[k<span class="number">-1</span>]=i;</span><br><span class="line">			<span class="keyword">else</span> p[j<span class="number">-1</span>]+(k-j);</span><br><span class="line">			j=(s[j]==s[k])?j+<span class="number">1</span>:i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;=j;i+=k-j);</span><br><span class="line">		p[i<span class="number">-1</span>]=i-(k-j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">1000000</span>) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">1112</span>%mod;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Lyndon</span>(s,n);</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">Add</span>(ans,pw[i<span class="number">-1</span>]*p[i]%mod);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>Lyndon分解</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyndon分解</title>
    <url>/2020/07/22/Lyndon%E5%88%86%E8%A7%A3/</url>
    <content><![CDATA[<p>一个似乎比较偏门的知识？</p>
<span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>Lyndon串：若某字符串中所有后缀字典序最小的是这个字符串本身，则这个串为 Lyndon串。</li>
<li>近似Lyndon串：设 $t$ 是一个Lyndon串，$t^c$ 为 $t$ 拼接 $c$ 次，$t’$ 为 $t$ 串可空前缀，那么 $t^c+t’$ 为近似Lyndon串。</li>
<li>Lyndon分解：将一个字符串 $S$ 分解成一个字符串序列 $s_1,s_2\cdots s_m$，其中 $s_i$ 是Lyndon串，$s=s_1+s_2+\cdots+s_m$（+号表示拼接），且 $\forall i\in[1,m),s_i\geq s_{i+1}$。</li>
</ul>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ul>
<li>若 $s,t$ 为Lyndon串，且 $s&lt;t$ ，则 $st$ 为Lyndon串。</li>
<li>对于一个字符串，Lyndon分解唯一。</li>
</ul>
<p>第一个定理显然，第二个可以用反证法。</p>
<h3 id="Duval-算法"><a href="#Duval-算法" class="headerlink" title="Duval 算法"></a>Duval 算法</h3><p>考虑依次增加一个数。</p>
<p>维护三个指针 $i,j,k$。</p>
<p>表示 $[1,i)$ 的字母都已经在Lyndon分解里面了，现在在考虑 $i$ 及其后面的字母；$[i,k)$ 可以表示为 $t^c+t’$ 的形式（即近似Lyndon串）；$j=k-|t|$，即 $k$ 一个周期前的字母。</p>
<p>考虑第 $k$ 个字母。</p>
<p>分三种情况讨论：</p>
<ul>
<li>$s_j=s_k$，那么可以继续接上去，$j,k$ 右移一位。</li>
<li>$s_j&lt;s_k$，那么 $[i,k]=t^c+t’+s_k$ 就是一个新的Lyndon串，此时将 $j$ 设为 $i$，然后 $k$ 右移一位，考虑下一个 $k$。</li>
<li>$s_j&gt;s_k$，那么只能 $c$ 个 $t$ 串作为新的Lyndon串，然后将 $i$ 设为 $t’$ 的开头，重新开始考虑，即 $j=i,k=i+1$。</li>
</ul>
<p>时间复杂度 $O(n)$。</p>
<p>程序实现：</p>
<p><a href="https://www.luogu.com.cn/problem/P6114">luogu模板题链接</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k;i&lt;=n;)</span><br><span class="line">	&#123;</span><br><span class="line">		j=i; k=i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;k&lt;=n&amp;&amp;s[j]&lt;=s[k];j=(s[j]==s[k++])?j+<span class="number">1</span>:i);</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;=j;i+=k-j,ans^=(i<span class="number">-1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小表示法"><a href="#最小表示法" class="headerlink" title="最小表示法"></a>最小表示法</h3><p>一个字符串的最小表示为所有循环同构的串中，字典序最小的那个。</p>
<p>可以用Lyndon分解求出。将 $s+s$ 进行Lyndon分解。然后找到分解后Lyndon串首字母位置 $\le n$ 的最大的位置。从那个位置开始的就是最小表示。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Lyndon分解</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2020多校1</title>
    <url>/2020/07/21/hdu2020%E5%A4%9A%E6%A0%A11/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=879">比赛链接</a></p>
<p><a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2020+Multi-University+Training+Contest+1&source=1&searchmode=source">题目链接</a></p>
<span id="more"></span>

<p>没有队友，被爆踩了。最终因罚时排到了61名。</p>
<p>还是不能一次写对啊qwq。</p>
<h3 id="D-Distinct-Sub-palindromes"><a href="#D-Distinct-Sub-palindromes" class="headerlink" title="D. Distinct Sub-palindromes"></a>D. Distinct Sub-palindromes</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>问有多少个长度为 $n$ 的，由小写字母组成的字符串，使得本质不同的回文串个数最少。</p>
<p>输出个数对 $998244353$ 取模的结果。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p><del>取模就是废的。</del></p>
<p><del>与本质不同的回文串个数相对应的是回文树上的节点个数减2。</del></p>
<p><del>打表得出前几个，26,676,17576,15600,15600,15600…</del></p>
<p><del>因此，时间复杂度 $O(1)$。</del></p>
<p>实际上考虑到 $n\leq 3$ 时答案就是 $26^n$。</p>
<p>当 $n&gt;3$ 时，构造形如 $abcabca\cdots$ 这样的可以发现，本质不同的回文串只有 $3$ 个。</p>
<p>那么当出现字母的个数不为 $3$ 时也显然不可以的。</p>
<p>当出现字母为 $3$ 时不能出现形如 $aba$ 或者 $aa$ 这样的子串。</p>
<p>那么就只剩下构造出来的那种情况了。</p>
<p>此时答案就是 $26\times 25\times 24$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>我想到了一个绝妙的写法，这里地方太小，写不下。</p>
<h3 id="E-Fibonacci-Sum"><a href="#E-Fibonacci-Sum" class="headerlink" title="E. Fibonacci Sum"></a>E. Fibonacci Sum</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给定 $n,c,k$，求 $\sum_{i=0}^n(F_{ic})^k$，其中 $F_i$ 为斐波那契数列第 $i$ 项。</p>
<p>对 $10^9+9$ 取模。</p>
<p>$T\leq 200,N,C\leq 10^{18},k\leq 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>设 $a=\frac{\sqrt{5}+1}{2},b=\frac{1-\sqrt{5}}{2}$。</p>
<p>那么有：</p>
<p>$\sum_{i=0}^n(F_{ic})^k$</p>
<p>$=\sum_{i=0}^n(\frac{a^{ic}-b^{ic}}{\sqrt{5}})^k$</p>
<p>$=(\frac{1}{\sqrt{5}})^k\sum_{i=0}^n(a^{ic}-b^{ic})^k$</p>
<p>$=(\frac{1}{\sqrt{5}})^k\sum_{i=0}^n\sum_{j=0}^k\binom{k}{j}(a^{ic})^j(-b^{ic})^{k-j}$</p>
<p>$=(\frac{1}{\sqrt{5}})^k\sum_{j=0}^k\binom{k}{j}(-1)^{k-j}\sum_{i=0}^n(a^{cj}b^{c(k-j)})^i$</p>
<p>然后等比数列求和。</p>
<p><strong>当时式子推错了一个地方调了好久好久，推式子时草稿一定要写好。</strong></p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>); <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll x=<span class="built_in">Pow</span>(<span class="number">383008016</span>,mod<span class="number">-2</span>);</span><br><span class="line"><span class="type">const</span> ll a=<span class="number">691504013</span>;</span><br><span class="line"><span class="type">const</span> ll b=<span class="number">308495997</span>;</span><br><span class="line">ll n,c,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">100000</span>);</span><br><span class="line">	ll _a,_b;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;c&gt;&gt;k;</span><br><span class="line">		c%=(mod<span class="number">-1</span>);</span><br><span class="line">		ll ans=<span class="number">0</span>,tmp,sum;</span><br><span class="line">		_a=<span class="built_in">Pow</span>(a,c); _b=<span class="built_in">Pow</span>(b,c);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,k)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp=<span class="built_in">Pow</span>(_a,i)*<span class="built_in">Pow</span>(_b,k-i)%mod;</span><br><span class="line">			<span class="keyword">if</span>(tmp==<span class="number">1</span>) sum=(n+<span class="number">1</span>)%mod;</span><br><span class="line">			<span class="keyword">else</span> sum=(<span class="built_in">Pow</span>(tmp,n+<span class="number">1</span>)<span class="number">-1</span>+mod)%mod*<span class="built_in">Pow</span>(tmp<span class="number">-1</span>,mod<span class="number">-2</span>)%mod;</span><br><span class="line">			<span class="keyword">if</span>((k-i)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">				ans=<span class="built_in">Add</span>(ans,sum*<span class="built_in">C</span>(k,i)%mod);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ans=<span class="built_in">Dec</span>(ans,sum*<span class="built_in">C</span>(k,i)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*<span class="built_in">Pow</span>(x,k)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F-Finding-a-MEX"><a href="#F-Finding-a-MEX" class="headerlink" title="F. Finding a MEX"></a>F. Finding a MEX</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给一个无向图，每个点上有点权。支持两种操作，一是修改某个点的点权，二是查询到某个点距离为 $1$ 的所有点的点权的Mex。</p>
<p>$T\leq 10,n,m,q\leq 10^5,a_i\leq 10^9$。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>这种套路都出烂了吧…</p>
<p>首先 $a_i\leq 10^9$ 是吓人的，实际上只需要有 $a_i\leq 10^5$，因为大过 $10^5$ 的数求Mex时不会碰到。</p>
<p><strong>考试时就是因为忘记这里然后RE，导致调了十年。有时这些细节可以写在纸上或者程序旁。</strong></p>
<p>然后数据分治，对于度数小于等于 $K$ 的点，我们暴力枚举旁边的点。</p>
<p>对于度数大于 $K$ 的点，最多有 $\frac{2m}{K}$ 个，然后对这些点相连的点的权值搞成一个桶，用分块或数据结构维护之。</p>
<p>空间和时间都大概是根号的。</p>
<h4 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Siz=<span class="number">1000</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> deg[N],a[N],bel[N],cnt,siz[Siz+<span class="number">5</span>][Siz+<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n,m,Sqr;</span><br><span class="line"><span class="type">int</span> flag[Siz+<span class="number">5</span>][N];</span><br><span class="line"><span class="type">bool</span> bo[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	deg[x]++; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bl[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> y,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	flag[i][y]+=d;</span><br><span class="line">	siz[i][bl[y]]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i+=Siz,j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> num=<span class="built_in">min</span>(<span class="number">100000</span>-i+<span class="number">1</span>,Siz);</span><br><span class="line">		<span class="built_in">ff</span>(k,<span class="number">0</span>,num) bl[i+k]=j;</span><br><span class="line">	&#125;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); Sqr=<span class="built_in">sqrt</span>(<span class="number">2</span>*m)+<span class="number">10</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i]=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;=<span class="number">100000</span>) a[i]=<span class="number">100000</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">all</span>(adj[i]));</span><br><span class="line">			adj[i].<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(adj[i]))-adj[i].<span class="built_in">begin</span>());</span><br><span class="line">			<span class="keyword">if</span>(deg[i]&gt;=Sqr)</span><br><span class="line">			&#123;</span><br><span class="line">				++cnt; bel[i]=cnt;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[i]) <span class="built_in">add</span>(cnt,a[v],<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">all</span>(adj[i]),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> bel[x]&gt;bel[y];&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> q=<span class="built_in">read</span>(),u,x;q--;)</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">read</span>()==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				u=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">				<span class="keyword">if</span>(x&gt;=<span class="number">100000</span>) x=<span class="number">100000</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">					<span class="keyword">if</span>(deg[v]&gt;=Sqr)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">add</span>(bel[v],a[u],<span class="number">-1</span>);</span><br><span class="line">						<span class="built_in">add</span>(bel[v],x,<span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">				a[u]=x;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				u=<span class="built_in">read</span>(); <span class="type">int</span> ans;</span><br><span class="line">				<span class="keyword">if</span>(deg[u]&lt;Sqr)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) bo[a[v]]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(ans=<span class="number">0</span>;bo[ans];ans++);</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) bo[a[v]]=<span class="number">0</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">bool</span> boo=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;=<span class="number">100000</span>&amp;&amp;!boo;i+=Siz,j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> num=<span class="built_in">min</span>(Siz,<span class="number">100000</span>-i+<span class="number">1</span>);</span><br><span class="line">						<span class="keyword">if</span>(siz[bel[u]][j]==num) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="built_in">ff</span>(k,<span class="number">0</span>,num) <span class="keyword">if</span>(!flag[bel[u]][i+k])</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i+k); boo=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(deg[i]&gt;=Sqr)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[i]) <span class="built_in">add</span>(bel[i],a[v],<span class="number">-1</span>);</span><br><span class="line">			bel[i]=deg[i]=<span class="number">0</span>;</span><br><span class="line">			adj[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="I-Leading-Robots"><a href="#I-Leading-Robots" class="headerlink" title="I. Leading Robots"></a>I. Leading Robots</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一个数轴上 $n$ 个动点在往右走。</p>
<p>每个点初始位置为 $p_i$，加速度为 $a_i$，一开始速度为 $0$。问这样的点 $i$ 的个数：存在某个大于等于 $0$ 的实数时间 $t$，使得所有不是 $i$ 的点都严格在点 $i$ 左侧。</p>
<p>$n\leq 50000$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>对于时间 $t$ 和两个点 $i,j$，点 $i$ 在点 $j$ 右侧的条件是：$p_i+\frac{a_it^2}{2}&gt;p_j+\frac{a_jt^2}{2}$。</p>
<p>移项得：$p_i-p_j&gt;(a_j-a_i)\frac{t^2}{2}$</p>
<p>因为 $t\geq 0$，所以 $\frac{t^2}{2}\geq 0$。</p>
<p>分类讨论一下，假设 $a_i&gt;a_j$。</p>
<p>那么 $-\frac{p_i-p_j}{a_i-a_j}&lt;\frac{t^2}{2}$。</p>
<p>按照 $a$ 的大小排序，将 $a$ 看成横坐标，$p$ 看成纵坐标。变成找到 $i$ 之前的点和点 $i$ 形成的直线的斜率的最小值。</p>
<p>这个比较容易，建一个上凸包即可。</p>
<p>$a_i&lt;a_j$ 的情况同理。</p>
<p>那么对于 $\frac{t^2}{2}$ 找到了一个范围 $[L,R]$，满足 $L\le R,0\le R$ 即可。</p>
<p>注意判断相等的那些情况。</p>
<p>因为要排序，时间复杂度 $O(n\log n)$。</p>
<h4 id="程序-3"><a href="#程序-3" class="headerlink" title="程序"></a>程序</h4><p>考场代码，写得超级烂。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> db inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-15</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll p,a; <span class="type">bool</span> ok;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.a!=B.a) <span class="keyword">return</span> A.a&lt;B.a;</span><br><span class="line">		<span class="keyword">return</span> A.p&lt;B.p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.p&lt;B.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Cross</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (q[y].a-q[x].a)*(q[z].p-q[x].p)-(q[z].a-q[x].a)*(q[y].p-q[x].p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,top,st[N];</span><br><span class="line">db L[N],R[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) q[i].p=<span class="built_in">read</span>(),q[i].a=<span class="built_in">read</span>(),q[i].ok=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>,cmp);</span><br><span class="line">		ll mx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j)</span><br><span class="line">		&#123;</span><br><span class="line">			mx=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(j=i;j&lt;=n&amp;&amp;q[i].p==q[j].p;j++) mx=<span class="built_in">max</span>(mx,q[j].a);</span><br><span class="line">			<span class="built_in">fo</span>(k,i,j<span class="number">-1</span>) <span class="keyword">if</span>(q[k].a!=mx) q[k].ok=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i+<span class="number">1</span>].a==q[i].a&amp;&amp;q[i+<span class="number">1</span>].p&gt;=q[i].p) q[i].ok=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(q[i+<span class="number">1</span>].a==q[i].a&amp;&amp;q[i+<span class="number">1</span>].p==q[i].p) q[i+<span class="number">1</span>].ok=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		st[top=<span class="number">1</span>]=n; R[n]=inf;</span><br><span class="line">		<span class="built_in">fd</span>(i,n<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(q[i+<span class="number">1</span>].p!=q[i].p||q[i+<span class="number">1</span>].a!=q[i].a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(top&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">Cross</span>(st[top<span class="number">-1</span>],i,st[top])&gt;<span class="number">0</span>) top--;</span><br><span class="line">			<span class="keyword">if</span>(q[i].ok) R[i]=-(db)(q[st[top]].p-q[i].p)/(q[st[top]].a-q[i].a);</span><br><span class="line">			st[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		st[top=<span class="number">1</span>]=<span class="number">1</span>; L[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(q[i<span class="number">-1</span>].p!=q[i].p||q[i<span class="number">-1</span>].a!=q[i].a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(top&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">Cross</span>(st[top<span class="number">-1</span>],st[top],i)&gt;<span class="number">0</span>) top--;</span><br><span class="line">			<span class="keyword">if</span>(q[i].ok)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(q[st[top]].a==q[i].a) L[i]=<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> L[i]=-(db)(q[st[top]].p-q[i].p)/(q[st[top]].a-q[i].a);</span><br><span class="line">			&#125;</span><br><span class="line">			st[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(q[i].ok)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(L[i]&lt;R[i]&amp;&amp;R[i]&gt;<span class="number">1e-12</span>) q[i].ok=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> q[i].ok=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(q[i].ok) ans++;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="K-Minimum-Index"><a href="#K-Minimum-Index" class="headerlink" title="K. Minimum Index"></a>K. Minimum Index</h3><a href="/2020/07/22/Minimum-Index-hdu6761/" title="链接">链接</a>

<h3 id="L-Mow"><a href="#L-Mow" class="headerlink" title="L. Mow"></a>L. Mow</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给一个 $n$ 个点的简单多边形，上面长满了草。</p>
<p>你需要在上面割草，有两种方式。</p>
<p>一种是使用手割，每割 $1$ 单位的草花费 $a$ 元；令一种是使用机器割，每割到 $1$ 单位的草花费 $b$ 元。</p>
<p>机器是一个半径为 $r$ 的圆，使用机器时，机器任意一个部位不能在多边形外面。</p>
<p>求割完所有草的最小花费。</p>
<p>$T\leq 100,n\leq 200$。</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>分类讨论：若 $a\le b$，则显然直接用手割完即可。求出多边形面积，然后 $\times a$ 即可。下面只考虑 $a&gt;b$ 的情况。</p>
<p>显然，我们需要机器割得越多越好。</p>
<p>那么机器能割多少呢？</p>
<p><img src="/hdu2020%E5%A4%9A%E6%A0%A11/Polygon.png" alt="Polygon"></p>
<p>对于这个多边形而言，我们将多边形内部的边向里面移 $r$ 个单位，形成了一个新的多边形。设这个多边形的面积为 $s$，周长为 $c$，显然机器最多能割 $s+cr+\pi r^2$ 的面积。</p>
<p>现在只需要求出这个新多边形就好了。</p>
<p>首先我们将点逆时针排好。然后将 $n$ 条直线往里面移动。然后求移动完的直线的半平面交，即可求出新多边形。</p>
<p>需要注意这个新多边形可能是不存在的。</p>
<p>时间复杂度 $O(n)$。</p>
<h4 id="程序-4"><a href="#程序-4" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">angle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y,x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">dis</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.x-B.x)&lt;eps) <span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">		<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> *(<span class="type">const</span> P &amp;A,<span class="type">const</span> db &amp;k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x*k,A.y*k&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> -(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x-B.x,A.y-B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> +(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;B.x+A.x,B.y+A.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span> *(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> db <span class="keyword">operator</span> ^(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.x*B.x+A.y*B.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">L</span>&#123;</span><br><span class="line">	P x,y; db ang;</span><br><span class="line">	<span class="built_in">L</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">L</span>(P a,P b)</span><br><span class="line">	&#123;</span><br><span class="line">		x=a; y=b-a; ang=y.<span class="built_in">angle</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> db <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> y.<span class="built_in">dis</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">parallel</span><span class="params">(L A,L B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">fabs</span>(A.ang-B.ang)&lt;eps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">intersection</span><span class="params">(L A,L B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	P u=A.x-B.x;</span><br><span class="line">	<span class="keyword">return</span> A.x+A.y*((B.y*u)/(A.y*B.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Area</span><span class="params">(P *a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	db sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">3</span>,n) sum+=(a[i<span class="number">-1</span>]-a[<span class="number">1</span>])*(a[i]-a[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">OnLeft</span><span class="params">(L A,P p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.y*(p-A.x)&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">OnRight</span><span class="params">(L A,P p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (p-A.x)*A.y&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> L &amp;A,<span class="type">const</span> L &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.ang-B.ang)&lt;eps) <span class="built_in">OnLeft</span>(A,B.x);</span><br><span class="line">	<span class="keyword">return</span> A.ang&lt;B.ang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line">P a[N],qp[N],p[N];</span><br><span class="line">L ql[N];</span><br><span class="line">db r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">solve</span><span class="params">(L *l,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(l+<span class="number">1</span>,l+n+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;</span><br><span class="line">	ql[++R]=l[<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;L&lt;R&amp;&amp;<span class="built_in">OnRight</span>(l[i],qp[R<span class="number">-1</span>]);R--);</span><br><span class="line">		<span class="keyword">for</span>(;L&lt;R&amp;&amp;<span class="built_in">OnRight</span>(l[i],qp[L]);L++);</span><br><span class="line">		ql[++R]=l[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(ql[R].y*ql[R<span class="number">-1</span>].y)&lt;eps)</span><br><span class="line">		&#123;</span><br><span class="line">			R--;;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">OnLeft</span>(ql[R],l[i].x)) ql[R]=l[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;R) qp[R<span class="number">-1</span>]=<span class="built_in">intersection</span>(ql[R],ql[R<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;L&lt;R&amp;&amp;<span class="built_in">OnRight</span>(ql[L],qp[R<span class="number">-1</span>]);R--);</span><br><span class="line">	qp[R]=<span class="built_in">intersection</span>(ql[R],ql[L]);</span><br><span class="line">	db c=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,L,R) a[++m]=qp[i];</span><br><span class="line">	<span class="keyword">if</span>(m&lt;=<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	s=<span class="built_in">Area</span>(a,m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) c+=(a[i%m+<span class="number">1</span>]-a[i]).<span class="built_in">dis</span>();</span><br><span class="line">	<span class="keyword">return</span> c*r+pi*r*r+s;</span><br><span class="line">&#125;</span><br><span class="line">L l[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	db a,b;</span><br><span class="line">	db PolygonArea,MachineArea;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">		a=<span class="built_in">read</span>(); b=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>();</span><br><span class="line">		PolygonArea=<span class="built_in">Area</span>(p,n);</span><br><span class="line">		<span class="keyword">if</span>(PolygonArea&lt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			PolygonArea=-PolygonArea;</span><br><span class="line">			<span class="built_in">reverse</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//DEBUG(PolygonArea);</span></span><br><span class="line">		<span class="keyword">if</span>(a&lt;b)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>,PolygonArea*a);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			P d=p[i%n+<span class="number">1</span>]-p[i];</span><br><span class="line">			<span class="built_in">swap</span>(d.x,d.y);</span><br><span class="line">			d.x=-d.x;</span><br><span class="line">			d=d*(r/d.<span class="built_in">dis</span>());</span><br><span class="line">			l[i]=<span class="built_in">L</span>(p[i]+d,p[i%n+<span class="number">1</span>]+d);</span><br><span class="line">		&#125;</span><br><span class="line">		MachineArea=<span class="built_in">solve</span>(l,n);</span><br><span class="line">		<span class="comment">//DEBUG(MachineArea);</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.12lf\n&quot;</span>,<span class="built_in">min</span>(PolygonArea*a,(PolygonArea-MachineArea)*a+MachineArea*b));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>计算几何</tag>
        <tag>PAM</tag>
        <tag>分块</tag>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>仙人掌[loj6496]</title>
    <url>/2020/07/20/%E4%BB%99%E4%BA%BA%E6%8E%8C-loj6496/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/6496">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给出一张 $n$ 个点 $m$ 条边的无向连通图，其中每条边至多属于一个简单环，保证没有自环，可能有重边。你需要为其中每条边定向，其中第 $i$ 个点的出度不能超过 $a_i$，求方案数。</p>
<p>$n\leq 10^5,m\leq 2\times 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先来看看30分的树的部分分。</p>
<p>考虑DP，设 $f_{i,0/1}$ 表示以 $i$ 为根的子树，$i$ 与父亲的边指向/不指向 $i$ 时的方案数。</p>
<p>这个东西的转移是个卷积形式，用分治ntt进行优化即可。</p>
<p>时间复杂度 $O(n\log^2n)$。</p>
<p>考虑建出仙人掌的圆方树，然后在圆方树上DP。</p>
<p>当点是圆点时的转移与树的转移部分类似。</p>
<p>考虑方点时如何处理，也就是一个环上的情况：</p>
<p><img src="/%E4%BB%99%E4%BA%BA%E6%8E%8C-loj6496/%E6%96%B9%E7%82%B9.png" alt="方点"></p>
<p>对于 $v$ 点而言，他有可能在这个环里有两个出度。因此，$f$ 数组改成 $f_{i,0/1/2}$ 表示以 $i$ 根的子树中，其他边连出去的出度为 $0/1/2$ 时的方案数。</p>
<p>在 $u$ 这个方点时考虑这个环，枚举 $u$ 和 $x$ 的这个边的顺序，然后下面从 $x$ 到 $y$ 的边的情况可以DP。</p>
<p>具体的，设 $g_{i,0/1}$ 为考虑到第 $i$ 个点，$i$ 和 $i-1$ 这条边的顺序为 $0/1$ 时的方案数，这个东西很好转移。</p>
<p>然后就做完了。时间复杂度 $O(n\log ^2n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">ll W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N],gra[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> st[N],top,dfn[N],low[N],tim,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++tim; st[++top]=u;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:gra[u])</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(v,u);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>(low[v]==dfn[u])</span><br><span class="line">			&#123;</span><br><span class="line">				++cnt;</span><br><span class="line">				adj[u].<span class="built_in">pb</span>(cnt);</span><br><span class="line">				<span class="keyword">do</span></span><br><span class="line">				&#123;</span><br><span class="line">					adj[cnt].<span class="built_in">pb</span>(st[top]);</span><br><span class="line">				&#125;<span class="keyword">while</span> (st[top--]!=v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(low[v]&gt;dfn[u]) adj[u].<span class="built_in">pb</span>(v),top--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(v==pre&amp;&amp;!flag) &#123;flag=<span class="number">1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;Poly&gt; vec;</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> vec[l];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">solve</span>(l,mid)*<span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">Poly G;</span><br><span class="line">ll f[N][<span class="number">3</span>],g[N][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!adj[u].<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		f[u][<span class="number">0</span>]=(a[u]&gt;=<span class="number">0</span>);</span><br><span class="line">		f[u][<span class="number">1</span>]=(a[u]&gt;=<span class="number">1</span>);</span><br><span class="line">		f[u][<span class="number">2</span>]=(a[u]&gt;=<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">dfs</span>(v);</span><br><span class="line">	<span class="keyword">if</span>(u&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			G.<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">if</span>(v&gt;n) G.<span class="built_in">pb</span>(f[v][<span class="number">2</span>]);</span><br><span class="line">			G.<span class="built_in">pb</span>(f[v][<span class="number">1</span>]); G.<span class="built_in">pb</span>(f[v][<span class="number">0</span>]);</span><br><span class="line">			vec.<span class="built_in">pb</span>(G);</span><br><span class="line">		&#125;</span><br><span class="line">		G=<span class="built_in">solve</span>(<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">1</span>,<span class="built_in">min</span>((<span class="type">int</span>)G.<span class="built_in">size</span>(),a[u]+<span class="number">1</span>)) G[i]=(G[i]+G[i<span class="number">-1</span>])%mod;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">if</span>(a[u]&gt;=i) f[u][i]=G[<span class="built_in">min</span>((<span class="type">int</span>)G.<span class="built_in">size</span>()<span class="number">-1</span>,a[u]-i)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">			g[<span class="number">0</span>][k]=<span class="number">1</span>; g[<span class="number">0</span>][<span class="number">1</span>-k]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">				g[i+<span class="number">1</span>][<span class="number">0</span>]=(g[i][<span class="number">0</span>]*f[v][<span class="number">1</span>]+g[i][<span class="number">1</span>]*f[v][<span class="number">2</span>])%mod,</span><br><span class="line">				g[i+<span class="number">1</span>][<span class="number">1</span>]=(g[i][<span class="number">0</span>]*f[v][<span class="number">0</span>]+g[i][<span class="number">1</span>]*f[v][<span class="number">1</span>])%mod,</span><br><span class="line">				i++;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">				f[u][k+j]=<span class="built_in">Add</span>(f[u][k+j],g[i][<span class="number">1</span>-j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	cnt=n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		gra[x].<span class="built_in">pb</span>(y); gra[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>圆方树</tag>
        <tag>仙人掌</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年百度之星·程序设计大赛 - 初赛一</title>
    <url>/2020/07/19/2020%E5%B9%B4%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%C2%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B-%E5%88%9D%E8%B5%9B%E4%B8%80/</url>
    <content><![CDATA[<p><a href="http://bestcoder.hdu.edu.cn/contests/contest_show.php?cid=889">比赛链接</a></p>
<span id="more"></span>

<h3 id="A-Drink"><a href="#A-Drink" class="headerlink" title="A. Drink"></a>A. Drink</h3><p>枚举。</p>
<h3 id="B-GPA"><a href="#B-GPA" class="headerlink" title="B. GPA"></a>B. GPA</h3><p>枚举。</p>
<h3 id="C-Dec"><a href="#C-Dec" class="headerlink" title="C. Dec"></a>C. Dec</h3><p>多重背包DP。</p>
<h3 id="D-Civilization"><a href="#D-Civilization" class="headerlink" title="D. Civilization"></a>D. Civilization</h3><p><del>难度在于读懂题目。</del></p>
<p>读懂之后就是对于每个点求，排序贪心求出答案即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Abs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N],dis[N][N],x,y,n,ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> nx,ny;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">-3</span>,+<span class="number">3</span>) <span class="built_in">fo</span>(j,<span class="number">-3</span>,+<span class="number">3</span>)</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">Abs</span>(i)+<span class="built_in">Abs</span>(j)&lt;=<span class="number">3</span>&amp;&amp;!((i==<span class="number">0</span>)&amp;&amp;(j==<span class="number">0</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		nx=i+x; ny=j+y;</span><br><span class="line">		<span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;ny&lt;=n) adj.<span class="built_in">pb</span>(a[nx][ny]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(adj));</span><br><span class="line">	adj.<span class="built_in">pb</span>(a[x][y]);</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(adj));</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>,now=<span class="number">0</span>,cnt=<span class="number">0</span>,t;</span><br><span class="line">	<span class="keyword">for</span>(t=<span class="number">0</span>;cnt!=<span class="number">9</span>;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=now;</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=<span class="number">8</span>*cnt*cnt)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(adj.<span class="built_in">size</span>()&gt;cnt) now+=adj[cnt];</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); ans=<span class="number">1000000000</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) dis[i][j]=<span class="built_in">calc</span>(i,j);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k=<span class="built_in">Abs</span>(i-x)+<span class="built_in">Abs</span>(j-y);</span><br><span class="line">			k=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,k+dis[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E-Rotate"><a href="#E-Rotate" class="headerlink" title="E. Rotate"></a>E. Rotate</h3><p>由于 $a_i$ 的单调性，这些黑块连成的是一个森林。</p>
<p>由期望的线性性，我们只需统计每一层的贡献。也就是看单独出来了多少个 $a_i$。</p>
<p>假设考虑到第 $i$ 层，要算和 $i+1$ 层的贡献。显然这个贡献为这一层黑色块的个数减去与上一层黑色块有交的期望个数。</p>
<p>与上一层黑色块有交的情况可以分为完全包含和在黑白边界上。</p>
<p>这一层黑色块有 $\frac{a_i}{2}$ 个。</p>
<p>由于是随机旋转，这一层的黑色块与上一层<strong>黑</strong>色块完全包含的期望个数=这一层的黑色块与上一层<strong>白</strong>色块完全包含的期望个数。</p>
<p>这一层的黑色块与上一层在黑白边界上的期望个数为 $\frac{a_{i+1}}{2}$，因为一共有 $a_{i+1}$ 个边界，每个边界上的颜色概率都是 $\frac{1}{2}$。</p>
<p>而这一层的黑色块与上一层<strong>黑</strong>色块完全包含的期望个数+这一层的黑色块与上一层在黑白边界上的期望个数/2= $\frac{a_{i}}{4}$</p>
<p>解得这个贡献就是：$\frac{a_i-a_{i+1}}{4}$。</p>
<p>第 $n$ 层特殊考虑，贡献是 $\frac{a_n}{2}$。</p>
<p>因此答案就是：$\frac{1}{4}\sum_{i=1}^n(a_i-a_{i+1})+\frac{a_n}{2}=\frac{a_1+a_n}{4}$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">n=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="number">1ll</span>*(a[<span class="number">1</span>]+a[n])/<span class="number">2</span>*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod);</span><br></pre></td></tr></table></figure>



<h3 id="G-Mosquito"><a href="#G-Mosquito" class="headerlink" title="G. Mosquito"></a>G. Mosquito</h3><p>可以先二分答案，然后建二分图，将矩阵上每个点看成右边的点，左边的是 $k$ 个点。然后用网络流判定。</p>
<p>但这样时间复杂度是 $O(T(nm)^{1.5}\log (n+m))$ 的，过不了。</p>
<p>因为 $k$ 很小，考虑用Hall定理加速判定。</p>
<p>我们需要对右边的点看是否存在完美匹配。</p>
<p>也就是枚举右边的点的一个子集，然后看左边 $k$ 个点中与之相连的所有的 $a_i$ 和是否大于等于子集的大小即可。</p>
<p>那么枚举左边与之相连的点的集合，然后看右边的集合最大能是多少就好了，一共有 $2^6$ 中情况，集合大小可以用Bitset加速判定，时间复杂度上就是 $2^6\times \frac{nm}{64}=nm$ 的。</p>
<p>时间复杂度 $O(Tknm)$，精细点该做法可以实现 $O(Tnm)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> n,m,k,x[<span class="number">6</span>],y[<span class="number">6</span>],z[<span class="number">1</span>&lt;&lt;<span class="number">6</span>],cnt;</span><br><span class="line">bitset&lt;1000*1001&gt; b[<span class="number">1</span>&lt;&lt;<span class="number">6</span>],ba;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Abs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x&gt;<span class="number">0</span>?x:-x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(t,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;k) b[t].<span class="built_in">reset</span>();</span><br><span class="line">	<span class="built_in">ff</span>(t,<span class="number">0</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Abs</span>(i-x[t])+<span class="built_in">Abs</span>(j-y[t])&lt;=dis)</span><br><span class="line">				b[<span class="number">1</span>&lt;&lt;t][(i<span class="number">-1</span>)*m+j<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ff</span>(t,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;k)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">lowbit</span>(t)!=t)</span><br><span class="line">			b[t]=b[t^<span class="built_in">lowbit</span>(t)]|b[<span class="built_in">lowbit</span>(t)];</span><br><span class="line">	<span class="built_in">ff</span>(t,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;k)</span><br><span class="line">		<span class="keyword">if</span>((b[t^cnt]^ba).<span class="built_in">count</span>()&gt;z[t])</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); s=<span class="number">0</span>;</span><br><span class="line">		ba.<span class="built_in">reset</span>();</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n*m) ba.<span class="built_in">set</span>(i);</span><br><span class="line">		cnt=(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,k) x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>(),z[<span class="number">1</span>&lt;&lt;i]=<span class="built_in">read</span>(),s+=z[<span class="number">1</span>&lt;&lt;i];</span><br><span class="line">		<span class="keyword">if</span>(s&lt;n*m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;k) <span class="keyword">if</span>(<span class="built_in">lowbit</span>(i)!=i) z[i]=z[i^<span class="built_in">lowbit</span>(i)]+z[<span class="built_in">lowbit</span>(i)];</span><br><span class="line">		<span class="type">int</span> l=<span class="number">0</span>,r=n+m,mid;</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>期望</tag>
        <tag>Hall定理</tag>
        <tag>数论</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #526[CF1083]</title>
    <url>/2020/07/18/Codeforces-Round-526-CF1083/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1083/problems">题目链接</a></p>
<span id="more"></span>

<h3 id="A-The-Fair-Nut-and-the-Best-Path"><a href="#A-The-Fair-Nut-and-the-Best-Path" class="headerlink" title="A. The Fair Nut and the Best Path"></a>A. The Fair Nut and the Best Path</h3><p>树形DP模板。</p>
<h3 id="B-The-Fair-Nut-and-Strings"><a href="#B-The-Fair-Nut-and-Strings" class="headerlink" title="B. The Fair Nut and Strings"></a>B. The Fair Nut and Strings</h3><p>先来看看给定 $k$ 个长度为 $n$ 的字符串，然后问你有多少个非空字符串是他们中至少一个的前缀。</p>
<p>把这 $k$ 个串建出一个Trie，那么Trie的节点个数-1就是满足条件的字符串个数。</p>
<p>那么把 $a,b$ 两个串建成Trie，然后在Trie树上数数每一层夹在他们中间的节点个数就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">500010</span>],s2[<span class="number">500010</span>];</span><br><span class="line">ll ans,now;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1,s2);</span><br><span class="line">	now=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		now&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s1[i]==<span class="string">&#x27;b&#x27;</span>) now--;</span><br><span class="line">		<span class="keyword">if</span>(s2[i]==<span class="string">&#x27;a&#x27;</span>) now--;</span><br><span class="line">		<span class="keyword">if</span>(now&gt;=k) &#123;ans+=<span class="number">1ll</span>*k*(n-i); <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">else</span> ans+=now;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Max-Mex"><a href="#C-Max-Mex" class="headerlink" title="C. Max Mex"></a>C. Max Mex</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给出一棵树，树上点的点权为一个 $[0,n-1]$ 的排列。</p>
<p>支持交换两点点权，以及求树上路径权值Mex的最大值。</p>
<p>$n\leq 2\times 10^5$。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先这个东西可以去二分找到最大值。</p>
<p>然后变成判断是否存在一条最短的路径使得某个区间上所有的数都在这条路径上。</p>
<p>考虑合并两个区间的答案。对于某两个区间 $[a,b],[b+1,c]$，假设对这两个区间都存在一条最短的路径，设为 $(A_x,A_y),(B_x,B_y)$，那么区间 $[a,c]$ 有解当且仅当这两条路径的并是一条路径。</p>
<p>那么枚举 $A_x,A_y,B_x,B_y$ 中的两个，看是否能作为合并后路径的端点即可。</p>
<p>判断很简单，需要用到lca。</p>
<p>然后在线段树上二分找到这个最大值即可。</p>
<p>时间复杂度 $O((n+6q)\log n)$.</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">namespace</span> T&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> m,fir[N],dep[N],f[N&lt;&lt;<span class="number">1</span>][<span class="number">20</span>],l2[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">		f[++m][<span class="number">0</span>]=u; fir[u]=m;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			f[++m][<span class="number">0</span>]=u;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dep[x]&gt;dep[y]?y:x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x=fir[x]; y=fir[y];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="type">int</span> k=l2[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">getmin</span>(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dep[x]+dep[y]-(dep[<span class="built_in">lca</span>(x,y)]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,m) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,l2[m])</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=m) f[i][j]=<span class="built_in">getmin</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> T::dis;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dis</span>(x,y)==<span class="built_in">dis</span>(x,z)+<span class="built_in">dis</span>(z,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">merge</span><span class="params">(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.x==<span class="number">-1</span>||B.x==<span class="number">-1</span>) <span class="keyword">return</span> (node)&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(A.x,A.y,B.x)&amp;&amp;<span class="built_in">check</span>(A.x,A.y,B.y)) <span class="keyword">return</span> A;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(B.x,B.y,A.x)&amp;&amp;<span class="built_in">check</span>(B.x,B.y,A.y)) <span class="keyword">return</span> B;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(A.x,B.x,A.y)&amp;&amp;<span class="built_in">check</span>(A.x,B.x,B.y)) <span class="keyword">return</span> (node)&#123;A.x,B.x&#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(A.y,B.y,A.x)&amp;&amp;<span class="built_in">check</span>(A.y,B.y,B.x)) <span class="keyword">return</span> (node)&#123;A.y,B.y&#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(A.x,B.y,A.y)&amp;&amp;<span class="built_in">check</span>(A.x,B.y,B.x)) <span class="keyword">return</span> (node)&#123;A.x,B.y&#125;;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">check</span>(A.y,B.x,A.x)&amp;&amp;<span class="built_in">check</span>(A.y,B.x,B.y)) <span class="keyword">return</span> (node)&#123;A.y,B.x&#125;;</span><br><span class="line">	<span class="keyword">return</span> (node)&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p[N],_p[N];</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	node t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(t[u]=(node)&#123;_p[l],_p[l]&#125;);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">		t[u]=<span class="built_in">merge</span>(t[lc],t[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(t[u]=(node)&#123;_p[l],_p[l]&#125;);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		(p&lt;=mid)?<span class="built_in">update</span>(ls,p):<span class="built_in">update</span>(rs,p);</span><br><span class="line">		t[u]=<span class="built_in">merge</span>(t[lc],t[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,node &amp;A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(t[u].x&gt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(A.x&gt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				node B=<span class="built_in">merge</span>(A,t[u]);</span><br><span class="line">				<span class="keyword">if</span>(B.x&gt;=<span class="number">0</span>) &#123;A=B; <span class="keyword">return</span> r+<span class="number">1</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;A=t[u]; <span class="keyword">return</span> r+<span class="number">1</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ans=<span class="built_in">ask</span>(ls,A);</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;mid) <span class="keyword">return</span> <span class="built_in">ask</span>(rs,A);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SGT;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) _p[p[i]]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) T::<span class="built_in">add</span>(<span class="built_in">read</span>(),i);</span><br><span class="line">	T::<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	node u;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">read</span>()==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">swap</span>(_p[p[x]],_p[p[y]]);</span><br><span class="line">			<span class="built_in">swap</span>(p[x],p[y]);</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[x]);</span><br><span class="line">			<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			u=(node)&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,u)<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-The-Fair-Nut’s-getting-crazy"><a href="#D-The-Fair-Nut’s-getting-crazy" class="headerlink" title="D. The Fair Nut’s getting crazy"></a>D. The Fair Nut’s getting crazy</h3><p>这题还是比较套路的。枚举区间的交 $[i,j]$，看有多少贡献。</p>
<p>设 $pre_i$ 表示值和 $a_i$ 相同的最大的比 $i$ 小的下标，$nex_i$ 表示值和 $a_i$ 相同的最小的比 $i$ 大的下标。</p>
<p>再设 $f_{i,j}=\max_{k\in[i,j]} pre_k+1,g_{i,j}=\min_{k\in[i,j]} nex_k-1$。</p>
<p>枚举一个 $i$，那么合法的 $j$ 是一段连续的区间，设此时这个 $j$ 为 $mx_j$。</p>
<p>那么一个 $i$ 的贡献就是：$\sum_{j=i}^{mx_j}(i-f_{i,j})\times (g_{i,j}-j)$。</p>
<p>化简一下得到：$i\sum_{j=i}^{mx_j}g_{i,j}-i\sum_{j=i}^{mx_j}j-\sum_{j=i}^{mx_j}f_{i,j}g_{i,j}+\sum_{k=i}^{mx_j}jf_{i,j}$。</p>
<p>考虑倒序枚举 $i$，那么每次会修改一些 $g_{i,j}$ 和 $f_{i,j}$，也就是对 $[i,n]$ 取一个 $\min$ 或者 $\max$。</p>
<p>这个用一个单调栈，转换成区间赋值。</p>
<p>那么相当于维护两个序列，支持对这两个序列区间赋值，求 $\sum_{i}g_i,\sum_{i}f_ig_i,\sum_{i}if_i$。</p>
<p>用线段维护若干个区间和即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*x*(x+<span class="number">1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">calc</span>(y)-<span class="built_in">calc</span>(x<span class="number">-1</span>)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (lc|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">ll s[N&lt;&lt;<span class="number">2</span>][<span class="number">4</span>],tag[N&lt;&lt;<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> opt,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s[u][<span class="number">2</span>]=s[u][opt^<span class="number">1</span>]*x%mod;</span><br><span class="line">	s[u][opt]=<span class="number">1ll</span>*(r-l+<span class="number">1</span>)*x%mod;</span><br><span class="line">	tag[u][opt]=x;</span><br><span class="line">	<span class="keyword">if</span>(opt==<span class="number">0</span>) s[u][<span class="number">3</span>]=<span class="number">1ll</span>*<span class="built_in">calc</span>(l,r)*x%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(tag[u][i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pushtag</span>(ls,i,tag[u][i]);</span><br><span class="line">			<span class="built_in">pushtag</span>(rs,i,tag[u][i]);</span><br><span class="line">			tag[u][i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">3</span>) s[u][i]=(s[lc][i]+s[rc][i])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> opt,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,l,r,opt,x);</span><br><span class="line">	<span class="built_in">pushdown</span>(u,l,r);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">update</span>(ls,L,R,opt,x);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">update</span>(rs,L,R,opt,x);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">ll sum[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">3</span>) sum[i]+=s[u][i];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(u,l,r);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">ask</span>(ls,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">ask</span>(rs,L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],m;</span><br><span class="line"><span class="type">int</span> las[N],pre[N],nex[N],st[N],top;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> f1[N],f2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">	m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,a[i])-b;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pre[i]=las[a[i]]+<span class="number">1</span>,las[a[i]]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) las[i]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) nex[i]=las[a[i]]<span class="number">-1</span>,las[a[i]]=i;</span><br><span class="line">	st[top=<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top&amp;&amp;pre[i]&gt;pre[st[top]];top--);</span><br><span class="line">		f1[i]=st[top]<span class="number">-1</span>; st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	st[top=<span class="number">0</span>]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top&amp;&amp;nex[i]&lt;nex[st[top]];top--);</span><br><span class="line">		f2[i]=st[top]<span class="number">-1</span>; st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) las[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=n;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,f1[i],<span class="number">0</span>,pre[i]);</span><br><span class="line">		<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,f2[i],<span class="number">1</span>,nex[i]);</span><br><span class="line">		las[a[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(;las[a[i]]&gt;=<span class="number">2</span>;las[a[j]]--,j--);</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">1</span>,<span class="number">3</span>) sum[k]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,j);</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">1</span>,<span class="number">3</span>) sum[k]%=mod;</span><br><span class="line">		(ans+=<span class="number">1ll</span>*i*(sum[<span class="number">1</span>]-<span class="built_in">calc</span>(i,j))-sum[<span class="number">2</span>]+sum[<span class="number">3</span>])%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(ans+mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E-The-Fair-Nut-and-Rectangles"><a href="#E-The-Fair-Nut-and-Rectangles" class="headerlink" title="E. The Fair Nut and Rectangles"></a>E. The Fair Nut and Rectangles</h3><p><del>Div 1.E就这难度？？？</del></p>
<p>把点按照 $x$ 排序，然后DP，然后斜率优化即可。</p>
<p>时间复杂度 $O(n\log n)$，瓶颈在排序上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll x,y,a;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="type">int</span> n,st[N],l,r;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">K</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (db)(f[y]-f[x])/(p[y].x-p[x].x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>(),p[i].a=<span class="built_in">read</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">	l=<span class="number">1</span>; r=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=p[i].x*p[i].y-p[i].a;</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;r&amp;&amp;<span class="built_in">K</span>(st[l],st[l+<span class="number">1</span>])&gt;=p[i].y;l++);</span><br><span class="line">		<span class="keyword">if</span>(l&lt;=r) f[i]=<span class="built_in">max</span>(f[i],p[i].x*p[i].y-p[i].a+f[st[l]]-p[st[l]].x*p[i].y);</span><br><span class="line">		<span class="keyword">for</span>(;l&lt;r&amp;&amp;<span class="built_in">K</span>(st[r<span class="number">-1</span>],i)&gt;<span class="built_in">K</span>(st[r<span class="number">-1</span>],st[r]);r--);</span><br><span class="line">		st[++r]=i;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>Trie</tag>
        <tag>线段树</tag>
        <tag>LCA</tag>
        <tag>单调栈</tag>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Global Round 1[CF1110]</title>
    <url>/2020/07/14/Codeforces-Global-Round-1-CF1110/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1110/problems">题目链接</a></p>
<span id="more"></span>

<p>A,B都没什么好说的。</p>
<h3 id="C-Meaningless-Operations"><a href="#C-Meaningless-Operations" class="headerlink" title="C. Meaningless Operations"></a>C. Meaningless Operations</h3><p>题意：多次询问，求 $f(a)=\max_{0 &lt; b &lt; a}\gcd(a\oplus b,a &amp; b)$。</p>
<p>先用二进制表示 $a$，显然有 $\gcd(a\oplus b,a&amp; b)\leq a\oplus b$，设 $a$ 的最高二进制位为 $x$，则 $a\oplus b\leq 2^{x+1}-1$。</p>
<p>可以发现，当 $a\not = 2^{x+1}-1$ 时，$a\oplus b$ 能取到最大值。此时有：$a+b=2^{x+1}-1$，则 $a&amp; b=0$，因此 $\gcd$ 也能取到最大值。</p>
<p>那么当 $a=2^{x+1}-1$ 时，$a\oplus b=a-b,a&amp; b=b$，则 $\gcd(a\oplus b,a&amp; b)=\gcd(a-b,b)=\gcd(a,b)$，找到 $a$ 的最大不是本身的因子即可。</p>
<h3 id="D-Jongmah"><a href="#D-Jongmah" class="headerlink" title="D. Jongmah"></a>D. Jongmah</h3><p>如果出现了三个 $(x-1,x,x+1)$，则可以用 $(x-1,x-1,x-1),(x,x,x),(x+1,x+1,x+1)$ 代替。</p>
<p>也就是一种合法的方案一定能转换成每种 $(x-1,x,x+1)$ 不超过 $2$ 个的形式。</p>
<p>设 $f_{i,j,k}$ 表示考虑到第 $i$ 位，$(i-1,i,i+1)$ 有 $j$ 个，$(i,i+1,i+2)$ 有 $k$ 个的最大值，然后DP即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">			<span class="built_in">fo</span>(l,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span>(f[i<span class="number">-1</span>][k][l]!=<span class="number">-1</span>&amp;&amp;j+k+l&lt;=a[i])</span><br><span class="line">					f[i][j][k]=<span class="built_in">max</span>(f[i][j][k],f[i<span class="number">-1</span>][k][l]+l+(a[i]-j-k-l)/<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[m][<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



<h3 id="E-Magic-Stones"><a href="#E-Magic-Stones" class="headerlink" title="E. Magic Stones"></a>E. Magic Stones</h3><p>题意：给一个序列 $c$，每次选一个 $i\in[2,n-1]$，将 $c_i$ 变成 $c_{i-1}+c_{i+1}-c_i$，问是否能将 $c$ 变成序列 $t$。</p>
<p>这种题通常都是差分或者前缀和就搞出来了。</p>
<p>首先必须要有 $c_1=t_1,c_n=t_n$。</p>
<p>我们进行差分，设 $a_i=c_{i}-c_{i-1}$，发现上述的操作实际上是在交换两个相邻的 $a_i$。题意转换成你可以交换任意相邻的数字，使得最后序列等于某个序列，排个序就没了。</p>
<h3 id="F-Nearest-Leaf"><a href="#F-Nearest-Leaf" class="headerlink" title="F. Nearest Leaf"></a>F. Nearest Leaf</h3><p>题意：</p>
<p>给定一棵带边权树，满足按照节点编号从小到大的顺序dfs得到的dfs序 $dfn_i=i$。</p>
<p>多次询问，可离线，求 $[l,r]$ 中所有的叶子结点点 $v$ 最近的距离。</p>
<p>$n,q\leq 5\times 10^5$</p>
<p>那就离线吧，把询问挂到树上，然后在dfs时处理询问。</p>
<p>假设你从 $u$ 开始经过了一条边 $(u,v,w)$，$w$ 表示权值，那么有些叶子结点的距离就 $+w$，有些就 $-w$，并且 dfs 序都是 $O(1)$ 段区间。由题目的性质知道对于的节点编号也是 $O(1)$ 段区间。</p>
<p>那么用线段树，把非叶子结点的距离设为 $+\infty$ ，然后随便打打标记就好了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1ll</span>&lt;&lt;<span class="number">60</span>;</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	ll mx[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,ll x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mx[u]+=x; tag[u]+=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushtag</span>(lc,tag[u]);</span><br><span class="line">		<span class="built_in">pushtag</span>(rc,tag[u]);</span><br><span class="line">		tag[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mx[u]=<span class="built_in">min</span>(mx[lc],mx[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,ll v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,v);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">add</span>(ls,L,R,v);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">add</span>(rs,L,R,v);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> mx[u];</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		ll ans=inf;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) ans=<span class="built_in">min</span>(ans,<span class="built_in">ask</span>(ls,L,R));</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  ans=<span class="built_in">min</span>(ans,<span class="built_in">ask</span>(rs,L,R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(mx[u]=v);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		(p&lt;=mid)?<span class="built_in">ins</span>(ls,p,v):<span class="built_in">ins</span>(rs,p,v);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,id;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;query&gt; q[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; leaf;</span><br><span class="line"><span class="type">int</span> n,m,fa[N];</span><br><span class="line">ll ans[N],now;</span><br><span class="line"><span class="type">int</span> ver[N],val[N],ne[N],head[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> le[N],ri[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:q[u])</span><br><span class="line">		ans[x.id]=SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,x.l,x.r)+now;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		now+=val[i];</span><br><span class="line">		SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,le[v],ri[v],-val[i]*<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		now-=val[i];</span><br><span class="line">		SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,le[v],ri[v],val[i]*<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> u,ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	le[u]=n+<span class="number">1</span>,ri[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		<span class="built_in">pre</span>(v,now+val[i]);</span><br><span class="line">		le[u]=<span class="built_in">min</span>(le[u],le[v]);</span><br><span class="line">		ri[u]=<span class="built_in">max</span>(ri[u],ri[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!head[u]) le[u]=ri[u]=u,SGT::<span class="built_in">ins</span>(<span class="number">1</span>,<span class="number">1</span>,n,u,now);</span><br><span class="line">	<span class="keyword">else</span> SGT::<span class="built_in">ins</span>(<span class="number">1</span>,<span class="number">1</span>,n,u,inf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(fa[i],i,<span class="built_in">read</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!head[i]) leaf.<span class="built_in">pb</span>(i);</span><br><span class="line">	<span class="built_in">pre</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> v,l,r;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		v=<span class="built_in">read</span>(); l=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">		l=<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(leaf),l)-leaf.<span class="built_in">begin</span>();</span><br><span class="line">		r=<span class="built_in">upper_bound</span>(<span class="built_in">all</span>(leaf),r)-leaf.<span class="built_in">begin</span>()<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;r) <span class="keyword">continue</span>;</span><br><span class="line">		q[v].<span class="built_in">pb</span>((query)&#123;leaf[l],leaf[r],i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="G-Tree-Tac-Toe"><a href="#G-Tree-Tac-Toe" class="headerlink" title="G. Tree-Tac-Toe"></a>G. Tree-Tac-Toe</h3><p>我们假设先不考虑刚开始就是白色的点。</p>
<p>首先显然的是，黑色不可能赢，因为如果黑色有必胜策略的话，白色能先走它的这个必胜策略。</p>
<p>那么看什么时候白色能赢。</p>
<p>设点 $i$ 的度数为 $deg_i$。</p>
<p>第一种情况：显然有，若存在 $i$ ，使得 $deg_i\geq 4$ ，则白色必赢。</p>
<p>第二种情况：接下来考虑度数是 $3$ 的点，发现如果他所连的三个点中存在至少两个不是叶子结点，那么白色也必胜了。</p>
<p>第三种情况：排除了上面两种情况以后，剩下的只能是一条链，然后在链的第二个和倒数第二个的点上最多再挂一个点的形式。</p>
<p>如果这两个点上都没再挂一个点，那么最后只能是平局。</p>
<p>最后只剩下这种：</p>
<p><img src="/Codeforces-Global-Round-1-CF1110/G1.png" alt="G1"></p>
<p>可以发现，当直径上点的长度是奇数的时候，白色必胜。</p>
<p>那么最后来考虑刚开始就有白色的情况。</p>
<p>它相当于你把这个点染成白色以后，必须要有一步黑色的操作，且这个黑色的操作不能影响到原来的点。</p>
<p>也就是必须设计一个东西，然后挂在这个被染成白色的点上面。</p>
<p>显然可以这样设计：</p>
<p><img src="/Codeforces-Global-Round-1-CF1110/G2.png" alt="G2"></p>
<p>当你选了白点以后，如果黑色不选这个中间的点，那么下一步白色选它，黑色就输了。</p>
<p>那么这题就能做了。时间复杂度 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2000010</span>;</span><br><span class="line"><span class="type">int</span> n,ans,deg[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N],vec;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); deg[x]++;</span><br><span class="line">	adj[y].<span class="built_in">pb</span>(x); deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(i,++n);</span><br><span class="line">			++n; <span class="built_in">add</span>(n<span class="number">-1</span>,n);</span><br><span class="line">			++n; <span class="built_in">add</span>(n<span class="number">-2</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) deg[i]=<span class="number">0</span>,adj[i].<span class="built_in">clear</span>();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			<span class="keyword">if</span>(deg[i]&gt;=<span class="number">4</span>) &#123;ans=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(deg[i]==<span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> v:adj[i]) <span class="keyword">if</span>(deg[v]&gt;=<span class="number">2</span>) cnt++;</span><br><span class="line">				<span class="keyword">if</span>(cnt&gt;=<span class="number">2</span>) &#123;ans=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(deg[i]==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> v:adj[i]) vec.<span class="built_in">pb</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(!ans)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">			vec.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vec))-vec.<span class="built_in">begin</span>());</span><br><span class="line">			<span class="type">int</span> u=vec[<span class="number">0</span>],v=vec[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(deg[u]==<span class="number">3</span>&amp;&amp;deg[v]==<span class="number">3</span>&amp;&amp;(n&amp;<span class="number">1</span>)) ans=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(ans?<span class="string">&quot;White&quot;</span>:<span class="string">&quot;Draw&quot;</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) deg[i]=<span class="number">0</span>,adj[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="H-Modest-Substrings"><a href="#H-Modest-Substrings" class="headerlink" title="H. Modest Substrings"></a>H. Modest Substrings</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>求一个字典序最小的长度为 $n$ 的数字串，满足不含前导零的子串所表示的数字在 $[l,r]$ 内的子串数目最多。输出这个子串数目和字符串。</p>
<p>$1\leq l \leq r \leq 10^{800},n\leq 200$，时限 5s，空间 1G。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>如果 $r-l$ 比较小的话，我们就可以把所有在 $[l,r]$ 内的数字建出一个AC自动机，然后在上面跑DP就好了。</p>
<p>类似于数位DP，如果某个时刻你选的数字已经脱离限制了，那么以后随便填就都可满足了。比如 $l=227$，$r=403$，第一位选了 $2$，当第二位选了 $3$ 的时候，后面随便乱选都满足在 $[l,r]$ 里面了（对应在AC自动机上是一个满10叉树）。</p>
<p>我们找到哪些前缀会在选完前缀的最后一个数后脱离限制。发现最多有 $800\times 10 \times 2=16000$ 个这样的前缀，找这些前缀分类讨论一下即可找到。</p>
<p>要注意，脱离了限制不代表一定可以满足在 $[l,r]$ 内，这个前缀还需要加上一定个数的字符才能在 $[l,r]$ 内。</p>
<p>然后对这些前缀建立AC自动机，然后在AC机上进行DP。</p>
<p>设 $f_{i,j}$ 表示考虑到第 $i$ 位，当前在AC自动机的第 $j$ 个点上的最值。</p>
<p>考虑往后转移，设此时字符串是 $s$，你在后面填上一个字符 $c$，看这个此时这个字符 $c$ 的贡献。</p>
<p>这个贡献相当于枚举 $s+c$ 的后缀，看这个后缀是否脱离限制，且后面能给它加足够的点来完成。那么设 $h_{j,k}$ 表示节点 $j$ 的点的fail链的所有点中，当中有 $h_{j,k}$ 个前缀满足需要再加 $k$ 个字符才能在 $[l,r]$ 内。</p>
<p>那么这个DP就是：$f_{i+1,ne_{j,c}}=\max\{f_{i,j}+\sum_{k\leq n-i-1}h_{ne_{j,c},k}\}$。</p>
<p>$h$ 做个前缀和即可快速转移。</p>
<p>时间复杂度 $O(nm\Sigma)$，其中 $m$ 为 AC自动机点数，$\Sigma$ 为字符集大小。</p>
<p>输出方案倒退回去再正推贪心即可。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">16100</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N][<span class="number">10</span>],fail[N],cnt,h[N][<span class="number">2003</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_next</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!ne[x][k]) ne[x][k]=++cnt;</span><br><span class="line">	<span class="keyword">return</span> ne[x][k];</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">9</span>) <span class="keyword">if</span>(ne[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(ne[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m) h[u][i]+=h[fail[u]][i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v=ne[u][i];</span><br><span class="line">			<span class="keyword">if</span>(!v) ne[u][i]=ne[fail[u]][i];</span><br><span class="line">			<span class="keyword">else</span> fail[v]=ne[fail[u]][i],q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n1,n2;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> s1[<span class="number">805</span>],s2[<span class="number">805</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1,s2);</span><br><span class="line">	n1=<span class="built_in">strlen</span>(s1); n2=<span class="built_in">strlen</span>(s2);</span><br><span class="line">	<span class="type">int</span> u1=<span class="number">0</span>,u2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n1==n2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(u1==u2)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(j,s1[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,s2[i]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>) h[<span class="built_in">get_next</span>(u1,j)][n1-i<span class="number">-1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(j,s1[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,<span class="number">9</span>) h[<span class="built_in">get_next</span>(u1,j)][n1-i<span class="number">-1</span>]++;</span><br><span class="line">				<span class="built_in">fo</span>(j,(!i)?<span class="number">1</span>:<span class="number">0</span>,s2[i]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>) h[<span class="built_in">get_next</span>(u2,j)][n2-i<span class="number">-1</span>]++;</span><br><span class="line">			&#125;</span><br><span class="line">			u1=<span class="built_in">get_next</span>(u1,s1[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			u2=<span class="built_in">get_next</span>(u2,s2[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		h[u1][<span class="number">0</span>]++;</span><br><span class="line">		<span class="keyword">if</span>(u1^u2) h[u2][<span class="number">0</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n1)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,s1[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,<span class="number">9</span>) h[<span class="built_in">get_next</span>(u1,j)][n1-i<span class="number">-1</span>]++;</span><br><span class="line">			u1=<span class="built_in">get_next</span>(u1,s1[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,n2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,(!i)?<span class="number">1</span>:<span class="number">0</span>,s2[i]-<span class="string">&#x27;0&#x27;</span><span class="number">-1</span>) h[<span class="built_in">get_next</span>(u2,j)][n2-i<span class="number">-1</span>]++;</span><br><span class="line">			u2=<span class="built_in">get_next</span>(u2,s2[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		h[u1][<span class="number">0</span>]++; h[u2][<span class="number">0</span>]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,n1+<span class="number">1</span>,n2<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="number">9</span>)</span><br><span class="line">				h[<span class="built_in">get_next</span>(<span class="number">0</span>,j)][i<span class="number">-1</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n2<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2005</span>][N];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">2005</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">getfail</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) h[i][j]+=h[i][j<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">128</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,cnt)</span><br><span class="line">			<span class="keyword">if</span>(f[i<span class="number">-1</span>][j]&gt;=<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">					f[i][ne[j][k]]=<span class="built_in">max</span>(f[i][ne[j][k]],f[i<span class="number">-1</span>][j]+h[ne[j][k]][n-i]);</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) mx=<span class="built_in">max</span>(mx,f[n][i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mx);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) <span class="keyword">if</span>(f[n][i]==mx) vis[n][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,n<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,cnt)</span><br><span class="line">			<span class="keyword">if</span>(f[i][j]&gt;=<span class="number">0</span>)</span><br><span class="line">				<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">					<span class="keyword">if</span>(vis[i+<span class="number">1</span>][ne[j][k]]&amp;&amp;f[i][j]+h[ne[j][k]][n-i<span class="number">-1</span>]==f[i+<span class="number">1</span>][ne[j][k]])</span><br><span class="line">						vis[i][j]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">			<span class="keyword">if</span>(vis[i][ne[u][k]]&amp;&amp;f[i<span class="number">-1</span>][u]+h[ne[u][k]][n-i]==f[i][ne[u][k]])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">putchar</span>(k^<span class="number">48</span>);</span><br><span class="line">				u=ne[u][k];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>线段树</tag>
        <tag>思维题</tag>
        <tag>博弈论</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Knights[CF1067C]</title>
    <url>/2020/07/12/Knights-CF1067C/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.luogu.com.cn/problem/CF1067C">luogu</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>就是一道裸构造题。</p>
<p>如图，对于橙色的格子，需要这 $8$ 个黑色格子的至少 $4$ 个。</p>
<p><img src="/Knights-CF1067C/1.png" alt="1"></p>
<p>假设用下面的四个来搞出这个橙色的格子。</p>
<p>如果要搞出一行橙色，不难想到用两行即可。</p>
<p>如图所示：</p>
<p><img src="/Knights-CF1067C/2.png" alt="2"></p>
<p>红色的即为黑色两行通过上面的方法新搞出来的格子。</p>
<p>那么每次长度-4，设这黑色两行长度为 $m$，则一共大概有：$\frac{m\times \frac{m}{4}}{2}\times 2=\frac{m^2}{4}$。</p>
<p>显然有：$2n=m$，则一共约有 $\frac{n^2}{16}$ 个格子。还差一点。</p>
<p>既然两行搞不定，我们尝试来三行的。</p>
<p>显然这三行不需要全都涂满。经过乱搞发现这样就可以变成三行了：</p>
<p><img src="/Knights-CF1067C/3.png" alt="3"></p>
<p>大概满足条件 $n=\frac{3}{2}m$，所以一共大概有 $\frac{m^2}{4}=\frac{n^2}{9}$ 个格子。</p>
<p>这样就可以做了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="number">19260817</span>+i,<span class="number">19890604</span>+i);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n%<span class="number">3</span>!=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="number">19260817</span>+n,<span class="number">19890604</span>+n);</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;3 %d\n&quot;</span>,<span class="number">2</span>*i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">3</span>+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;2 %d\n&quot;</span>,<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n/<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;1 %d\n&quot;</span>,<span class="number">2</span>*i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #517[CF1071]</title>
    <url>/2020/07/12/Codeforces-Round-517-CF1071/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1071/problems">Codeforces Round #517</a></p>
<span id="more"></span>

<h3 id="A-Cram-Time"><a href="#A-Cram-Time" class="headerlink" title="A. Cram Time"></a>A. Cram Time</h3><p>显然，在里面的肯定是一段前缀。</p>
<p>先二分出最大值，找到这个前缀。</p>
<p>然后从大到小贪心减去即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s1,s2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,V.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:V) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a=<span class="built_in">read</span>(); b=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">100000</span>,mid;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">1ll</span>*mid*(mid+<span class="number">1</span>)/<span class="number">2</span>&lt;=a+b) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	l--;</span><br><span class="line">	<span class="built_in">fd</span>(i,l,<span class="number">1</span>) <span class="keyword">if</span>(a&gt;=i) s1.<span class="built_in">pb</span>(i),a-=i; <span class="keyword">else</span> s2.<span class="built_in">pb</span>(i),b-=i;</span><br><span class="line">	<span class="built_in">print</span>(s1);</span><br><span class="line">	<span class="built_in">print</span>(s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B-Minimum-path"><a href="#B-Minimum-path" class="headerlink" title="B. Minimum path"></a>B. Minimum path</h3><p>$n\times n$ 的网格，上面有字母。从左上到右下走，每次只能往下或往右走，一条路径形成了长度为 $2n-1$ 的字符串，你可以在网格图上修改 $k$ 次，每次修改一个字母，输出最小的字典序。</p>
<p>显然如果 $k\geq 2n-1$ ，则答案为 $2n-1$ 个 $a$。</p>
<p>然后把这个字符串分成两部分，一部分是前面的 $a$，另一部分是后面的东西。</p>
<p>考虑贪心，设 $dp_{i,j}$ 表示走到 $(i,j)$ 最少经过多少个不是 $a$ 的网格。</p>
<p>那么找到 $i+j-1$ 最大的且 $dp_{i,j}\leq k$ 的 $(i,j)$，前 $i+j-1$ 个就全都是 $a$ 了。</p>
<p>剩下的就一个 bfs 就好了。</p>
<p>注意bfs时的去重，以及 $k=0$ 的情况。</p>
<p>时间复杂度 $O(n^2)$ 左右。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> n,k,f[N][N];</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.x!=B.x) <span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">		<span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.x==B.x&amp;&amp;A.y==B.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;P&gt; p,q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mi=<span class="number">27</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u.x&lt;n) mi=<span class="built_in">min</span>(mi,s[u.x+<span class="number">1</span>][u.y]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(u.y&lt;n) mi=<span class="built_in">min</span>(mi,s[u.x][u.y+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getnext</span><span class="params">(<span class="type">int</span> mi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(u.x&lt;n&amp;&amp;s[u.x+<span class="number">1</span>][u.y]-<span class="string">&#x27;a&#x27;</span>==mi) p.<span class="built_in">pb</span>((P)&#123;u.x+<span class="number">1</span>,u.y&#125;);</span><br><span class="line">		<span class="keyword">if</span>(u.y&lt;n&amp;&amp;s[u.x][u.y+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>==mi) p.<span class="built_in">pb</span>((P)&#123;u.x,u.y+<span class="number">1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(p));</span><br><span class="line">	p.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(p))-p.<span class="built_in">begin</span>());</span><br><span class="line">	q=p; p.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(k&gt;=<span class="number">2</span>*n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">2</span>*n<span class="number">-1</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>]=(s[<span class="number">1</span>][<span class="number">1</span>]!=<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		c=(s[i][j]!=<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(i<span class="number">-1</span>) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i<span class="number">-1</span>][j]+c);</span><br><span class="line">		<span class="keyword">if</span>(j<span class="number">-1</span>) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][j<span class="number">-1</span>]+c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(f[i][j]&lt;=k) mx=<span class="built_in">max</span>(mx,i+j<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,mx) <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(f[i][j]&lt;=k&amp;&amp;i+j<span class="number">-1</span>==mx) q.<span class="built_in">pb</span>((P)&#123;i,j&#125;);</span><br><span class="line">	<span class="keyword">if</span>(f[<span class="number">1</span>][<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;k==<span class="number">0</span>) k=<span class="number">1</span>,<span class="built_in">putchar</span>(s[<span class="number">1</span>][<span class="number">1</span>]),q.<span class="built_in">pb</span>((P)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;),mx=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(t,mx+<span class="number">1</span>,<span class="number">2</span>*n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">find</span>();</span><br><span class="line">		<span class="built_in">putchar</span>(x+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="built_in">getnext</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-Triple-Flips"><a href="#C-Triple-Flips" class="headerlink" title="C. Triple Flips"></a>C. Triple Flips</h3><p><del>打表题×1。</del></p>
<p>考虑暴力，枚举一个等差数列是否选择，然后判断。</p>
<p>然后你会发现，题目中的 $12$ 非常的奇怪。然后你又发现长度为 $8$ 的序列的等差数列个数就是 $12$。</p>
<p>暴力打表发现，所有长度为 $8$ 的情况都是可以的。</p>
<p>也就是说，长度小于 $8$ 的可以暴力做，长度大于 $8$ 的要通过不超过 $\frac{n}{3}$ 次操作搞成长度小于 $8$ 的就可以进行暴力了。</p>
<p>考虑当前区间 $[l,r]$ 左边连续的三个数，大力分类讨论：</p>
<ol>
<li><p>$0**$，直接变成子问题 $[l+1,r]$ 。</p>
</li>
<li><p>$111$，操作一次 $(l,l+1,l+2)$ 。</p>
</li>
<li><p>$101$，操作一次 $(l,l+2,l+4)$。</p>
</li>
<li><p>$100$，操作一次 $(l,l+3,l+6)$。</p>
</li>
<li><p>$110$，不会。</p>
</li>
</ol>
<p>把右边连续的三个数也考虑上，那么“不会”的情况就是 $110\cdots011$。</p>
<p>显然再分类一下就必定可以用两次将这六位都变成 $0$。</p>
<p>时间复杂度为 $O(n)$ 加上暴力的复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> a[N],b[N],flag;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; vec,opt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	a[x]^=<span class="number">1</span>; a[y]^=<span class="number">1</span>; a[(x+y)&gt;&gt;<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;r-l+<span class="number">1</span>&lt;<span class="number">8</span>&amp;&amp;l&gt;<span class="number">1</span>;l--);</span><br><span class="line">	<span class="keyword">for</span>(;r-l+<span class="number">1</span>&lt;<span class="number">8</span>&amp;&amp;r&lt;n;r++);</span><br><span class="line">	<span class="built_in">fo</span>(i,l,r)</span><br><span class="line">		<span class="built_in">fo</span>(j,i+<span class="number">1</span>,r)</span><br><span class="line">			<span class="keyword">if</span>((j-i)%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">				opt.<span class="built_in">pb</span>(<span class="built_in">mp</span>(i,j));</span><br><span class="line">	<span class="type">int</span> k=opt.<span class="built_in">size</span>(),m=<span class="number">1</span>&lt;&lt;k;</span><br><span class="line">	<span class="type">bool</span> bo;</span><br><span class="line">	<span class="built_in">ff</span>(s,<span class="number">0</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,l,r) b[i]=a[i];</span><br><span class="line">		bo=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,k)</span><br><span class="line">			<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s)</span><br><span class="line">				<span class="built_in">update</span>(opt[i].fi,opt[i].se);</span><br><span class="line">		<span class="built_in">fo</span>(i,l,r) <span class="keyword">if</span>(a[i]) &#123;bo=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(!bo)</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,k) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s) vec.<span class="built_in">pb</span>(opt[i]);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,l,r) a[i]=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;=<span class="number">8</span>) <span class="keyword">return</span> <span class="built_in">work</span>(l,r);</span><br><span class="line">	<span class="keyword">if</span>(!a[l]) <span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">if</span>(!a[r]) <span class="keyword">return</span> <span class="built_in">solve</span>(l,r<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(a[l+<span class="number">1</span>]&amp;&amp;a[l+<span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,l+<span class="number">2</span>)),<span class="built_in">update</span>(l,l+<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">3</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[l+<span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,l+<span class="number">4</span>)),<span class="built_in">update</span>(l,l+<span class="number">4</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">3</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!a[l+<span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,l+<span class="number">6</span>)),<span class="built_in">update</span>(l,l+<span class="number">6</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">3</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[r<span class="number">-1</span>]&amp;&amp;a[r<span class="number">-2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(r<span class="number">-2</span>,r)),<span class="built_in">update</span>(r<span class="number">-2</span>,r);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l,r<span class="number">-3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[r<span class="number">-2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(r<span class="number">-4</span>,r)),<span class="built_in">update</span>(r<span class="number">-4</span>,r);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l,r<span class="number">-3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!a[r<span class="number">-1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(r<span class="number">-6</span>,r)),<span class="built_in">update</span>(r<span class="number">-6</span>,r);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l,r<span class="number">-3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((r-l+<span class="number">1</span>)&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,r)),<span class="built_in">update</span>(l,r);</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l+<span class="number">1</span>,r<span class="number">-1</span>)),<span class="built_in">update</span>(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">3</span>,r<span class="number">-3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l+<span class="number">1</span>,r)),<span class="built_in">update</span>(l+<span class="number">1</span>,r);</span><br><span class="line">		vec.<span class="built_in">pb</span>(<span class="built_in">mp</span>(l,r<span class="number">-1</span>)),<span class="built_in">update</span>(l,r<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">solve</span>(l+<span class="number">3</span>,r<span class="number">-3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,vec.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec) <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,v.fi,(v.se+v.fi)/<span class="number">2</span>,v.se);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D-Familiar-Operations"><a href="#D-Familiar-Operations" class="headerlink" title="D. Familiar Operations"></a>D. Familiar Operations</h3><p><del>打表题×2。</del></p>
<p>先把数 $x$ 质因数分解：$x=\prod p_i^{a_i}$，</p>
<p>然后把 $a_i$ 排序，$a$ 序列相同的数归为一类。</p>
<p>显然有用的数的 $a$ 序列长度不会超过 $8$。</p>
<p>通过打表发现，有意义的 $a$ 序列不同的个数在 $1000$ 以内。</p>
<p>通过打表又发现 $\prod (a_i+1)$ （即约数个数）不同的种类在 $200$ 左右。</p>
<p>打表可以用dfs实现。</p>
<p>接着就把不同的 $a$ 序列看成一个点，和在序列上加一或减一后形成的序列对应的点连一条权值为 $1$ 的边。</p>
<p>最终结果是使得两个序列的约数个数相等。</p>
<p>那么枚举最后相同的约数个数是哪一类，然后求出最短距离就好了。</p>
<p>求最短距离用bfs即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> p[]=&#123;<span class="number">19</span>,<span class="number">17</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">map&lt;vector&lt;<span class="type">int</span>&gt;,<span class="type">int</span>&gt; ma;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; d[<span class="number">4010</span>],vec,ve,E[<span class="number">4010</span>],h[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> cnt,siz,f[<span class="number">4000</span>][<span class="number">4000</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> id,vector&lt;<span class="type">int</span>&gt; &amp;V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) f[id][i]=inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:V) q.<span class="built_in">push</span>(x),f[id][x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:E[u])</span><br><span class="line">			<span class="keyword">if</span>(f[id][v]==inf)</span><br><span class="line">			&#123;</span><br><span class="line">				f[id][v]=f[id][u]+<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll now,<span class="type">int</span> limit,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">8</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		++cnt;</span><br><span class="line">		ma[vec]=cnt;</span><br><span class="line">		d[cnt]=vec;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec) x*=v+<span class="number">1</span>;</span><br><span class="line">		h[x].<span class="built_in">pb</span>(cnt);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,vec.<span class="built_in">size</span>())</span><br><span class="line">		<span class="keyword">if</span>((i==<span class="number">0</span>&amp;&amp;vec[i])||(i!=<span class="number">0</span>&amp;&amp;vec[i]!=vec[i<span class="number">-1</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			ve=vec; ve[i]--;</span><br><span class="line">			x=ma[ve];</span><br><span class="line">			E[x].<span class="built_in">pb</span>(cnt); E[cnt].<span class="built_in">pb</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">30</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(now&gt;<span class="number">100000000ll</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=limit) vec.<span class="built_in">pb</span>(i),<span class="built_in">dfs</span>(now,i,k+<span class="number">1</span>),vec.<span class="built_in">pop_back</span>();</span><br><span class="line">		now*=p[k];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;i++)</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(y=<span class="number">0</span>;x%i==<span class="number">0</span>;x/=i) y++;</span><br><span class="line">			vec.<span class="built_in">pb</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(x!=<span class="number">1</span>) vec.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(;vec.<span class="built_in">size</span>()&lt;<span class="number">8</span>;vec.<span class="built_in">pb</span>(<span class="number">0</span>));</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(vec));</span><br><span class="line">	<span class="keyword">return</span> ma[vec];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,<span class="number">100000</span>)</span><br><span class="line">		<span class="keyword">if</span>(h[i].<span class="built_in">size</span>())</span><br><span class="line">			++siz,<span class="built_in">bfs</span>(siz,h[i]);</span><br><span class="line">	<span class="type">int</span> x,y,ans;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">g</span>(<span class="built_in">read</span>()),y=<span class="built_in">g</span>(<span class="built_in">read</span>()); ans=inf;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz) ans=<span class="built_in">min</span>(ans,f[i][x]+f[i][y]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round #516[CF1063]</title>
    <url>/2020/07/11/Codeforces-Round-516-CF1063/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1063/problems">Codeforces Round #516</a></p>
<span id="more"></span>

<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>题意：重排字符串，使得字符串的回文子串个数最多。输出任意一个满足条件的字符串。</p>
<p>找规律发现，将字符从小到大排好就是一个满足条件的字符串。</p>
<p>考虑一个字母，它出现了 $x$ 遍，那么由这个字母结尾的回文串最多只有 $\frac{x(x+1)}{2}$ 个，而排序则刚好达到这个上界。</p>
<p>因此上面那个规律就是正确的了。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>题意：$n\times m$ 个格子，某些格子是障碍物。从某一个点出发，向左不能超过 $L$ 次，向右不能超过 $R$ 次，问能到达的点的个数。</p>
<p>一看上去它有两个限制条件，非常不好做，如果只剩一个那就可以随便bfs了。</p>
<p>首先，假设你从 $(x,y)$ 出发，要到达 $(x_0,y_0)$，假设你向左走了 $l$ 步，那么你显然是向右走了 $l+(y_0-y)$ 步。</p>
<p>因此，只需要最小化其中任意一个限制就可以了。</p>
<p>剩下就是一个简单的 bfs。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> n,m,max_le,max_ri,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(node u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node v;</span><br><span class="line">	<span class="keyword">for</span>(v=u,v.x--;;v.x--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.x&lt;=<span class="number">0</span>||vis[v.x][v.y]) <span class="keyword">break</span>;</span><br><span class="line">		vis[v.x][v.y]=<span class="number">1</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(v);</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(v=u,v.x++;;v.x++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v.x&gt;n||vis[v.x][v.y]) <span class="keyword">break</span>;</span><br><span class="line">		vis[v.x][v.y]=<span class="number">1</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(v);</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Left</span><span class="params">(node u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u.l&gt;=max_le) <span class="keyword">return</span>;</span><br><span class="line">	u.y--; u.l++;</span><br><span class="line">	<span class="keyword">if</span>(u.y&lt;=<span class="number">0</span>||vis[u.x][u.y]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u.x][u.y]=<span class="number">1</span>;</span><br><span class="line">	ans++;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="built_in">update</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Right</span><span class="params">(node u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u.r&gt;=max_ri) <span class="keyword">return</span>;</span><br><span class="line">	u.y++; u.r++;</span><br><span class="line">	<span class="keyword">if</span>(u.y&gt;m||vis[u.x][u.y]) <span class="keyword">return</span>;</span><br><span class="line">	vis[u.x][u.y]=<span class="number">1</span>;</span><br><span class="line">	ans++;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="built_in">update</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> nx=<span class="built_in">read</span>(),ny=<span class="built_in">read</span>();</span><br><span class="line">	max_le=<span class="built_in">read</span>(); max_ri=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m) vis[i][j]=(s[j]==<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(vis[nx][ny]==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	q.<span class="built_in">push</span>((node)&#123;nx,ny,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	vis[nx][ny]=<span class="number">1</span>; <span class="built_in">update</span>((node)&#123;nx,ny,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	ans++;</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		node u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="built_in">Left</span>(u); <span class="built_in">Right</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>题意：交互题，问交互器 $n$ 遍，每次你可以询问一个点是黑色还是白色，最后让你求出一条直线，使得该直线将询问的 $n$ 个点分成两部分，每部分颜色相同，两部分颜色不同。</p>
<p>$n\leq 30$，$0\leq x,y \leq 10^9$。</p>
<p>可以发现，$\log_2{10^9}\approx 30$，考虑二分。</p>
<p>实际上二维是假的，我们只需要考虑一条直线上的点，最后再用一条斜斜的直线截成两部分就好了。</p>
<p>枚举 $[l,r]$ 的中间点 $mid$，问它是否是白色还是黑色就好了。</p>
<p>时间复杂度 $O(n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,x,y);</span><br><span class="line">	<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">	<span class="keyword">return</span> s[<span class="number">0</span>]==<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1e9</span>,mid;</span><br><span class="line">	<span class="type">bool</span> b=<span class="built_in">ask</span>(<span class="number">0</span>,<span class="number">1</span>),t;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">ask</span>(mid,<span class="number">1</span>)==b) l=mid; <span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>,l,<span class="number">0</span>,l+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>题意：一个圆环上 $n$ 个人，$k$ 个糖果。你可以设定每个人每次最多拿走 $1$ 个或 $2$ 个糖果，从 $l$ 开始顺时针让人拿糖果，最后在 $r$ 时糖果没了。如果还有糖果则这个人能要拿最多的，但不能超出限制。最大化最多拿两个糖果的人数。$n,l,r,k\leq 10^{11}$。</p>
<p>数据分治，然后列出一大堆不等式，讨论一下注意细节就好了。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><a href="/2020/05/27/%E9%BB%91%E7%BA%A2%E5%85%94-FJWC2020Day1/" title="黑红兔[FJWC2020Day1]">黑红兔[FJWC2020Day1]</a>]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>后缀数组</tag>
        <tag>bfs</tag>
        <tag>交互题</tag>
        <tag>数据分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Construction of a tree[AGC029F]</title>
    <url>/2020/07/07/Construction-of-a-tree-AGC029F/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定 $n-1$ 个点集(全集为 $\{1,2,\cdots,n\}$)，从每个集合内选两个点连边，使得最后形成一棵树。输出方案。</p>
<p>$n\leq 10^5$，点集大小之和 $\le 2\times 10^5$。</p>
<span id="more"></span>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://atcoder.jp/contests/agc029/tasks/agc029_f">AtCoder</a></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对于这 $n-1$ 个集合 $S=\{S_1,S_2\cdots S_{n-1}\}$，我们选出这些集合的若干个子集 $T\subseteq S$，设 $f(T)$ 表示在 $T$ 中的集合 $S_i$ 所拥有的点的集合的大小。那么如果存在一个非空集合 $T$ 使得 $f(T)\leq |T|$，这 $f(T)$ 个点最多连出 $f(T)-1$ 条边，而 $f(T)-1&lt; |T|$，显然不可能符合题意。</p>
<p>也就是说，$\forall T\subseteq S,|T|&gt;0$，满足 $f(T)&gt;|T|$ 是有解的必要条件。</p>
<p>发现这个很像Hall定理的形式：$f(T)\geq T$。</p>
<p>考虑构造一个二分图，左边是原图中的 $n$ 个点，右边是 $n-1$ 个集合，每个点如果在某个集合内则连一条边。</p>
<p>然后跑一个二分图匹配，不存在完美匹配则不满足Hall定理，则一定无解。</p>
<p>那么左边的点就有且仅有一个点没有匹配上，设这个点为 $x$。</p>
<p>考虑构造，对当前的 $x$ 进行dfs，找到与其相连的还未被标记的一个集合 $w$，然后标记它，再对这个集合 $w$ 找到与其匹配的点 $y$，则 $(x,y)$ 这条边就是集合 $w$ 中的边了。</p>
<p>构造的正确性证明：</p>
<p>我们只需说明不会出现有解的在这种构造下变为无解。按照这种方法，当无解的时候，当前被标记的集合所形成的的集合满足 $f(T)\leq |T|$ ，而有解的时候是不会有这种情况的。得证。</p>
<p>在二分图下跑Dinic，时间复杂度 $O(n\sqrt{m})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2000000</span>;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	<span class="type">int</span> head[N],cur[N],ne[M],ver[M],val[M],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> d[N];</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,t) cur[i]=head[i];</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,t) d[i]=<span class="number">-1</span>; q.<span class="built_in">push</span>(s); d[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flow||u==t) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,r,v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==d[u]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i]));</span><br><span class="line">				<span class="keyword">if</span>(!r) <span class="keyword">continue</span>;</span><br><span class="line">				val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">				res-=r; <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">bfs</span>()) flow+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> X[N],Y[N],cnt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=s&amp;&amp;!vis[v-n])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[v-n]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=head[v];j;j=ne[j])</span><br><span class="line">				<span class="keyword">if</span>(val[j])</span><br><span class="line">					cnt++,X[v-n]=u,Y[v-n]=ver[j],<span class="built_in">dfs</span>(ver[j]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	Dinic::t=<span class="number">2</span>*n;</span><br><span class="line">	s=<span class="number">0</span>; t=<span class="number">2</span>*n;</span><br><span class="line">	<span class="built_in">ff</span>(i,n+<span class="number">1</span>,<span class="number">2</span>*n) <span class="function">CASET <span class="title">add</span><span class="params">(read(),i,<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">add</span>(s,i,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,n+<span class="number">1</span>,<span class="number">2</span>*n) <span class="built_in">add</span>(i,t,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">dinic</span>()!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[<span class="number">0</span>];i;i=ne[i]) <span class="keyword">if</span>(val[i]) root=ver[i];</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="keyword">if</span>(cnt!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,X[i],Y[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AtCoder</category>
        <category>AGC</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>思维题</tag>
        <tag>Hall定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ball Eat Chameleons[AGC021]</title>
    <url>/2020/07/05/Ball-Eat-Chameleons-AGC021/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://atcoder.jp/contests/agc021/tasks/agc021_e">AtCoder</a></p>
<p><a href="https://www.luogu.com.cn/problem/AT3871">luogu</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设选了 $R$ 个红球，则选了 $B=k-R$ 个蓝球。</p>
<p>考虑一只变色龙最后是红色的当且仅当：</p>
<ol>
<li>所吃红球&gt;蓝球；</li>
<li>所吃红球=蓝球，且最后一次吃的是蓝球。</li>
</ol>
<p>接下来来看什么时候可行。</p>
<p>分类讨论：</p>
<ol>
<li><p>$R&lt;B$，此时方案数显然为 $0$。因为至少存在一只变色龙是蓝色。</p>
</li>
<li><p>$R\geq B+n$，此时方案数显然为 $\binom{R+B}{B}$，因为每只变色龙都可以符合第一种情况。</p>
</li>
<li><p>$R=B$，这时候必须满足序列中最后一个是蓝球，否则必然不合法，然后转换成 $(R,B-1)$ 的问题。</p>
</li>
<li><p>$R\in (B,B+n)$，这时候需要有 $n-(R-B)$ 只变色龙符合第二种情况。并且，当这只变色龙吃的球的个数大于 $2$ 的话，可以将最后的一个红球和蓝球不吃，让给剩下 $R-B$ 只满足第一种情况的变色龙吃，也能满足情况。</p>
<p>因此，这种情况就变成了给定一个 <code>R,B</code> 序列，里面有 $R$ 个 <code>R</code>，$B$ 个 <code>B</code>，至少要找到 $n-(R-B)$ 个互不相交的子序列，且这个子序列是 <code>RB</code>，问符合情况的方案数。</p>
<p>把 <code>R</code> 看成 $+1$，<code>B</code> 看成 $-1$，上面的条件相当于：</p>
<p>对于每个前缀都满足前缀和 $\geq B-(n-(R-B))=R-n$</p>
<p>这时候由经典的折线法容斥一下就好了，得到方案数：$\binom{R+B}{R}-\binom{R+B}{2R-n+1}$。</p>
</li>
</ol>
<p>预处理组合数，时间复杂度 $O(k)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="type">int</span> n,k,R,B;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n-m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>); <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;k) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">init</span>(k);</span><br><span class="line">	<span class="built_in">fo</span>(R,<span class="number">0</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		B=k-R;</span><br><span class="line">		<span class="keyword">if</span>(R&lt;B) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(R&gt;=B+n) &#123;ans=<span class="built_in">Add</span>(ans,<span class="built_in">C</span>(R+B,R)); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(R==B) B--;</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="built_in">Dec</span>(<span class="built_in">C</span>(R+B,R),<span class="built_in">C</span>(R+B,<span class="number">2</span>*R-n+<span class="number">1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AtCoder</category>
        <category>AGC</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Mike and Friends[CF547E]</title>
    <url>/2020/07/04/Mike-and-Friends-CF547E/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.ml/contest/547/problem/E">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>练手速的题</del></p>
<p><del>这种题也需要写20min。。。</del></p>
<p>显然你建一个广义SAM然后离线一下再线段树合并就没了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>注意广义SAM不仅需要las=1，还需要特殊处理一些东西。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N*<span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ls[M],rs[M],cnt;</span><br><span class="line"><span class="type">int</span> siz[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) u=++cnt;</span><br><span class="line">	siz[u]++;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	(p&lt;=mid)?<span class="built_in">update</span>(ls[u],l,mid,p):<span class="built_in">update</span>(rs[u],mid+<span class="number">1</span>,r,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">	ls[x]=<span class="built_in">merge</span>(ls[x],ls[y]);</span><br><span class="line">	rs[x]=<span class="built_in">merge</span>(rs[x],rs[y]);</span><br><span class="line">	siz[x]+=siz[y];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> siz[u];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) ans+=<span class="built_in">ask</span>(ls[u],l,mid,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  ans+=<span class="built_in">ask</span>(rs[u],mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt[N],pos[N];</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	vector&lt;query&gt; vec[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">dfs</span>(v),rt[u]=<span class="built_in">merge</span>(rt[u],rt[v]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec[u]) ans[v.id]=<span class="built_in">ask</span>(rt[u],<span class="number">1</span>,n,v.x,v.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> ne[N&lt;&lt;<span class="number">1</span>][<span class="number">26</span>],fa[N&lt;&lt;<span class="number">1</span>],len[N&lt;&lt;<span class="number">1</span>],cnt,las;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt=las=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ne[las][c])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> p=las,q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) &#123;las=q; <span class="keyword">return</span>;&#125;</span><br><span class="line">			<span class="type">int</span> clone=++cnt;</span><br><span class="line">			<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">			len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">			fa[clone]=fa[q];</span><br><span class="line">			<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">			fa[q]=clone;</span><br><span class="line">			las=clone;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> cur=++cnt,p=las;</span><br><span class="line">		len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> clone=++cnt;</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">				fa[clone]=fa[q];</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">				fa[q]=fa[cur]=clone;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,cnt) Tree::<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SAM::las;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	SAM::<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		las=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,len) SAM::<span class="built_in">extend</span>(s[j]-<span class="string">&#x27;a&#x27;</span>),<span class="built_in">update</span>(rt[las],<span class="number">1</span>,n,i);</span><br><span class="line">		pos[i]=las;</span><br><span class="line">	&#125;</span><br><span class="line">	SAM::<span class="built_in">build</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=pos[<span class="built_in">read</span>()];</span><br><span class="line">		Tree::vec[z].<span class="built_in">pb</span>((query)&#123;x,y,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Berserk Robot[CF538G]</title>
    <url>/2020/07/04/Berserk-Robot-CF538G/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://codeforces.com/problemset/problem/538/G">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>真的是人类智慧题啊。</del></p>
<p>首先遇到这种走格子题，往往都或许可以通过某些变换，将横纵坐标分开来考虑的。</p>
<p>考虑上面的套路，将坐标系旋转 $45$ 度，那么就变成了：</p>
<p>$$U(x+1,y+1),D(x-1,y-1),L(x-1,y+1),R(x+1,y-1)$$</p>
<p>原先的坐标 $(x,y)$ 就变成了 $(x+y,y-x)$。</p>
<p>现在就可以分开横纵坐标考虑了，每次可以加上 $1$ 或者减去 $1$，并满足第 $t_i$ 秒等于某个值 $x$。</p>
<p>设走了 $k$ 次 $+1$，那么有：$k-(t-k)=x$，即 $k=\frac{x+t}{2}$。</p>
<p>那么再转换一下，原先在第 $t$ 秒的坐标 $(x,y)$ 变成 $(\frac{x+y+t}{2},\frac{y-x+t}{2})$，然后横纵坐标都满足，每次 $+1$ 或者不加。（注意特判掉 $x+y+t$ 不是偶数的情况）</p>
<p>那么原先的四个方向就变成了：</p>
<p>$$U(x+1,y+1),D(x,y),L(x,y+1),R(x+1,y)$$</p>
<p>下面只考虑 $x$ 的（$y$ 同理）：</p>
<p>设第 $i$ 秒的位置在 $pos_i$。$k_i=\left\lfloor \frac{t_i}{l}\right\rfloor,w_i=t_i\bmod l$。</p>
<p>那么有：$X_i=pos_{t_i}=pos_l\times k_i+pos_{w_i}$。</p>
<p>$w_i$ 是比较小的，考虑将这 $n$ 个方程按照 $w_i$ 的大小排序，然后差分。</p>
<p>为了方便，我们加入两个方程，分别满足 $k_i=0,w_i=0,X_i=0$，以及 $k_i=-1,w_i=l,X_i=0$，原因是最前一段和最后一段也需要考虑。</p>
<p>假设是方程 $i$ 和方程 $j$ 进行差分，那么有：</p>
<p>$$X_i-X_j=pos_l\times (k_i-k_j)+(pos_{w_i}-pos_{w_j})$$</p>
<p>由于我们按照 $w_i$ 进行排序，那么就有 $pos_{w_i}-pos_{w_j}\geq 0$。</p>
<p>设 $X=X_i-X_j,k=k_i-k_j$。原式变为：$X=pos_l\times k+(pos_{w_i}-pos_{w_j})$</p>
<p>由于每次只能让 $pos_{i}$ 最多加上 $1$，因此 $pos_{w_i}-pos_{w_j}\in[0,w_i-w_j]$。</p>
<p>原式再变为：$X-(w_i-w_j)\leq pos_l\times k\leq X$。</p>
<p>根据 $k$ 的大小分 $k=0,k&gt;0,k&lt;0$ 三种情况进行讨论，得出无解，或者一个关于 $pos_l$ 大小的区间。</p>
<p>那么在这个区间内的值都是能满足的了。</p>
<p>得到了 $pos_l$，由最开始的方程 $X_i=pos_{t_i}=pos_l\times k_i+pos_{w_i}$ 就能算出每个 $pos_{w_i}$。</p>
<p>最后只需构造方案就好了，根据贪心，我们对于 $x,y$ 每次都加一，直到 $x$ 或 $y$ 不能再加为止。然后再 $x$ 或 $y$ 单独跳，最后走 $U(x,y)$（也就是不动）就好了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200020</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">8e18</span>;</span><br><span class="line"><span class="type">int</span> n,l;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll x,y,k,w;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.w&lt;B.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line">ll lx,rx,ly,ry,dx,dy,nx,ny;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); l=<span class="built_in">read</span>();</span><br><span class="line">	ll X,Y,T,w,k;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		T=<span class="built_in">read</span>(); X=<span class="built_in">read</span>(); Y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>((X+Y+T)&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">		q[i].x=(X+Y+T)/<span class="number">2</span>;</span><br><span class="line">		q[i].y=(Y-X+T)/<span class="number">2</span>;</span><br><span class="line">		q[i].k=T/l; q[i].w=T%l;</span><br><span class="line">	&#125;</span><br><span class="line">	q[n+<span class="number">1</span>].k=<span class="number">-1</span>,q[n+<span class="number">1</span>].w=l;</span><br><span class="line">	<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">2</span>);</span><br><span class="line">	lx=ly=-inf;</span><br><span class="line">	rx=ry=inf;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		w=q[i].w-q[i<span class="number">-1</span>].w;</span><br><span class="line">		k=q[i].k-q[i<span class="number">-1</span>].k;</span><br><span class="line">		X=q[i].x-q[i<span class="number">-1</span>].x;</span><br><span class="line">		Y=q[i].y-q[i<span class="number">-1</span>].y;</span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(X-w&gt;<span class="number">0</span>||X&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(Y-w&gt;<span class="number">0</span>||Y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lx=<span class="built_in">max</span>(lx,(ll)<span class="built_in">ceil</span>((<span class="type">long</span> db)(X-w)/k));</span><br><span class="line">			ly=<span class="built_in">max</span>(ly,(ll)<span class="built_in">ceil</span>((<span class="type">long</span> db)(Y-w)/k));</span><br><span class="line">			rx=<span class="built_in">min</span>(rx,(ll)<span class="built_in">floor</span>((<span class="type">long</span> db)X/k));</span><br><span class="line">			ry=<span class="built_in">min</span>(ry,(ll)<span class="built_in">floor</span>((<span class="type">long</span> db)Y/k));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			lx=<span class="built_in">max</span>(lx,(ll)<span class="built_in">ceil</span>((<span class="type">long</span> db)X/k));</span><br><span class="line">			ly=<span class="built_in">max</span>(ly,(ll)<span class="built_in">ceil</span>((<span class="type">long</span> db)Y/k));</span><br><span class="line">			rx=<span class="built_in">min</span>(rx,(ll)<span class="built_in">floor</span>((<span class="type">long</span> db)(X-w)/k));</span><br><span class="line">			ry=<span class="built_in">min</span>(ry,(ll)<span class="built_in">floor</span>((<span class="type">long</span> db)(Y-w)/k));</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//DEBUG(lx); DEBUG(rx);</span></span><br><span class="line">	<span class="keyword">if</span>(lx&gt;rx||ly&gt;ry) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	nx=lx; ny=ly;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n+<span class="number">1</span>) q[i].x=q[i].x-q[i].k*nx,q[i].y=q[i].y-q[i].k*ny;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		dx=q[i].x-q[i<span class="number">-1</span>].x,dy=q[i].y-q[i<span class="number">-1</span>].y;</span><br><span class="line">		X=Y=<span class="number">0</span>; w=q[i].w-q[i<span class="number">-1</span>].w;</span><br><span class="line">		<span class="keyword">for</span>(;w--;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(X&lt;dx)</span><br><span class="line">			&#123;</span><br><span class="line">				++X;</span><br><span class="line">				<span class="keyword">if</span>(Y&lt;dy) ++Y,<span class="built_in">putchar</span>(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(Y&lt;dy) ++Y,<span class="built_in">putchar</span>(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>Tavas in Kansas[CF536D]</title>
    <url>/2020/07/04/Tavas-in-Kansas-CF536D/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://codeforces.com/problemset/problem/536/D">CF</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><ul>
<li><p>给定一张 $n$ 个点 $m$ 条边的可能有自环和重边的无向连通图，每条边都有一个非负边权。</p>
</li>
<li><p>小 X 和小 Y 在这张图上玩一个游戏，在游戏中，第 $i$ 个城市有一个权值 $p_i$。</p>
</li>
<li><p>一开始，小 X 在城市 $s$ 中，小 Y 在城市 $t$ 中，两人各有一个得分，初始为 $0$，小 X 为先手，然后轮流进行操作。</p>
</li>
<li><p>当轮到某一个人时，他必须选择一个非负整数 $x$，以选定所有与他所在的城市的最短距离不超过 $x$ 的还未被选定过的城市，他的得分将会加上这些城市的权值。</p>
</li>
<li><p>另外，每个人每次必须能够至少选定一个城市。</p>
</li>
<li><p>当没有人可以选择时，游戏结束，得分高者获胜。</p>
</li>
<li><p>现在请你计算出，在两人都使用最佳策略的情况下，谁会获胜（或者判断为平局）。</p>
</li>
<li><p>$n\leq 2000,m\leq 10^5,|p_i|\leq 10^9$。</p>
</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>分析一下可以发现，这两个人博弈所形成的的状态可以由 $(k,i,j)$ 表示，其中 $k$ 表示当前谁先手，第一个人当前的距离是 $i$，第二个人当前的距离是 $j$ 。</p>
<p>因此，先把到 $s$ 和 $t$ 的最短路预处理，然后进行离散化，那么这个状态就是 $O(n^2)$ 级别的了。设第 $i$ 个点在这两个离散化数组中的下标是 $id1_i,id2_i$。</p>
<p>考虑DP，设 $f_{k,i,j}$ 表示状态为 $(k,i,j)$ 时，第一个人减去第二个人的值是多少。设 $sum(i,j,k,l)$ 表示满足 $id1_x\in[i,j],id2_x\in[k,l]$ 的 $x$ 点的权值之和。</p>
<p>那么有：</p>
<p>$$f_{0,i,j}=\max\{f_{1,k,j}+sum(i,k-1,j,\infty)|k&gt;i\}$$</p>
<p>$$f_{1,i,j}=\min\{f_{0,i,k}+sum(i,\infty,j,k-1)|k&gt;j\}$$</p>
<p>此外，还需满足每个人每次必须能够至少选定一个城市的条件，也就是必须有至少一个点在里面。</p>
<p>算 $sum$ 可以二维前缀和搞一搞就好。</p>
<p>DP直接暴力是 $O(n^3)$ 的，然后你发现用一个前缀最值优化一下就好了。</p>
<p>时间复杂度 $O(m\log n+n^2)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],ne[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> u; ll d;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> A.d&gt;B.d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	ll h[N],d[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_dis</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> &amp;m,<span class="type">int</span> *id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		q.<span class="built_in">push</span>((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[i]=inf,vis[i]=<span class="number">0</span>;</span><br><span class="line">		d[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">top</span>().u; q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">			vis[u]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(d[v=ver[i]]&gt;d[u]+val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+val[i];</span><br><span class="line">					<span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>((node)&#123;v,d[v]&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) id[i]=i,h[i]=d[i];</span><br><span class="line">		<span class="built_in">sort</span>(h+<span class="number">1</span>,h+n+<span class="number">1</span>);</span><br><span class="line">		m=<span class="built_in">unique</span>(h+<span class="number">1</span>,h+n+<span class="number">1</span>)-h<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) id[i]=<span class="built_in">lower_bound</span>(h+<span class="number">1</span>,h+m+<span class="number">1</span>,d[i])-h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s,t,p[N];</span><br><span class="line"><span class="type">int</span> ids[N],idt[N],ns,nt;</span><br><span class="line">ll sum[N][N],f[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> siz[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">si</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> siz[l][r]-siz[l][y<span class="number">-1</span>]-siz[x<span class="number">-1</span>][r]+siz[x<span class="number">-1</span>][y<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">su</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sum[l][r]-sum[l][y<span class="number">-1</span>]-sum[x<span class="number">-1</span>][r]+sum[x<span class="number">-1</span>][y<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	s=<span class="built_in">read</span>(); t=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">read</span>(),Graph::<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	Graph::<span class="built_in">get_dis</span>(s,ns,ids);</span><br><span class="line">	Graph::<span class="built_in">get_dis</span>(t,nt,idt);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) siz[ids[i]][idt[i]]++,sum[ids[i]][idt[i]]+=p[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,ns)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,nt)</span><br><span class="line">			siz[i][j]+=siz[i<span class="number">-1</span>][j]+siz[i][j<span class="number">-1</span>]-siz[i<span class="number">-1</span>][j<span class="number">-1</span>],</span><br><span class="line">			sum[i][j]+=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fd</span>(i,ns,<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">fd</span>(j,nt,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">si</span>(i,j,i,nt)) f[<span class="number">0</span>][i][j]=<span class="built_in">max</span>(f[<span class="number">0</span>][i+<span class="number">1</span>][j],f[<span class="number">1</span>][i+<span class="number">1</span>][j])+<span class="built_in">su</span>(i,j,i,nt);</span><br><span class="line">			<span class="keyword">else</span> f[<span class="number">0</span>][i][j]=f[<span class="number">0</span>][i+<span class="number">1</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">si</span>(i,j,ns,j)) f[<span class="number">1</span>][i][j]=<span class="built_in">min</span>(f[<span class="number">1</span>][i][j+<span class="number">1</span>],f[<span class="number">0</span>][i][j+<span class="number">1</span>])-<span class="built_in">su</span>(i,j,ns,j);</span><br><span class="line">			<span class="keyword">else</span> f[<span class="number">1</span>][i][j]=f[<span class="number">1</span>][i][j+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]&gt;<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;Break a heart&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;Cry&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Flowers&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>Bear and Chemistry[CF639F]</title>
    <url>/2020/07/03/Bear-and-Chemistry-CF639F/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/contest/639/problem/F">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>用来练码力的题。</del></p>
<p><del>这种题还写了1.5h真的差评。</del></p>
<p>显然你先直接缩点，变成一个森林。</p>
<p>然后每次询问就是给你一些点和边，表示在森林的基础上再加上这些边，然后跑边双，问这些点是否在同一个边双内。</p>
<p>那么在森林上对这些点建出虚树，然后再跑Tarjan就好了。</p>
<p>时间复杂度 $O((n+m)\log n)$。</p>
<p>有那么亿点细节。。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,col[N],bel[N],m,q,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> dfn[N],low[N],tim;</span><br><span class="line">	<span class="type">int</span> ver[N],ne[N],head[N],tot;</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; bridge;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfn[u]=low[u]=++tim;</span><br><span class="line">		<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(!dfn[v=ver[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">				low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">				<span class="keyword">if</span>(low[v]&gt;dfn[u]) vis[i]=vis[i^<span class="number">1</span>]=<span class="number">1</span>,bridge.<span class="built_in">pb</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(v!=pre) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">if</span>(!flag) flag=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">else</span> low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		col[u]=cnt;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(!col[v=ver[i]]&amp;&amp;!vis[i])</span><br><span class="line">				<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;edge&gt; &amp;E)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tim=<span class="number">0</span>; tot=<span class="number">1</span>; cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:bridge) vis[i]=vis[i^<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		bridge.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:a) head[i]=dfn[i]=low[i]=col[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(edge v:E) <span class="built_in">add</span>(v.x,v.y);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:a) <span class="keyword">if</span>(!col[i]) ++cnt,<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Graph::ver;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; E,E1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; V,V1,V2;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> dep[N],f[N][<span class="number">20</span>],rt[N],dfn[N],tim;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfn[u]=++tim; f[u][<span class="number">0</span>]=pre;</span><br><span class="line">		dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">19</span>) f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v:adj[u]) <span class="keyword">if</span>(v!=pre) rt[v]=rt[u],<span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:Graph::bridge) <span class="built_in">add</span>(col[ver[i]],col[ver[i^<span class="number">1</span>]]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(!dep[i]) rt[i]=i,<span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">19</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[y][i]&amp;&amp;dep[f[y][i]]&gt;=dep[x]) y=f[y][i];</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">19</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">		<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">sort</span>(<span class="built_in">all</span>(a),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">		a.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(a))-a.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> st[N],top,now;</span><br><span class="line">		top=now=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x:a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(top&amp;&amp;rt[x]!=now)</span><br><span class="line">				<span class="keyword">for</span>(;--top;) E1.<span class="built_in">pb</span>((edge)&#123;st[top],st[top+<span class="number">1</span>]&#125;);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(top)</span><br><span class="line">			&#123;</span><br><span class="line">				y=<span class="built_in">lca</span>(x,st[top]);</span><br><span class="line">				<span class="keyword">if</span>(y!=st[top])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(;top&gt;=<span class="number">2</span>&amp;&amp;dep[st[top<span class="number">-1</span>]]&gt;=dep[y];top--) E1.<span class="built_in">pb</span>((edge)&#123;st[top],st[top<span class="number">-1</span>]&#125;);</span><br><span class="line">					<span class="keyword">if</span>(st[top]!=y) E1.<span class="built_in">pb</span>((edge)&#123;st[top],y&#125;),st[top]=y,V1.<span class="built_in">pb</span>(y);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			now=rt[x];</span><br><span class="line">			<span class="keyword">if</span>(st[top]!=x) st[++top]=x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(top) <span class="keyword">for</span>(;--top;) E1.<span class="built_in">pb</span>((edge)&#123;st[top],st[top+<span class="number">1</span>]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(edge i:E) V2.<span class="built_in">pb</span>(i.x),V2.<span class="built_in">pb</span>(i.y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:V) V2.<span class="built_in">pb</span>(i);</span><br><span class="line">	Tree::<span class="built_in">build</span>(V2);</span><br><span class="line">	<span class="keyword">for</span>(edge i:E) E1.<span class="built_in">pb</span>((edge)&#123;i.x,i.y&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:V2) V1.<span class="built_in">pb</span>(i);</span><br><span class="line">	<span class="built_in">sort</span>(<span class="built_in">all</span>(V1));</span><br><span class="line">	V1.<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(V1))-V1.<span class="built_in">begin</span>());</span><br><span class="line">	Graph::<span class="built_in">work</span>(V1,E1);</span><br><span class="line">	<span class="type">int</span> c=col[V[<span class="number">0</span>]];</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,V.<span class="built_in">size</span>()) <span class="keyword">if</span>(col[V[i]]!=c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Rnow;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=(x+Rnow)%n;</span><br><span class="line">	<span class="keyword">if</span>(x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) E.<span class="built_in">pb</span>((edge)&#123;<span class="built_in">read</span>(),<span class="built_in">read</span>()&#125;);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) V.<span class="built_in">pb</span>(i);</span><br><span class="line">	Graph::<span class="built_in">work</span>(V,E);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) bel[i]=col[i];</span><br><span class="line">	Tree::<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> T=<span class="number">1</span>,v,e;T&lt;=q;T++)</span><br><span class="line">	&#123;</span><br><span class="line">		v=<span class="built_in">read</span>(); e=<span class="built_in">read</span>();</span><br><span class="line">		E.<span class="built_in">clear</span>(); V.<span class="built_in">clear</span>();</span><br><span class="line">		E1.<span class="built_in">clear</span>(); V1.<span class="built_in">clear</span>(); V2.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,v) V.<span class="built_in">pb</span>(bel[<span class="built_in">change</span>(<span class="built_in">read</span>())]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,e) E.<span class="built_in">pb</span>((edge)&#123;bel[<span class="built_in">change</span>(<span class="built_in">read</span>())],bel[<span class="built_in">change</span>(<span class="built_in">read</span>())]&#125;);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>()) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>),Rnow=(Rnow+T)%n;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>双连通分量</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>Orchestra[CF627E]</title>
    <url>/2020/07/03/Orchestra-CF627E/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/contest/627/problem/E">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然有一个暴力的做法是：枚举矩阵的上边界和下边界，然后统计每一列的情况，压缩成一维，然后双指针扫一遍就没了。</p>
<p>时间复杂度是三次方的，显然过不了。</p>
<p>考虑先枚举一个上边界，然后按顺序从上往下枚举下边界，这时你会在这个一维数组中插入一个数，这时影响到答案的只有他前面的 $k$ 个点和后面一个点，我们将这些点找出来，然后修改贡献就好了。</p>
<p>可以用链表来维护，但是链表不支持随机访问。</p>
<p>因此我们从下往上枚举下边界，然后插入变成删除就可以了。</p>
<p>时间复杂度 $O(n^2k)$，$n,r,c$ 同阶。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3005</span>;</span><br><span class="line"><span class="type">int</span> r,c,n,k,x[N],y[N],sum[N],a[N],pos[N],cnt,L[N],R[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec[N];</span><br><span class="line">ll ans,s,val[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum[a[x]]--;</span><br><span class="line">	<span class="type">int</span> le=x,ri;</span><br><span class="line">	s-=val[x]; val[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) <span class="keyword">if</span>(L[le]) le=L[le],s-=val[le],val[le]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> t=R[x];</span><br><span class="line">	<span class="keyword">if</span>(!sum[a[x]])</span><br><span class="line">	&#123;</span><br><span class="line">		L[R[x]]=L[x],R[L[x]]=R[x];</span><br><span class="line">		s-=val[t],val[t]=<span class="number">0</span>; t=R[t];</span><br><span class="line">		<span class="keyword">if</span>(le==x) le=R[le];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(le==cnt+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ri=le;</span><br><span class="line">	<span class="type">int</span> now=sum[a[le]];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) <span class="keyword">if</span>(now&lt;k) ri=R[ri],now+=sum[a[ri]];</span><br><span class="line">	<span class="keyword">if</span>(ri==cnt+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(;le!=t&amp;&amp;ri!=cnt+<span class="number">1</span>;)</span><br><span class="line">	&#123;</span><br><span class="line">		s+=(val[le]=<span class="number">1ll</span>*(c-a[ri]+<span class="number">1</span>)*(a[le]-a[L[le]]));</span><br><span class="line">		now-=sum[a[le]]; le=R[le];</span><br><span class="line">		<span class="keyword">for</span>(;now&lt;k&amp;&amp;ri&lt;=cnt;ri=R[ri],now+=sum[a[ri]]);</span><br><span class="line">		<span class="keyword">if</span>(ri==cnt+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	r=<span class="built_in">read</span>(); c=<span class="built_in">read</span>(); n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>(),vec[x[i]].<span class="built_in">pb</span>(y[i]);</span><br><span class="line">	<span class="built_in">fo</span>(l,<span class="number">1</span>,r)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt=<span class="number">0</span>; s=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(x[i]&gt;=l) sum[y[i]]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,c) <span class="keyword">if</span>(sum[i]) a[++cnt]=i,pos[i]=cnt;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) L[i]=i<span class="number">-1</span>,R[i]=i+<span class="number">1</span>;</span><br><span class="line">		R[<span class="number">0</span>]=<span class="number">1</span>; R[cnt+<span class="number">1</span>]=cnt+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> ri=<span class="number">0</span>,le=<span class="number">1</span>,now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) <span class="keyword">if</span>(now&lt;k) ri=R[ri],now+=sum[a[ri]];</span><br><span class="line">		<span class="keyword">if</span>(now&gt;=k&amp;&amp;ri!=cnt+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt)</span><br><span class="line">			&#123;</span><br><span class="line">				s+=(val[le]=<span class="number">1ll</span>*(c-a[ri]+<span class="number">1</span>)*(a[le]-a[L[le]]));</span><br><span class="line">				now-=sum[a[le]]; le=R[le];</span><br><span class="line">				<span class="keyword">for</span>(;now&lt;k&amp;&amp;ri&lt;=cnt;ri=R[ri],now+=sum[a[ri]]);</span><br><span class="line">				<span class="keyword">if</span>(ri==cnt+<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fd</span>(d,r,l)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=s;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec[d]) <span class="built_in">del</span>(pos[v]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt+<span class="number">1</span>) L[i]=R[i]=a[i]=val[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,c) sum[i]=pos[i]=<span class="number">0</span>; cnt=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>New Year and Forgotten Tree[CF611H]</title>
    <url>/2020/07/02/New-Year-and-Forgotten-Tree-CF611H/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/611/problem/H">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先简化一下，将位数相同的点搞在一起形成一个大的点，那么一共就有 $m=\left \lfloor \log_{10}n \right \rfloor \leq 6$ 个大点。对于每个大点，随便选择一个点作为关键点。</p>
<p>如果有解，那么肯定存在一种情况，使得一条原树中的边，其中一个点连向的是关键点。</p>
<p>那么关键点之间形成的，是一个树结构。</p>
<p>根据prufer数列，我们有 $m^{m-2}$ 种树。</p>
<p>那么暴力枚举所有的情况，考虑剩下的边怎么连。</p>
<p>也就是说，一条边 $(x,y)$ 有两种选择，要么 $x$ 连的是关键点，要么 $y$ 连。</p>
<p>建立一个二分图，左边的点代表剩下的边，右边的点代表一个大点。</p>
<p>然后建这个二分图，判断是否存在完美匹配，如果存在就找到一个解了。</p>
<p>判断是否存在完美匹配可以用Hall定理或者暴力跑网络流。</p>
<p>因为要输出方案，可以跑一个网络流，然后根据残量网络输出即可。</p>
<p>时间复杂度 $O(m^{m-2}2^m+m^3)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	<span class="type">int</span> ver[M],ne[M],head[M],val[M],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> cur[M],d[M];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,s,t) d[i]=<span class="number">-1</span>,cur[i]=head[i];</span><br><span class="line">		q.<span class="built_in">push</span>(s); d[s]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(d[v=ver[i]]==<span class="number">-1</span>&amp;&amp;val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!flow||u==t) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,v,r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==d[u]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i]));</span><br><span class="line">				<span class="keyword">if</span>(!r) <span class="keyword">continue</span>;</span><br><span class="line">				res-=r; val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">				<span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">bfs</span>();<span class="built_in">dfs</span>(s,inf));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,E[<span class="number">7</span>][<span class="number">7</span>],sum[<span class="number">7</span>],pw[<span class="number">7</span>],fa[<span class="number">7</span>],id[<span class="number">100</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,m) E[i][fa[i]]--,E[fa[i]][i]--;</span><br><span class="line">	s=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k=m;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m)</span><br><span class="line">		<span class="built_in">ff</span>(j,i,m)</span><br><span class="line">			<span class="keyword">if</span>(E[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">				++k;</span><br><span class="line">				id[k][<span class="number">0</span>]=i,id[k][<span class="number">1</span>]=j;</span><br><span class="line">				<span class="built_in">add</span>(s,k,E[i][j]);</span><br><span class="line">				<span class="built_in">add</span>(k,i+<span class="number">1</span>,inf);</span><br><span class="line">				<span class="built_in">add</span>(k,j+<span class="number">1</span>,inf);</span><br><span class="line">			&#125;</span><br><span class="line">	t=k+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m) <span class="built_in">add</span>(i+<span class="number">1</span>,t,sum[i]<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">dinic</span>();</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,pw[i],pw[fa[i]]);</span><br><span class="line">	<span class="built_in">fo</span>(u,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>((v=ver[i])!=t)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> j=(u<span class="number">-1</span>)^id[v][<span class="number">0</span>]^id[v][<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">fo</span>(tim,<span class="number">1</span>,val[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,pw[u<span class="number">-1</span>]+now,pw[j]),now++;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f[<span class="number">1</span>&lt;&lt;<span class="number">6</span>],g[<span class="number">1</span>&lt;&lt;<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">cle</span>(f); <span class="built_in">cle</span>(g);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m) g[<span class="number">1</span>&lt;&lt;i]=sum[i]<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m)</span><br><span class="line">		<span class="built_in">ff</span>(j,i,m)</span><br><span class="line">			f[<span class="number">1</span>&lt;&lt;i]+=E[i][j],f[<span class="number">1</span>&lt;&lt;j]+=E[i][j],</span><br><span class="line">			f[(<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;j)]-=E[i][j];</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		f[<span class="number">1</span>&lt;&lt;i]--,f[<span class="number">1</span>&lt;&lt;fa[i]]--,</span><br><span class="line">		f[(<span class="number">1</span>&lt;&lt;i)|(<span class="number">1</span>&lt;&lt;fa[i])]++;</span><br><span class="line">	<span class="built_in">ff</span>(s,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">lowbit</span>(s)^s)</span><br><span class="line">		&#123;</span><br><span class="line">			f[s]+=f[<span class="built_in">lowbit</span>(s)]+f[s^<span class="built_in">lowbit</span>(s)];</span><br><span class="line">			g[s]+=g[<span class="built_in">lowbit</span>(s)]+g[s^<span class="built_in">lowbit</span>(s)];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f[s]&lt;g[s]) <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u==m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x=i;</span><br><span class="line">			<span class="built_in">ff</span>(j,<span class="number">1</span>,m) x=fa[x];</span><br><span class="line">			<span class="keyword">if</span>(x) <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">check</span>();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(u!=i&amp;&amp;E[u][i])</span><br><span class="line">		&#123;</span><br><span class="line">			fa[u]=i;</span><br><span class="line">			<span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">			fa[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">char</span> s1[<span class="number">10</span>],s2[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> u,v;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1,s2);</span><br><span class="line">		u=<span class="built_in">strlen</span>(s1)<span class="number">-1</span>; v=<span class="built_in">strlen</span>(s2)<span class="number">-1</span>;</span><br><span class="line">		E[u][v]++;</span><br><span class="line">		<span class="keyword">if</span>(u^v) E[v][u]++;</span><br><span class="line">	&#125;</span><br><span class="line">	m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>,m++) sum[m]=<span class="built_in">min</span>(i*<span class="number">10</span>,n+<span class="number">1</span>)-i,pw[m]=i;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>Hall定理</tag>
        <tag>prufer数列</tag>
      </tags>
  </entry>
  <entry>
    <title>prufer数列</title>
    <url>/2020/07/02/prufer%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>prufer数列的一些基础。</p>
<span id="more"></span>

<p>prufer数列是一棵无根树所生成的数列，对于一棵有 $n$ 个点的树，它的prufer数列长度为 $n-2$。</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="树-gt-prufer数列"><a href="#树-gt-prufer数列" class="headerlink" title="树-&gt;prufer数列"></a>树-&gt;prufer数列</h3><p>我们定义一棵无根树中度数为 $1$ 的点是叶子。</p>
<p>将以下操作重复 $n-2$ 遍：</p>
<p>将树中编号最小的叶子拎出来，在数列末尾写上与这个叶子相连的点，然后删除这个叶子。</p>
<h3 id="prufer数列-gt-树"><a href="#prufer数列-gt-树" class="headerlink" title="prufer数列-&gt;树"></a>prufer数列-&gt;树</h3><p>定义集合 $A=\{1,2,\cdots,n\}$，将以下操作重复 $n-2$ 遍：</p>
<p>找到当前的 $A$ 中最小的不在当前数列的点 $x$，与数列开头的第一个点 $y$ 连边，在 $A$ 中删除 $x$，在数列中删除 $y$。</p>
<p>最后 $A$ 集合剩下的两个点连一条边。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol>
<li><p>prufer数列与树一一对应。</p>
</li>
<li><p>$n$ 个点的完全无向图的生成树个数是 $n^{n-2}$。（Caylay公式）</p>
</li>
<li><p>prufer数列中，某个点的出现次数+1=在树中该点的度数。证明显然。</p>
</li>
<li><p>对于每个点给定度数 $deg_u$，生成树个数为 $\frac{(n-2)!}{\prod(deg_u-1)!}$。</p>
<p>证明：由性质3，在长度为 $n-2$ 的prufer数列中，每个点 $u$ 的出现次数为 $deg_u-1$.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>prufer数列</tag>
      </tags>
  </entry>
  <entry>
    <title>Fox And Travelling[CF512D]</title>
    <url>/2020/07/01/Fox-And-Travelling-CF512D/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/512/problem/D">CF</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><ul>
<li>给定一张 $n$ 个点 $m$ 条边的无向图。</li>
<li>一个点只有当<strong>与它直接相连的点中最多只有一个点未被遍历过时</strong>才可被遍历。</li>
<li>询问对于每个$k\in [0,n]$，遍历 $k$ 个点的方案数。</li>
<li>$n\leq 100$，对 $10^9+9$ 取模。</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先来看看什么点是不能够被遍历的。</p>
<p>显然环中的点是不行的。两个环上点之间的路径上的点也是不行的。</p>
<p>可以发现，我们把整个图进行拓扑排序，有拓扑序的点就是能遍历的点。</p>
<p>那么把这些不能选的点去掉以后，剩下的是一堆树结构。这些树有两种情况：</p>
<ol>
<li>有根树，即根节点的父亲是不能被遍历的。</li>
<li>无根树，即可以乱选的。</li>
</ol>
<p>对于有根树我们直接进行树形背包DP，合并的时候乘一个组合数。</p>
<p>对于无根树，我们考虑沿用有根树的做法，对于每个点都来搞一次DP，然后将DP值相加。但发现会算重，对于一个选了 $k$ 个点的方案，那么在其他 $n-k$ 个点的DP中就会统计到它，因此最后将相加后的DP值除一个 $n-k$ 就好了。注意全选的时候是不用除的。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">20005</span>;</span><br><span class="line">ll fac[N],inv[N],ninv[N];</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Poly vector<span class="string">&lt;ll&gt;</span></span></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>+(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>*(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>()<span class="number">-1</span>,m=B.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	Poly C; C.<span class="built_in">resize</span>(n+m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">0</span>,n+m)</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(j,n))</span><br><span class="line">			<span class="keyword">if</span>(j-i&lt;=m)</span><br><span class="line">				C[j]=<span class="built_in">Add</span>(C[j],A[i]*B[j-i]%mod*(fac[j]*inv[i]%mod*inv[j-i]%mod)%mod);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>); <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">	ninv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) ninv[i]=(mod-mod/i)*ninv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">Poly ans,f[N],s;</span><br><span class="line"><span class="type">int</span> ver[M],ne[M],head[M],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"><span class="type">bool</span> flag[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	deg[x]++; deg[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(deg[i]&lt;=<span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); flag[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(!flag[v=ver[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				deg[v]--;</span><br><span class="line">				<span class="keyword">if</span>(deg[v]&lt;=<span class="number">1</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>; f[u].<span class="built_in">clear</span>(); f[u].<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">			<span class="built_in">dfs</span>(v,u),f[u]=f[u]*f[v];</span><br><span class="line">	f[u].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	f[u][f[u].<span class="built_in">size</span>()<span class="number">-1</span>]=f[u][f[u].<span class="built_in">size</span>()<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vec.<span class="built_in">pb</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i]) <span class="keyword">if</span>((v=ver[i])!=pre) <span class="built_in">dfs2</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">topo</span>();</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	ans.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=ver[i&lt;&lt;<span class="number">1</span>],y=ver[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(!flag[x]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span>(flag[x]&amp;&amp;!flag[y])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(x,y);</span><br><span class="line">			ans=ans*f[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(flag[i]&amp;&amp;!vis[i])</span><br><span class="line">	&#123;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">dfs2</span>(i,<span class="number">0</span>);</span><br><span class="line">		s.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> u:vec)<span class="built_in">dfs</span>(u,<span class="number">0</span>),s=s+f[u];</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,vec.<span class="built_in">size</span>()) s[i]=s[i]*ninv[vec.<span class="built_in">size</span>()-i]%mod;</span><br><span class="line">		ans=ans*s;</span><br><span class="line">	&#125;</span><br><span class="line">	ans.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序[NOI2018]</title>
    <url>/2020/06/30/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-NOI2018/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://loj.ac/problem/2719">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然我们需要分析一下达到交换次数下界的排列的充要条件。</p>
<p>如果有三个数 $a_i,a_j,a_k (i &lt; j &lt; k)$ 满足 $a_i&gt;a_j&gt;a_k$，那么这个排列一定不合法。因为 $a_j$ 至少要向右和向左都交换一次，那么这两次交换对这个 $a_j$ 是毫无意义的。</p>
<p>那么剩下的情况只有最长下降子序列长度不超过 $2$ 的情况。可以发现，这样的情况一定合法。</p>
<p>如果不考虑字典序的限制，只统计有多少个排列满足最长下降子序列长度不超过 $2$。</p>
<p>尝试DP，设 $f_{i,j}$ 表示考虑到第 $i$ 位，前缀最大值为 $j$ 的方案数。看看 $f_{i,j}$ 能转移到哪里去。显然 $f_{i+1,k}(k&gt;j)$ 是一定可以的，且系数是 $1$。那么能否转移到 $f_{i+1,j}$ 呢？可以发现，如果你第 $i+1$ 位填的不是前 $i$ 位最小的没有出现过的正整数 $t$ 的话，后面一定会填上这个 $t$，此时 $j,a_{i+1},t$ 就会形成一个长度为 $3$ 的下降子序列了。因此 $f_{i,j}$ 给 $f_{i+1,j}$ 的贡献的系数为 $1$，且必须满足 $i+1\leq j$（不然就没数可填了）。</p>
<p>考虑这个 $f_{i,j}$ 的组合意义，显然是从 $(0,0)$ 开始走，每次可以往右边且纵坐标不比当前点小的格点走，不经过 $y=x-1$，走到 $(n,n)$ 的方案数。</p>
<p>用折线法容斥一下，把不经过直线的限制去掉。剩下的是一个组合数。</p>
<p>现在考虑字典序的限制。假设我们从第 $i$ 位开始打破字典序的限制，那么就相当于前面的情况，只不过不是从 $(0,0)$ 开始走罢了。</p>
<p>预处理组合数，枚举从哪一位开始打破限制就好了。注意及时break。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1200010</span>;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>); <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p[N],mx,pos;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">C</span>(<span class="number">2</span>*n-x-y,n-y)-<span class="built_in">C</span>(<span class="number">2</span>*n-x-y,n-y<span class="number">-1</span>)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">1200000</span>);</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>(),vis[i]=<span class="number">0</span>;</span><br><span class="line">		mx=<span class="number">0</span>; pos=<span class="number">1</span>; ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(;vis[pos];pos++);</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,<span class="built_in">calc</span>(i<span class="number">-1</span>,<span class="built_in">max</span>(mx,p[i])+<span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span>(mx&gt;p[i]&amp;&amp;p[i]&gt;pos) <span class="keyword">break</span>;</span><br><span class="line">			mx=<span class="built_in">max</span>(mx,p[i]); vis[p[i]]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>思维题</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>yja[jzoj5606]</title>
    <url>/2020/06/30/yja-jzoj5606/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在平面上找 $n$ 个点, 要求这 $n$ 个点离原点的距离分别为 $r_1, r_2, \cdots, r_n$。 最大化这 $n$ 个点构成的凸包面积。凸包上的点的顺序任意。</p>
<p>$n\leq 8,r_i\leq 1000$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>拉格朗日乘数法模板题。</del></p>
<p>由于 $n$ 比较小，我们可以暴力枚举这 $n$ 个点顺时针的顺序，一共有 $(n-1)!$ 种。$n$ 个点分别和原点连线，设这 $n$ 条直线的夹角为 $\alpha <em>i$，显然 $a_i$ 不会超过 $\pi$ 。凸包面积为 $\frac{1}{2}\sum</em>{i=1}^nr_ir_{i\% n+1}\sin\alpha_i$。</p>
<p>好看一点，设 $R_i=r_ir_{i \% n+1}$，我们需要最大化 $\sum_{i=1}^nR_i\sin \alpha _i$，满足条件 $\sum \alpha_i=2\pi$。</p>
<p>由拉格朗日乘数法的套路，设函数 $F(\alpha_1,\alpha_2,\cdots,\alpha_n,\lambda)=\sum_{i=1}^nR_i\sin \alpha <em>i+\lambda(2\pi-\sum</em>{i=1}^n\alpha_i)$。</p>
<p>求偏导数可得：</p>
<p>$$\frac{\partial F}{\partial \alpha_i}=R_i\cos {\alpha_i}-\lambda=0 \\ \frac{\partial F}{\partial \lambda}=2\pi-\sum_{i=1}^na_i=0$$</p>
<p>也就是：$\cos \alpha_i=\frac{\lambda}{R_i}$。</p>
<p>当 $0\leq \alpha_i\leq \pi$ 时，$\cos \alpha_i$ 单调递减。</p>
<p>满足单调性，那么我们就可以二分这个 $\lambda$，然后就可以算出此时的 $a_i$ 了。</p>
<p>时间复杂度 $O(n!\log Ans)$。</p>
<p><strong>注意二分的范围</strong></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line">db ans;</span><br><span class="line"><span class="type">int</span> n,l[<span class="number">9</span>],pos[<span class="number">9</span>],bo[<span class="number">9</span>];</span><br><span class="line">db R[<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	db mi=<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) mi=<span class="built_in">min</span>(mi,R[i]=l[pos[i]]*l[pos[i%n+<span class="number">1</span>]]);</span><br><span class="line">	db l=-mi,r=mi,mid,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(tim,<span class="number">0</span>,<span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2.</span>;</span><br><span class="line">		sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=<span class="built_in">acos</span>(mid/R[i]);</span><br><span class="line">		<span class="keyword">if</span>(sum&lt;pi*<span class="number">2</span>) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=<span class="built_in">sin</span>(<span class="built_in">acos</span>(mid/R[i]))*R[i];</span><br><span class="line">	ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;n) <span class="keyword">return</span> <span class="built_in">solve</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="keyword">if</span>(!bo[i])</span><br><span class="line">	&#123;</span><br><span class="line">		bo[i]=<span class="number">1</span>; pos[k]=i; <span class="built_in">dfs</span>(k+<span class="number">1</span>);</span><br><span class="line">		pos[k]=<span class="number">0</span>; bo[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(yja);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;l[i]);</span><br><span class="line">	bo[<span class="number">1</span>]=<span class="number">1</span>; pos[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,ans/<span class="number">2.</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>拉格朗日乘数法</tag>
      </tags>
  </entry>
  <entry>
    <title>Sanrd[uoj188]</title>
    <url>/2020/06/29/Sanrd-uoj188/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://uoj.ac/problem/188">uoj</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求 $[l,r]$ 内整数的次大质因子（重复算多次）的和。质数的次大质因子为 $0$。</p>
<p>$l+r,r\leq 10^{11}$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看着数据范围显然要往Min25的方向去想。</p>
<p>但是这个东西并不是积性函数。我们考虑Min25的第二部分，即求 $S(n,j)$ 的地方。</p>
<p>普通的Min25筛做法是分别考虑质数与合数的贡献，这里质数的贡献是 $0$。那么只需考虑合数部分。</p>
<p>还是像Min25筛的套路，枚举最小的质因子 $P_k$ 以及他的幂次 $q$，如果此时这个质因子不是次大的质因子，那么贡献就是 $S(\frac{n}{P_k^q},k+1)$，否则就是 $P_k$ 乘上 $[1,\frac{n}{P_k^q}]$ 中的质数个数。</p>
<p>那么只需要预处理出所有形如 $\frac{n}{i}$ 的质数个数就好了。</p>
<p>这个用Min25的前半部分即可。</p>
<p>时间复杂度 $O(\frac{n^{\frac{3}{4}}}{\log n})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e6</span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line">ll pri[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) vis[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) pri[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;<span class="number">1ll</span>*pri[j]*i&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll now_n,f[N],w[N];</span><br><span class="line"><span class="type">int</span> id1[N],id2[N];</span><br><span class="line"><span class="type">int</span> Sqr,m;</span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(pri[j]&gt;n||n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll sum=<span class="number">0</span>,tmp,x; <span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=j;<span class="number">1ll</span>*pri[i]*pri[i]&lt;=n&amp;&amp;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;tmp*pri[i]&lt;=n;tmp*=pri[i],k++)</span><br><span class="line">		&#123;</span><br><span class="line">			x=n/tmp;</span><br><span class="line">			y=(x&lt;=Sqr)?id1[x]:id2[now_n/x];</span><br><span class="line">			sum+=<span class="built_in">S</span>(x,i+<span class="number">1</span>)+<span class="number">1ll</span>*pri[i]*(f[y]-(i<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sqr=<span class="built_in">sqrt</span>(n); m=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j=n/(n/i);</span><br><span class="line">		w[++m]=n/i;</span><br><span class="line">		w[m]&lt;=Sqr?id1[w[m]]=m:id2[n/w[m]]=m;</span><br><span class="line">		f[m]=w[m]<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll x; <span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt&amp;&amp;<span class="number">1ll</span>*pri[i]*pri[i]&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;<span class="number">1ll</span>*pri[i]*pri[i]&lt;=w[j];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			x=w[j]/pri[i];</span><br><span class="line">			y=(x&lt;=Sqr)?id1[x]:id2[n/x];</span><br><span class="line">			f[j]-=f[y]-(i<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	now_n=n;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">S</span>(n,<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll l,r,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">	<span class="built_in">init</span>(<span class="built_in">sqrt</span>(r));</span><br><span class="line">	cout&lt;&lt;<span class="built_in">solve</span>(r)-<span class="built_in">solve</span>(l<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>Min25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforce Global Round 8[CF1368]</title>
    <url>/2020/06/28/Codeforce-Global-Round-8-CF1368/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1368/problems">Codeforce Global Round 8</a></p>
<span id="more"></span>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>对于每一个二进制位，无论如何操作，1的个数都是不会变化的。</p>
<p>假设你现在进行一次操作，原本是 $x,y(x\leq y)$，现在变成了 $x-z,y+z(z\leq 0)$，那么贡献的差就是 $(x-z)^2+(y+z)^2-(x^2+y^2)=2(y-x)z+z^2\geq 0$。</p>
<p>也就是最大值越大越好。那么从大到小，对于每一位贪心即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,x,cnt[<span class="number">21</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;x) cnt[j]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">if</span>(cnt[j]) x|=(<span class="number">1</span>&lt;&lt;j),cnt[j]--;</span><br><span class="line">		ans+=<span class="number">1ll</span>*x*x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>占坑。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>一道不错的交互题。</p>
<p>我们用 $1$ 表示环上的这个灯是亮着的。</p>
<p>我们先来看看如何算出 $R(n)$。首先，假设环上已经有了 $m$ 个点，你现在考虑加 $x$ 个点进去。如果要产生贡献的话，这 $m+x$ 个点所连成的最大连续的段的长度最多是 $x-1$。也就是说，这些连续段最多有 $\left \lceil \frac{m+x}{x-1} \right \rceil$ 段，也就是 $0$ 的个数最少要有 $\left \lceil \frac{m+x}{x-1} \right \rceil$ 个。那么列出不等式：$m+x+\left \lceil \frac{m+x}{x-1} \right \rceil\leq n$。</p>
<p>解得 $m\leq n-\left \lceil \frac{n}{x} \right \rceil-x$。</p>
<p>由于 $m$ 此时还能产生贡献，那么 $R(n)$ 就等于 $m$ 的最大值加 $1$。</p>
<p>这时候我们算出了一个 $x$，表示每次操作后不能使得有一个段的长度大于等于 $x$。那么每隔 $x$ 个就设置一个点，表示无论如何都不能放 $1$ 在这上面。</p>
<p>然后一直选不在这些点且灯是关着的 $x$ 个点，直到大于等于 $R(n)$ 时结束就好了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> a[<span class="number">1010</span>],flag[<span class="number">1010</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:v) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	<span class="type">int</span> u; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u); <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>,k=<span class="number">0</span>,tmp;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		tmp=n-(n+i<span class="number">-1</span>)/i-i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mx&lt;tmp) mx=tmp,k=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=k) flag[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>,tim=k;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(a[i]) sum++;</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=mx)&#123; <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!a[i]&amp;&amp;!flag[i])</span><br><span class="line">		&#123;</span><br><span class="line">			tim--;</span><br><span class="line">			vec.<span class="built_in">pb</span>(i); a[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!tim) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">ask</span>(vec);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">		&#123;</span><br><span class="line">			a[u]=<span class="number">0</span>;</span><br><span class="line">			u++;</span><br><span class="line">			<span class="keyword">if</span>(u&gt;n) u=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title>GDOI2020退役记</title>
    <url>/2020/06/21/GDOI2020%E9%80%80%E5%BD%B9%E8%AE%B0/</url>
    <content><![CDATA[<p>退役失败！</p>
<span id="more"></span>

<h3 id="Day-约-150"><a href="#Day-约-150" class="headerlink" title="Day 约-150"></a>Day 约-150</h3><p>由于众所周知的原因，我开始在家里学习OI。这期间听了中大学生的课，以及做了他们出的模拟赛，Zayin的题质量好评。</p>
<h3 id="Day-约-40"><a href="#Day-约-40" class="headerlink" title="Day 约-40"></a>Day 约-40</h3><p>开学的第二天停课了。</p>
<p>一开始在loj等大量刷题。</p>
<p>然后过了几天后开始在jz的gmoj上做题。</p>
<p>学到了很多新姿势和算法，越来越熟练了。</p>
<p>考前模拟赛ITcarrot爆切大数据结构，惨遭爆锤；初二的lsd，zzh爆切多项式，惨遭爆锤 $\times 2$。</p>
<h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>下午3点出发，来到了广州大学城<del>大学城是真的大</del>。</p>
<p>住的房间极大无比，然后他们又把我推去一个人一间房<del>第二天可以换一张床睡</del>。在房间里复习到5点多决定去吃完饭，结果最后叫了M记的外卖。</p>
<p>没带牌，于是开始颓generals和皇室。</p>
<p>11点05就睡下了。</p>
<p>一个人一间房真的爽。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>早上7点起床看到了好朋友的祝福，温暖，感动，幸福，也更加放松更加自信了，觉得或许就是最后一次比赛了，加油就是了。</p>
<p>通过打的的方式去到了广大附，结果老师他们去了正门。正当我们想走过去时，侧门的所有人同时把我们喊回来了，说只有侧门能进。</p>
<p>结果他们竟然也从正门溜了进去（</p>
<p>8点15就进去了考场，结果发现没人试机，发现有Sublime可用，压缩包解压密码乱码差评。</p>
<p>先看T1，似乎是个线段树二分，T3不太可做，T2裸出计数题，那应该不会太简单吧，先放着，去写T1。</p>
<p>分析5min后发现是线段树二分无疑，9点左右开始写，决定先写暴力。</p>
<p>但是总感觉暴力极其难写，加上一个智障错误，写了快半个小时。</p>
<p>然后开始码线段树上二分，由于细节极多无比写了快大半个小时。结果发现大样例过不了，且只有第一个数是错的。</p>
<p>想了想细节，似乎发现自己看错题了，然后魔改代码发现一直过不去。这时自己想放弃，但想到这么些年的努力不应该就这样白费，提醒自己必须做出这道题，过了几分钟后就清醒了。</p>
<p>再回去留神题意发现自己没读错。然而这时候已经过了10点半了。</p>
<p>于是又改了改了线段树，调了好几个错之后大样例对了，这时已经11点了，赶紧造了数据对拍，没有出错，在11点15分时拍上了。</p>
<p>赶紧开第二题，然后发现把多项式拆开，然后用第二类斯特林数将幂转换成下降幂，然后再用组合数的一些性质搞一下，最后二项式定理就好了。</p>
<p><del>怎么可以出这么裸的题啊</del></p>
<p>但是我的神奇做法要用到 $x$ 的逆元，然而 $x$ 有时候是没有逆元的，没管那么多了。直接开码。</p>
<p>期间发现自己的式子推错了一两个地方，都是些小问题。</p>
<p>最后在12点多时做对了这个神奇做法。然后我神奇的发现是可以不用 $x$ 的逆元的，然后改了一下，在12点半的程序就过了小样例。然后发现自己智障的在快速幂时将幂次模了个 $mod-1$，改了之后大样例也过了。</p>
<p>这时候已经12点45了，决定跑去再看一下T1，直接弃疗T3。。。</p>
<p>出来以后发现大众分200+，完了看来是要垫底了。</p>
<p>最后T1还被卡了几个点，变成了90分。</p>
<p>中午去了某个商场吃饭，然后踩单车回去，在酒店颓了一个下午。</p>
<p>晚饭用华莱士解决。</p>
<p>晚上和好朋友聊到了12点多才睡。</p>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>早上起来发现有点困，于是洗了个脸后精神了一点。</p>
<p>开始后先看T1，应该是一道卡常+状压Dp题，先放着。然后看一眼T2，发现秒了，不就是dsu on tree+Trie嘛，<del>两个log，能过能过</del>。再看一眼T3，似乎是矩阵树+莫反的嵌套题。</p>
<p>于是决定先开T2。20min码完发现自己直接过了大样例？？然后开T3，分析一波复杂度发现过不去，分析一波发现不会（我怎么就没想到用多项式，我怎么就没用链式前向星），不管了，开始码了，30min后又直接过了所有的样例，我有点慌，于是把两题对拍都打了，发现都过了。</p>
<p>这时候才11点，发现还有两个小时做T1。</p>
<p>显然状压Dp可直接获得六七十分，然后发现某个东西可以预处理一下，就变成 $O(m2^m)$ 了。</p>
<p>但是我的做法空间是 $O(m2^m)$ 的，过不去，于是发现可以减少一位，那么 $23\times 2^{22}$ 个int才300多M，于是在12点多的时候搞定了。</p>
<p>发现T1有点卡，然后优化不了了，也没想到其他做法。</p>
<p>于是对着电脑十分无聊得过了大半个小时，发现电脑上没有扫雷。</p>
<p>中午何老师请吃必胜客，中途遇到SM的好友拍了张照。</p>
<p>10个人点了6个pizza。</p>
<p>感觉要退役了，于是准备去学文化课。</p>
<p>回到机房上了六楼想看电影，结果听到了轩攸分享SM的日食十分快乐，然后就忘记看了。</p>
<h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>多停了一天的课，在机房又休息了一天。</p>
<h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>回去上文化课，上着上着语文课手机突然在震，发现分数出了，$90+100+0+80+100+70$，被卡掉了 $60$ 分，然后还是排到了14名。十分激动，在语文课上哭了出来。</p>
<p>上完课立刻把消息告诉了给家人和好朋友。</p>
<p>于是就退役失败啦。</p>
<p>中午由于某种原因十分感动，又大哭了一场。</p>
<h3 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h3><p><del>成功达成成就：在本学期内只上了两天的课。</del></p>
<p>又回到了熟悉的机房。</p>
<p>因为昨天中午的这个某种原因，写了一篇朋友圈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GDOI2020退役记：</span><br><span class="line"></span><br><span class="line">退役失败。</span><br><span class="line"></span><br><span class="line">记得那是还很小的六年级，第一次听说了OI。</span><br><span class="line">那是还很懵懂的初一，第一次参加NOIP，刚开始还觉得自己没能考进复赛大哭一场，结果复赛刚好压线搞了个普及一等奖。也是第一次体验了省选。</span><br><span class="line">那是还很水的初三，第一次参加了NOIP的提高组，结果顺利水到了一等十分开心。</span><br><span class="line">不知怎的就考上了华附，与很多好朋友分开了。</span><br><span class="line"></span><br><span class="line">由于初三一年几乎没学过，很多知识也已经忘记。以及接下来若干次比赛的失利，让我觉得自己或许真的不适合走这条路。看着学长和同学的退役，脑海里也不止一次想过放弃的念头。</span><br><span class="line">或许是坚韧，是顽强，是那想要证明自己的决心，让我一直坚持着。</span><br><span class="line"></span><br><span class="line">是时候了。</span><br><span class="line"></span><br><span class="line">需要感谢我的亲人。或许你们不太了解这一条路，但自始至终都一直支持我鼓励我，想尽办法让我放松心情。你们永远都是我最亲爱，最重要的人。</span><br><span class="line"></span><br><span class="line">需要感谢我的教练，老师。谢谢李老师，刘老师，广爷，吴老师作为我的班主任给予的支持；是黄靖老师，带我走进那属于OI的浩瀚星空；是张思胜老师，像朋友般的关心我，为我加油；是何，梁，黄老师两年来的辛勤付出与深切教诲，让我离梦想更近一步。你们是一条鞭子，让我前行，也是一缕春风，温暖心脾。</span><br><span class="line"></span><br><span class="line">还有我的好友们。你们给我的那些n年来一起走过的时光，带给我的快乐，支持，我想我没有忘记，不敢忘记，也不会忘记，这像是那隐形的翅膀，助我飞翔：万分感谢轩攸带给我的运气，和一直以来的关心；Snakes学长，祝你的高考能像中考那般辉煌；同级的ITcarrot,aspe,dddmh,henry_he,Malzahar,HelloElwin,MCPlayer542,Kevin327,Eabo,beng,zqq和外校的朋友，也祝福你们的高三过得幸福，充实；也祝hsfzLZH1,KesdiaelKen,JC,qfr,白井黑子,BilyHurington,zengxy,Hermione_Granger,gzchenben等，能在后几年的省选中发挥出色，成功女装（雾</span><br><span class="line"></span><br><span class="line">NOI2020加油!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title>tree[jzoj6511]</title>
    <url>/2020/06/14/tree-jzoj6511/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/tree-jzoj6511/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然直接算是非常不好算的。因为有 $3$ 个数，如果能减少到枚举两个数或者一个就更好了。</p>
<p>对于一条有向的路径 $(u,v)$，我们定义 $W_{u,v}$ 为该路径权值模 $P$ 后是否不为 $0$。</p>
<p>那么一共有 $2^3=8$ 种情况，我们需要算的只有两种。</p>
<p>无论如何，先列个表看看再说：</p>
<table>
<thead>
<tr>
<th align="center">$W_{u,v}$</th>
<th align="center">$W_{u,t}$</th>
<th align="center">$W_{t,v}$</th>
<th align="center">是否计算</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">Yes</td>
</tr>
<tr>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">$1$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$0$</td>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$0$</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">$0$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">$1$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$0$</td>
<td align="center">No</td>
</tr>
<tr>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">$1$</td>
<td align="center">Yes</td>
</tr>
</tbody></table>
<p>考虑容斥，看看不计算的能不能算，最后用 $n^3$ 减去就好了。</p>
<p>我们发现，不需要计算的情况都包含两组 $W$ ，满足这两种 $W$ 的值是不相等的。</p>
<p>那么可以枚举这两组 $W$ 是哪两组，剩下那组不管它，然后把方案数加起来后，除以 $2$ 就是答案了。</p>
<p>分三类讨论：</p>
<ol>
<li>$W_{u,v}\not = W_{u,t}$</li>
<li>$W_{u,v}\not = W_{t,v}$</li>
<li>$W_{u,t}\not = W_{t,v}$</li>
</ol>
<p>这样来看，我们只需要对于每个点 $u$，都算出 $W_{u,i}=0$ 和 $W_{i,u}=0$ 有多少种，这样就可以算出答案了。</p>
<p>至此，我们把枚举三个点变成了枚举两个点的路径问题。</p>
<p>跟树上所有的路径相关的，考虑点分治。</p>
<p>对于点分治过程中的一个分治结构，我们考虑用容斥的方法减去子树自己对自己的贡献。</p>
<p>那么只需要考虑一条经过分治中心的一条链的权值怎么算就好了。</p>
<p>先来看 $W_{i,u}$ 如何计算。</p>
<p><img src="/tree-jzoj6511/tree.png" alt="tree"></p>
<p>如图，$w_i,l_i$ 表示为该链（有方向）的权值以及长度。</p>
<p>那么将这两条链合起来的权值就是：$w_2\times K^{l_1}+w_1$</p>
<p>要使得这个权值为 $0$，则有：$w_2=\frac{-w_1}{K^{l_1}}$。</p>
<p>$W_{u,i}$ 同理。</p>
<p>那么先来一次dfs，用个 map 或者哈希记录 $\frac{-w_1}{K^{l_1}}$ 的出现次数，然后再来一次dfs统计即可。</p>
<p>时间复杂度 $O(n\log n)$ 或 $O(n\log ^2n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line">ll base,mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> siz[N],mx[N],rt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll pw[N],iw[N],w[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; mx[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre&amp;&amp;!vis[v])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">getroot</span>(v,u,S);</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">		mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[u],S-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(mx[rt]&gt;mx[u]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; g[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> now_siz;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> len,ll w1,ll w2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g[<span class="number">0</span>][(mod-w1)*iw[len]%mod]++; g[<span class="number">1</span>][w2]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!vis[v]&amp;&amp;(v!=pre))</span><br><span class="line">		<span class="built_in">dfs</span>(v,u,len+<span class="number">1</span>,(w1+w[v])*base%mod,(w2+w[v]*pw[len+<span class="number">1</span>])%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> opt,<span class="type">int</span> len,ll w1,ll w2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp;</span><br><span class="line">	tmp=(mod-w2)*iw[len]%mod;</span><br><span class="line">	<span class="keyword">if</span>(g[<span class="number">1</span>].<span class="built_in">count</span>(tmp)) f[u][<span class="number">0</span>][<span class="number">0</span>]+=opt*g[<span class="number">1</span>][tmp];</span><br><span class="line">	tmp=w1;</span><br><span class="line">	<span class="keyword">if</span>(g[<span class="number">0</span>].<span class="built_in">count</span>(tmp)) f[u][<span class="number">1</span>][<span class="number">0</span>]+=opt*g[<span class="number">0</span>][tmp];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!vis[v]&amp;&amp;(v!=pre))</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u,opt,len+<span class="number">1</span>,(w1+w[v]*pw[len+<span class="number">1</span>])%mod,(w2+w[v])*base%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g[<span class="number">0</span>].<span class="built_in">clear</span>(); g[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(u,pre,<span class="number">1</span>,w[u]*base%mod,w[u]*base%mod);</span><br><span class="line">		<span class="built_in">dfs2</span>(u,pre,opt,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(u,pre,<span class="number">2</span>,(w[pre]*base%mod+w[u])%mod*base%mod,(w[u]*base%mod+w[pre])%mod*base%mod);</span><br><span class="line">		<span class="built_in">dfs2</span>(u,pre,opt,<span class="number">1</span>,w[u]*base%mod,w[u]*base%mod);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	now_siz=S; <span class="built_in">calc</span>(u,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!vis[v])</span><br><span class="line">	&#123;</span><br><span class="line">		now_siz=(siz[u]&lt;siz[v])?S-siz[u]:siz[v];</span><br><span class="line">		<span class="built_in">calc</span>(v,u,<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!vis[v])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> Si=(siz[u]&lt;siz[v])?S-siz[u]:siz[v];</span><br><span class="line">		rt=<span class="number">0</span>; <span class="built_in">getroot</span>(v,u,Si); <span class="built_in">divide</span>(rt,Si);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*f[u][x][<span class="number">0</span>]*f[u][y][<span class="number">1</span>]+<span class="number">1ll</span>*f[u][x][<span class="number">1</span>]*f[u][y][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(tree);</span><br><span class="line">	n=<span class="built_in">read</span>(); base=<span class="built_in">read</span>(); mod=<span class="built_in">read</span>();</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>; iw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	pw[<span class="number">1</span>]=base; iw[<span class="number">1</span>]=<span class="built_in">Pow</span>(base,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) pw[i]=pw[i<span class="number">-1</span>]*pw[<span class="number">1</span>]%mod,iw[i]=iw[i<span class="number">-1</span>]*iw[<span class="number">1</span>]%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) w[i]=<span class="built_in">read</span>()%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	mx[<span class="number">0</span>]=<span class="number">1e9</span>; rt=<span class="number">0</span>; <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>,n); <span class="built_in">divide</span>(rt,n);</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) f[i][j][<span class="number">1</span>]=n-f[i][j][<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sum+=<span class="built_in">work</span>(i,<span class="number">1</span>,<span class="number">1</span>)+<span class="built_in">work</span>(i,<span class="number">0</span>,<span class="number">0</span>)+<span class="built_in">work</span>(i,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">1ll</span>*n*n*n-(sum/<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>匹配字符串[loj547]</title>
    <url>/2020/06/12/%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2-loj547/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/547">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>这个idea我之前想过了。。。但只想到了52分</del></p>
<p>首先有一个很显然的DP，设 $f_{i}$ 表示长度为 $i$ 的字符串，且第 $i$ 位必须选 $0$ 的合法方案数，则有：</p>
<p>$$f_i=\sum_{j=1}^{\min\{i,m\}}f_{i-j}$$</p>
<p>对于 $m$ 的大小，我们进行分类讨论。</p>
<h4 id="m-leq-2500"><a href="#m-leq-2500" class="headerlink" title="$m\leq 2500$"></a>$m\leq 2500$</h4><p>上述的DP方程可以用常系数线性齐次递推，暴力多项式取模，时间复杂度为 $O(m^2\log n)$。</p>
<h4 id="otherwise"><a href="#otherwise" class="headerlink" title="otherwise"></a>otherwise</h4><p>我们考虑前缀和，设 $s_i=\sum_{j=1}^if_j$。</p>
<p>那么上面的式子就是：$s_i-s_{i-1}=s_{i-1}-s_{i-m-1}$。</p>
<p>即：$s_i=2s_{i-1}-s_{i-m-1}$。</p>
<p>这个相当于是在数轴上走，走到 $i+m+1$，就贡献 $-1$，走到 $i+1$，就贡献 $2$。</p>
<p>由于走 $i+m+1$ 的次数比较少，那么可以枚举这个次数，因此有：</p>
<p>$$s_n=\sum_{i=0}\binom{n-im}{i}2^{n-i(m+1)}(-1)^i$$</p>
<p>组合数用Lucas定理计算即可。</p>
<p>时间复杂度 $O(\frac{n}{m}\times \log _{65537}n)$</p>
<p><strong>注意 $m=1$ 的特判。</strong></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">65537</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> CM&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line">	ll f[N],g[N],h[N],b[N],c[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,k) <span class="built_in">fo</span>(j,<span class="number">0</span>,k) c[i+j]=<span class="built_in">Add</span>(c[i+j],a[i]*b[j]%mod);</span><br><span class="line">		<span class="built_in">fd</span>(i,k&lt;&lt;<span class="number">1</span>,k) <span class="built_in">fo</span>(j,<span class="number">0</span>,k) c[i+j-k]=<span class="built_in">Dec</span>(c[i+j-k],c[i]*g[j]%mod);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,k<span class="number">-1</span>) a[i]=c[i],c[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ppow</span><span class="params">(ll *a,ll n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		a[<span class="number">0</span>]=<span class="number">1</span>; b[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,<span class="built_in">mul</span>(b,b,m)) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">mul</span>(a,b,m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		h[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) h[i]=(h[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> h[n];</span><br><span class="line">		g[m]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,m) g[i]=mod<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">Ppow</span>(f,n,m);</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) ans=<span class="built_in">Add</span>(ans,f[i]*h[i]%mod); </span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Lucas&#123;</span><br><span class="line">	ll fac[mod],inv[mod];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;mod) <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">C</span>(n%mod,m%mod)*<span class="built_in">C</span>(n/mod,m/mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ll tmp=<span class="built_in">Pow</span>(<span class="built_in">Pow</span>(<span class="number">2</span>,m+<span class="number">1</span>),mod<span class="number">-2</span>),now=<span class="built_in">Pow</span>(<span class="number">2</span>,n),ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n/(m+<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i&amp;<span class="number">1</span>) ans-=<span class="built_in">C</span>(n-m*i,i)*now%mod;</span><br><span class="line">			<span class="keyword">else</span> ans+=<span class="built_in">C</span>(n-m*i,i)*now%mod;</span><br><span class="line">			now=now*tmp%mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (ans%mod+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,mod<span class="number">-1</span>) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		inv[mod<span class="number">-1</span>]=<span class="built_in">Pow</span>(fac[mod<span class="number">-1</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">fd</span>(i,mod<span class="number">-1</span>,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">work</span>(n+<span class="number">1</span>)-<span class="built_in">work</span>(n)+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(m&lt;=<span class="number">2500</span>)?CM::<span class="built_in">solve</span>():Lucas::<span class="built_in">solve</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>常系数线性齐次递推</tag>
        <tag>Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到塞莱斯特山[jzoj6506]</title>
    <url>/2020/06/12/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%A1%9E%E8%8E%B1%E6%96%AF%E7%89%B9%E5%B1%B1-jzoj6506/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E5%A1%9E%E8%8E%B1%E6%96%AF%E7%89%B9%E5%B1%B1-jzoj6506/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先，因为是在一棵树上，我们不妨考虑的是树形DP。那么来看一棵子树应该如何设计状态。</p>
<p>子树 $u$ 中的点在排列上形成了若干个不相交的段。在DP的时候我们需要合并$u$ 的子树的结果，也就是将若干个段合成几个段。如果两个不同子树的段在这时合成了一段，那么这两个段的衔接处就会产生一个 $dep_u$ 的贡献。</p>
<p>因此，我们可以设计状态为 $f_{u,i}$ 表示考虑子树 $u$ 时，一共有 $i$ 个段，段与段之间有序的方案数。</p>
<p>那么考虑枚举 $u$ 的子树 $v$，然后将贡献合并到 $u$ 那里去。</p>
<p>枚举 $i,j,k$，有</p>
<p>$$f’<em>{u,k}=\sum</em>{i}\sum_{j}f_{u,i}\times f_{v,j}\times g_{i,j,k}\times dep_u^{i+j-k}$$</p>
<p>其中，$g_{i,j,k}$ 为将两种不同的段，第一种有 $i$ 个段，第二种有 $j$ 个，合并成 $k$ 个段的方案数（段与段之间有序）。</p>
<p>那么，枚举合并之后 $k$ 个段中，第一个段是怎么来的。分三种情况讨论，得到：</p>
<p>$$g_{i,j,k}=(2\times \sum_{l=1}g_{i-l,j-l,k-1})+\sum_{l=0}g_{i-l,j-l-1,k-1}+\sum_{l=0}g_{i-l-1,j-l,k-1}$$</p>
<p>发现这三个都是一个前缀和的形式，用前缀和优化一下即可达到 $O(n^3)$ 的预处理。</p>
<p>时间复杂度 $O(n^3)$。</p>
<p>注意树上背包的时候需要按照子树大小来搞，不然复杂度不对。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> dep[N],siz[N];</span><br><span class="line">ll f[N][N],h[N],s[N&lt;&lt;<span class="number">1</span>][N],pw[N][N];</span><br><span class="line"><span class="type">int</span> g[N][N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; f[u][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">	&#123;</span><br><span class="line">		dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u])</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,siz[v])</span><br><span class="line">				<span class="built_in">fo</span>(k,<span class="built_in">max</span>(i-j,<span class="number">1</span>),i+j)</span><br><span class="line">					h[k]=<span class="built_in">Add</span>(h[k],<span class="built_in">Mul</span>(f[u][i]*f[v][j]%mod,pw[dep[u]][i+j-k]*g[i][j][k]%mod));</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,siz[u]) f[u][i]=h[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) h[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(tree);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) adj[<span class="built_in">read</span>()].<span class="built_in">pb</span>(i);</span><br><span class="line">	g[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m=n+<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n)</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,n-i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i+j&gt;=k) g[i][j][k]=(s[i-j+m][k<span class="number">-1</span>]*<span class="number">2</span>%mod+(s[i-j+<span class="number">1</span>+m][k<span class="number">-1</span>]+s[i-j<span class="number">-1</span>+m][k<span class="number">-1</span>]))%mod;</span><br><span class="line">				s[i-j+m][k<span class="number">-1</span>]=<span class="built_in">Add</span>(s[i-j+m][k<span class="number">-1</span>],g[i][j][k<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		pw[k][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pw[k][i]=pw[k][i<span class="number">-1</span>]*k%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>圣痕[jzoj6496]</title>
    <url>/2020/06/11/%E5%9C%A3%E7%97%95-jzoj6496/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%9C%A3%E7%97%95-jzoj6496/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然是需要二分半径的。</p>
<p>那么二分完之后，如何判断两个直线的交点是否在圆内呢？</p>
<p>可以求出直线与圆的交点，这两个交点形成了一个扇形。</p>
<p>当且仅当两条直线所代表的扇形出现重合部分，且不是覆盖关系，那么交点即在圆内。</p>
<p>那么将这些交点按极角排序。变成线段上的问题，问在这些线段中选出两个满足上述关系的方案数。</p>
<p>扫描线，然后用一个线段树随便维护。</p>
<p>算出了这个 $r$ 以后，我们需要算距离之和。</p>
<p>因为 $m$ 只有 $10^7$ ，所以对于此时的半径 $r$，暴力在线段树上找出所有的交点计算即可。</p>
<p>此时<strong>在圆内</strong>的交点个数是比 $m$ 少的（实际上还是有可能大一点的，因为奇奇怪怪的精度问题）。总之，不能统计圆周上的点，因为如果所有的线段交点一样你就完了。不统计圆周上的点可以在极角排序的时候，如果两个点很近，则把右端点排到前面去。</p>
<p>时间复杂度 $O(m+n\log n \log ans)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-7</span>;</span><br><span class="line"><span class="type">const</span> db pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> db inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	db k,b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	db x; <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> P <span class="title">LineAndCircle</span><span class="params">(db r,db k,db b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	db a=k*k+<span class="number">1</span>,c=b*b-r*r,t;</span><br><span class="line">	b=b*k*<span class="number">2</span>; t=b*b<span class="number">-4.0</span>*a*c;</span><br><span class="line">	<span class="keyword">if</span>(t&lt;<span class="number">0</span>) <span class="keyword">return</span> (P)&#123;inf,inf&#125;;</span><br><span class="line">	t=<span class="built_in">sqrt</span>(t);</span><br><span class="line">	<span class="keyword">return</span> (P)&#123;(-b+t)/(a*<span class="number">2</span>),(-b-t)/(a*<span class="number">2</span>)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmps</span><span class="params">(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.x-B.x)&lt;eps) <span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">	<span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">line L[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt,in[N&lt;&lt;<span class="number">1</span>],out[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">node a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(db k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	P u; cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		u=<span class="built_in">LineAndCircle</span>(k,L[i].k,L[i].b);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(u.x-inf)&gt;eps)</span><br><span class="line">		&#123;</span><br><span class="line">			u.x=<span class="built_in">atan2</span>(L[i].k*u.x+L[i].b,u.x);</span><br><span class="line">			u.y=<span class="built_in">atan2</span>(L[i].k*u.y+L[i].b,u.y);</span><br><span class="line">			<span class="keyword">if</span>(u.x&gt;u.y) <span class="built_in">swap</span>(u.x,u.y);</span><br><span class="line">			a[++cnt]=(node)&#123;u.x,i&#125;;</span><br><span class="line">			a[++cnt]=(node)&#123;u.y,-i&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+cnt+<span class="number">1</span>,cmps);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(a[i].y&gt;<span class="number">0</span>) in[a[i].y]=i; <span class="keyword">else</span> out[-a[i].y]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line">db sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> A,<span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	db x=(L[B].b-L[A].b)/(L[A].k-L[B].k),y=L[A].k*x+L[A].b;</span><br><span class="line">	sum+=<span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,v[u].<span class="built_in">size</span>()) <span class="built_in">solve</span>(now,v[u][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s[u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) ans+=<span class="built_in">ask</span>(lc,l,mid,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  ans+=<span class="built_in">ask</span>(rc,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s[u]++; <span class="keyword">if</span>(flag) v[u].<span class="built_in">pb</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	(p&lt;=mid)?<span class="built_in">add</span>(lc,l,mid,p,x):<span class="built_in">add</span>(rc,mid+<span class="number">1</span>,r,p,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(db k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">build</span>(k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt*<span class="number">4</span>) s[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt)</span><br><span class="line">		<span class="keyword">if</span>(a[i].y&gt;<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			l=in[a[i].y],r=out[a[i].y]; now=a[i].y;</span><br><span class="line">			ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,l,r);</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,r,now);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">work</span><span class="params">(db k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	flag=<span class="number">1</span>; ll ans=<span class="built_in">calc</span>(k);</span><br><span class="line">	<span class="keyword">return</span> sum-(ans-m)*k;</span><br><span class="line">&#125;</span><br><span class="line">db x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(stigmata);</span><br><span class="line">	n=<span class="built_in">read</span>(); x=(db)<span class="built_in">read</span>()/<span class="number">1000.</span>,y=(db)<span class="built_in">read</span>()/<span class="number">1000.</span>;</span><br><span class="line">	m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		L[i].k=(db)<span class="built_in">read</span>()/<span class="number">1000.</span>,L[i].b=(db)<span class="built_in">read</span>()/<span class="number">1000.</span>-y;</span><br><span class="line">		L[i].b+=L[i].k*x;</span><br><span class="line">	&#125;</span><br><span class="line">	db l=<span class="number">0</span>,r=<span class="number">1e8</span>,mid;</span><br><span class="line">	<span class="built_in">fo</span>(t,<span class="number">1</span>,<span class="number">70</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2.</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">calc</span>(mid)&gt;m) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	cerr&lt;&lt;<span class="built_in">clock</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.10lf&quot;</span>,<span class="built_in">work</span>(r));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>勘探[jzoj6494]</title>
    <url>/2020/06/11/%E5%8B%98%E6%8E%A2-jzoj6494/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%8B%98%E6%8E%A2-jzoj6494/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="L-为奇数"><a href="#L-为奇数" class="headerlink" title="$L$ 为奇数"></a>$L$ 为奇数</h4><p>首先来看看 $50$ 分的。 </p>
<p>这时候重心在边上，这条边将树分成了两部分，且这两部分中叶子结点到根的路径为长度为 $\frac{L-1}{2}$。</p>
<p>那么设 $f_{i,j}$ 表示 $i$ 个点，最长路径的长度为 $j$ 的有根树的方案数。</p>
<p>考虑从 $f_{k,j-1}$ 转移过来，因为根节点已经是固定了的，所以儿子中只要有一个 $f_{k,j-1}$ 即可满足条件。</p>
<p>显然我们不能一个个枚举儿子选什么，因为会出现重复的情况，为避免之，再枚举儿子中最长路径长度为 $j-1$ 的节点个数，假设有 $l$ 个。</p>
<p>那么后面这个系数相当于是在 $f_{k,j-1}$ 棵树中选出 $l$ 个形成一个集合，可以重复选的方案数。由插板法可知，系数为 $\binom{f_{k,j-1}+l-1}{l}$。</p>
<p>那么则有：$f_{i,j}=\sum_{k}\sum_{l}f_{i-kl,j}\binom{f_{k,j-1}+l-1}{l}$。</p>
<p>需要注意一下枚举的顺序，且 $l$ 从小到大枚举即可用 $l-1$ 的组合数来 $O(1)$ 算出 $l$ 时的组合数。</p>
<p>但这只是最长路径长度为 $j-1$ 的，还可以有其他长度小于 $j-1$ 的可以插进去。</p>
<p>那么再维护多一个 $g_{i,j}$ 表示 $i+1$ 个点（除去根节点外还有 $i$ 个），最长路径的长度 $\leq j$ 的有根树的方案数。</p>
<p>用现在的 $f_j$ 和 $g_{j-1}$ 卷积以后就得到了真正的 $f_{i,j}$ 了。</p>
<p>然后再维护 $g$ 数组，方法和 $f$ 的是几乎一样的。</p>
<p>算出了 $f$ 数组，接下来的就很容易了。</p>
<p>枚举两部分中节点个数较少的节点个数 $i$，然后将 $f_{i,\frac{L-1}{2}}\times f_{n-i,\frac{L-1}{2}}$ 相加就是答案了。</p>
<p>需要注意一下当 $i=\frac{n}{2}$ 时的方案数。</p>
<h4 id="L-为偶数"><a href="#L-为偶数" class="headerlink" title="$L$ 为偶数"></a>$L$ 为偶数</h4><p>然后再来考虑 $L$ 为偶数的。设 $x=\frac{L}{2}$。</p>
<p>和奇数类似，现在重心是一个点，将树分成了若干部分。但是可能会有很多棵子树。</p>
<p>我们需要满足至少有两棵子树的高度恰好为 $x-1$，且所有的子树高度都不能超过 $x-1$。</p>
<p>考虑容斥，用 $f_{n,x}$ 减去只有一棵子树的高度为 $x-1$ 的方案数。</p>
<p>那么枚举这个子树的节点个数 $i$，则此时方案数为 $f_{i,x-1}\times g_{n-i,x-1}$。</p>
<p>这个节点个数 $i$ 满足 $i\geq x,n-i\geq x$。 </p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>我们需要枚举 $i,j,k,l$ 来计算 $f$ 和 $g$，但由于 $kl\leq i\leq n$，因此时间复杂度是 $O(Ln^2\log n)$ 的。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll fac[N],inv[N],f[N][N],g[N][N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=inv[l];</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,l) sum=sum*(n+i)%mod;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>; g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	ll t,w;</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">1</span>,m/<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f[<span class="number">1</span>][k]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t=w=f[j][k<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;j*l&lt;i;t=t*(w+l)%mod,l++)</span><br><span class="line">					f[i][k]=<span class="built_in">Add</span>(f[i][k],f[i-j*l][k]*t%mod*inv[l]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		f[<span class="number">1</span>][k]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) h[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,n-i) h[i+j]=<span class="built_in">Add</span>(h[i+j],f[j][k]*g[i][k<span class="number">-1</span>]%mod);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) f[i][k]=h[i],g[i][k]=g[i][k<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				t=w=f[j][k<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;j*l&lt;=i;t=t*(w+l)%mod,l++)</span><br><span class="line">					g[i][k]=<span class="built_in">Add</span>(g[i][k],g[i-j*l][k]*t%mod*inv[l]%mod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(m&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=(m<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(i&lt;=n-i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="number">2</span>*i!=n) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(f[i][x],f[n-i][x]));</span><br><span class="line">				<span class="keyword">else</span> ans=<span class="built_in">Add</span>(ans,<span class="built_in">S</span>(f[i][x],<span class="number">2</span>));</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=m/<span class="number">2</span>;</span><br><span class="line">		ans=f[n][x];</span><br><span class="line">		<span class="built_in">fo</span>(i,x,n<span class="number">-1</span>) ans=<span class="built_in">Dec</span>(ans,<span class="built_in">Mul</span>(f[i][x<span class="number">-1</span>],g[n-i<span class="number">-1</span>][x<span class="number">-1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(exploit);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(n==<span class="number">1</span>)%mod);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(n==<span class="number">2</span>)%mod);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(n&gt;=<span class="number">3</span>)%mod);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥原理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>守卫疆域[jzoj6489]</title>
    <url>/2020/06/10/%E5%AE%88%E5%8D%AB%E7%96%86%E5%9F%9F-jzoj6489/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%AE%88%E5%8D%AB%E7%96%86%E5%9F%9F-jzoj6489/problem.png" alt="problem"></p>
<p>原题：$n\leq 500$，加强 $n\leq 2000$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="算法一，-n-leq-20"><a href="#算法一，-n-leq-20" class="headerlink" title="算法一，$n\leq 20$"></a>算法一，$n\leq 20$</h4><p>$n\leq 20$，不难想到暴力枚举哪些点可能成为圆内的点，然后跑最小圆覆盖即可。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<h4 id="算法二，-n-leq-100"><a href="#算法二，-n-leq-100" class="headerlink" title="算法二，$n\leq 100$"></a>算法二，$n\leq 100$</h4><p>我们知道，$n$ 个点跑一遍最小圆覆盖，这个圆必定是这 $n$ 个点中选两个点组成直径所形成的圆，或者选三个点的外接圆。那么枚举这三个点，然后 $O(n)$ 判断一下即可。</p>
<p>时间复杂度 $O(n^4)$。</p>
<h4 id="算法三，-n-leq-500"><a href="#算法三，-n-leq-500" class="headerlink" title="算法三，$n\leq 500$"></a>算法三，$n\leq 500$</h4><p><del>似乎可以有 $O(n^3)$ 的做法，不管了。</del></p>
<p>显然可以二分半径 $R$。</p>
<p>然后枚举一个点 $P_i$ 是否在最终的圆 $B$ 中，贪心地考虑，这个圆的圆心 $B$ 在以 $P_i$ 为圆心 $R$ 为半径的圆 $C$ 上是最好的。因为这样才能覆盖尽可能多的点。那么如果我要使得另一个点也在圆里面，满足条件的是圆 $C$ 的一段圆弧。这段圆弧可以用圆圆求交来搞定。那么只需要将这些圆弧的两个端点拎出来进行排序，然后扫描线统计一下最大值即可。这一部分需要排序，时间复杂度 $O(n\log n)$。</p>
<p>加上枚举 $P_i$ 及二分半径，时间复杂度 $O(n^2\log n \log D)$，其中 $\log D$ 为二分次数。 </p>
<h4 id="算法四，-n-leq-2000"><a href="#算法四，-n-leq-2000" class="headerlink" title="算法四，$n\leq 2000$"></a>算法四，$n\leq 2000$</h4><p>算法四告诉我们，可以在 $O(n\log n)$ 的时间内求出：是否存在一个圆，半径为 $R$，满足 $P_i$ 必须在圆内，且圆内点的权值和大于等于某个值。</p>
<p>对于算法四中的 $P_i$，它也是可以去二分的。也就是说，可以通过 $O(n\log n\log D)$ 的时间来求出满足 $P_i$ 必须在圆内，且权值和大于等于某个值的最小半径，方法和算法四相同，设这个半径为 $R_i$。</p>
<p>还是考虑算法四中一个一个去枚举，假设当前的最小答案是 $ans$，那如果不存在一个以 $ans$ 为半径的圆，满足 $P_i$ 在圆内且权值和满足条件，那么就有 $R_i&gt;ans$，因此这个点实际上是废掉的，$R_i$ 无法产生任何贡献。这个也可以通过 $O(n\log n)$ 的时间去判断。</p>
<p>那如果我这个 $ans$ 经过几次暴力算出 $R_i$ 后，变得足够小，剩下的点就可以只需要判断一次 $R_i&gt;ans$ ，然后可以知道它不会产生任何贡献了。</p>
<p>那么每次去选一个点，判断是否能让 $ans$ 变小，如果阔以，就用 $O(n\log n\log D)$ 的时间算出 $R_i$ 去更新 $ans$，否则就直接跳过，因为不会让 $ans$ 变小。</p>
<p>如果上面的方法是随机选择的话，对于一个从小到大排名为 $j$ 的 $R_i$ 而言，有 $\frac{1}{j}$ 的概率是需要算出真正的 $R_i$ 的。那么 $n$ 个 $R_i$ 就期望要算 $\sum_{i=1}^n\frac{1}{i}=O(\log n)$ 次，因此这一部分的时间复杂度是 $O(n\log ^2n\log D)$ 的。</p>
<p>对于每个 $i$，都需要一次判断是否能让答案变小，时间复杂度是 $O(n^2\log n)$ 的。</p>
<p>因此只需要一个random_shuffle，我们就可以得到一个期望时间复杂度为 $O(n^2\log n+n\log ^2n\log D)$ 的算法。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> db pi2=<span class="number">2</span>*<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B) &#123;<span class="keyword">return</span> A.x!=B.x?A.x&lt;B.x:A.y&lt;B.y;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span>+(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)&#123;<span class="keyword">return</span> (P)&#123;A.x+B.x,A.y+B.y&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span>-(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)&#123;<span class="keyword">return</span> (P)&#123;A.x-B.x,A.y-B.y&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Cross</span><span class="params">(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span></span>&#123;<span class="keyword">return</span> A.x*B.y-A.y*B.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Dot</span><span class="params">(<span class="type">const</span> P &amp;A,<span class="type">const</span> P &amp;B)</span></span>&#123;<span class="keyword">return</span> A.x*B.x+A.y*B.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Len2</span><span class="params">(<span class="type">const</span> P &amp;A)</span></span>&#123;<span class="keyword">return</span> A.x*A.x+A.y*A.y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">Len</span><span class="params">(<span class="type">const</span> P &amp;A)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Len2</span>(A));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">ang</span><span class="params">(<span class="type">const</span> P &amp;A)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(A.y,A.x);&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">P a[N],pos[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">db d,w,t,l,r;</span><br><span class="line"><span class="type">int</span> k,sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,db R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	R*=<span class="number">2</span>; k=<span class="number">0</span>; sum=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(j^i)</span><br><span class="line">	&#123;</span><br><span class="line">		d=<span class="built_in">Len</span>(a[i]-a[j]);</span><br><span class="line">		<span class="keyword">if</span>(d&lt;eps) &#123;sum++;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(d&gt;R) <span class="keyword">continue</span>;</span><br><span class="line">		w=<span class="built_in">ang</span>(a[i]-a[j]);</span><br><span class="line">		<span class="keyword">if</span>(w&lt;<span class="number">0</span>) w+=pi2;</span><br><span class="line">		t=<span class="built_in">acos</span>(d/R);</span><br><span class="line">		l=w-t; r=w+t;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;<span class="number">0</span>) l+=pi2;</span><br><span class="line">		<span class="keyword">if</span>(r&gt;pi2) r-=pi2;</span><br><span class="line">		pos[++k]=(P)&#123;l,<span class="number">1</span>&#125;;</span><br><span class="line">		pos[++k]=(P)&#123;r,<span class="number">-1</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span>(l&gt;r) sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum&gt;=m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(pos+<span class="number">1</span>,pos+k+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		sum+=(<span class="type">int</span>)pos[i].y;</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(guard);</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i].x=<span class="built_in">read</span>(),a[i].y=<span class="built_in">read</span>(),tot++;</span><br><span class="line">	<span class="keyword">if</span>(tot&lt;m) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">random_shuffle</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	db ans=<span class="number">14143</span>,l,r,mid;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">calc</span>(i,ans)) <span class="keyword">continue</span>;</span><br><span class="line">		l=<span class="number">0</span>; r=ans;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="built_in">log</span>(ans)*<span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">calc</span>(i,mid)) r=mid;</span><br><span class="line">			<span class="keyword">else</span> l=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		ans=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.7lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>随机</tag>
        <tag>最小圆覆盖</tag>
      </tags>
  </entry>
  <entry>
    <title>铺路[jzoj6491]</title>
    <url>/2020/06/10/%E9%93%BA%E8%B7%AF-jzoj6491/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E9%93%BA%E8%B7%AF-jzoj6491/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先来分析一波：</p>
<p>我们发现，当所有的点的度数都为奇数时，点数必定是偶数。</p>
<p>证明可以用归纳法。</p>
<p>考虑一棵偶数个点的树，它一定符合所有点的度数为奇数。</p>
<p>那么对于一个偶数个点的图，我们保留它的一棵最小生成树，最小生成树中最大的边权就是答案了。</p>
<p>考虑 $n,m\leq 2000$ 的做法，也就是只考虑一次询问时该怎么做。</p>
<p>可以将边从小到大排好序，然后一个一个插进去。直到所有连通块的点数都是偶数，当前这条边的权值就是答案。</p>
<p>那么你获得了一个 $O(n^2\alpha(n))$ 的50分做法。</p>
<p>接下来考虑正解：</p>
<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>考虑继续沿用50分做法的思想，不考虑离线，直接做。</p>
<p>显然答案是单调不降的。</p>
<p>那么对于当前的生成森林，你如果删掉了权值最大的边后，这条边就以后都不可能再加回去了。</p>
<p>考虑用LCT维护这个生成森林，每次尝试插进一条新的边，如果插进去以后形成了环，那么将环上的最大的边删掉。</p>
<p>然后如果此时连通块均为偶数，我们则可以考虑去删最大的边。</p>
<p>那么我们维护一个可删堆，每次在堆中找到还生成森林里面的最大的边，直到删掉之后连通块出现了奇数。</p>
<p>需要在LCT中维护子树大小以及链的最大边。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="方法1-1"><a href="#方法1-1" class="headerlink" title="方法1"></a>方法1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">400010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line">	<span class="type">int</span> fa[N],ch[N][<span class="number">2</span>],siz[N],si[N],val[N],mi[N];</span><br><span class="line">	<span class="type">bool</span> r[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">son</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]!=x&amp;&amp;ch[fa[x]][<span class="number">1</span>]!=x;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val[x]&lt;=val[y]?y:x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[x]=siz[ch[x][<span class="number">0</span>]]+siz[ch[x][<span class="number">1</span>]]+si[x]+(val[x]==-inf);</span><br><span class="line">		mi[x]=<span class="built_in">getmax</span>(x,<span class="built_in">getmax</span>(mi[ch[x][<span class="number">0</span>]],mi[ch[x][<span class="number">1</span>]]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">		r[x]^=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">swap</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!r[x]) <span class="keyword">return</span>;</span><br><span class="line">		r[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rev</span>(ch[x][<span class="number">0</span>]); <span class="built_in">rev</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!<span class="built_in">isroot</span>(x)) <span class="built_in">push</span>(fa[x]); <span class="built_in">pushdown</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> y=fa[x],z=fa[y],d=<span class="built_in">son</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">isroot</span>(y)) ch[z][<span class="built_in">son</span>(y)]=x; fa[x]=z;</span><br><span class="line">		ch[y][d]=ch[x][<span class="number">1</span>-d]; fa[ch[y][d]]=y;</span><br><span class="line">		ch[x][<span class="number">1</span>-d]=y; fa[y]=x;</span><br><span class="line">		<span class="built_in">pushup</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">push</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=fa[x];!<span class="built_in">isroot</span>(x);<span class="built_in">rotate</span>(x),y=fa[x])</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">isroot</span>(y)) <span class="built_in">rotate</span>((<span class="built_in">son</span>(x)^<span class="built_in">son</span>(y))?x:y);</span><br><span class="line">		<span class="built_in">pushup</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">splay</span>(x);</span><br><span class="line">			si[x]+=siz[ch[x][<span class="number">1</span>]]-siz[y];</span><br><span class="line">			ch[x][<span class="number">1</span>]=y;</span><br><span class="line">			<span class="built_in">pushup</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">makeroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="built_in">access</span>(x); <span class="built_in">splay</span>(x); <span class="built_in">rev</span>(x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="built_in">makeroot</span>(x); <span class="built_in">access</span>(y); <span class="built_in">splay</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split</span>(x,y); fa[x]=y; si[y]+=siz[x]; <span class="built_in">pushup</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split</span>(x,y); ch[y][<span class="number">0</span>]=fa[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">access</span>(x); <span class="built_in">splay</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(;ch[x][<span class="number">0</span>];<span class="built_in">pushdown</span>(x),x=ch[x][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findsiz</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">access</span>(x); <span class="built_in">splay</span>(x); <span class="keyword">return</span> siz[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findmax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">split</span>(x,y);</span><br><span class="line">		<span class="keyword">return</span> mi[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LCT;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)</span> </span>&#123;<span class="keyword">return</span> (val[x]==val[y])?x&lt;y:val[x]&lt;val[y];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">del_queue</span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; q1,q2;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		q1.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		q2.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q1.<span class="built_in">empty</span>()&amp;&amp;!q2.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q1.<span class="built_in">top</span>()==q2.<span class="built_in">top</span>()) q1.<span class="built_in">pop</span>(),q2.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(q1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> q1.<span class="built_in">top</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> q1.<span class="built_in">size</span>()==q2.<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p;</span><br><span class="line"><span class="type">int</span> cnt,n,m,X[N],Y[N],fx,fy,x,y,z,sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!p.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=p.<span class="built_in">top</span>();</span><br><span class="line">		<span class="built_in">cut</span>(X[u],u);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">findsiz</span>(X[u])&amp;<span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">link</span>(X[u],u));</span><br><span class="line">		<span class="built_in">cut</span>(Y[u],u);</span><br><span class="line">		p.<span class="built_in">pop</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(road);</span><br><span class="line">	sum=cnt=n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	val[<span class="number">0</span>]=-inf<span class="number">-1</span>; siz[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) mi[i]=i,val[i]=-inf,siz[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(); ++cnt; val[cnt]=z=<span class="built_in">read</span>(); mi[cnt]=cnt;</span><br><span class="line">		X[cnt]=x; Y[cnt]=y;</span><br><span class="line">		fx=<span class="built_in">findroot</span>(x); fy=<span class="built_in">findroot</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(fx!=fy)</span><br><span class="line">		&#123;</span><br><span class="line">			sum-=(<span class="built_in">findsiz</span>(fx)&amp;<span class="number">1</span>)+(<span class="built_in">findsiz</span>(fy)&amp;<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">link</span>(x,cnt); <span class="built_in">link</span>(y,cnt);</span><br><span class="line">			sum+=(<span class="built_in">findsiz</span>(cnt)&amp;<span class="number">1</span>);</span><br><span class="line">			p.<span class="built_in">push</span>(cnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> k;</span><br><span class="line">			k=<span class="built_in">findmax</span>(x,y);</span><br><span class="line">			<span class="keyword">if</span>(val[k]&gt;z)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cut</span>(X[k],k),<span class="built_in">cut</span>(Y[k],k);</span><br><span class="line">				p.<span class="built_in">pop</span>(k);</span><br><span class="line">				<span class="built_in">link</span>(x,cnt); <span class="built_in">link</span>(y,cnt);</span><br><span class="line">				p.<span class="built_in">push</span>(cnt);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!sum) <span class="built_in">del</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum?<span class="number">-1</span>:val[p.<span class="built_in">top</span>()]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>堆</tag>
        <tag>并查集</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>异或树[jzoj6707]</title>
    <url>/2020/06/09/%E5%BC%82%E6%88%96%E6%A0%91-jzoj6707/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%BC%82%E6%88%96%E6%A0%91-jzoj6707/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然这是一道DP题。看起来似乎只能从高位到低位考虑。</p>
<p>假设有些点的最高位为 $0$，剩下的点最高位为 $1$，那么这些点形成了两个连通块。</p>
<p>这两个连通块内部先做一次最小生成树，然后之间需要连一条边权最小的边链接这两个连通块。</p>
<p>现在我们先来算，假设你考虑到某一位 $i$（从 $0$ 开始），有两块的大小是 $k,l$，这时候中间这条边的权值的期望*方案数是多少，记这个数为 $g_{i,k,l}$。</p>
<p>然而这个 $g$ 是无法直接算的。考虑转换最小值，有一个经典的套路，要算一个随机变量 $x$ 的期望，那么可以通过以下转换：</p>
<p>$$E(x)=\sum_{i=0} i[P(x=i)]=\sum_{i=1}[P(x\geq i)]$$</p>
<p>我们转换成求这条权值最小的边大于等于某个数 $j(j&lt; 2^i)$ 的方案数，也就是所以跨过两个块的边都大于等于这个 $j$ 的方案数。设这个方案数为 $f_{i,j,k,l}$。</p>
<p>现在只需要考虑 $f$ 如何计算。</p>
<p>进行大力分类讨论：</p>
<ol>
<li><p>$k=0$ 或 $l=0$</p>
<p>这时候为了方便其他 $f$ 的计算，可以令 $f_{i,j,k,l}$ 直接表示为所有的方案数，即 $2^{(i+1)(k+l)}$。</p>
</li>
<li><p>$j$ 的第 $i$ 位为 $1$</p>
<p>这时候 $k,l$ 都大于 $0$ 了，那么这两个块的最高位异或后必须为 $1$，也就是一个块的最高位全是 $0$ ，令一个的最高位全是 $1$，这样的方案数有两种，然后还需要看 $j$ 除去第 $i$ 位后的结果，也就是 $f_{i-1,j\oplus 2^i,k,l}$。</p>
</li>
<li><p>$j$ 的第 $i$ 位为 $0$</p>
<p>此时，这两个块的最高位就没有什么限制了，也就是块内的最高位可以不相同。那么，就需要分别枚举两个块有多少个最高位为 $0$ 的，设为 $u,v$，一共有 $\binom{k}{u}\times \binom{l}{v}$ 种选法，对于 $j$ 的限制，显然不需要考虑不同块且最高位不同的点，方案数为 $f_{i-1,j,u,v}\times f_{i-1,j,k-u,l-v}$。</p>
</li>
</ol>
<p>然后大力转移就好了。需要注意 $i=0$ 时的边界。</p>
<p>现在你已经求出了所有的 $g_{i,k,l}$。</p>
<p>最后需要将这些 $g_{i,k,l}$ 转换成答案。</p>
<p>我们可以再来一个DP，设 $h_{i,j}$ 表示考虑到第 $i$ 位（从 $0$ 开始），一共 $j$ 个点时的答案之和。</p>
<p>然后还是按照最高位分两块，枚举其中一块的点数 $k$，则有：</p>
<p>$$h_{i,j}=\sum_{k=0}^j\binom{j}{k}\left (2^{i(j-k)}h_{i-1,k}+2^{ik}h_{i-1,j-k}+[k&gt;0,j&gt;k](g_{i-1,k,j-k}+2^i\times 2^{ij})\right )$$</p>
<p>最后面的 $[k&gt;0,j&gt;k]$ 是需要保证两个块都有点，才能有一条跨过两块的边。</p>
<p>时间复杂度 $O(mn^42^m)$，有超级多个 $\frac{1}{2}$ 的常数，因此卡卡常，减小一下取模的次数就过了。</p>
<p><strong>注意 $n=1$ 的特判。</strong></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">53</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll p2[N*N],C[N][N],f[<span class="number">9</span>][<span class="number">260</span>][N][N],h[<span class="number">9</span>][N],g[<span class="number">9</span>][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(<span class="keyword">xor</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;mod;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">	p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,N*N<span class="number">-1</span>) p2[i]=(p2[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) C[i][<span class="number">0</span>]=C[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">			C[i][j]=<span class="built_in">Add</span>(C[i<span class="number">-1</span>][j],C[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n-i)</span><br><span class="line">			f[<span class="number">0</span>][<span class="number">0</span>][i][j]=p2[i+j],f[<span class="number">0</span>][<span class="number">1</span>][i][j]=<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,n)</span><br><span class="line">				f[i<span class="number">-1</span>][j][k][<span class="number">0</span>]=f[i<span class="number">-1</span>][j][<span class="number">0</span>][k]=p2[i*k];</span><br><span class="line">	ll tmp;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">ff</span>(j,<span class="number">0</span>,<span class="number">1</span>&lt;&lt;(i+<span class="number">1</span>))</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">1</span>,n)</span><br><span class="line">				<span class="built_in">fo</span>(l,<span class="number">1</span>,n-k)</span><br><span class="line">					<span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">						f[i][j][k][l]=f[i<span class="number">-1</span>][j^(<span class="number">1</span>&lt;&lt;i)][k][l]*<span class="number">2</span>%mod;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">fo</span>(u,<span class="number">0</span>,k)</span><br><span class="line">						&#123;</span><br><span class="line">							tmp=<span class="number">0</span>;</span><br><span class="line">							<span class="built_in">fo</span>(v,<span class="number">0</span>,l) tmp=<span class="built_in">Add</span>(tmp,C[l][v]*f[i<span class="number">-1</span>][j][u][v]%mod*f[i<span class="number">-1</span>][j][k-u][l-v]%mod);</span><br><span class="line">							f[i][j][k][l]+=tmp*C[k][u]%mod;</span><br><span class="line">						&#125;</span><br><span class="line">						f[i][j][k][l]%=mod;</span><br><span class="line">					&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">fo</span>(l,<span class="number">1</span>,n-k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">ff</span>(j,<span class="number">1</span>,p2[i+<span class="number">1</span>])</span><br><span class="line">					g[i][k][l]+=f[i][j][k][l];</span><br><span class="line">				g[i][k][l]%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) h[<span class="number">0</span>][i]=<span class="built_in">Dec</span>(p2[i],<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,j)</span><br><span class="line">				h[i][j]=<span class="built_in">Add</span>(h[i][j],<span class="built_in">Mul</span>(C[j][k],<span class="built_in">Add</span>(<span class="built_in">Add</span>(h[i<span class="number">-1</span>][k]*p2[i*(j-k)]%mod,h[i<span class="number">-1</span>][j-k]*p2[i*k]%mod),(k&gt;<span class="number">0</span>&amp;&amp;j&gt;k)*<span class="built_in">Add</span>(g[i<span class="number">-1</span>][k][j-k],p2[i*j]*p2[i]%mod))));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,h[m<span class="number">-1</span>][n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>期望</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>排列[jzoj6709]</title>
    <url>/2020/06/08/%E6%8E%92%E5%88%97-jzoj6709/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E6%8E%92%E5%88%97-jzoj6709/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>做多了FFT，这题似乎感觉还是挺简单滴~。</p>
<p>显然容斥一下，设 $g_n$ 表示恰好 $i$ 个的答案，设 $f_n$ 表示至少 $i$ 个的答案。</p>
<p>那么有：$f_i=\sum_{j=i}^ng_j\binom{j}{i}$。</p>
<p>二项式反演一下：$g_i=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}f_j$。</p>
<p>这个是一个卷积形式，求完 $f_i$ 后一个卷积就好了。</p>
<p>下面来看如何求 $f_i$。</p>
<p>我们建一个二分图，$X_i,Y_j$ 连边当且仅当 $|i-j|=m$。我们选一条边 $(i,j)$ 表示令 $P_i=j$。</p>
<p>对于 $f_i$ 而言，我们需要在这个二分图中找到 $i$ 条边的方案数，最后乘一个随意乱连的方案，即 $(n-i)!$。</p>
<p>那么对于二分图中的一条链，假设长度为 $k$，你需要选 $j$ 条边，那么方案数就为 $h_j=\binom{k-j}{j}$。</p>
<p>然后把这个 $h$ 写成生成函数的形式，那么在二分图中找到 $i$ 条边的方案数相当于就是将所有的链的 $h$ 乘起来后的第 $i$ 项。</p>
<p>因为这些链的 $h$ 的次数的和是 $n$，因此这个也可以随便做做就好了。比如写个最低级的多项式快速幂。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Poly vector<span class="string">&lt;ll&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll W[M];</span><br><span class="line"><span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">nttinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">				a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">				a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">	<span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span> </span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) A[i]=<span class="built_in">Mul</span>(A[i],B[i]);</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ^(Poly A,<span class="type">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	Poly B; B.<span class="built_in">resize</span>(<span class="number">0</span>); B.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(;k;k&gt;&gt;=<span class="number">1</span>,A=A*A) <span class="keyword">if</span>(k&amp;<span class="number">1</span>) B=B*A;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">facinit</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line">Poly A,B,F,G,H;</span><br><span class="line"><span class="type">int</span> k,n,m,len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(perm);</span><br><span class="line">	<span class="built_in">nttinit</span>();</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">facinit</span>(n+<span class="number">1</span>);</span><br><span class="line">	k=n%m; len=n/m+<span class="number">1</span>;</span><br><span class="line">	A.<span class="built_in">resize</span>(len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len/<span class="number">2</span>) A[i]=<span class="built_in">C</span>(len-i,i);</span><br><span class="line">	A=A^(k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	k=m-n%m; len--;</span><br><span class="line">	B.<span class="built_in">resize</span>(len/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len/<span class="number">2</span>) B[i]=<span class="built_in">C</span>(len-i,i);</span><br><span class="line">	B=B^(k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	F=A*B;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) F[i]=<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(F[i],fac[n-i]),fac[i]);</span><br><span class="line">	G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) G[n-i]=<span class="built_in">Pow</span>(mod<span class="number">-1</span>,i)*inv[i]%mod;</span><br><span class="line">	H=G*F;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,H[i+n]*inv[i]%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>FFT</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>密码[jzoj6708]</title>
    <url>/2020/06/08/%E5%AF%86%E7%A0%81-jzoj6708/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><img src="/%E5%AF%86%E7%A0%81-jzoj6708/problem.png" alt="problem"></p>
<span id="more"></span>

<h3 id="做法1"><a href="#做法1" class="headerlink" title="做法1"></a>做法1</h3><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>考虑多项式。</p>
<p>题目实际上求的是 $\prod_{k=i}^{i+m-1}val_{k,s[k-i+1]}$。</p>
<p>那么求一个ln后，变成求加法。</p>
<p>由于字符集大小只有10，我们将10个字符分开来处理。</p>
<p>对于一种字符 $j$，定义 $f_i=[s[i]==j]$。</p>
<p>然后将其中一个串反转，做个卷积即可。</p>
<p>时间复杂度 $O(n|S| \log n)$，其中 $|S|$ 为字符集大小。</p>
<p>感觉可能会有精度问题？但有人过了qwq。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><p>太简单，不写了。</p>
<h3 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h3><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>我们发现，对于每位字符，大于 $0.5$ 的概率最多只有一个，而如果他经过了比较多的概率 $&lt;0.5$ 的点，那么最终答案就会很小。显然，经过 $30$ 个左右就会使得答案小于 $10^{-9}$。</p>
<p>根据这个性质，我们把所有大于 $0.5$ 的字符拿出来，没有的那一位填一个为出现过的数。然后枚举每一个结束位置，拿着密码串去跟这一位去做lcp，将这些概率乘起来，当匹配次数超过 $30$ 遍后就直接返回 $0$。</p>
<p>这个可以用后缀数组或者SAM用 $O(n\log n)$ 预处理做到 $O(1)$ 查询。</p>
<p>最后你发现将这些概率乘起来时是一段区间，统计这段区间不能有前缀积，因为会有精度问题，可以写一个线段树或者猫树。</p>
<p>无论如何，总的时间复杂度为 $O(n\log n)$。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2.5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	db s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n) s[i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,db x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[u]*=x;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		(p&lt;=mid)?<span class="built_in">add</span>(lc,l,mid,p,x):<span class="built_in">add</span>(rc,mid+<span class="number">1</span>,r,p,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">db <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> s[u];</span><br><span class="line">		db ans=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) ans=ans*<span class="built_in">ask</span>(lc,l,mid,L,R);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  ans=ans*<span class="built_in">ask</span>(rc,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> base[N],rk[N],t[N],sa[N],height[N],f[N][<span class="number">19</span>],l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y,<span class="type">const</span> <span class="type">int</span> &amp;len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t[x]==t[y]&amp;&amp;t[x+len]==t[y+len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> *s,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s[n+<span class="number">1</span>]=<span class="number">13</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=i,rk[i]=s[i];</span><br><span class="line">	<span class="built_in">rsort</span>(n,m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">		<span class="built_in">rsort</span>(n,p);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">		rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=(<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">		<span class="keyword">for</span>(j=sa[rk[i]<span class="number">-1</span>],(k?k--:<span class="number">0</span>);s[i+k]==s[j+k];k++);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="number">18</span>)</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=rk[x]; y=rk[y];</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	x++;</span><br><span class="line">	<span class="type">int</span> l=l2[y-x+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(f[x][l],f[y-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>][l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s[N],n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">db val[N][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> db <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=m,d;</span><br><span class="line">	db ans=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">35</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		d=<span class="built_in">lcp</span>(m+<span class="number">1</span>-l,n+m+<span class="number">2</span>-x-l);</span><br><span class="line">		<span class="keyword">if</span>(d) ans*=SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,x+l-d+<span class="number">1</span>,x+l);</span><br><span class="line">		l-=d;</span><br><span class="line">		<span class="keyword">if</span>(!l) <span class="keyword">return</span> ans;</span><br><span class="line">		ans*=val[l+x][str[l]-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">		l--;</span><br><span class="line">		<span class="keyword">if</span>(!l) <span class="keyword">return</span> ans;</span><br><span class="line">		<span class="keyword">if</span>(ans&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(password);</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	SGT::<span class="built_in">init</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i]=<span class="number">11</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">9</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">read</span>(); val[i][j]=(db)x/<span class="number">1000000000.0</span>;</span><br><span class="line">			<span class="keyword">if</span>(x&gt;=<span class="number">500000000</span>) s[i]=j+<span class="number">1</span>,SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,val[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s[n+<span class="number">1</span>]=<span class="number">12</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) s[n+<span class="number">1</span>+i]=str[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(s+<span class="number">1</span>,s+n+m+<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">build</span>(s,n+m+<span class="number">1</span>,<span class="number">12</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,m,n) <span class="built_in">printf</span>(<span class="string">&quot;%.15lf\n&quot;</span>,<span class="built_in">calc</span>(i-m));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>线段树</tag>
        <tag>SAM</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>手链强化[FJWC2020Day2]</title>
    <url>/2020/06/08/%E6%89%8B%E9%93%BE%E5%BC%BA%E5%8C%96-FJWC2020Day2/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 $n$ 的手链，对于每一个珠子，可以不染色，也可<br>以染 $k$ 种颜色中的一种。不能有相邻的两个珠子同时被染色。问<br>不同的染色手链种类数。旋转相同视作一种。对 $10^9+7$ 取模。</p>
<p>$n,k\leq 10^9$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先由 Burnside引理，得到答案为 $\frac{1}{n}\sum_{i=1}^n=f(\gcd(i,n))$，其中 $f(i)$ 表示长度为 $i$ 的环，不考虑旋转时的答案。</p>
<p>显然答案也等于 $\frac{1}{n}\sum_{d|n}\varphi(\frac{n}{d})f(d)$。</p>
<p>那么现在只需要考虑如何求 $f(i)$ 就好了。</p>
<p>设 $g_{i,0/1}$ 表示依次考虑环上每一个点，考虑到环上第 $i$ 个，该点染不染色的方案数。</p>
<p>显然有：$g_{i,0}=g_{i-1,0}+g_{i-1,1},g_{i,1}=kg_{i-1,0}$。</p>
<p>然后分两种情况讨论：</p>
<p>1，第一个点不染色，那么有 $g_{1,0}=1,g_{1,1}=0$，此时对答案贡献为 $g_{n,0}+g_{n,1}$。</p>
<p>2，第一个点染色，那么有 $g_{1,0}=0,g_{1,1}=k$，此时对答案贡献为 $g_{n,0}$。</p>
<p>那么就可以用矩阵快速幂求出这个 $f(i)$ 了。</p>
<p>求一个 $\varphi(i)$ 的复杂度可以通过预处理根号内的质数做到 $\frac{\sqrt i}{\log i}$。</p>
<p>那么时间复杂度为：</p>
<p>$$O(\sum_{d|n}\frac{\sqrt{d}}{\log d})\le O(\sum_{d|n}\frac{\sqrt{n}}{\log n})\le O(n^{\frac{1}{3}}\frac{\sqrt n}{\log n})=O(\frac{n^{\frac{5}{6}}}{\log n})$$</p>
<p><del>实际上跑得极快。</del></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span>&#123;</span><br><span class="line">	ll a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">mat</span>() &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">	<span class="keyword">inline</span> ll* <span class="keyword">operator</span> [] (<span class="type">const</span> <span class="type">int</span> &amp;x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> mat <span class="keyword">operator</span> * (mat A,mat B)</span><br><span class="line">	&#123;</span><br><span class="line">		mat C;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">			C[i][j]=<span class="built_in">Add</span>(C[i][j],A[i][k]*B[k][j]%mod);</span><br><span class="line">		<span class="keyword">return</span> C;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> mat <span class="title">Pow</span><span class="params">(mat A,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mat B; B[<span class="number">0</span>][<span class="number">0</span>]=B[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,A=A*A) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) B=B*A;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line">mat F,G,H,A;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	H[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; H[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	A=<span class="built_in">Pow</span>(F,n<span class="number">-1</span>);</span><br><span class="line">	G=H*A;</span><br><span class="line">	sum=<span class="built_in">Add</span>(sum,<span class="built_in">Add</span>(G[<span class="number">0</span>][<span class="number">0</span>],G[<span class="number">0</span>][<span class="number">1</span>]));</span><br><span class="line">	H[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; H[<span class="number">0</span>][<span class="number">1</span>]=k;</span><br><span class="line">	G=H*A;</span><br><span class="line">	sum=<span class="built_in">Add</span>(sum,G[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> vis[M],pri[M],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;pri[++cnt]=i;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[pri[j]*i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll s=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt&amp;&amp;pri[i]*pri[i]&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span>(n%pri[i]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s=s*(pri[i]<span class="number">-1</span>)/pri[i];</span><br><span class="line">			<span class="keyword">for</span>(;n%pri[i]==<span class="number">0</span>;n/=pri[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(n!=<span class="number">1</span>) s=s*(n<span class="number">-1</span>)/n;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="built_in">sqrt</span>(n))</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">phi</span>(n/i),<span class="built_in">f</span>(i)));</span><br><span class="line">			<span class="keyword">if</span>(i*i!=n) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">phi</span>(i),<span class="built_in">f</span>(n/i)));</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(bracelet);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="built_in">init</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">	F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; F[<span class="number">0</span>][<span class="number">1</span>]=k;</span><br><span class="line">	F[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>; F[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Mul</span>(<span class="built_in">calc</span>(n),<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵[bzoj2406]</title>
    <url>/2020/06/04/%E7%9F%A9%E9%98%B5-bzoj2406/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://darkbzoj.tk/problem/2406">darkbzoj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>过了那么久，才发现自己的Dinic原来写成EK了。。。</p>
<p>首先二分答案 $mid$，变成判断是否对于所有的式子，都满足 $|\sum a_i-\sum b_i|\leq mid$，那么每个式子的 $\sum b_i$ 的大小就是在一个区间内了。</p>
<p>然后行和列分别建点，每个 $b_{i,j}$ 的范围是 $[L,R]$，那么就连 $(i,j,L,R)$。</p>
<p>然后就变成了有源有汇有上下界可行流。</p>
<p>连边 $(t,s,inf)$，然后转成无源无汇有上下界可行流就好了。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">int</span> SS,TT,S,T,cnt;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],ne[M],head[N],tot;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) head[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=d; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d[N],cur[N];</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) d[i]=<span class="number">-1</span>,cur[i]=head[i];</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		q.<span class="built_in">push</span>(SS); d[SS]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d[TT]!=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u==TT||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,v,r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==d[u]+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!(r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i])))) <span class="keyword">continue</span>;</span><br><span class="line">				res-=r;</span><br><span class="line">				val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">				<span class="keyword">if</span>(!res) <span class="keyword">break</span>;<span class="comment">//不能在for循环中写&quot;i&amp;&amp;res&quot;，因为会使得i=ne[i]后才退出</span></span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">bfs</span>();) flow+=<span class="built_in">dfs</span>(SS,inf);</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Dinic::SS;</span><br><span class="line"><span class="keyword">using</span> Dinic::TT;</span><br><span class="line"><span class="keyword">using</span> Dinic::T;</span><br><span class="line"><span class="keyword">using</span> Dinic::S;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,L,R;</span><br><span class="line"><span class="type">int</span> c[N],d[N],a[N][N],in[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Dinic::<span class="built_in">add</span>(x,y,r-l);</span><br><span class="line">	in[x]-=l; in[y]+=l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	Dinic::<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">add</span>(S,i,c[i]-k,c[i]+k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(i+n,T,d[i]-k,d[i]+k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="built_in">add</span>(i,j+n,L,R);</span><br><span class="line">	Dinic::<span class="built_in">add</span>(T,S,inf);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,Dinic::cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(in[i]&gt;<span class="number">0</span>) Dinic::<span class="built_in">add</span>(SS,i,in[i]),sum+=in[i];</span><br><span class="line">		<span class="keyword">if</span>(in[i]&lt;<span class="number">0</span>) Dinic::<span class="built_in">add</span>(i,TT,-in[i]);</span><br><span class="line">		in[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Dinic::<span class="built_in">dinic</span>()==sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); Dinic::cnt=n+m+<span class="number">3</span>;</span><br><span class="line">	S=<span class="number">0</span>; T=n+m+<span class="number">1</span>; SS=T+<span class="number">1</span>; TT=T+<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m) a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m) c[i]+=a[i][j],d[j]+=a[i][j];</span><br><span class="line">	L=<span class="built_in">read</span>(); R=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">200000</span>,mid;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>Chips Challenge[WF2011]</title>
    <url>/2020/06/04/Chips-Challenge-WF2011/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/UVA1104">luogu</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>可以通过连 $\infty/ -\infty$ 的边来实现强制相等。</strong></p>
<p>首先，每个格子选的总数难以确定，那么我们可以枚举格子选的总数 $k$，然后最后看看这时候的答案是否和这个 $k$ 相等。枚举以后，每行和每列的限制就确定了，设 $mx=\lfloor k\times \frac{a}{b}\rfloor$。</p>
<p>根据网络流的套路，我们将行列分别建点。然后连边。</p>
<p>首先建一个源点 $s$ 和汇点 $t$，$s$ 向每行的点连一条 $[0,mx]$ 的边，每列向 $t$ 连一条 $[0,mx]$ 的边，表示不超过 $mx$ 的限制。</p>
<p>对于每个格子 $(i,j)$ ：可选连 $[0,1]$，必选连 $[1,1]$，不选啥都不干。</p>
<p>然后跑最大流就好了。</p>
<p>但是，有个很恶心的是他要求行和列选择的要相同。</p>
<p>这时候需要考虑增设一个费用，把每选一个格子就增设费用 $1$，即考虑行和列之间连边时的费用是 $1$。</p>
<p>还需要强制满足 $i$ 行和 $i$ 列选的个数相同。那么增设一条从 $i$ 行连向 $i$ 列，容量 $[0,\infty]$，费用为 $0$ 的边。那么它最后一定是要满流的（不满流就不是最大流了），且除了这条边以外的流量之和相等（否则就不满流了）。</p>
<p>这样就可以了，最后求个最大费用最大流。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> s,t;</span><br><span class="line"><span class="keyword">namespace</span> MCMF&#123;</span><br><span class="line">	<span class="type">int</span> ver[M],ne[M],cost[M],val[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; cost[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; cost[tot]=-c;ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d[N],pre[N],mi[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,t) d[i]=inf,pre[i]=mi[i]=<span class="number">0</span>;</span><br><span class="line">		d[s]=<span class="number">0</span>; mi[s]=inf; q.<span class="built_in">push</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[u]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]&gt;d[u]+cost[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+cost[i];</span><br><span class="line">					pre[v]=i; mi[v]=<span class="built_in">min</span>(mi[u],val[i]);</span><br><span class="line">					<span class="keyword">if</span>(!vis[v]) vis[v]=<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mi[t]!=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">spfa</span>();ans+=d[t]*mi[t])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> v=t;v!=s;v=ver[pre[v]^<span class="number">1</span>]) val[pre[v]]-=mi[t],val[pre[v]^<span class="number">1</span>]+=mi[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fx[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,a[N][N];</span><br><span class="line"><span class="type">char</span> ss[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (x<span class="number">-1</span>)*m+y+opt*n*m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss[i]+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">			<span class="keyword">if</span>(ss[i][j]==<span class="string">&#x27;R&#x27;</span>) a[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ss[i][j]==<span class="string">&#x27;L&#x27;</span>) a[i][j]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(ss[i][j]==<span class="string">&#x27;D&#x27;</span>) a[i][j]=<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> a[i][j]=<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s=<span class="number">0</span>; t=n*m*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">id</span>(i,j,<span class="number">0</span>),x,y;</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			x=i+fx[k],y=j+fy[k];</span><br><span class="line">			<span class="keyword">if</span>(x==<span class="number">0</span>) x=n; <span class="keyword">if</span>(x&gt;n) x=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(y==<span class="number">0</span>) y=m; <span class="keyword">if</span>(y&gt;m) y=<span class="number">1</span>;</span><br><span class="line">			MCMF::<span class="built_in">add</span>(u,<span class="built_in">id</span>(x,y,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>-(a[i][j]==k));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,m) MCMF::<span class="built_in">add</span>(s,<span class="built_in">id</span>(i,j,<span class="number">0</span>),<span class="number">1</span>,<span class="number">0</span>),MCMF::<span class="built_in">add</span>(<span class="built_in">id</span>(i,j,<span class="number">1</span>),t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,MCMF::<span class="built_in">work</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>Delight for a Cat[bzoj4842]</title>
    <url>/2020/06/03/Delight-for-a-Cat-bzoj4842/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://vjudge.net/problem/HYSBZ-4842">vjudge</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先你可以先强制令所有时间都打隔膜。那么如果某个时间点变为了睡觉，那么收益就为 $c_i=a_i-b_i$。</p>
<p>然后令 $x_i$ 表示每个时间段是否变为睡觉，那么有：</p>
<p>$$\forall j\in [1,n-k+1],t_1\leq \sum_{i=j}^{j+k-1} x_i\leq k-t_2$$</p>
<p>根据线性规划的那套东西，我们再设变量 $y_i$，将不等式变为等式：</p>
<p>$$\forall j\in [1,n-k+1],\sum_{i=j}^{j+k-1} x_i+y_j-t_1=0,y_j\leq k-t_1-t_2$$</p>
<p>再这 $n-k+1$ 个方程后面添加 $0=0$，然后差分得到：</p>
<p>$$x_1+x_2+\cdots+x_k+y_1-t_1=0 \\ x_{k+1}-x_1+y_2-y_1=0 \\ x_{k+2}-x_2+y_3-y_2=0 \\ \vdots \\ x_n-x_{n-k}+y_{n-k+1}-y_{n-k}=0 \\ -x_{n-k+1}-x_{n-k+2}-\cdots-x_n-y_{n-k+1}+t_1=0$$</p>
<p>最后要使得 $\sum x_ic_i$ 最大。</p>
<p>然后你发现每个变量都只出现了两遍，且系数为 $1$ 和 $-1$。</p>
<p>那么把每个方程看做一个点，每个变量从系数为 $1$ 的点连向 $-1$ 的点。对于 $x_i$，流量为 $1$，费用为 $c_i$；对于 $y_i$，流量为 $k-t_1-t_2$，费用为 $0$。因为网络流有个非常好的就是除了源汇点之外，流入=流出。这样连边就相当于保证了变量的上限以及变量的守恒。</p>
<p>然后跑最大费用最大流就好了。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">40010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">namespace</span> MCMF&#123;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],ne[M],cost[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	ll d[N];</span><br><span class="line">	<span class="type">int</span> mi[N],pre[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; cost[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; cost[tot]=-c;ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,t) d[i]=-inf,vis[i]=pre[i]=mi[i]=<span class="number">0</span>;</span><br><span class="line">		d[s]=<span class="number">0</span>; pre[s]=<span class="number">0</span>; mi[s]=<span class="number">2e9</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(s); vis[s]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[u]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]&lt;d[u]+cost[i])</span><br><span class="line">			&#123;</span><br><span class="line">				d[v]=d[u]+cost[i]; pre[v]=i; mi[v]=<span class="built_in">min</span>(mi[u],val[i]);</span><br><span class="line">				<span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mi[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			ans+=<span class="number">1ll</span>*d[t]*mi[t];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> v=t;v;v=ver[pre[v]^<span class="number">1</span>]) val[pre[v]]-=mi[t],val[pre[v]^<span class="number">1</span>]+=mi[t];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="type">int</span> n,k,t1,t2,a[N],b[N],pos[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); t1=<span class="built_in">read</span>(); t2=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) b[i]=<span class="built_in">read</span>(),sum+=b[i];</span><br><span class="line">	MCMF::s=<span class="number">0</span>; MCMF::t=n-k+<span class="number">3</span>;</span><br><span class="line">	MCMF::<span class="built_in">add</span>(MCMF::s,<span class="number">1</span>,k-t2,<span class="number">0</span>);</span><br><span class="line">	MCMF::<span class="built_in">add</span>(n-k+<span class="number">2</span>,MCMF::t,k-t2,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) MCMF::<span class="built_in">add</span>(<span class="built_in">max</span>(<span class="number">1</span>,i-k+<span class="number">1</span>),<span class="built_in">min</span>(i+<span class="number">1</span>,n-k+<span class="number">2</span>),<span class="number">1</span>,a[i]-b[i]),pos[i]=MCMF::head[<span class="built_in">max</span>(<span class="number">1</span>,i-k+<span class="number">1</span>)];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n-k+<span class="number">1</span>) MCMF::<span class="built_in">add</span>(i,i+<span class="number">1</span>,k-t1-t2,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum+MCMF::<span class="built_in">work</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">putchar</span>(MCMF::val[pos[i]]?<span class="string">&#x27;E&#x27;</span>:<span class="string">&#x27;S&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title>泳池[NOI2017]</title>
    <url>/2020/06/01/%E6%B3%B3%E6%B1%A0-NOI2017/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2304">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这种毒瘤DP谁想得到。。。</p>
<p>显然恰好为 $k$ 比较难算，</p>
<p>由于 $k$ 比较小，考虑DP，设 $g_i$ 表示前 $i$ 列中，第 $i$ 列的第一行格子必须不安全时的答案。</p>
<p>那么显然 $g_i$ 只跟前 $k$ 个值有关系。那么有 $g_i=\sum_{j=1}^kg_{i-j}h_j$。</p>
<p>最终的答案显然为 $\frac{g_{n+1}}{1-q}$。</p>
<p>如果算出了 $h_j$ 以及前 $k$ 项，那么就可以用常系数线性齐次递推做了，暴力多项式取模即可做到 $O(k^2\log n)$。</p>
<p>这个 $h_j$ 表示的 $j-1$ 列，$1001$ 行时，最大面积不超过 $k$ 的方案数。</p>
<p>考虑一个<del>我如何都想不到的</del>DP：设 $f_{i,j}$ 表示只有 $j$ 列，不考虑前 $i$ 行（即前 $i$ 行全都是安全的），第 $i+1$ 行开始出现不安全的，且最大面积不超过 $k$ 的方案数。设 $g_{i,j}=\sum_{k\geq i} f_{k,j}$。</p>
<p>那么当 $ij&gt;k$ 时，$f_{i,j}=0$。</p>
<p>否则，枚举第 $i+1$ 行，从左到右第 $1$ 个出现的不安全的点。</p>
<p>那么有：</p>
<p>$$f_{i,j}=\sum_{k=1}^jq^i(1-q)g_{i+1,k-1}g_{i,j-k}$$</p>
<p>这个DP看起来是 $O(k^3)$ 的，但由于 $ij\leq k$，实际上是 $O(k^2\log k)$ 的。</p>
<p>那么 $h_i$ 就很容易用 $f_{1,x}$ 来表示了。</p>
<p>时间复杂度 $O(k^2(\log k+\log n))$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll p,q,f[N][N],qw[N],g[N],h[N];</span><br><span class="line">ll a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mul</span><span class="params">(ll *a,ll *b,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,k) <span class="built_in">fo</span>(j,<span class="number">0</span>,k) c[i+j]=<span class="built_in">Add</span>(c[i+j],<span class="built_in">Mul</span>(a[i],b[j]));</span><br><span class="line">	<span class="built_in">fd</span>(i,k&lt;&lt;<span class="number">1</span>,k) <span class="built_in">fo</span>(j,<span class="number">0</span>,k) c[i+j-k]=<span class="built_in">Dec</span>(c[i+j-k],<span class="built_in">Mul</span>(c[i],h[j]));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,k<span class="number">-1</span>) a[i]=c[i],c[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Ppow</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	a[<span class="number">1</span>]=<span class="number">1</span>; b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,<span class="built_in">mul</span>(a,a,m)) <span class="keyword">if</span>(n&amp;<span class="number">1</span>) <span class="built_in">mul</span>(b,a,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Pow</span>(p,n);</span><br><span class="line">	<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[m+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">fd</span>(i,m,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i][<span class="number">0</span>]=<span class="number">1</span>; t=<span class="built_in">min</span>(n,m/i);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,t)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,j<span class="number">-1</span>) f[i][j]=<span class="built_in">Add</span>(f[i][j],<span class="built_in">Mul</span>(f[i+<span class="number">1</span>][k],f[i][j<span class="number">-1</span>-k]));</span><br><span class="line">			f[i][j]=<span class="built_in">Add</span>(f[i+<span class="number">1</span>][j],<span class="built_in">Mul</span>(f[i][j],qw[i]*p%mod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m++;</span><br><span class="line">	g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>) g[i]=<span class="built_in">Add</span>(g[i],<span class="built_in">Mul</span>(g[j],<span class="built_in">Mul</span>(p,f[<span class="number">1</span>][i-j<span class="number">-1</span>])));</span><br><span class="line">	h[m]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,m) h[m-i]=<span class="built_in">Dec</span>(<span class="number">0</span>,<span class="built_in">Mul</span>(p,f[<span class="number">1</span>][i<span class="number">-1</span>]));</span><br><span class="line">	<span class="built_in">Ppow</span>(n+<span class="number">1</span>,m);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) ans=<span class="built_in">Add</span>(ans,b[i]*g[i]%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Mul</span>(ans,<span class="built_in">Pow</span>(p,mod<span class="number">-2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); q=<span class="built_in">read</span>(); q=<span class="built_in">Mul</span>(q,<span class="built_in">Pow</span>(<span class="built_in">read</span>(),mod<span class="number">-2</span>));</span><br><span class="line">	qw[<span class="number">0</span>]=<span class="number">1</span>; p=<span class="built_in">Dec</span>(<span class="number">1</span>,q);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">1000</span>) qw[i]=<span class="built_in">Mul</span>(qw[i<span class="number">-1</span>],q);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Dec</span>(<span class="built_in">work</span>(m),<span class="built_in">work</span>(m<span class="number">-1</span>)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>常系数线性齐次递推</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串[FJWC2020Day3]</title>
    <url>/2020/06/01/%E5%AD%97%E7%AC%A6%E4%B8%B2-FJWC2020Day3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>你喜欢字符串。有人送了你一个仅含小写字母的字符串。</p>
<p>由于你是一名优秀的 𝑂𝐼er，所以你决定对这个字符串展开研究。</p>
<p>定义两个字符串是相似的，当且仅当存在至多一个 $i$ ，使得这两个字符串中只有第 $i$ 个字母不同。</p>
<p>你取出了这个字符串中所有长度为 $m$ 的子串。你想知道，对于每个长度为 $m$ 的子串，有多少个其它长度为 $m$ 的子串与它相似。</p>
<p>$n\leq 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>也不知为啥别人的可以这么短。。。</p>
<p>显然，两个字符串 $i,j$ 是相似的当且仅当 $lcp(i,j)+lcs(i+m-1,j+m-1)\geq m-1$。</p>
<p>那么分别对正串和反串建出 SAM 的建出两棵树，记 $P1_i$ 和 $P2_i$ 表示第 $i$ 个长度为 $m$ 的字符串在两棵树中的所在的位置，那么上面的条件就是 $len_{lca1(P1_i,P1_j)}+len_{lca2(P2_i,P2_j)}\geq m-1$。</p>
<p>那么，我们可以对两棵树进行处理。</p>
<p>首先对第一棵树进行dsu on tree。枚举第一棵树的lca，那么上述条件就是 $len_{lca2(P2_i,P2_j)}\geq m-1-len_{lca}$</p>
<p>先递归处理轻儿子，然后将贡献删掉。然后递归重儿子，保留其贡献。</p>
<p>我们只需要考虑：</p>
<h4 id="轻儿子节点之间的贡献"><a href="#轻儿子节点之间的贡献" class="headerlink" title="轻儿子节点之间的贡献"></a>轻儿子节点之间的贡献</h4><p>对于一个节点 $u$，将轻儿子从左到右排成一列，只考虑 $j&lt;i$ 时 $j$ 对 $i$ 的贡献（否则反过来再处理一遍就可以了），那么枚举第 $i$ 个轻儿子的子树中的节点，考虑之前的所有节点，要使得在第二棵树上的 $len_{lca2}$ 大于等于 $k=m-1-len_{lca}$，那么用倍增找到这个节点在第二棵树上的祖先中最浅的节点 $w$，使得 $len_w\geq k$。</p>
<p>之后就在 $w$ 的子树中找有多少个节点满足这个节点在第一棵树中在 $j$ 的子树里。这个是一个单点加，区间查询，用树状数组维护即可。</p>
<h4 id="重儿子对轻儿子的贡献"><a href="#重儿子对轻儿子的贡献" class="headerlink" title="重儿子对轻儿子的贡献"></a>重儿子对轻儿子的贡献</h4><p>显然你不能再枚举一遍重儿子，那么再维护一个树状数组（表示的就是上面所说的贡献），意义跟第一种情况是几乎一样的，然后枚举轻儿子的所有节点，倍增，然后查询即可。</p>
<h4 id="轻儿子对重儿子的贡献"><a href="#轻儿子对重儿子的贡献" class="headerlink" title="轻儿子对重儿子的贡献"></a>轻儿子对重儿子的贡献</h4><p>显然你不能再枚举一遍重儿子，那么对于一个轻儿子子树中的节点 $v$ 而言，设它在一种情况中的 $w$ 是 $w_v$，那么所有满足在第一棵树重儿子的子树中且在第二棵树 $w_v$ 的子树中的节点的答案需要加 $1$。</p>
<p>这是一个矩形加，最后再单点查询的问题。</p>
<p>那么将矩形加离线，然后扫描线+树状数组解决即可。</p>
<p>综上，时间复杂度是 $O(n\log^2n)$ 的。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><del>也就接近300行而已。。。</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> c[N],d[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;x&lt;=cnt;x+=<span class="built_in">lowbit</span>(x)) b[x]+=d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(b,l,d); <span class="built_in">add</span>(b,r+<span class="number">1</span>,-d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) s+=b[x];</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> *b,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ask</span>(b,r)-<span class="built_in">ask</span>(b,l<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][<span class="number">26</span>],len[N],fa[N],siz,las;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,siz) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),len[i]=fa[i]=<span class="number">0</span>;</span><br><span class="line">		siz=las=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> cur=++siz,p=las;</span><br><span class="line">		len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> np=++siz;</span><br><span class="line">				len[np]=len[p]+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[np],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				fa[np]=fa[q];</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=np;</span><br><span class="line">				fa[cur]=fa[q]=np;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur;</span><br><span class="line">		<span class="keyword">return</span> las;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> T2&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> dfl[N],dfr[N],tim,f[N][<span class="number">18</span>],len[N],p[N],id[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addtree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfl[u]=++tim;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">17</span>) f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) f[v][<span class="number">0</span>]=u,<span class="built_in">pre_dfs</span>(v);</span><br><span class="line">		dfr[u]=tim;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">17</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[x][i]&amp;&amp;len[f[x][i]]&gt;=d) x=f[x][i];</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> T1&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> dfl[N],dfr[N],tim,id[N],p[N],siz[N],son[N],len[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addtree</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[u]=<span class="number">1</span>; dfl[u]=++tim;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">pre_dfs</span>(v);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">		dfr[u]=tim;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> _w[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dd)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(id[u]) BIT::<span class="built_in">add</span>(c,T2::dfl[T2::p[id[u]]],dd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> t=id[u],v=T2::p[t],w=T2::<span class="built_in">jump</span>(v,k);</span><br><span class="line">		_w[u]=w;</span><br><span class="line">		ans[t]+=BIT::<span class="built_in">ask</span>(c,T2::dfl[w],T2::dfr[w]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">add</span>(u,d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">add_dfs</span>(v,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ask_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">ask</span>(u,k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">ask_dfs</span>(v,k);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc_d</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> t=id[u],w=_w[u];</span><br><span class="line">		ans[t]+=BIT::<span class="built_in">ask</span>(d,T2::dfl[w],T2::dfr[w]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_d</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> dd)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(id[u]) BIT::<span class="built_in">add</span>(d,T2::dfl[T2::p[id[u]]],dd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add_d_dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">add_d</span>(u,d);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">add_d_dfs</span>(v,d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">calc_d_dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">calc_d</span>(u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">calc_d_dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">		<span class="type">int</span> l,r,d;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;query&gt; q[N];</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!id[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> w=_w[u];</span><br><span class="line">		q[l].<span class="built_in">pb</span>((query)&#123;T2::dfl[w],T2::dfr[w],<span class="number">1</span>&#125;);</span><br><span class="line">		q[r+<span class="number">1</span>].<span class="built_in">pb</span>((query)&#123;T2::dfl[w],T2::dfr[w],<span class="number">-1</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins_dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">ins</span>(u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">ins_dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">bool</span> flag)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> tot=adj[u].<span class="built_in">size</span>(),v,k=m<span class="number">-1</span>-len[u];</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(son[u]) <span class="built_in">dfs</span>(son[u],<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ask</span>(u,k);</span><br><span class="line">		<span class="built_in">add</span>(u,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">ask_dfs</span>(v,k); <span class="built_in">add_dfs</span>(v,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">add</span>(u,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add_dfs</span>(v,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fd</span>(i,tot<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">ask_dfs</span>(v,k); <span class="built_in">add_dfs</span>(v,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ask</span>(u,k);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">add_dfs</span>(v,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">calc_d</span>(u);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">calc_d_dfs</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add_d</span>(u,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">			&#123;</span><br><span class="line">				v=adj[u][i];</span><br><span class="line">				<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="built_in">add_d_dfs</span>(v,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(son[u]) <span class="built_in">add_d_dfs</span>(son[u],<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">		l=dfl[son[u]],r=dfr[son[u]];</span><br><span class="line">		<span class="built_in">ins</span>(u);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			v=adj[u][i];</span><br><span class="line">			<span class="keyword">if</span>(v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="built_in">ins_dfs</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> g[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n-m+<span class="number">1</span>) g[dfl[p[i]]]=i;</span><br><span class="line">		<span class="type">int</span> si=tim;</span><br><span class="line">		<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,si)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:q[i]) BIT::<span class="built_in">add</span>(c,x.l,x.r,x.d);</span><br><span class="line">			<span class="keyword">if</span>(!g[i]) <span class="keyword">continue</span>;</span><br><span class="line">			ans[g[i]]+=BIT::<span class="built_in">ask</span>(c,T2::dfl[T2::p[g[i]]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	SAM::<span class="built_in">init</span>();</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		x=SAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=m) T1::p[i-m+<span class="number">1</span>]=x,T1::id[x]=i-m+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,SAM::siz) T1::<span class="built_in">addtree</span>(SAM::fa[i],i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,SAM::siz) T1::len[i]=SAM::len[i];</span><br><span class="line">	SAM::<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=SAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="keyword">if</span>(i+m<span class="number">-1</span>&lt;=n) T2::p[i]=x,T2::id[x]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,SAM::siz) T2::<span class="built_in">addtree</span>(SAM::fa[i],i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,SAM::siz) T2::len[i]=SAM::len[i];</span><br><span class="line">	cnt=SAM::siz;</span><br><span class="line">	T1::<span class="built_in">pre_dfs</span>(<span class="number">1</span>);</span><br><span class="line">	T2::<span class="built_in">pre_dfs</span>(<span class="number">1</span>);</span><br><span class="line">	T1::<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n-m+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>SAM</tag>
        <tag>树状数组</tag>
        <tag>倍增</tag>
        <tag>扫描线</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>夕张的改造[FJWC2020Day4]</title>
    <url>/2020/05/30/%E5%A4%95%E5%BC%A0%E7%9A%84%E6%94%B9%E9%80%A0-FJWC2020Day4/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://gmoj.net/senior/#main/show/6569">jzoj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>提督们惊奇地发现，2019 年实装的改造非常少。</p>
<p>经调查，原来是改造厂的厂长于八日克扣了其他舰娘改造的图纸，并且在 2020 年的第一个月利用这些图纸进行了华丽的改造，一共有三种形态，于八日改二，于八日改二特，于八日改二丁，对空、对陆、对潜、开幕雷、五装备格，无所不能。镇守府雪菜八万钢惨遭退役。</p>
<p>舰娘的结构可以看成一棵 $n$ 个点的树，点编号为 $0 \sim n−1$。使用一张图纸可以把树中的某一条边去掉，再加上一条边，使得它依然是一棵树。</p>
<p>现在，于八日想在 2020 年继续拿走别的舰娘的图纸对自己进行改造，她一共拿走了 $k$ 张图纸。她想知道，自己经过接下来的改造之后，总共会有多少种形态。两个形态不同，表示有一条边 $(x,y)$ 在第一棵树中出现，在另一棵树中不出现。</p>
<p>$k\leq n\leq 50$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题还挺简单的。。。</p>
<p>刚开始在想树形DP，结果毫无思路，那么剩下的就只有矩阵树定理了。</p>
<p>题目实际上要求的是至多有不超过 $k$ 条边不出现在原树中的生成树。</p>
<p>我们知道，矩阵树定理求的是生成树的边权的乘积。</p>
<p>那么对于所有不在原树的边，边权为 $x$，否则为 $1$。求出来的行列式是一个 $n-1$ 次多项式。</p>
<p>然后想到暴力算多项式乘法，时间复杂度 $O(n^5)$。（应该过不了）</p>
<p>哪有人这么蠢的。既然是一个多项式，那么把 $x=1,2\cdots n$ 代进去，算出来后暴力拉格朗日差值就好了。</p>
<p>时间复杂度 $O(n^4)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   y%=(mod<span class="number">-1</span>);ll f=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) f=f*x%mod;</span><br><span class="line">   <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">ll a[N][N];</span><br><span class="line"><span class="type">bool</span> bo[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">guass</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>,tmp;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j=<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(k,i,n) <span class="keyword">if</span>(a[k][i]) &#123;j=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(j!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			ans=mod-ans;</span><br><span class="line">			<span class="built_in">ff</span>(k,i,n) <span class="built_in">swap</span>(a[j][k],a[i][k]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">ff</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp=<span class="built_in">Pow</span>(a[i][i],mod<span class="number">-2</span>)*a[j][i]%mod;</span><br><span class="line">			<span class="built_in">ff</span>(k,i,n) a[j][k]=<span class="built_in">Dec</span>(a[j][k],tmp*a[i][k]%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) ans=<span class="built_in">Mul</span>(ans,a[i][i]);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) <span class="built_in">ff</span>(j,<span class="number">0</span>,n) a[i][j]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		<span class="built_in">ff</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			v=bo[i][j]?<span class="number">1</span>:x;</span><br><span class="line">			a[i][j]-=v; a[j][i]-=v;</span><br><span class="line">			a[i][i]+=v; a[j][j]+=v;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,n) <span class="built_in">ff</span>(j,<span class="number">0</span>,n) a[i][j]=(a[i][j]+mod)%mod;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">guass</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ll h[N],f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>();</span><br><span class="line">		bo[x][i]=bo[i][x]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		ll tmp=<span class="built_in">calc</span>(i),d;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,n) g[j]=<span class="number">0</span>;</span><br><span class="line">		g[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(j!=i)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp=<span class="built_in">Mul</span>(tmp,(i&lt;j)?(mod-<span class="built_in">Pow</span>(j-i,mod<span class="number">-2</span>)):<span class="built_in">Pow</span>(i-j,mod<span class="number">-2</span>));</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				h[k]=<span class="built_in">Mul</span>(mod-j,g[k]);</span><br><span class="line">				<span class="keyword">if</span>(k) h[k]=<span class="built_in">Add</span>(h[k],g[k<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,n) g[k]=h[k],h[k]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,n) f[j]=<span class="built_in">Add</span>(f[j],<span class="built_in">Mul</span>(g[j],tmp));</span><br><span class="line">	&#125;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m) sum=<span class="built_in">Add</span>(sum,f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Honorable Mention[gym102331H]</title>
    <url>/2020/05/29/Honorable-Mention-gym102331H/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/gym/102331/problem/H">CF</a></p>
<p><a href="https://gmoj.net/senior/#main/show/6664">jzoj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个长度为 $n$ 的序列，$m$ 个询问，每次询问在 $[l,r]$ 内选出 $k$ 段互不相交的子段，使得子段和最大。</p>
<p>$n,m\leq 35000,k\leq r-l+1,|a_i|\leq 35000$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这跟之前某道题有点像啊。</p>
<p>$k$ 很小时，一个非常简单的做法是模拟费用流，每次在线段树中找出区间内的最大子段，然后加进答案里，再把这个子段的所有数变成其相反数。</p>
<p>这样的单次询问时间复杂度是 $O(k\log n)$ 的。</p>
<p>能在jzoj上获得大概 $28\sim 40$ 的分数。</p>
<p>这个做法无法再扩展下去了，我们考虑换另一种。</p>
<p>考虑DP，设 $f_i$ 表示在该区间中选 $i$ 段的最大值。</p>
<p>显然有 $f_{i+1}-f_i\leq f_i-f_{i-1}$，也就是说，$f_i$ 会形成一个上凸包的形式。</p>
<p>考虑如何将两个区间合并到一起。</p>
<p>设这两个区间为 $a,b$，假设先不考虑两个区间衔接的地方是否将选两次合成一次，那么就有：</p>
<p>$$f_{ab}(i)=\max_{j+k=i}\{f_a(j)+f_b(k)\}$$</p>
<p>又由于这个 $f$ 是一个上凸包的形式，这个式子相当于是对 $f_a$ 和 $f_b$ 两个凸包做了一次闵科夫斯基和。</p>
<p>那么就可以用归并的思路，将 $f_a,f_b$ 合并到一起。</p>
<p>考虑两个区间衔接的地方是否将选两次合成一次：对于每个区间，记录 $g_{0/1,0/1}$ 表示左右端点是否选择时的 $f$ 数组，当 $a$ 的右端点和 $b$ 的左端点均选择的时候，实际上就是将 $f_{ab}$ 向左移了一位。</p>
<p>那么就可以将这两个区间在线性时间内的答案合并到一起。</p>
<p>可以开一个线段树。预处理出线段树中区间的答案。</p>
<p>这一部分的时间复杂度是 $O(n\log n)$ 的，有个 $2^4$ 的常数。</p>
<p>然后考虑如何计算一个区间的答案。</p>
<p>显然这个区间可以表示成线段树中 $O(\log n)$ 的区间。</p>
<p>显然我们不能直接将这写区间合并到一起。</p>
<p>由于斜率是单调不增的，我们可以考虑使用wqs二分，二分答案对应的斜率，然后对于线段树中的每个区间，再来一次二分，找到斜率所对应的贡献即可。</p>
<p>时间复杂度是 $O(q\log^ n\log V)$ 的，还有至少是 $8$ 的常数。</p>
<p>这个显然过不了。</p>
<p>因为可以离线，我们使用整体二分也应是可以的。</p>
<p>但我们也可以一起二分，将这些询问的 $mid$ 值从大到小排序，然后对于每个那样的上凸包，都记录一个指针表示当前在哪里。对于每次外面的二分，这个指针只会向右移动。因此，每次外面的二分，所有的指针移动次数是 $O(n\log n)$ 级别的。</p>
<p>那么这样就不需要线段树里面的二分了。</p>
<p>时间复杂度 $O(n\log n+q\log v\log q+n\log n\log v)$，有个 $16$ 左右的常数。</p>
<p><strong>二分范围搞错了，导致调了好久。。。</strong></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">35004</span>;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="type">const</span> ll inf=N*N;</span><br><span class="line"><span class="type">const</span> ll INF=inf*N;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vec vector<span class="string">&lt;ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">Vec g[N&lt;&lt;<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(Vec &amp;A,Vec b,Vec c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=b.<span class="built_in">size</span>()<span class="number">-1</span>,m=c.<span class="built_in">size</span>()<span class="number">-1</span>,nl=<span class="number">0</span>,ml=<span class="number">0</span>,tot=<span class="number">1</span>;</span><br><span class="line">	A.<span class="built_in">resize</span>(n+m+<span class="number">1</span>);</span><br><span class="line">	ll dec;</span><br><span class="line">	dec=A[<span class="number">0</span>]=b[<span class="number">0</span>]+c[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(;nl&lt;n&amp;&amp;ml&lt;m;tot++)</span><br><span class="line">		<span class="keyword">if</span>(b[nl+<span class="number">1</span>]-b[nl]&gt;c[ml+<span class="number">1</span>]-c[ml])</span><br><span class="line">		&#123;</span><br><span class="line">			dec+=b[nl+<span class="number">1</span>]-b[nl];</span><br><span class="line">			nl++; A[tot]=dec;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			dec+=c[ml+<span class="number">1</span>]-c[ml];</span><br><span class="line">			ml++; A[tot]=dec;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(;nl&lt;n;tot++,nl++) dec+=b[nl+<span class="number">1</span>]-b[nl],A[tot]=dec;</span><br><span class="line">	<span class="keyword">for</span>(;ml&lt;m;tot++,ml++) dec+=c[ml+<span class="number">1</span>]-c[ml],A[tot]=dec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(Vec &amp;A,Vec B,<span class="type">bool</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		A[i]=<span class="built_in">max</span>(A[i],B[i]);</span><br><span class="line">		<span class="keyword">if</span>(opt&amp;&amp;i) A[i<span class="number">-1</span>]=<span class="built_in">max</span>(A[i<span class="number">-1</span>],B[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			g[x][i][j].<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>) g[x][i][j][k]=-inf;</span><br><span class="line">		&#125;</span><br><span class="line">		g[x][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; t=g[x][<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">read</span>();</span><br><span class="line">		sum+=<span class="built_in">abs</span>(t);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">	Vec A;</span><br><span class="line">	<span class="type">int</span> len=r-l+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(u,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(v,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g[x][u][v].<span class="built_in">resize</span>(len+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,len) g[x][u][v][i]=-INF;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(u,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(v,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(w,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(t,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">get</span>(A,g[lc][u][v],g[rc][w][t]);</span><br><span class="line">		<span class="built_in">merge</span>(g[x][u][t],A,v&amp;&amp;w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//calc(g)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	ll x; <span class="type">int</span> y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.x!=B.x) <span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">		<span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (node)&#123;A.x+B.x,A.y+B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> now,pos[N&lt;&lt;<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">node f[<span class="number">2</span>],pre[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">find</span><span class="params">(Vec &amp;A,<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;p&lt;A.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;A[p+<span class="number">1</span>]-A[p]&gt;=now;p++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcf</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) pre[i]=f[i],f[i]=(node)&#123;-inf,-inf&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(x,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(y,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">find</span>(g[u][x][y],pos[u][x][y]);</span><br><span class="line">		node tmp=(node)&#123;g[u][x][y][pos[u][x][y]],pos[u][x][y]&#125;,las;</span><br><span class="line">		<span class="built_in">fo</span>(z,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			las=tmp+pre[z]; las.x-=<span class="number">1ll</span>*tmp.y*now;</span><br><span class="line">			f[y]=<span class="built_in">max</span>(f[y],las);</span><br><span class="line">			<span class="keyword">if</span>(z&amp;&amp;x)</span><br><span class="line">			&#123;</span><br><span class="line">				las.y--; las.x+=now;</span><br><span class="line">				f[y]=<span class="built_in">max</span>(f[y],las);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">calcf</span>(x));</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">ask</span>(ls,L,R);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">ask</span>(rs,L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,k,L,R;</span><br><span class="line">&#125;q[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> id[N],mid[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) mid[i]=((ll)q[i].L+q[i].R)&gt;&gt;<span class="number">1</span>,id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+m+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> mid[x]&gt;mid[y];&#125;);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n&lt;&lt;<span class="number">2</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>) pos[i][j][k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,flag;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">init</span>(); flag=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			x=id[i];</span><br><span class="line">			<span class="keyword">if</span>(q[x].L&gt;q[x].R) <span class="keyword">continue</span>;</span><br><span class="line">			flag=<span class="number">0</span>; now=mid[x];</span><br><span class="line">			f[<span class="number">0</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; f[<span class="number">1</span>]=(node)&#123;-inf,inf&#125;;</span><br><span class="line">			<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,q[x].l,q[x].r);</span><br><span class="line">			f[<span class="number">0</span>]=<span class="built_in">max</span>(f[<span class="number">0</span>],f[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span>(f[<span class="number">0</span>].y&gt;=q[x].k) q[x].L=mid[x]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> q[x].R=mid[x]<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) mid[i]=q[i].L<span class="number">-1</span>,id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+m+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> mid[x]&gt;mid[y];&#125;);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n&lt;&lt;<span class="number">2</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>) pos[i][j][k]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=id[i];</span><br><span class="line">		now=mid[x];</span><br><span class="line">		f[<span class="number">0</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;; f[<span class="number">1</span>]=(node)&#123;-inf,inf&#125;;</span><br><span class="line">		<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,q[x].l,q[x].r);</span><br><span class="line">		f[<span class="number">0</span>]=<span class="built_in">max</span>(f[<span class="number">0</span>],f[<span class="number">1</span>]);</span><br><span class="line">		ans[x]=f[<span class="number">0</span>].x+<span class="number">1ll</span>*q[x].k*now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>(),q[i].k=<span class="built_in">read</span>();</span><br><span class="line">		q[i].L=<span class="number">-35000</span>; q[i].R=sum/q[i].k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>网络流</tag>
        <tag>闵科夫斯基和</tag>
        <tag>线段树</tag>
        <tag>wqs二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Easy Win[gym102331E]</title>
    <url>/2020/05/29/Easy-Win-gym102331E/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://codeforces.com/gym/102331/problem/E">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$m$ 条边，有边权 $a$ 和价值 $v$。在前 $i$ 条边中选出若干条，使得不存在一个环，边权的异或和为 $0$。求选的边的价值之和的最大值。</p>
<p>$n\leq 64,a_i&lt; 2^{60},v_i\leq 10^9$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>边权的异或和不为 $0$，可以看成是这些向量都线性无关。</p>
<p>但现在加多了一个环的条件。发现 $n$ 非常小，可以从中搞些事情。</p>
<p>对于一条边 $(x,y,a)$，我们只需要把边权改为 $a+2^{60}(2^x+2^y)$。</p>
<p>那么成环且异或和为 $0$ 的条件就变为了这些边权形成的向量线性相关。</p>
<p>题目转换成，求在前 $i$ 个向量里，选出一些使得它们线性无关，且向量的权值和最大。</p>
<p>如果不是求前缀，则可以排个序，然后从大到小插入线性基里。</p>
<p>现在可以对于线性基里的每个数，记录它是由哪些向量异或得来的。</p>
<p>加入一个向量，如果最后无法插入线性基里，变成了 $0$，则替换掉表示这个向量的所有向量中，权值最小的那个，然后更新由哪些向量得来的数组即可。</p>
<p>时间复杂度 $O(q\frac{(n+60)^2}{w})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">128</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Bit bitset<span class="string">&lt;M&gt;</span></span></span><br><span class="line">ll ans;</span><br><span class="line">Bit b[M],a[M];</span><br><span class="line"><span class="type">bool</span> vis[M];</span><br><span class="line">ll val[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(Bit u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Bit now; now.<span class="built_in">reset</span>();</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">125</span>,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span>(u[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[i])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i]=<span class="number">1</span>; ans+=v; val[i]=v;</span><br><span class="line">				b[i]=u; a[i]=now;</span><br><span class="line">				a[i][i]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			u^=b[i]; now^=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">125</span>)</span><br><span class="line">		<span class="keyword">if</span>(vis[i]&amp;&amp;now[i])</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">-1</span>||val[i]&lt;val[t]) t=i;</span><br><span class="line">	<span class="keyword">if</span>(v&gt;val[t])</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=v-val[t];</span><br><span class="line">		now[t]=<span class="number">0</span>; val[t]=v;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">125</span>) <span class="keyword">if</span>(vis[i]&amp;&amp;a[i][t]) a[i]^=now;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">read</span>();</span><br><span class="line">	Bit b;</span><br><span class="line">	<span class="type">int</span> x,y,v;</span><br><span class="line">	ll a;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>()<span class="number">-1</span>,y=<span class="built_in">read</span>()<span class="number">-1</span>; a=<span class="built_in">read</span>(); v=<span class="built_in">read</span>();</span><br><span class="line">		b.<span class="built_in">reset</span>();</span><br><span class="line">		b[x]=<span class="number">1</span>; b[y]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,<span class="number">60</span>) <span class="keyword">if</span>((a&gt;&gt;i)&amp;<span class="number">1</span>) b[<span class="number">64</span>+i]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">ins</span>(b,v);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
        <category>jzoj</category>
      </categories>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>图[FJWC2020Day3]</title>
    <url>/2020/05/28/%E5%9B%BE-FJWC2020Day3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一张 $n$ 个点，$m$ 条边的无向图，你想选出一个非空点集，使得仅保留这个点集中的点和两个端点都在这个点集里的边后得到的图是连通的。你想知道有多少种可能的选点集的方案。</p>
<p>对 $2$ 取模。</p>
<p>$n\leq 50$，对于所有的边 $(x,y)$，均有 $|x-y|\leq 12$。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这种毒瘤题谁想得到啊qwq。</p>
<p>看到 $|x-y|\leq 12$，能想到状压，也就是 $f_{i,s}$ 表示前 $i$ 位，$[i-11,i]$ 状态为 $s$ 的答案是什么。</p>
<p>导出子图连通，也就是连通块个数为 $1$，否则大于 $1$。</p>
<p>又看到答案对 $2$ 取模。如果用 $cnt$ 表示连通块个数，那么计算 $\sum 2^{cnt}\mod 4$ 就可以了。（这谁想得到啊qwq）</p>
<p>因为当连通块个数大于 $1$ 时，$2^{cnt}\equiv 0\pmod 4$。</p>
<p>而我们知道，连通块个数是非常难统计的。我们转换一下，对于一个导出子图，变成求将点分成两个部分，不同部分的点之间没有连边的方案数。</p>
<p>那么就可以状压了，一个点有三个状态，分别是不在导出子图里，在第一部分，在第二部分。</p>
<p>转移很简单。</p>
<p>最后记得将空集去掉。</p>
<p>时间复杂度 $O(n\times 12\times 3^{12})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">531442</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> bo[N][N];</span><br><span class="line"><span class="type">int</span> pw[<span class="number">13</span>],f[N][M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bit</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x/pw[y]%<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(graph);</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		bo[x][y]=bo[y][x]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">12</span>) pw[i]=pw[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> w,t,b[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="built_in">ff</span>(s,<span class="number">0</span>,pw[<span class="number">12</span>])</span><br><span class="line">			<span class="keyword">if</span>(w=f[i<span class="number">-1</span>][s])</span><br><span class="line">			&#123;</span><br><span class="line">				t=s/<span class="number">3</span>;</span><br><span class="line">				(f[i][t]+=w)&amp;=<span class="number">3</span>;</span><br><span class="line">				b[<span class="number">1</span>]=b[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">ff</span>(j,<span class="built_in">max</span>(<span class="number">13</span>-i,<span class="number">0</span>),<span class="number">12</span>)</span><br><span class="line">					<span class="keyword">if</span>(bo[i][i<span class="number">-12</span>+j])</span><br><span class="line">						b[<span class="number">3</span>-<span class="built_in">bit</span>(s,j)]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(b[<span class="number">1</span>]) (f[i][t+pw[<span class="number">11</span>]]+=w)&amp;=<span class="number">3</span>;</span><br><span class="line">				<span class="keyword">if</span>(b[<span class="number">2</span>]) (f[i][t+<span class="number">2</span>*pw[<span class="number">11</span>]]+=w)&amp;=<span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">3</span>;</span><br><span class="line">	<span class="built_in">ff</span>(s,<span class="number">0</span>,pw[<span class="number">12</span>]) (ans+=f[n][s])&amp;=<span class="number">3</span>;</span><br><span class="line">	ans&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>挖宝[FJWC2020Day3]</title>
    <url>/2020/05/28/%E6%8C%96%E5%AE%9D-FJWC2020Day3/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个挖宝游戏，它在一棵 n 个点的树上进行，宝藏埋在某个未知的点 $𝑥$ 。每次挖掘一个点 $u$，玩家得到的反馈信息是一个数值 $d$，表示 $u$ 号点到 $𝑥$ 号点简单路径上的边数。这个游戏会进行 $q$ 次，每次游戏藏宝的位置不一定相同。</p>
<p>你作为一名优秀的 OIer，对自己无比自信。你希望用最少的挖掘次数来找出宝藏。于是你挑了两个不同的点 $a,b$ 进行挖掘，并得到了反馈信息，分别为 $d_a,d_b$。接下来的第三次挖掘中，你想要直接奔着一个可能的 $𝑥$ 进行挖掘。由于树太大了，凭借人眼无法找出 $𝑥$ 的确切位置，你便转向了电脑，开始写一个程序，帮助你解决这个问题。</p>
<p>$n,q\leq 10^6,1\leq d \leq n$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一道这么简单的lca写完后都调了1个多小时。。。</p>
<p>主要还是有一些细节没有考虑到。</p>
<p>首先通过树上倍增，我们可以在 $O(\log n)$ 的时间内，求出两点的 $lca$，某个点到根节点路径中距离为 $d$ 的点，某个点到另外一点的路径中距离为 $d$ 的点。</p>
<p>设 $k=\frac{d_a+d_b-dist(a,b)}{2}$，这个 $k$ 表示的是，$a$ 到 $x$ 和 $b$ 到 $x$ 这两条路径在最后面的重合的长度。</p>
<p>显然如果 $k$ 不为整数或者 $&lt;0$ 就一定无解。</p>
<p>那么就可以找到从 $a$ 出发到 $b$ 的路径中第 $d_a-k$ 个点，设为 $z$。（显然如果 $d_a-k&lt;0$ 或者 $d_a-k&gt;dist(a,b)$ 也无解。）</p>
<p>转换成求任意一点 $x$，满足从 $z$ 出发，不经过 $a,b$ 两点的方向到达 $x$，且距离为 $k$。</p>
<p>那么就可以先判断满足条件的最远的点到 $z$ 的距离是否大于等于 $k$，如果存在，那么就从 $z$ 往这个点跳 $k$ 步即可。</p>
<p>假定 $1$ 为根，然后dfs找出子树中路径前 $3$ 长的路径，以及往根方向走的最长的路径。这样就可以枚举这 $4$ 个方向，然后判断这四个方向到 $z$ 的路径是否符合条件，分类讨论一下即可。</p>
<p>时间复杂度 $O(n\log n)$，常数有点大。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,dep[N],f[N][<span class="number">21</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,d;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.d&gt;=B.d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!B.u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!A.u) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> A.d&lt;B.d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> <span class="type">int</span> &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (node)&#123;A.u,A.d+B&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	node a[<span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(node b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		b.d++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">			<span class="keyword">if</span>(b&gt;=a[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fd</span>(j,<span class="number">1</span>,i) a[j+<span class="number">1</span>]=a[j];</span><br><span class="line">				a[i]=b;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;mx[N];</span><br><span class="line">node h[N];</span><br><span class="line"><span class="type">int</span> tim,l[N],r[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	l[u]=++tim;</span><br><span class="line">	dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">	f[u][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">20</span>) f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		mx[u].<span class="built_in">ins</span>(mx[v].a[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	mx[u].<span class="built_in">ins</span>((node)&#123;u,<span class="number">-1</span>&#125;);</span><br><span class="line">	r[u]=tim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">20</span>,<span class="number">0</span>) <span class="keyword">if</span>(dep[f[y][i]]&gt;=dep[x]) y=f[y][i];</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">20</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> dep[x]+dep[y]-(dep[<span class="built_in">lca</span>(x,y)]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">20</span>) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;d) x=f[x][i];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,node g)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	h[u]=g;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(mx[u].a[<span class="number">0</span>].d==<span class="built_in">dist</span>(v,mx[u].a[<span class="number">0</span>].u)+<span class="number">1</span>) <span class="built_in">dfs2</span>(v,u,<span class="built_in">max</span>(g+<span class="number">1</span>,mx[u].a[<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">dfs2</span>(v,u,<span class="built_in">max</span>(g+<span class="number">1</span>,mx[u].a[<span class="number">0</span>]+<span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> z=<span class="built_in">lca</span>(x,y);</span><br><span class="line">	<span class="keyword">if</span>(dep[x]-dep[z]&gt;=d) <span class="keyword">return</span> <span class="built_in">jump</span>(x,d);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">jump</span>(y,(dep[x]+dep[y]-(dep[z]&lt;&lt;<span class="number">1</span>))-d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">dist</span>(x,y)+<span class="built_in">dist</span>(y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> l[x]&lt;=l[a]&amp;&amp;l[a]&lt;=r[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	node u;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span>(mx[x].a[i].d&gt;=k)</span><br><span class="line">	&#123;</span><br><span class="line">		u=mx[x].a[i];</span><br><span class="line">		<span class="comment">//DEBUG(u.u);</span></span><br><span class="line">		<span class="keyword">if</span>((!<span class="built_in">check</span>(x,a)||<span class="built_in">lca</span>(u.u,a)==x)&amp;&amp;(!<span class="built_in">check</span>(x,b)||<span class="built_in">lca</span>(u.u,b)==x)) <span class="keyword">return</span> <span class="built_in">jump</span>(x,u.u,k);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cerr&lt;&lt;&quot;FUCK&quot;&lt;&lt;h[x].d;</span></span><br><span class="line">	<span class="keyword">if</span>(h[x].d&gt;=k)</span><br><span class="line">	&#123;</span><br><span class="line">		u=h[x];</span><br><span class="line">		<span class="comment">//DEBUG(u.u);</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(x,a)&amp;&amp;<span class="built_in">check</span>(x,b))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//DEBUG(k);</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">jump</span>(x,u.u,k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(hunting);</span><br><span class="line">	n=<span class="built_in">read</span>(); <span class="type">int</span> q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> x,y,dx,dy,dis,k,z;q--;)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(); dx=<span class="built_in">read</span>(); y=<span class="built_in">read</span>(); dy=<span class="built_in">read</span>();</span><br><span class="line">		z=<span class="built_in">lca</span>(x,y); dis=dep[x]+dep[y]-(dep[z]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		k=dx+dy-dis;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;<span class="number">0</span>||(k&amp;<span class="number">1</span>)) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		k/=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(dx-k&lt;<span class="number">0</span>||dx-k&gt;dis) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]-dep[z]&gt;=dx-k) z=<span class="built_in">jump</span>(x,dx-k);</span><br><span class="line">		<span class="keyword">else</span> z=<span class="built_in">jump</span>(y,dy-k);</span><br><span class="line">		<span class="comment">//DEBUG(z); DEBUG(k);</span></span><br><span class="line">		<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,z);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">work</span>(z,k,x,y));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>换根DP</tag>
      </tags>
  </entry>
  <entry>
    <title>黑红兔[FJWC2020Day1]</title>
    <url>/2020/05/27/%E9%BB%91%E7%BA%A2%E5%85%94-FJWC2020Day1/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><img src="/%E9%BB%91%E7%BA%A2%E5%85%94-FJWC2020Day1/problem.png" alt="problem"></p>
<p>$n\leq 5\times 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>（好神仙的一道题）</p>
<p>首先经过一波分析，我得到了以下几个性质：</p>
<p>1，必定存在一种最优方案，使得子串的长度依次递减 1。即若答案为 $k$，则必有一种选法使得从左往右的子串大小为 $k,k-1\cdots2,1$。</p>
<p>2，答案不会超过 $\sqrt n$。</p>
<p>那么就可以进行DP，设 $f_i$ 表示从后往前考虑到第 $i$ 位时，以这一位开头的字符串作为第一个字符串，答案最大能是多少。</p>
<p>那么可以二分，考虑长度为 $mid$ 的字符串是否可行。</p>
<p>需要看在 $[i+mid,n]$ 内，是否存在一个 $j$，满足 $f_j\geq mid-1$，且 $s[j,n]$ 和 $s[i,i+mid-1]$ 的最长公共子串的长度是否大于等于 $mid-1$。</p>
<p>后面的部分就是：$lcp(i,j)\geq mid-1$ 或 $lcp(i+1,j)\geq mid-1$。</p>
<p>对于这两部分分开来考虑，而 $lcp(i,j)\geq mid-1$ 相当于 $rank_j$ 需要满足在某段区间内，这个区间可以用SA+RMQ+二分轻易求出，设这个区间为 $[l,r]$。</p>
<p><del>转换成二维数点求最大值</del>转换成求 $\max_{i+mid\leq j \leq n,l\leq rank_j\leq r}\{f_j\}$。</p>
<p>考虑到 $n$ 是固定的，那么维护一个可持久化线段树，表示 $i\leq j \leq n$ 的答案，每次询问时找 $rt_{i+mid}$ 即可。</p>
<p>时间复杂度是 $O(n\log^2n)$ 的。收获80pts。</p>
<p><del>那么我们开始卡常</del>考虑继续分析性质。</p>
<p>参考题解，我们发现一个及其神奇的和SA的height数组极像的性质：$f_i\leq f_{i+1}+1$。</p>
<p>不会证明，感性理解下。。。</p>
<p>那么就不需要二分 $f_i$ 的答案了，直接搞就好。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>没测过，但应该没啥问题qwq。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=N*<span class="number">60</span>;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> SA&#123;</span><br><span class="line">	<span class="type">int</span> base[N],rk[N],t[N],sa[N],height[N],f[N][<span class="number">20</span>],l2[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (t[x]==t[y])&amp;&amp;(t[x+l]==t[y+l]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[n+<span class="number">1</span>]=<span class="number">254</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,t[i]=i;</span><br><span class="line">		<span class="built_in">rsort</span>(n,m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">			<span class="built_in">rsort</span>(n,p);</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">			rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=(<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">			<span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i];</span><br><span class="line">		l2[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="number">19</span>)</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">				<span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> l=l2[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">min</span>(f[x][l],f[y-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>][l]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> &amp;L,<span class="type">int</span> &amp;R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		L=R=x; k--;</span><br><span class="line">		<span class="type">int</span> l,r,mid;</span><br><span class="line">		<span class="keyword">for</span>(l=<span class="number">1</span>,r=x<span class="number">-1</span>;l&lt;=r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ask</span>(mid+<span class="number">1</span>,x)&gt;=k) L=mid,r=mid<span class="number">-1</span>; <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(l=x+<span class="number">1</span>,r=n;l&lt;=r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">ask</span>(x+<span class="number">1</span>,mid)&gt;=k) R=mid,l=mid+<span class="number">1</span>; <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::rk;</span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="keyword">namespace</span> PST&#123;</span><br><span class="line">	<span class="type">int</span> ls[M],rs[M],mx[M],cnt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		u=++cnt; ls[u]=ls[v]; rs[u]=rs[v]; mx[u]=<span class="built_in">max</span>(mx[v],x);</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		(p&lt;=mid)?<span class="built_in">add</span>(ls[u],ls[v],l,mid,p,x):<span class="built_in">add</span>(rs[u],rs[v],mid+<span class="number">1</span>,r,p,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> mx[u];</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) ans=<span class="built_in">max</span>(ans,<span class="built_in">ask</span>(ls[u],l,mid,L,R));</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R) ans=<span class="built_in">max</span>(ans,<span class="built_in">ask</span>(rs[u],mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i+k&lt;=n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l,r,mx=<span class="number">0</span>;</span><br><span class="line">		SA::<span class="built_in">work</span>(rk[i],k,l,r);</span><br><span class="line">		mx=PST::<span class="built_in">ask</span>(rt[i+k],<span class="number">1</span>,n,l,r);</span><br><span class="line">		<span class="keyword">if</span>(i&lt;n)</span><br><span class="line">		&#123;</span><br><span class="line">			SA::<span class="built_in">work</span>(rk[i+<span class="number">1</span>],k,l,r);</span><br><span class="line">			mx=<span class="built_in">max</span>(mx,PST::<span class="built_in">ask</span>(rt[i+k],<span class="number">1</span>,n,l,r));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mx&gt;=k<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>&gt;=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;!<span class="built_in">check</span>(i,k);k--);</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(brr);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	SA::<span class="built_in">build</span>(s,n,<span class="number">255</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=<span class="built_in">calc</span>(i,f[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">		PST::<span class="built_in">add</span>(rt[i],rt[i+<span class="number">1</span>],<span class="number">1</span>,n,rk[i],f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>jzoj</category>
        <category>FJWC</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>线段树</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>我们的 CPU 遭到攻击[loj558]</title>
    <url>/2020/05/25/%E6%88%91%E4%BB%AC%E7%9A%84-CPU-%E9%81%AD%E5%88%B0%E6%94%BB%E5%87%BB-loj558/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/558">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>毒瘤lct。。。</p>
<p>显然先建一个lct，然后看看对于一个节点怎么维护。</p>
<p>我们知道，lct中一棵splay代表的是树上的一条链，中序遍历就是链从上往下的节点。</p>
<p>那么对于一个节点 $x$，它的左儿子就是到根路径的第一个点。</p>
<p>考虑如何维护答案。</p>
]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>事情的相似度[loj6041]</title>
    <url>/2020/05/24/%E4%BA%8B%E6%83%85%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6-loj6041/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/6041">链接</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>多次询问前缀在 $[l,r]$ 中选两个的最长公共后缀。</p>
<p>$n\leq 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>首先你显然先建一个SAM，然后构造出 fail 树。</p>
<p>接着我想了一个 $n\sqrt n\log n$ 的做法，也就是用莫队，然后每次增加或删除一个点用个 set 去维护它，这个过程需要求个 lca。</p>
<p>不过不需要这么麻烦（也不知能不能过）。</p>
<p>显然将所有的询问离线，按 $r$ 从小到大排序。</p>
<p>对于两个前缀 $a,b$ 的贡献，不妨在 $a$ 那里统计它，那么假设考虑到右端点到 $r$ 时，$a$ 的最大值为 $mx_a$，那么答案就是 $\max_{l\leq i \leq r}\{mx_i\}$。</p>
<p>现在只需要看这个 $mx_i$ 怎么求。</p>
<p>考虑新加一个节点 $pos_i$ 上去，然后将它到根中所有的点都染成颜色 $i$。那么这条路径中的点之前的颜色就能有贡献，对于一种颜色 $j$，显然染成 $j$ 的节点形成了一条到根的连续的路径。那么颜色 $j$ 的需要跟 $mx_j$ 比较的数就是 $pos_i$ 往根跳的路径中，第一个为颜色 $j$ 的节点的 $len$。</p>
<p>但是你会发现，有些颜色会被覆盖掉，$mx$ 的值不对。不过这是没有关系的，因为是按顺序加进去的，其他颜色会统计这个贡献。</p>
<p>那么就能用上面这种方法了，维护一个不换根的lct，加一个树状数组求单点修改后缀最值即可。</p>
<p>时间复杂度 $O(n\log n)$ 左右？</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">namespace</span> BIT&#123;</span><br><span class="line">    <span class="type">int</span> mx[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) mx[x]=<span class="built_in">max</span>(mx[x],d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) ans=<span class="built_in">max</span>(ans,mx[x]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> LCT&#123;</span><br><span class="line">    <span class="type">int</span> fa[N],ch[N][<span class="number">2</span>],col[N],len[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isroot</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]!=x&amp;&amp;ch[fa[x]][<span class="number">1</span>]!=x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">son</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> y=fa[x],z=fa[y],d=<span class="built_in">son</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">isroot</span>(y)) ch[z][<span class="built_in">son</span>(y)]=x; fa[x]=z;</span><br><span class="line">        ch[y][d]=ch[x][<span class="number">1</span>-d]; fa[ch[y][d]]=y;</span><br><span class="line">        ch[x][<span class="number">1</span>-d]=y; fa[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">0</span>]) col[ch[x][<span class="number">0</span>]]=col[x];</span><br><span class="line">        <span class="keyword">if</span>(ch[x][<span class="number">1</span>]) col[ch[x][<span class="number">1</span>]]=col[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span>(!<span class="built_in">isroot</span>(x)) <span class="built_in">push</span>(fa[x]); <span class="built_in">pushdown</span>(x);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=fa[x];!<span class="built_in">isroot</span>(x);<span class="built_in">rotate</span>(x),y=fa[x])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isroot</span>(y)) <span class="built_in">rotate</span>((<span class="built_in">son</span>(x)^<span class="built_in">son</span>(y))?x:y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">            <span class="built_in">splay</span>(x),ch[x][<span class="number">1</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">access</span>(x); <span class="built_in">splay</span>(y); <span class="built_in">splay</span>(x);</span><br><span class="line">        fa[y]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])</span><br><span class="line">            <span class="built_in">splay</span>(x),BIT::<span class="built_in">add</span>(col[x],len[x]),col[x]=c,ch[x][<span class="number">1</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">    <span class="type">int</span> ne[N][<span class="number">2</span>],fa[N],len[N],siz,las;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz=las=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur=++siz,p=las;</span><br><span class="line">        len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">        <span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> q=ne[p][c];</span><br><span class="line">            <span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> clone=++siz;</span><br><span class="line">                <span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">                len[clone]=len[p]+<span class="number">1</span>; fa[clone]=fa[q];</span><br><span class="line">                <span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">                fa[q]=fa[cur]=clone;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        las=cur;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">2</span>,siz) LCT::<span class="built_in">link</span>(fa[i],i);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,siz) LCT::len[i]=len[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,id;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> query &amp;A,<span class="type">const</span> query &amp;B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> A.r&lt;B.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="type">int</span> pos[N],ans[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    SAM::<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) pos[i]=SAM::<span class="built_in">extend</span>(s[i]^<span class="number">48</span>);</span><br><span class="line">    SAM::<span class="built_in">build</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>(),q[i].id=i;</span><br><span class="line">    <span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LCT::<span class="built_in">add</span>(pos[i],i);</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;=m&amp;&amp;q[j].r==i;j++) ans[q[j].id]=BIT::<span class="built_in">ask</span>(q[j].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>SAM</tag>
        <tag>树状数组</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title>反回文串[SDOI2018]</title>
    <url>/2020/05/22/%E5%8F%8D%E5%9B%9E%E6%96%87%E4%B8%B2-SDOI2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P4607">luogu</a></p>
<p><a href="https://loj.ac/problem/2563">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求字符集大小为 $k$ 的，长度为 $n$ 的所有字符串，满足存在至少一种旋转同构的情况，使得旋转后该串为回文串。</p>
<p>$k\leq n\leq 10^{18}$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设我们先枚举回文串，然后计算这个回文串有多少种情况。这个方案数相当于就是，你一直将这个回文串旋转，直到变成了另外一个回文串，此时旋转的次数就是方案数。</p>
<p>可以发现，对于一个回文串，这旋转的次数和它最小的循环节有关（此处的循环节指倍长后相等）。</p>
<p>如果最小的循环节 $d$ 是偶数，那么旋转的次数为 $\frac{d}{2}$，否则旋转的次数为 $d$。</p>
<p>那么试着枚举这个 $d$。设 $f(d)$ 表示长度为 $n$，字符集大小为 $k$，最小循环节的长度为 $d$ 的回文串个数，设 $g(n)=k^{\lceil \frac{n}{2}\rceil}$ 表示长度为 $n$，字符集大小为 $k$ 的回文串个数。</p>
<p>显然有：$\sum_{d|n}f(d)=g(n)$。</p>
<p>莫比乌斯反演：$\sum_{d|n}\mu(\frac{n}{d})g(d)=f(n)$</p>
<p>设 $h(d)$ 为当循环节为 $d$ 时的旋转次数，即 $h(d)=\frac{d}{1+[2|d]}$。</p>
<p>那么最终答案就是：</p>
<p>$$\sum_{d|n}f(d)h(d)\=\sum_{d|n}h(d)\sum_{m|d}\mu(\frac{d}{m})g(m)\=\sum_{m|n}g(m)\sum_{d|\frac{n}{m}}\mu(d)h(dm)$$</p>
<p>下面来看看 $W(k,m)=\sum_{d|k}\mu(d)h(dm)$ 怎样求？</p>
<p>可以发现，当 $m$ 为奇数，$k$ 为偶数的时候，$W(k,m)=0$。</p>
<p>其他情况，则有：$W(k,m)=h(m)\sum_{d|k}\mu(d)d$</p>
<p>那么答案就是：$\sum_{m|n}g(m)h(m)[m\equiv 1&amp; \frac{n}{m}\equiv 0]\sum_{d|\frac{n}{m}}\mu(d)d$</p>
<p>然后再来看看 $\sum_{d|k}\mu(d)d$ 怎么求。</p>
<p>显然只需要考虑 $\mu(d)\not =0$ 的项。那么就是枚举哪个质因子选不选，即 $\prod_{p\in \mathbb{P},p|k}(1-p)$。</p>
<p>剩下的就用pollard_rho分解下质因数，然后枚举 $\frac{n}{m}$ 即可。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"></span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll x,ll y,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x*y-(ll)((lb)x*y/n)*n+n)%n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y,ll p=mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=<span class="built_in">mul</span>(x,x,p)) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=<span class="built_in">mul</span>(ans,x,p);</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;ll&gt; d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PollardRho&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> prime[<span class="number">7</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">61</span>,<span class="number">31</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> m=<span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> t; ll r;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">witness</span><span class="params">(<span class="type">int</span> a,ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll b=<span class="built_in">Pow</span>(a,r,n);</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++,b=<span class="built_in">mul</span>(b,b,n)) <span class="keyword">if</span>(b==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isprime</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ff</span>(i,<span class="number">0</span>,m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n==prime[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r=n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(t=<span class="number">0</span>;!(r&amp;<span class="number">1</span>);r&gt;&gt;=<span class="number">1</span>) t++;</span><br><span class="line">        <span class="built_in">ff</span>(i,<span class="number">0</span>,m) <span class="keyword">if</span>(!<span class="built_in">witness</span>(prime[i],n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">pollard_rho</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll c=<span class="built_in">rand</span>()%(n<span class="number">-1</span>),x=<span class="built_in">rand</span>()%n,y=x,d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">2</span>;i++;)</span><br><span class="line">        &#123;</span><br><span class="line">            x=(<span class="built_in">mul</span>(x,x,n)+c)%n;</span><br><span class="line">            d=__gcd(<span class="built_in">abs</span>(y-x),n);</span><br><span class="line">            <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=n) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">if</span>(y==x) <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span>(i==k) y=x,k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isprime</span>(n)) <span class="keyword">return</span> (<span class="type">void</span>)(d.<span class="built_in">pb</span>(n));</span><br><span class="line">        ll x=n; <span class="keyword">for</span>(;x==n;x=<span class="built_in">pollard_rho</span>(n));</span><br><span class="line">        <span class="built_in">find</span>(x); <span class="built_in">find</span>(n/x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> PollardRho::find;</span><br><span class="line"></span><br><span class="line">ll n,k,ans;</span><br><span class="line"><span class="type">int</span> m,cnt,t[<span class="number">100</span>];</span><br><span class="line">ll po[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll d,ll s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((d&amp;<span class="number">1</span>)==<span class="number">0</span>&amp;&amp;((n/d)&amp;<span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">        ll nd=n/d;</span><br><span class="line">        ans=<span class="built_in">Add</span>(ans,<span class="built_in">Pow</span>(k,(nd+<span class="number">1</span>)/<span class="number">2</span>)*(((nd&amp;<span class="number">1ll</span>)?nd:(nd/<span class="number">2</span>))%mod)%mod*((s%mod+mod)%mod)%mod);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(u+<span class="number">1</span>,d,s);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,t[u]) <span class="built_in">dfs</span>(u+<span class="number">1</span>,d*po[u][i],s*(<span class="number">1ll</span>-po[u][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(;T--;)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;k&gt;&gt;mod;</span><br><span class="line">        k%=mod;</span><br><span class="line">        d.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">find</span>(n);</span><br><span class="line">        <span class="built_in">sort</span>(<span class="built_in">all</span>(d));</span><br><span class="line">        <span class="comment">//for(auto v:d) DEBUG(v);</span></span><br><span class="line">        m=d.<span class="built_in">size</span>(); cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j;i&lt;m;i=j)</span><br><span class="line">        &#123;</span><br><span class="line">            po[++cnt][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            po[cnt][<span class="number">1</span>]=d[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">                <span class="keyword">if</span>(d[j]!=d[i]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> po[cnt][j-i+<span class="number">1</span>]=po[cnt][j-i]*d[i];</span><br><span class="line">            t[cnt]=j-i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>PollardRho</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>异或图[bzoj4671]</title>
    <url>/2020/05/21/%E5%BC%82%E6%88%96%E5%9B%BE-bzoj4671/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://darkbzoj.tk/problem/4671">darkbzoj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义两个结点数相同的图 $G_1$ 与图 $G_2$ 的异或为一个新的图 $G$，其中如果 $(u, v)$ 在 $G_1$ 与 $G_2$ 中的出现次数之和为 $1$，那么边 $(u, v)$ 在 $G$ 中，否则这条边不在 $G$ 中。</p>
<p>现在给定 $s$ 个结点数相同的图 $G_{1\cdots s}$, 设 $S = \{G_1,G_2, \cdots , G_s\}$ ，请问 $S$ 有多少个子集的异或为一个连通图？</p>
<p>$n\leq 10,s\leq 60$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设 $f_i$ 表示恰好有 $i$ 个连通块的方案数。</p>
<p>这个显然比较难求，那么再设一个 $g_i$ 表示至少有 $i$ 个连通块的方案数。</p>
<p>考虑用 $f_j$ 表示 $g_i$，系数就是将 $j$ 个不同的连通块放到 $i$ 个相同的盒子里方案数，即第二类斯特林数 $S_2(j,i)$。</p>
<p>那么有：$g_i=\sum_{j=i}^nS_2(j,i)f_j$。</p>
<p>斯特林反演一下得到：$f_i=\sum_{j=i}^nS_1(j,i)(-1)^{j-i}g_j$。</p>
<p>我们需要求的是 $f_1=\sum_{i=1}^n(i-1)!(-1)^{i-1}g_i$。</p>
<p>因此题目可转换成求 $g_i$。</p>
<p>由于点数比较少，我们可以枚举所有的集合划分，每个集合内的点可以随便连，不同集合之间的点不存在连边。</p>
<p>然后我们只考虑不同集合之间的边，对于每个图，是否存在这些边可以写成一个二进制数，需要在 $s$ 个数中选一些，使得异或起来为 $0$，这个用线性基统计一下即可。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[<span class="number">12</span>];</span><br><span class="line"><span class="type">bool</span> g[<span class="number">62</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line">ll ans,fac[<span class="number">12</span>],base[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> siz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(base,<span class="number">0</span>,<span class="built_in">sizeof</span>(base));</span><br><span class="line">    <span class="type">int</span> cnt,tot=<span class="number">0</span>; ll sum;</span><br><span class="line">    <span class="built_in">ff</span>(k,<span class="number">0</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">            <span class="built_in">ff</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">                <span class="keyword">if</span>(a[i]!=a[j])</span><br><span class="line">                    sum|=((ll)g[k][i][j]&lt;&lt;cnt),cnt++;</span><br><span class="line">        <span class="built_in">fd</span>(i,cnt<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>((sum&gt;&gt;i)&amp;<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!base[i]) &#123;tot++,base[i]=sum; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> sum^=base[i];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(siz&amp;<span class="number">1</span>) ans+=(<span class="number">1ll</span>&lt;&lt;(m-tot))*fac[siz<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span> ans-=(<span class="number">1ll</span>&lt;&lt;(m-tot))*fac[siz<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u&gt;=n) <span class="keyword">return</span> <span class="built_in">calc</span>(k);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,k+<span class="number">1</span>) a[u]=i,<span class="built_in">dfs</span>(u+<span class="number">1</span>,<span class="built_in">max</span>(i,k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">ff</span>(k,<span class="number">0</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!n) n=(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">1</span>+<span class="number">8</span>*<span class="built_in">strlen</span>(s)))/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">            <span class="built_in">ff</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">                g[k][i][j]=(s[t++]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>线性基</tag>
        <tag>斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛40</title>
    <url>/2020/05/20/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B40/</url>
    <content><![CDATA[<p>自闭了。。。B一直卡在那，赛后把链表改成vector就过了。。。</p>
<span id="more"></span>

<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>对 $m$ 进行分解以后，变成 $a\sqrt b$ 的形式。</p>
<p>然后变成整数拆分，问 $x_1+x_2+\cdots+x_n=a$ 有多少组本质不同的非负整数解。</p>
<p>那么DP，设 $f_{i,j}$ 表示用了 $i$ 个数，和为 $j$ 的方案数。</p>
<p>$f_{i,j}=f_{i-1,j-1}+f_{i,j-i}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n,m,sum;</span><br><span class="line">ll f[N][N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); sum=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,<span class="built_in">sqrt</span>(m)+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m%(i*i)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;m%(i*i)==<span class="number">0</span>;m/=(i*i)) sum*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m=sum+n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">0</span>,i)</span><br><span class="line">            f[i][j]=<span class="built_in">Add</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i-j][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[m][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>由于那些数是随机的，跟 GDOI2017 一样，我们将这些数按位拆分成 $4$ 份，每份 $16$ 位。如果异或后不相同的位数小于等于 $3$ 的话，那么至少有一份是相同的。</p>
<p>那么枚举相同的那份，用一个vector将那一份相同的数列出来，然后一一比较是否满足条件。</p>
<p>这样做，每个 vector 的期望长度就是 $\frac{n}{2^{16}}$，每次需要枚举 $4$ 份，每次判断的次数是 $3$ 次，那么期望时间复杂度就是 $O(\frac{n}{2^{16}}\times 12m)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ull x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>());</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=x&amp;-x) <span class="keyword">if</span>(++t&gt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> t&lt;=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">G</span><span class="params">(ull x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x^=(x&lt;&lt;<span class="number">13</span>);</span><br><span class="line">    x^=(x&gt;&gt;<span class="number">7</span>);</span><br><span class="line">    x^=(x&lt;&lt;<span class="number">17</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line">ull a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[<span class="number">4</span>][<span class="number">1</span>&lt;&lt;<span class="number">17</span>]; </span><br><span class="line"><span class="type">int</span> ne[N][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="number">20030403</span>);</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    cin&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) a[i]=<span class="built_in">G</span>(a[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">random_shuffle</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    ull x,k=(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)<span class="number">-1</span>,t;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        t=a[i];</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            adj[j][t&amp;k].<span class="built_in">pb</span>(i);</span><br><span class="line">            t&gt;&gt;=<span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ull y,z;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">bool</span> flag;m--;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>,&amp;y);</span><br><span class="line">        z=y;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x=y&amp;k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[j][x])</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(a[v]^z))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            y&gt;&gt;=<span class="number">16</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=ans+ans+flag;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;=mod) ans-=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>对于两个长度为 $n$ 的 01 串，当且仅当 $1$ 的个数相同才能配对。</p>
<p>对 $1$ 的个数作前缀和，记为 $s_i$，那么两个串 $s_1,s_2$ 的贡献就是 $\sum_{i=1}^n|s_{1_i}-s_{2_i}|$。</p>
<p>根据这个就可以进行数位DP了。</p>
<p>设 $f_{i,j,x,y}$ 表示考虑到第 $i$ 位，当前两个串的 $1$ 的个数的差为 $j$，$x,y$ 为这两个串是否一直取最大值。</p>
<p>转移的时候分 $4$ 类讨论。</p>
<p>时间复杂度 $O(n^2)$。有个大常数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Abs(x) ((x)&gt;0?(x):-(x))</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(ll &amp;x,ll y)</span></span>&#123;x+=y; (x&lt;mod)?<span class="number">0</span>:(x-=mod);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1003</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>;</span><br><span class="line">ll f[N][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>],g[N][N&lt;&lt;<span class="number">1</span>][<span class="number">2</span>][<span class="number">2</span>],ans;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][M][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; g[<span class="number">0</span>][M][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nx,ny;</span><br><span class="line">    ll sg,sf;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        <span class="built_in">fo</span>(j,-i,i)</span><br><span class="line">            <span class="built_in">fo</span>(x,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(y,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nx=x?(s[i]-<span class="string">&#x27;0&#x27;</span>):<span class="number">1</span>; ny=y?(s[i]-<span class="string">&#x27;0&#x27;</span>):<span class="number">1</span>;</span><br><span class="line">                sg=g[i<span class="number">-1</span>][j+M][x][y],sf=f[i<span class="number">-1</span>][j+M][x][y];</span><br><span class="line">                <span class="comment">//0,0</span></span><br><span class="line">                    <span class="built_in">Add</span>(g[i][j+M][x&amp;!nx][y&amp;!ny],(sf*<span class="built_in">Abs</span>(j)+sg)%mod),</span><br><span class="line">                    <span class="built_in">Add</span>(f[i][j+M][x&amp;!nx][y&amp;!ny],sf);</span><br><span class="line">                <span class="comment">//1,0</span></span><br><span class="line">                <span class="keyword">if</span>(nx)</span><br><span class="line">                    <span class="built_in">Add</span>(g[i][j+<span class="number">1</span>+M][x][y&amp;!ny],(sf*<span class="built_in">Abs</span>(j+<span class="number">1</span>)+sg)%mod),</span><br><span class="line">                    <span class="built_in">Add</span>(f[i][j+<span class="number">1</span>+M][x][y&amp;!ny],sf);</span><br><span class="line">                <span class="comment">//0,1</span></span><br><span class="line">                <span class="keyword">if</span>(ny)</span><br><span class="line">                    <span class="built_in">Add</span>(g[i][j<span class="number">-1</span>+M][x&amp;!nx][y],(sf*<span class="built_in">Abs</span>(j<span class="number">-1</span>)+sg)%mod),</span><br><span class="line">                    <span class="built_in">Add</span>(f[i][j<span class="number">-1</span>+M][x&amp;!nx][y],sf);</span><br><span class="line">                <span class="comment">//1,1</span></span><br><span class="line">                <span class="keyword">if</span>(nx&amp;&amp;ny)</span><br><span class="line">                    <span class="built_in">Add</span>(g[i][j+M][x][y],(sf*<span class="built_in">Abs</span>(j)+sg)%mod),</span><br><span class="line">                    <span class="built_in">Add</span>(f[i][j+M][x][y],sf);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">Add</span>(ans,g[n][M][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>set大力搞，启发式合并就好了。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>随便暴力一下就好了。</p>
]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>数位DP</tag>
        <tag>启发式合并</tag>
        <tag>平衡树</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏[AHOI/HNOI2018]</title>
    <url>/2020/05/20/%E6%B8%B8%E6%88%8F-AHOI-HNOI2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2508">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一开始看错题了。。。浪费了好久的时间。</p>
<p>首先经过胡乱分析发现，一个点能走到的点集是一个区间。</p>
<p>因此对于每个点 $i$，求出这个 $[l_i,r_i]$ 区间，然后就可以 $O(1)$ 判断了。</p>
<p>对于一个门，我们假设 $x$ 向 $y$ 连一条边。</p>
<p>前 $20\%$ 的很简单，我们只需考虑 $y\leq x$ 的 $40$ 分。</p>
<h4 id="y-leq-x"><a href="#y-leq-x" class="headerlink" title="$y\leq x$"></a>$y\leq x$</h4><p>这一部分保证了钥匙一定在门的左侧。</p>
<p>也就是说，如果你往左走，碰到了一扇门，那么你就没了，你一定走不过这扇门。那么，$l_i$ 的值就很容易求出来了。</p>
<p>现在来看看 $r_i$ 怎么求。如果某个点 $i$ 能走到 $r_i$，且另外一个点 $j$ 能走到 $i$，那么 $r_j$ 就至少是 $r_i$ 了。</p>
<p>可以用一个单调栈，里面存当前情况下，被门隔开的所有区间。从后往前枚举每个线段，判断这个区间是否能和栈顶的区间合并（也就是这个门能否被打开），如果可以就并到一起。</p>
<p>判断一个门能否打开相当于判断这个钥匙是否在当前区间内。</p>
<p>时间复杂度 $O(n)$。</p>
<h4 id="100"><a href="#100" class="headerlink" title="$100\%$"></a>$100\%$</h4><p>这时候，如果按照上面的方法从右往左做，$l_i$ 是会发生改变。</p>
<p>但是，你发现它还是不能从右往左跨过 $y\leq x$ 的门。</p>
<p>那么当一个 $[l_i,r_i]$ 的右端点变大之后，$l_i$ 能去到哪里呢？</p>
<p>显然最多最多不会超过第一个 $y\leq x$ 的门，记这个为 $le_i$。</p>
<p>那么在 $[le_i,l_i)$ 里面，这些门都是向右指的。</p>
<p>对于当前离 $l_i$ 最近的门（其实就是 $l_i$），如果它的钥匙在 $\leq r$ 处，那么这扇门就可以开。</p>
<p>也就是在 $[le_i,l_i)$ 中找到第一个离 $l_i$ 最近的，且钥匙 $&gt;r$ 的门。</p>
<p>用个线段树即可。时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,key[N],l[N],r[N],le[N];</span><br><span class="line"><span class="type">int</span> st[N],top;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mx[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(mx[u]=key[l]);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid); <span class="built_in">build</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">    mx[u]=<span class="built_in">max</span>(mx[lc],mx[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid&lt;R&amp;&amp;mx[rc]&gt;x) ans=<span class="built_in">ask</span>(rc,mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">    <span class="keyword">if</span>(!ans&amp;&amp;L&lt;=mid&amp;&amp;mx[lc]&gt;x) ans=<span class="built_in">ask</span>(lc,l,mid,L,R,x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,le[x],l[x]<span class="number">-1</span>,r[x]);</span><br><span class="line">    l[x]=tmp?tmp+<span class="number">1</span>:le[x];</span><br><span class="line">    <span class="keyword">return</span> l[x]&lt;=key[r[x]]&amp;&amp;key[r[x]]&lt;=r[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),key[x]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;n&amp;&amp;!key[j];j++);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++) l[k]=i,r[k]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=n;le[i++]=j)</span><br><span class="line">        <span class="keyword">if</span>(key[i<span class="number">-1</span>]&amp;&amp;key[i<span class="number">-1</span>]&lt;i)</span><br><span class="line">            j=i;</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) <span class="keyword">for</span>(st[++top]=r[i];top&amp;&amp;<span class="built_in">check</span>(i);r[i]=st[--top]);</span><br><span class="line">    <span class="keyword">for</span>(;T--;<span class="built_in">puts</span>((l[x]&lt;=y&amp;&amp;y&lt;=r[x])?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>)) x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制[BJOI2018]</title>
    <url>/2020/05/19/%E4%BA%8C%E8%BF%9B%E5%88%B6-BJOI2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2492">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个长为 $n$ 的 $01$ 串，每次单调修改，或询问某个区间内，有多少个子区间，满足这个子区间存在一种方案，使得经过重排后为 $3$ 的倍数。</p>
<p>$n,m\leq 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>线段树神奇操作qwq。</p>
<p>首先容斥，变成求有多少个子区间不满足，发现当且仅当区间中（ $1$ 的个数只有 $1$ ）或者（ $1$ 的个数出现奇数次且 $0$ 的次数小于 $2$）时，这个区间不满足条件。</p>
<p>那么我们只需要上面这算两种情况就好了，注意两种情况的重合部分（即 $1,01,10$ 三种情况）。</p>
<p>对于这两种情况，在线段树中存强制选左/右端点，主体部分是 $0/1$，到这个端点里有 $0/1$ 个其他数的区间有多少种。</p>
<p>合并的时候大力分类讨论即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l0,l1,r0,r1,len;</span><br><span class="line">    <span class="type">int</span> zl0,zl1,zr0,zr1;</span><br><span class="line">    ll sum;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        len=<span class="number">1</span>,sum=x;</span><br><span class="line">        l0=r0=zl1=zr1=x;</span><br><span class="line">        l1=r1=zl0=zr0=!x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum=<span class="number">1</span>-sum;</span><br><span class="line">        l0=r0=zl1=zr1=sum;</span><br><span class="line">        l1=r1=zl0=zr0=!sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">    &#123;</span><br><span class="line">        node S;</span><br><span class="line">        S.len=A.len+B.len;</span><br><span class="line">        S.sum=A.sum+B.sum;</span><br><span class="line">        S.sum+=<span class="number">1ll</span>*A.zr0*B.zl1+<span class="number">1ll</span>*A.zr1*B.zl0;</span><br><span class="line">        ll le[<span class="number">2</span>],ri[<span class="number">2</span>];</span><br><span class="line">        le[<span class="number">0</span>]=A.r0&gt;&gt;<span class="number">1</span>; le[<span class="number">1</span>]=A.r0-le[<span class="number">0</span>];</span><br><span class="line">        ri[<span class="number">0</span>]=B.l0&gt;&gt;<span class="number">1</span>; ri[<span class="number">1</span>]=B.l0-ri[<span class="number">0</span>];</span><br><span class="line">        S.sum+=le[<span class="number">0</span>]*ri[<span class="number">1</span>]+le[<span class="number">1</span>]*ri[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(A.r1)</span><br><span class="line">        &#123;</span><br><span class="line">            le[<span class="number">0</span>]=(A.r1+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; le[<span class="number">1</span>]=A.r1-le[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(A.r0&amp;<span class="number">1</span>) <span class="built_in">swap</span>(le[<span class="number">0</span>],le[<span class="number">1</span>]);</span><br><span class="line">            ri[<span class="number">0</span>]=B.l0&gt;&gt;<span class="number">1</span>; ri[<span class="number">1</span>]=B.l0-ri[<span class="number">0</span>];</span><br><span class="line">            S.sum+=le[<span class="number">0</span>]*ri[<span class="number">1</span>]+le[<span class="number">1</span>]*ri[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(!A.r0&amp;&amp;B.l0) S.sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(B.l1)</span><br><span class="line">        &#123;</span><br><span class="line">            le[<span class="number">0</span>]=A.r0&gt;&gt;<span class="number">1</span>; le[<span class="number">1</span>]=A.r0-le[<span class="number">0</span>];</span><br><span class="line">            ri[<span class="number">0</span>]=(B.l1+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; ri[<span class="number">1</span>]=B.l1-ri[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(B.l0&amp;<span class="number">1</span>) <span class="built_in">swap</span>(ri[<span class="number">0</span>],ri[<span class="number">1</span>]);</span><br><span class="line">            S.sum+=le[<span class="number">0</span>]*ri[<span class="number">1</span>]+le[<span class="number">1</span>]*ri[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(!B.l0&amp;&amp;A.r0) S.sum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!A.l1) S.l0=A.l0+B.l0,S.l1=B.l1;</span><br><span class="line">        <span class="keyword">else</span> S.l0=A.l0,S.l1=A.l1+((A.l1+A.l0==A.len)?B.l0:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!B.r1) S.r0=B.r0+A.r0,S.r1=A.r1;</span><br><span class="line">        <span class="keyword">else</span> S.r0=B.r0,S.r1=B.r1+((B.r1+B.r0==B.len)?A.r0:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!A.zl1) S.zl0=A.zl0+B.zl0,S.zl1=B.zl1;</span><br><span class="line">        <span class="keyword">else</span> S.zl0=A.zl0,S.zl1=A.zl1+((A.zl1+A.zl0==A.len)?B.zl0:<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!B.zr1) S.zr0=B.zr0+A.zr0,S.zr1=A.zr1;</span><br><span class="line">        <span class="keyword">else</span> S.zr0=B.zr0,S.zr1=B.zr1+((B.zr1+B.zr0==B.len)?A.zr0:<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[<span class="number">400010</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[u].<span class="built_in">init</span>(<span class="built_in">read</span>());</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">    tr[u]=tr[lc]+tr[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[u].<span class="built_in">change</span>();</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    (p&lt;=mid)?<span class="built_in">update</span>(ls,p):<span class="built_in">update</span>(rs,p);</span><br><span class="line">    tr[u]=tr[lc]+tr[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rs,L,R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(ls,L,R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(ls,L,R)+<span class="built_in">query</span>(rs,L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,l,r,len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    CASET</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">read</span>()==<span class="number">1</span>) <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="built_in">read</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(); len=r-l+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="number">1ll</span>*len*(len+<span class="number">1</span>)/<span class="number">2</span>-<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r).sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[loj6198]谢特</title>
    <url>/2020/05/18/loj6198-%E8%B0%A2%E7%89%B9/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/6198">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>主要是为了练练SA。。。</p>
<h4 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h4><p>两个后缀的最长公共前缀是两个点的 lca 处，那么枚举这个 $lca$ 进行统计，建一个Trie存子树中的 $w_i$，每次合并时启发式合并。</p>
<h4 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h4><p>两个后缀的最长公共前缀是后缀数组中的一段区间的最小值。</p>
<p>那么从大到小枚举这个最小值的位置，还是跟SAM那样启发式合并Trie即可。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>SA做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> base[N],rk[N],sa[N],t[N],height[N],f[N][<span class="number">18</span>],l2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rsort</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) base[rk[t[i]]]++;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) sa[base[rk[t[i]]]--]=t[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t[x]==t[y])&amp;&amp;(t[x+l]==t[y+l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SA</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">27</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) rk[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>,t[i]=i;</span><br><span class="line">    <span class="built_in">rsort</span>(n,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>,p;p&lt;n;w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,n-w+<span class="number">1</span>,n) t[++p]=i;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(sa[i]&gt;w) t[++p]=sa[i]-w;</span><br><span class="line">        <span class="built_in">rsort</span>(n,p);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) t[i]=rk[i];</span><br><span class="line">        rk[sa[<span class="number">1</span>]]=p=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">2</span>,n) rk[sa[i]]=(<span class="built_in">cmp</span>(sa[i],sa[i<span class="number">-1</span>],w)?p:++p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j,k=<span class="number">0</span>;i&lt;=n;height[rk[i++]]=k)</span><br><span class="line">        <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rk[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][<span class="number">0</span>]=height[i];</span><br><span class="line">    l2[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) l2[i]=l2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(j,<span class="number">1</span>,l2[n])</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)&lt;=n) f[i][j]=<span class="built_in">min</span>(f[i][j],f[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=rk[x]; y=rk[y];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    x++; <span class="type">int</span> l=l2[y-x+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(f[x][l],f[y-(<span class="number">1</span>&lt;&lt;l)+<span class="number">1</span>][l]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ne[N&lt;&lt;<span class="number">5</span>][<span class="number">2</span>],rt[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=++cnt,rt=u;</span><br><span class="line">    <span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ne[u][(x&gt;&gt;i)&amp;<span class="number">1</span>]=++cnt;</span><br><span class="line">        u=cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//if(!ne[x][0]&amp;&amp;!ne[x][1]) return v;</span></span><br><span class="line">    <span class="type">int</span> ans=v;</span><br><span class="line">    <span class="keyword">if</span>(ne[x][<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[y][<span class="number">1</span>]) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(ne[x][<span class="number">0</span>],ne[y][<span class="number">1</span>],(v&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(ne[x][<span class="number">0</span>],ne[y][<span class="number">0</span>],v&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ne[x][<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[y][<span class="number">0</span>]) ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(ne[x][<span class="number">1</span>],ne[y][<span class="number">0</span>],(v&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(ne[x][<span class="number">1</span>],ne[y][<span class="number">1</span>],v&lt;&lt;<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ne[x][<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[y][<span class="number">0</span>]) <span class="built_in">merge</span>(ne[x][<span class="number">0</span>],ne[y][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> ne[y][<span class="number">0</span>]=ne[x][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ne[x][<span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ne[y][<span class="number">1</span>]) <span class="built_in">merge</span>(ne[x][<span class="number">1</span>],ne[y][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> ne[y][<span class="number">1</span>]=ne[x][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N],siz[N],id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[N],ans,n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">SA</span>(s,n);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) val[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) id[i]=i,fa[i]=i,siz[i]=<span class="number">1</span>,rt[i]=<span class="built_in">build</span>(val[sa[i]]);</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">2</span>,id+n+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> height[x]&gt;height[y];&#125;);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        x=id[i]; y=x<span class="number">-1</span>;</span><br><span class="line">        x=<span class="built_in">find</span>(x); y=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[x]&lt;siz[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(rt[y],rt[x],<span class="number">0</span>)+height[id[i]]);</span><br><span class="line">        siz[x]+=siz[y]; fa[y]=x;</span><br><span class="line">        <span class="built_in">merge</span>(rt[y],rt[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>后缀数组</tag>
        <tag>SAM</tag>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>Bipartite Blanket[bzoj4788]</title>
    <url>/2020/04/21/Bipartite-Blanket-bzoj4788/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个 $n+m$ 个点的二分图，求有多少个点集，满足存在至少一个二分图匹配，使得该点集都在这个匹配中，且该点集的权值和大于某个值 $D$。</p>
<p>$n,m\leq 20,D\leq 4\times 10^8$。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>假设我们只考虑一边的点的情况。那么由Hall定理，我们就可以暴力判断某个点集是否存在完美匹配。只需要枚举一个子集，这是 $O(3^n)$ 的，显然不行。</p>
<p>不过枚举子集干嘛。。。直接来个高维前缀与和就好了，时间复杂度 $O(n2^n)$。</p>
<p>现在考虑两边点的情况，如果两边的两个点集都满足Hall定理的话，那么一定由一个匹配使得该点集在这个匹配中。只会爆猜结论，并不会证明qwq。。。</p>
<p>那么对两边的点分别做上面的做法，然后按权值和从小到大排序，然后two-pointer扫一遍。</p>
<p>时间复杂度 $O(n2^n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fa,fb;</span><br><span class="line"><span class="type">int</span> a[N],b[N],n,m,T,bit[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="type">int</span> va[N],vb[N],h[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;g,<span class="type">int</span> *val,<span class="type">int</span> *v,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">int</span> f,s;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;n))</span><br><span class="line">    &#123;</span><br><span class="line">        f=s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,n)</span><br><span class="line">            <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i)</span><br><span class="line">                f|=v[j],s+=val[j];</span><br><span class="line">        h[i]=(bit[i]&lt;=bit[f]);</span><br><span class="line">        <span class="keyword">if</span>(h[i])</span><br><span class="line">            <span class="built_in">ff</span>(j,<span class="number">0</span>,n)</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i)</span><br><span class="line">                    h[i]&amp;=h[i^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">        <span class="keyword">if</span>(h[i]) g.<span class="built_in">pb</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(g));       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;n) <span class="built_in">ff</span>(j,<span class="number">0</span>,n) bit[i]+=((i&gt;&gt;j)&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>(<span class="built_in">max</span>(n,m));</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        <span class="built_in">ff</span>(j,<span class="number">0</span>,m) <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>) va[i]|=(<span class="number">1</span>&lt;&lt;j),vb[j]|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">ff</span>(i,<span class="number">0</span>,m) b[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dp</span>(fa,a,va,n,m);</span><br><span class="line">    <span class="built_in">dp</span>(fb,b,vb,m,n);</span><br><span class="line">    <span class="type">int</span> i=fb.<span class="built_in">size</span>()<span class="number">-1</span>,cnt=fb.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:fa)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>&amp;&amp;fb[i]+v&gt;=T;i--);</span><br><span class="line">        ans+=cnt-i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>Hall定理</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>经典题[20200415模拟]</title>
    <url>/2020/04/15/%E7%BB%8F%E5%85%B8%E9%A2%98-20200415%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$m$ 个整数变量，求满足一下条件的正整数解的个数对 $998244353$ 取模后的结果。</p>
<ul>
<li>$\forall i\in [1,n],1\leq x_i\leq T$</li>
<li>$\sum_{i=1}^m\leq S$。</li>
</ul>
<p>$n\leq 10^{18},n\leq 10^9,nT\leq S,m-n\leq 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考场上只能做到 $m-n=1$ 的情况。</p>
<p>这题太毒瘤了…</p>
<p>由于 $nT\leq S$，那么考虑暴力枚举前 $n$ 个数选了 $x_i$，那么这时，后面 $m-n$ 个数就有 $\binom{S-\sum_{i=1}^nx_i}{m-n}$ 种情况。</p>
<p>这个东西显然没法直接求，考虑这个组合数，我们把它转换成上升幂的形式。</p>
<p>$$ans=\frac{1}{(m-n)!}\sum_{x_1,x_2,\cdots,x_n}(S-(m-n)+1-\sum_{x=1}^mx_i)^{\overline{m-n}}$$</p>
<p>然后由第一类斯特林数的性质得到：</p>
<p>$$ans=\frac{1}{(m-n)!}\sum_{i=0}^{m-n}\left <a href="S-(m-n)+1-\sum_{i=1}^nx_i"> ^{m-n} _{\ \ \ i}\right </a>^{i}$$</p>
<p>而第一类斯特林数可以 $O(n\log n)$ 求出来。</p>
<p>以下为了方便，设 $k=m-n$，用 $S$ 代表原来的 $S-(m-n)+1$。</p>
<p>那么原式就变为：</p>
<p>$$\frac{1}{k!}\sum_{i=0}^k\left <a href="S-\sum_{j=1}^nx_j"> ^{k} _{i} \right </a>^{i}$$</p>
<p>由多项式定理暴力展开： </p>
<p>$$(S-\sum_{j=1}^nx_j)^i=\sum_{a_0+a_1+\cdots+a_n=i}\frac{i!}{a_0!a_1!\cdots a_n!}S^{a_0}(-x_1)^{a_1}\cdots (-x_n)^{a_n}$$</p>
<p>那么就可以用EGF来算一下。</p>
<p>设 $G(x)=\sum \frac{S^i}{i!}x^i,F(x)=\sum_{i=0}^{\infty}\frac{(-1)^i\sum_{j=1}^{T}j^i}{i!}x^i$</p>
<p>那么 $i$ 次方的答案就是 $[x^i] i!G(x)F^n(x)$。</p>
<p>也就是说，如果搞出了 $F(x)$，然后多项式快速幂就可以了。</p>
<p>剩下的问题是，对于所有的 $k$，计算 $\sum_{i=1}^Ti^k$。</p>
<p>可以用伯努利数来算。</p>
<p>由伯努利数的性质可以得到：</p>
<p>$$\sum_{i=0}^{n-1}i^k=\frac{1}{k+1}\sum_{i=0}^k\binom{k+1}{i}B_in^{k+1-i}$$</p>
<p>伯努利数可以用多项式求逆 $O(n\log n)$ 求出前几项。</p>
<p>上式也是一个卷积形式，很容易算出。</p>
<p>所以你只需要，求出第一类斯特林数的其中一列，多项式快速幂，以及伯努利数前 $n$ 项。</p>
<p>多项式快速幂用ln+exp搞，那么总的时间复杂度就是 $O(n\log n)$。</p>
<p>代码6k…</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">ll W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">    A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Mul</span>(A[i],k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">    B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">    Poly g,h;</span><br><span class="line">    g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">    <span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">        <span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">        <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">    <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">ln</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">    A=<span class="built_in">jf</span>((~A)*<span class="built_in">df</span>(A));</span><br><span class="line">    A.<span class="built_in">resize</span>(n); <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">exp</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>; <span class="keyword">for</span>(;n&lt;A.<span class="built_in">size</span>();n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    Poly B,C,D; B.<span class="built_in">clear</span>(); B.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        C=B; C.<span class="built_in">resize</span>(m); D=A; D.<span class="built_in">resize</span>(m);</span><br><span class="line">        C=D-<span class="built_in">ln</span>(C); C[<span class="number">0</span>]=<span class="built_in">Add</span>(C[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">        B=B*C; B.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    B.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()); <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ^(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!A.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">    ll tmp=A[<span class="number">0</span>],w=<span class="built_in">Pow</span>(tmp,k);</span><br><span class="line">    tmp=<span class="built_in">Pow</span>(tmp,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Mul</span>(A[i],tmp);</span><br><span class="line">    A=<span class="built_in">exp</span>(<span class="built_in">ln</span>(A)*k);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Mul</span>(A[i],w);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line">ll fc[N],fv[N],iv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PolyInit</span>();</span><br><span class="line">    fc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    fv[n]=<span class="built_in">Pow</span>(fc[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) fv[i<span class="number">-1</span>]=fv[i]*i%mod;</span><br><span class="line">    iv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) iv[i]=(mod-mod/i)*iv[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll S,T,n,m,s[N];</span><br><span class="line">Poly G,F,B;</span><br><span class="line"></span><br><span class="line">ll d[M],c[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcS</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) &#123;s[<span class="number">0</span>]=<span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;s[<span class="number">1</span>]=<span class="number">1</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calcS</span>(n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fd</span>(i,n,<span class="number">1</span>) s[i]=<span class="built_in">Add</span>(s[i<span class="number">-1</span>],<span class="built_in">Mul</span>(s[i],n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">calcS</span>(n&gt;&gt;<span class="number">1</span>); <span class="type">int</span> l=n&gt;&gt;<span class="number">1</span>,len;</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        d[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,l) d[i]=d[i<span class="number">-1</span>]*l%mod;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) d[i]=d[i]*fv[i]%mod,c[i]=s[i]*fc[i]%mod;</span><br><span class="line">        <span class="built_in">reverse</span>(&amp;d[<span class="number">0</span>],&amp;d[l+<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">1</span>); <span class="built_in">ntt</span>(c,len,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=d[i]*c[i]%mod;</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) d[i]=d[i+l]*fv[i]%mod;</span><br><span class="line">        <span class="built_in">fo</span>(i,l+<span class="number">1</span>,len<span class="number">-1</span>) d[i]=c[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,l) c[i]=s[i];</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">1</span>); <span class="built_in">ntt</span>(c,len,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=d[i]*c[i]%mod;</span><br><span class="line">        <span class="built_in">ntt</span>(d,len,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n) s[i]=d[i];</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=c[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcB</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n+=<span class="number">2</span>;</span><br><span class="line">    B.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) B[i]=fv[i+<span class="number">1</span>];</span><br><span class="line">    B=~B;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n) B[i]=B[i]*fc[i]%mod;</span><br><span class="line">    B.<span class="built_in">resize</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcF</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T=(T+<span class="number">1</span>)%mod;</span><br><span class="line">    ll tmp=T;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n+<span class="number">1</span>) d[i]=<span class="built_in">Mul</span>(tmp,fv[i]),tmp=<span class="built_in">Mul</span>(tmp,T);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n) c[i]=<span class="built_in">Mul</span>(B[i],fv[i]);</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>; <span class="keyword">for</span>(;len&lt;=n+n+<span class="number">1</span>;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ntt</span>(d,len,<span class="number">1</span>); <span class="built_in">ntt</span>(c,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) d[i]=d[i]*c[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(d,len,<span class="number">-1</span>);</span><br><span class="line">    F.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(j,<span class="number">0</span>,n) F[j]=<span class="built_in">Mul</span>(d[j+<span class="number">1</span>],fc[j]);</span><br><span class="line">    F[<span class="number">0</span>]=<span class="built_in">Dec</span>(F[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(j,<span class="number">0</span>,n) F[j]=<span class="built_in">Mul</span>(F[j],(j&amp;<span class="number">1</span>)?(mod-fv[j]):fv[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    S=(S-(m-n)+<span class="number">1</span>)%mod;</span><br><span class="line">    n=m-n;</span><br><span class="line">    <span class="built_in">calcS</span>(n); <span class="built_in">calcB</span>(n+<span class="number">1</span>);</span><br><span class="line">    G.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    ll tmp=<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n) G[i]=<span class="built_in">Mul</span>(tmp,fv[i]),tmp=<span class="built_in">Mul</span>(tmp,S);</span><br><span class="line">    <span class="built_in">calcF</span>(n);</span><br><span class="line">    F=(F^(m-n))*G;</span><br><span class="line">    F.<span class="built_in">resize</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(F[i],<span class="built_in">Mul</span>(fc[i],s[i])));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mul</span>(ans,fv[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">FO</span>(count);</span><br><span class="line">    cin&gt;&gt;S&gt;&gt;T&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>(m-n+<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>模拟赛</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>斯特林数</tag>
        <tag>伯努利数</tag>
      </tags>
  </entry>
  <entry>
    <title>合唱队形[uoj214]</title>
    <url>/2020/04/15/%E5%90%88%E5%94%B1%E9%98%9F%E5%BD%A2-uoj214/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://uoj.ac/problem/214">uoj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以说这道题超级超级毒瘤了。</p>
<p>刚开始还以为 $n,m\leq 30$ 是折半搜索，谁知道是这么毒瘤的。</p>
<p>既然 $n,m\leq 30$ 暂时看起来不可做，那就先试试80pts的部分分吧。</p>
<p>首先直接统计显然不可做。设这些长度为 $m$ 的集合为 $S$，现在需要统计的是最小值的期望。</p>
<p>由Min-Max容斥得到：</p>
<p>$$E(\min(S))=\sum_{T\not =\varnothing,T\in S}(-1)^{|T|-1}E(\max(T))$$</p>
<p>那么设 $g(T)$ 表示要使得 $T$ 集合中的点满足条件需要多少个覆盖，设总覆盖数为 $s$，那么现在需要求在 $s$ 个覆盖中，每次随机选择一个，问第一次出现 $T$ 集合中所有数时的期望次数。</p>
<p>然后你就可以枚举 $t$，表示当操作次数 $\leq t$ 时已经全部覆盖的期望。</p>
<p>还是容斥一下，枚举至少有 $i$ 个数没覆盖，那么就有：</p>
<p>$$ans=\sum_{T=\varnothing,T\in S}(-1)^{|T|-1}\sum_{t=0}^{\infty}\sum_{i=0}^{g(T)}(-1)^{i-1}\binom{g(T)}{i}(\frac{s-i}{s})^t$$</p>
<p>把 $t$ 移过去，化简得到：</p>
<p>$$ans=\sum_{T=\varnothing,T\in S}(-1)^{|T|-1}\sum_{i=0}^{g(T)}(-1)^{i-1}\binom{g(T)}{i}(\frac{s}{i})$$</p>
<p>时间复杂度 $O(2^{n-m+1}n)\sim O(2^{n-m+1}n^2)$。</p>
<p>这样子就有 80分了。<del>也就只想到这里了。</del></p>
<p>可以发现，一旦 $g(T)$ 知道是多少了，那么也就可以算了。</p>
<p>因此转换为统计使得 $g(T)=j$ 的集合 $T$ 的 $(-1)^{|T|-1}$ 的和。</p>
<p>而对于一个点而言，他需要学哪些字母是由前面 $m$ 个点所决定的，如果前面 $m$ 个点中某个点 $i$ ，满足 $[i,i+m-1]$ 在 $T$ 中，那么这个点就需要选择对应的字母。</p>
<p>根据这个性质，状压DP即可。</p>
<p>时间复杂度 $O(2^mn^3)$。</p>
<p>跟前一个算法结合就可以100分了。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,ss;</span><br><span class="line"><span class="type">bool</span> bo[<span class="number">31</span>][<span class="number">31</span>],b[<span class="number">31</span>];</span><br><span class="line"><span class="type">char</span> t[<span class="number">31</span>];</span><br><span class="line">ll fac[<span class="number">905</span>],inv[<span class="number">905</span>],s[<span class="number">905</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Part1&#123;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="type">bool</span> vis[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> w=n-m+<span class="number">1</span>,cnt=<span class="number">1</span>&lt;&lt;w;</span><br><span class="line">        <span class="built_in">fo</span>(sta,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">int</span> sum=<span class="number">0</span>,tim=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">25</span>) vis[j][k]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">0</span>,w<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;sta)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!b[j]) flag=<span class="number">0</span>;</span><br><span class="line">                    tim++;</span><br><span class="line">                    <span class="built_in">fo</span>(k,<span class="number">1</span>,m)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(!vis[j+k][t[k]-<span class="string">&#x27;a&#x27;</span>]) sum++;</span><br><span class="line">                        vis[j+k][t[k]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line">            ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">Pow</span>(mod<span class="number">-1</span>,tim),s[sum]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Part2&#123;</span><br><span class="line">    ll g[<span class="number">1</span>&lt;&lt;<span class="number">12</span>],f[<span class="number">2</span>][<span class="number">1</span>&lt;&lt;<span class="number">12</span>][<span class="number">905</span>],ans;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">1</span>&lt;&lt;m,w=n-m+<span class="number">1</span>,d=<span class="number">0</span>,tot=(<span class="number">1</span>&lt;&lt;(m<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="built_in">fo</span>(sta,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g[sta]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))&amp;sta) g[sta]|=(<span class="number">1</span>&lt;&lt;(t[i]-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            g[sta]=__builtin_popcount(g[sta]);</span><br><span class="line">        &#125;</span><br><span class="line">        f[d=<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            d=<span class="number">1</span>-d;</span><br><span class="line">            <span class="built_in">memset</span>(f[d],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[d]));</span><br><span class="line">            <span class="built_in">fo</span>(sta,<span class="number">0</span>,tot<span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fo</span>(j,<span class="number">0</span>,i*m)</span><br><span class="line">                    <span class="keyword">if</span>(f[<span class="number">1</span>-d][sta][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        (f[d][(sta&lt;&lt;<span class="number">1</span>)&amp;(tot<span class="number">-1</span>)][j+g[sta&lt;&lt;<span class="number">1</span>]]+=f[<span class="number">1</span>-d][sta][j])%=mod;</span><br><span class="line">                        <span class="keyword">if</span>(b[i<span class="number">-1</span>]) (f[d][(sta&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)&amp;(tot<span class="number">-1</span>)][j+g[sta&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]]+=mod-f[<span class="number">1</span>-d][sta][j])%=mod;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">0</span>,w*m)</span><br><span class="line">            ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(f[d][<span class="number">0</span>][j],s[j]));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">900</span>);</span><br><span class="line">    CASET</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); ss=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="built_in">strlen</span>(t+<span class="number">1</span>)) bo[i][t[j]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">            ss=ss+<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n*m)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,i) s[i]=<span class="built_in">Add</span>(s[i],<span class="built_in">Mul</span>(<span class="built_in">Pow</span>(mod<span class="number">-1</span>,j),<span class="built_in">Mul</span>(<span class="built_in">C</span>(i,j),<span class="built_in">Pow</span>(j,mod<span class="number">-2</span>))));</span><br><span class="line">            s[i]=<span class="built_in">Mul</span>(s[i],ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> w=n-m+<span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,w<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,m) <span class="keyword">if</span>(!bo[i+j][t[j]-<span class="string">&#x27;a&#x27;</span>]) &#123;b[i]=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            flag|=b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(n-m)&lt;=<span class="number">18</span>?Part1::<span class="built_in">work</span>():Part2::<span class="built_in">work</span>());</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">25</span>) bo[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,w<span class="number">-1</span>) b[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>状压DP</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>烷基计数 加强版 加强版[loj6538]</title>
    <url>/2020/04/14/%E7%83%B7%E5%9F%BA%E8%AE%A1%E6%95%B0-%E5%8A%A0%E5%BC%BA%E7%89%88-%E5%8A%A0%E5%BC%BA%E7%89%88-loj6538/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/6185">烷基计数</a></p>
<p><a href="https://loj.ac/problem/6269">烷基计数 加强版</a></p>
<p><a href="https://loj.ac/problem/6538">烷基计数 加强版 加强版</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>主要是想记录下自己第一道牛顿迭代的题qwq</del></p>
<p>设 $f_i$ 表示 $i$ 个节点时的答案，那么有：</p>
<p>$f_0=1,f_i=\sum_{j+k+l+1=i}f_j f_k f_l$。</p>
<p>显然这个是错的。因为没有考虑树同构的情况。</p>
<p>设 $F(x)$ 表示 $f$ 的OGF。</p>
<p>这里有 $3!=6$ 种置换。</p>
<p>由Burnside引理得，总方案数=每个置换的不动点个数的平均数。</p>
<ul>
<li>对于 $(1,2,3)$ 这种情况，随你便，也就是 $F^3(x)$。</li>
<li>对于 $(2,1,3),(3,2,1),(1,3,2)$ 这三种情况，有两个是需要一样的，也就是 $F(x^2)F(x)$。</li>
<li>对于剩下两种情况，三个都必须一样，也就是 $F(x^3)$。</li>
</ul>
<p>那么就有：</p>
<p>$$F(x)=x\frac{F^3(x)+3F(x^2)F(x)+2F(x^3)}{6}+1$$</p>
<p>设 $G(F(x))=x\frac{F^3(x)+3F(x^2)F(x)+2F(x^3)}{6}+1-F(x)$</p>
<p>假设求出了在模 $x^{\frac{n}{2}}$ 意义下的 $F(x)$，由牛顿迭代得：</p>
<p>$$F_{new}(x)=F(x)-\frac{G(F(x))}{G’(F(x))}$$</p>
<p>而如果求出了在模 $x^{\frac{n}{2}}$ 意义下的 $F(x)$，那么模 $x^n$ 意义下的 $F(x^2),F(x^3)$ 也已经知道了。</p>
<p>对 $G(F(x))$ 求导得：</p>
<p>$$\frac{G(F(x))}{G’(F(x))}=\frac{x(F^3(x)+3F(x^2)F(x)+2F(x^3))-6F(x)-6}{x(3F^2(x)+3F(x^2))-6}$$</p>
<p>那么有：</p>
<p>$$F_{new}(x)=F(x)-\frac{x(F^3(x)+3F(x^2)F(x)+2F(x^3))-6F(x)-6}{x(3F^2(x)+3F(x^2))-6}$$</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line"><span class="keyword">namespace</span> NTT&#123;</span><br><span class="line">    <span class="type">int</span> R[M]; ll W[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll wn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            W[i]=<span class="number">1</span>; wn=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*wn%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                    w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                    a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                    a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,opt);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> NTT::ntt;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*x%mod;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;=k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">    B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">    A.<span class="built_in">resize</span>(k);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">    Poly g,h;</span><br><span class="line">    g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">    <span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">        g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">        <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">    <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Poly <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poly f; f.<span class="built_in">clear</span>(); f.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> f;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">1</span>;</span><br><span class="line">    Poly f2,f3,g,h,a;</span><br><span class="line">    <span class="keyword">for</span>(;m&lt;(n&lt;&lt;<span class="number">1</span>);m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(m); f2.<span class="built_in">resize</span>(m); f3.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) f2[i]=f3[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i+=<span class="number">2</span>) f2[i]=f[i/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i+=<span class="number">3</span>) f3[i]=f[i/<span class="number">3</span>];</span><br><span class="line">        a=f*f; a.<span class="built_in">resize</span>(m);</span><br><span class="line">        h=(a+f2)*<span class="number">3</span>; h.<span class="built_in">insert</span>(h.<span class="built_in">begin</span>(),mod<span class="number">-6</span>);</span><br><span class="line">        a=f*a; a.<span class="built_in">resize</span>(m);</span><br><span class="line">        g=a+((f2*f)*<span class="number">3</span>)+(f3*<span class="number">2</span>);</span><br><span class="line">        g.<span class="built_in">insert</span>(g.<span class="built_in">begin</span>(),<span class="number">6</span>);</span><br><span class="line">        g=g-(f*<span class="number">6</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">        g=g*(~h); g.<span class="built_in">resize</span>(m);</span><br><span class="line">        f=f-g;</span><br><span class="line">    &#125;</span><br><span class="line">    f.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTT::<span class="built_in">init</span>();</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    Poly f=<span class="built_in">solve</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>牛顿迭代</tag>
        <tag>Burnside引理</tag>
      </tags>
  </entry>
  <entry>
    <title>小Z的礼物[集训队作业2018]</title>
    <url>/2020/04/14/%E5%B0%8FZ%E7%9A%84%E7%A4%BC%E7%89%A9-%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://uoj.ac/problem/422">uoj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>可以发现，最大值这种东西一般都不太好做。考虑转换成最小值（即第一次被覆盖）。</p>
<p>由期望下的Min-Max容斥得到：</p>
<p>$$E(\max(S))=\sum_{T\in S,T\not= \varnothing }E(\min(T))(-1)^{|T|+1}$$</p>
<p>其中 $E(\min(T))$ 表示 $T$ 集合中物品中的其中一个，第一次被覆盖的期望时间。</p>
<p>设选一次相邻的两个物品中至少含有一个 $T$ 集合中物品的概率为 $P$。</p>
<p>设 $f(i)$ 表示前 $i$ 次覆盖都没有覆盖成功的概率，显然有：$f(i)=(1-P)^i$。</p>
<p>那么 $T$ 集合中物品第一次被覆盖的期望时间为：$\sum_{i=0}^{\infty} f(i)=\sum_{i=0}^{\infty}(1-P)^i$</p>
<p>由于 $P\not =0$，那么 $1-P&lt;1$，则上式收敛，那么有：$E(\min (T))=\frac{1}{1-(1-P)}=\frac{1}{P}$</p>
<p>这个 $P=\frac{W_T}{2nm-n-m}$，其中 $W_T$ 为选两个相邻物品至少包含一个 $T$ 集合中物品的方案数。</p>
<p>$n$ 这么小，那么就可以考虑轮廓线DP了。</p>
<p>设 $f_{i,j,s,k}$ 表示考虑到第 $i$ 列第 $j$ 行，状态为 $s$，$W_T=k$ 的容斥系数和。</p>
<p>最后的答案为 $\sum_{s}\sum_{k}\frac{f_{m,n,s,k}\times (2nm-n-m)}{k}$。</p>
<p>这个DP很好转移，考虑4个方向的情况就好了。</p>
<p>时间复杂度 $O(2^nn^2m^2)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">int</span> cnt,sum,d,t;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> S[<span class="number">7</span>][<span class="number">105</span>];</span><br><span class="line">ll f[<span class="number">2</span>][<span class="number">70</span>][<span class="number">1205</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bit</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> (x&gt;&gt;k)&amp;<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,S[i]+<span class="number">1</span>);</span><br><span class="line">    cnt=<span class="number">1</span>&lt;&lt;n; sum=<span class="number">2</span>*n*m-n-m;</span><br><span class="line">    f[d=<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=mod<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            d=<span class="number">1</span>-d;</span><br><span class="line">            <span class="built_in">memset</span>(f[d],<span class="number">0</span>,<span class="built_in">sizeof</span>(f[d]));</span><br><span class="line">            <span class="built_in">fo</span>(s,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">                <span class="built_in">fo</span>(k,<span class="number">0</span>,sum)</span><br><span class="line">                    <span class="keyword">if</span>(f[d^<span class="number">1</span>][s][k])</span><br><span class="line">                    &#123;</span><br><span class="line">                        t=s&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                        f[d][t][k]=<span class="built_in">Add</span>(f[d][t][k],f[d^<span class="number">1</span>][s][k]);</span><br><span class="line">                        t=t|(<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>));</span><br><span class="line">                        <span class="keyword">if</span>(S[j][i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            w=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">if</span>(i&gt;<span class="number">1</span>&amp;&amp;!<span class="built_in">bit</span>(s,<span class="number">0</span>))   w++;</span><br><span class="line">                            <span class="keyword">if</span>(j&gt;<span class="number">1</span>&amp;&amp;!<span class="built_in">bit</span>(s,n<span class="number">-1</span>)) w++;</span><br><span class="line">                            <span class="keyword">if</span>(j&lt;n) w++; <span class="keyword">if</span>(i&lt;m) w++;</span><br><span class="line">                            f[d][t][k+w]=<span class="built_in">Dec</span>(f[d][t][k+w],f[d^<span class="number">1</span>][s][k]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">0</span>,sum)</span><br><span class="line">            ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(f[d][i][j],<span class="built_in">Pow</span>(j,mod<span class="number">-2</span>)));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Mul</span>(sum,ans));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>uoj</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>Min-Max容斥</tag>
        <tag>轮廓线DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Fake bullions[CF804F]</title>
    <url>/2020/04/14/Fake-bullions-CF804F/</url>
    <content><![CDATA[<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://codeforces.com/problemset/problem/804/F">CF</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一道二合一码农题。。。</p>
<p>不难发现如果我们算出一个点最多能有多少个人有金条，那么似乎可以组合数学去计算它。</p>
<p>然后此题就分为了两部分。</p>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>第一部分是算出一个点最多或者最少有几个人有多少金条。</p>
<p>最少很容易求，下面只考虑最多的如何求。</p>
<p>考虑图中的一条边 $(u,v)$，可以发现，某个点的第 $j$ 个人能有金条当且仅当这两个点中存在一个人 $i$ 有金条且 $i\equiv j\pmod {\gcd(s_u,s_v)}$。</p>
<p>考虑图中的一条链，后面这个 $\gcd$ 就变为链中所有的 $s_u$ 的 $\gcd$ 了。</p>
<p>那么对于一个强连通分量，我们就可以在上面xjb走，因此上面的所有点中，上式的 $\gcd$ 就是强联通分量中所有的 $s_u$ 的 $\gcd$ 了。</p>
<p>考虑缩点，看看会变成什么样子。</p>
<p>由于原图中两个点中有且只有一条有向边，那么缩点之后还是会满足这个性质。但是又不能有环，因此这个缩点之后的图就可以看成一条链，链上一个点跟后面所有点都有连边的图。</p>
<p>然后你会发现不走链上的路径一定是不优的，因为走链的路径 $\gcd$ 不会变大。</p>
<p>那么最后就只剩下一条链了，拓扑排序依次计算即可。</p>
<p>这一部分时间复杂度为 $O(n^2+\sum s_i)$。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>这一部分相当于是给你两个长度为 $n$ 的数组 $l_i,r_i$。$n$ 个整数变量，第 $i$ 个变量取值在 $[l_i,r_i]$ 间。问在前 $A$ 大的数中选出 $B$ 个组成的下标集合的种类数。</p>
<p>枚举这些变量中，最小的且下标最大的一个下标 $i$。</p>
<p>贪心得考虑，为了让可以调剂的人数尽量多，这个人去 $r_i$ 的时候是最优的，这样就能有少一点人必须在 $B$ 中。</p>
<p>然后统计出来有多少个人必须比这个 $i$ 大的人数 $x$，有多少个人既可以比 $i$ 大，亦可以比 $i$ 小的人数 $y$。枚举 $y$ 中选了 $j$ 个人在 $B$ 集合中，那么方案数就是 $\binom{y}{j}\binom{x}{B-j-1}$。需要注意 $A$ 的限制就可以了。</p>
<p>这一部分时间复杂度为 $O(n^2)$。</p>
<p>$$ \$$</p>
<p>总的复杂度就是 $O(n^2+\sum s_i)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Part1&#123;</span><br><span class="line">    string s[N]; <span class="type">char</span> t[N];</span><br><span class="line">    <span class="type">int</span> m[N];</span><br><span class="line">    <span class="type">int</span> st[N],dfn[N],low[N],top,cnt,belong[N],tim,in[N],g[N],now[N];</span><br><span class="line">    <span class="type">bool</span> instack[N],vi[M];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[N],vec[N],p[N];</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; vis[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[x].<span class="built_in">pb</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        instack[u]=<span class="number">1</span>;</span><br><span class="line">        st[++top]=u;</span><br><span class="line">        dfn[u]=low[u]=++tim;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">            <span class="keyword">if</span>(!dfn[v]) <span class="built_in">dfs</span>(v,u),low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(instack[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">        <span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="type">int</span> d=<span class="number">0</span>,v;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                v=st[top--];</span><br><span class="line">                instack[v]=<span class="number">0</span>;</span><br><span class="line">                d=__gcd(d,m[v]);</span><br><span class="line">                belong[v]=cnt;</span><br><span class="line">                p[cnt].<span class="built_in">pb</span>(v);</span><br><span class="line">            &#125;<span class="keyword">while</span>(u!=v);</span><br><span class="line">            g[cnt]=d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[i])</span><br><span class="line">                <span class="keyword">if</span>(belong[v]!=belong[i])</span><br><span class="line">                    vec[belong[i]].<span class="built_in">pb</span>(belong[v]);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="built_in">sort</span>(<span class="built_in">all</span>(vec[i])),vec[i].<span class="built_in">resize</span>(<span class="built_in">unique</span>(<span class="built_in">all</span>(vec[i]))-vec[i].<span class="built_in">begin</span>());</span><br><span class="line">        <span class="built_in">fo</span>(u,<span class="number">1</span>,cnt) <span class="keyword">for</span>(<span class="keyword">auto</span> v:vec[u]) in[v]++;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> *mn,<span class="type">int</span> *mx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(t[j]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">add</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            m[i]=<span class="built_in">read</span>();</span><br><span class="line">            cin&gt;&gt;s[i];</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">0</span>,m[i]<span class="number">-1</span>) mn[i]+=(s[i][j]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">        <span class="built_in">fo</span>(u,<span class="number">1</span>,cnt) <span class="keyword">if</span>(!in[u]) q.<span class="built_in">push</span>(u);</span><br><span class="line">        <span class="built_in">fo</span>(u,<span class="number">1</span>,cnt) now[u]=g[u],vis[u].<span class="built_in">resize</span>(g[u]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:p[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fo</span>(j,<span class="number">0</span>,m[i]<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        vis[u][j%g[u]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:vec[u])</span><br><span class="line">            &#123;</span><br><span class="line">                --in[v];</span><br><span class="line">                <span class="keyword">if</span>(!in[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    now[v]=__gcd(now[u],now[v]);</span><br><span class="line">                    <span class="built_in">fo</span>(i,<span class="number">0</span>,g[u]<span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">if</span>(vis[u][i])</span><br><span class="line">                            vi[i%now[v]]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">fo</span>(i,<span class="number">0</span>,now[v]<span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">if</span>(vi[i])</span><br><span class="line">                            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;g[v];j+=now[v])</span><br><span class="line">                                vis[v][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">fo</span>(i,<span class="number">0</span>,now[v]<span class="number">-1</span>) vi[i]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">0</span>,g[i]<span class="number">-1</span>) <span class="keyword">if</span>(vis[i][j]) sum++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v:p[i]) mx[v]=(<span class="number">1ll</span>*m[v]*sum)/g[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Part2&#123;</span><br><span class="line">    ll fac[N],inv[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> *l,<span class="type">int</span> *r,<span class="type">int</span> A,<span class="type">int</span> B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A=<span class="built_in">min</span>(A,n);</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">        ll x,y,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            x=y=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l[j]&gt;r[i]) x++;</span><br><span class="line">                <span class="keyword">if</span>(l[j]&lt;=r[i]&amp;&amp;((r[i]&lt;r[j])||(r[i]&lt;=r[j]&amp;&amp;i&gt;j))) y++;<span class="comment">//???</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=A) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> tmp=<span class="built_in">min</span>(y,A<span class="number">-1</span>-x);</span><br><span class="line">            tmp=<span class="built_in">min</span>(B<span class="number">-1</span>,tmp);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">0</span>,tmp)</span><br><span class="line">                <span class="keyword">if</span>(B-j<span class="number">-1</span>&lt;=x)</span><br><span class="line">                    ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">C</span>(y,j),<span class="built_in">C</span>(x,B-j<span class="number">-1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A,B;</span><br><span class="line"><span class="type">int</span> mi[N],mx[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//FO(na);</span></span><br><span class="line">    n=<span class="built_in">read</span>(); A=<span class="built_in">read</span>(); B=<span class="built_in">read</span>();</span><br><span class="line">    Part1::<span class="built_in">solve</span>(mi,mx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Part2::<span class="built_in">solve</span>(mi,mx,A,B));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>yww与树上的回文串[loj6681]</title>
    <url>/2020/04/11/yww%E4%B8%8E%E6%A0%91%E4%B8%8A%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2-loj6681/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/6681">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>好神仙的一道题啊qwq…</p>
<p>首先统计路径嘛，那么点分治。</p>
<p>考虑经过重心的合法路径的方案数。先把所有子树合在一起算，最后容斥减掉各子树的贡献。</p>
<p>那么剩下就是如何计算的问题。考虑经过重心的字符串只有两种情况：</p>
<ul>
<li>被分成一样的两部分。建个Trie统计一下即可。</li>
<li>被分成不同的两部分，即：</li>
</ul>
<p><img src="/yww%E4%B8%8E%E6%A0%91%E4%B8%8A%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2-loj6681/1.png" alt="1"></p>
<p>其中 $S$ 是一个字符串，$T$ 为非空回文串。</p>
<p>那么你建一个AC自动机，上面的形式相当于统计AC自动机上的某个节点的fail树的祖先中，减去该祖先所代表的字符串的长度后的前缀是回文串的个数。</p>
<p>我们知道，一个字符串的前缀回文串可以看成 $O(\log n)$ 个等差数列。</p>
<p>那么对于每个字符串记录下这些等差数列以后，相当于统计该节点跳fail链中的一些等差数列的和。</p>
<p>根据套路：</p>
<ul>
<li><p>当公差 $\geq \sqrt{n}$ 的时候暴力往上跳。</p>
</li>
<li><p>当公差 $&lt;\sqrt{n}$ 的时候，开个数组，记录下当前节点中，祖先字符串的长度模 $i$ 后为 $k$ 的有多少个，然后进行离线统计。</p>
</li>
</ul>
<p>时间复杂度 $T(n)=2T(\frac{n}{2})+O(n\log n+n\sqrt{n})=O(n\sqrt{n})$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">50005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base=<span class="number">43</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">100</span>;</span><br><span class="line">ll pw[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> l,r,d;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;node&gt; s[N],q[N];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">    <span class="type">int</span> ne[N][<span class="number">2</span>],fail[N],siz[N],len[N],cnt;</span><br><span class="line">    ll ans,h1[N],h2[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) len[i]=h1[i]=h2[i]=ne[i][<span class="number">0</span>]=ne[i][<span class="number">1</span>]=fail[i]=siz[i]=<span class="number">0</span>,s[i].<span class="built_in">clear</span>(),q[i].<span class="built_in">clear</span>(),adj[i].<span class="built_in">clear</span>();</span><br><span class="line">        cnt=<span class="number">0</span>; ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> &amp;p=ne[u][c];</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            p=++cnt; len[p]=len[u]+<span class="number">1</span>;</span><br><span class="line">            h1[p]=(h1[u]*base+c)%mod;</span><br><span class="line">            h2[p]=(h2[u]+pw[len[u]]*c)%mod;</span><br><span class="line">            s[p]=s[u];</span><br><span class="line">            <span class="keyword">if</span>(h1[p]==h2[p])<span class="comment">//is a plalindrome string</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[u].<span class="built_in">empty</span>()) s[p].<span class="built_in">pb</span>((node)&#123;len[p],len[p],inf&#125;);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> las=s[u].<span class="built_in">back</span>();</span><br><span class="line">                    <span class="keyword">if</span>(las.d==inf) s[p].<span class="built_in">back</span>()=(node)&#123;las.l,len[p],len[p]-las.l&#125;;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(las.d==len[p]-las.r) s[p].<span class="built_in">back</span>().r=len[p];</span><br><span class="line">                    <span class="keyword">else</span> s[p].<span class="built_in">pb</span>((node)&#123;len[p],len[p],inf&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[p]++; <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> f[N],g[N],m;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">        &#123;</span><br><span class="line">            u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span>(v=ne[u][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!u) fail[v]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> fail[v]=ne[fail[u]][i];</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ne[u][i]=ne[fail[u]][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) adj[fail[i]].<span class="built_in">pb</span>(i),f[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[len[u]]=u;</span><br><span class="line">        g[++m]=len[u];</span><br><span class="line">        <span class="type">int</span> l,r,L,R;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:s[u])</span><br><span class="line">        &#123;</span><br><span class="line">            l=len[u]-v.l; r=len[u]-v.r;</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="keyword">if</span>(v.d&gt;B)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i+=v.d) <span class="keyword">if</span>(f[i]!=<span class="number">-1</span>) ans+=<span class="number">1ll</span>*siz[f[i]]*siz[u];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                L=<span class="built_in">lower_bound</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>,l)-g<span class="number">-1</span>;<span class="comment">//&lt;</span></span><br><span class="line">                R=<span class="built_in">upper_bound</span>(g+<span class="number">1</span>,g+m+<span class="number">1</span>,r)-g<span class="number">-1</span>;<span class="comment">//&lt;=</span></span><br><span class="line">                <span class="keyword">if</span>(L==R) <span class="keyword">continue</span>;</span><br><span class="line">                q[f[g[R]]].<span class="built_in">pb</span>((node)&#123;v.d,r%v.d, siz[u]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(L) q[f[g[L]]].<span class="built_in">pb</span>((node)&#123;v.d,r%v.d,-siz[u]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:adj[u]) <span class="built_in">dfs1</span>(v);</span><br><span class="line">        f[len[u]]=<span class="number">-1</span>;</span><br><span class="line">        g[m--]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum[B+<span class="number">3</span>][N/B+<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,B) sum[i][len[u]%i]+=siz[u];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:q[u]) ans+=<span class="number">1ll</span>*p.d*sum[p.l][p.r];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:adj[u]) <span class="built_in">dfs2</span>(v);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,B) sum[i][len[u]%i]-=siz[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tle</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f[len[u]]=u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=u;i;i=fail[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=len[u]=len[i];</span><br><span class="line">            <span class="keyword">if</span>(f[l]!=<span class="number">-1</span>&amp;&amp;h1[f[l]]==h2[f[l]]) ans+=<span class="number">1ll</span>*siz[i]*siz[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">tle</span>(v);</span><br><span class="line">        f[len[u]]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getfail</span>();</span><br><span class="line">        <span class="comment">//tle(0); return ans;</span></span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) ans+=<span class="number">1ll</span>*siz[i]*(siz[i]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">    ll ans;</span><br><span class="line">    <span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],val[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot=<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> z,<span class="type">int</span> y,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">        ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rt,siz[N],mx[N]; <span class="type">bool</span> vis[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz[u]=<span class="number">1</span>; mx[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;!vis[ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">getroot</span>(v,u,S);</span><br><span class="line">                siz[u]+=siz[v];</span><br><span class="line">                mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        mx[u]=<span class="built_in">max</span>(mx[u],S-siz[u]);</span><br><span class="line">        <span class="keyword">if</span>(mx[rt]&gt;mx[u]) rt=u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(!vis[ver[i]]&amp;&amp;(v=ver[i])!=pre)</span><br><span class="line">                <span class="built_in">build</span>(v,u,AC::<span class="built_in">insert</span>(rt,val[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> opt,<span class="type">int</span> val=<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        AC::<span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> v=(opt==<span class="number">1</span>)?<span class="number">0</span>:(AC::<span class="built_in">insert</span>(<span class="number">0</span>,val));</span><br><span class="line">        AC::siz[v]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u,<span class="number">0</span>,v);</span><br><span class="line">        ans+=AC::<span class="built_in">work</span>()*opt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> Siz)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Siz==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//DEBUG(u);</span></span><br><span class="line">        <span class="built_in">calc</span>(u,<span class="number">1</span>);</span><br><span class="line">        vis[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(!vis[v=ver[i]])</span><br><span class="line">                <span class="built_in">calc</span>(v,<span class="number">-1</span>,val[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v,S;i;i=ne[i])</span><br><span class="line">            <span class="keyword">if</span>(!vis[v=ver[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                S=siz[v]&gt;siz[u]?Siz-siz[u]:siz[v];</span><br><span class="line">                rt=<span class="number">0</span>; <span class="built_in">getroot</span>(v,u,S);</span><br><span class="line">                <span class="built_in">divide</span>(rt,S);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans=<span class="number">0</span>;mx[<span class="number">0</span>]=inf;</span><br><span class="line">        <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="built_in">divide</span>(rt,n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pw[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) pw[i]=pw[i<span class="number">-1</span>]*base%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) Tree::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Tree::<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2020 US Open Platinum</title>
    <url>/2020/04/09/USACO-2020-US-Open-Platinum/</url>
    <content><![CDATA[<p>USACO 2020 US Open Platinum部分题解。</p>
<span id="more"></span>

<h3 id="Sprinklers-2-Return-of-the-Alfalfa"><a href="#Sprinklers-2-Return-of-the-Alfalfa" class="headerlink" title="Sprinklers 2: Return of the Alfalfa"></a>Sprinklers 2: Return of the Alfalfa</h3><h4 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://loj.ac/problem/3283">loj</a></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>显然被C覆盖的点是及其有规律的，是被一条从左上到右下，只会往下和右走的折线切成两半，左下方的部分全覆盖给C。</p>
<p>那么就可以根据这个轮廓线进行DP了，设 $f_{i,j,0/1}$ 表示考虑到第 $i$ 行第 $j$ 列，是在向下走还是向右走，且这个位置填C的方案数。</p>
<p>那么转移分两类讨论一下即可。</p>
<p>时间复杂度 $O(n^3)$。</p>
<p>然后发现这是一个前缀和，那么就是 $O(n^2)$ 的了。</p>
<p>细节初始化什么的注意一下。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N][N];</span><br><span class="line">ll a[N][N],b[N][N],sa[N][N],sb[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">FO</span>(sprinklers2);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n+<span class="number">1</span>) <span class="keyword">if</span>(s[i<span class="number">-1</span>][<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>) sb[i][<span class="number">0</span>]=b[i][<span class="number">0</span>]=inv2;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(s[<span class="number">1</span>][i]==<span class="string">&#x27;.&#x27;</span>) sa[<span class="number">1</span>][i]=a[<span class="number">1</span>][i]=inv2;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;.&#x27;</span>) a[i][j]=<span class="built_in">Mul</span>(inv2,sb[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j!=n&amp;&amp;s[i<span class="number">-1</span>][j+<span class="number">1</span>]==<span class="string">&#x27;.&#x27;</span>) b[i][j]=<span class="built_in">Mul</span>(inv2,sa[i<span class="number">-1</span>][j]);</span><br><span class="line">            sa[i][j]=<span class="built_in">Add</span>(sa[i<span class="number">-1</span>][j],a[i][j]);</span><br><span class="line">            sb[i][j]=<span class="built_in">Add</span>(sb[i][j<span class="number">-1</span>],b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    ll sum=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;.&#x27;</span>) sum=<span class="built_in">Mul</span>(sum,<span class="number">2</span>);</span><br><span class="line">    sum=<span class="built_in">Mul</span>(sum,<span class="built_in">Add</span>(sb[n+<span class="number">1</span>][n],sa[n][n]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://loj.ac/problem/3284">loj</a></p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>似乎有 $O(n\log n)$ 的神奇做法。。。</p>
<p>对于一个排列我们求的是所有的环长的LCM，那么考虑对于每个质因数分开来求。</p>
<p>记 $F_{x}(p)$ 表示最大的 $k$ 满足 $p^k|x$。那么对于一个拆分 $(x_1,x_2\cdots x_m)$ 及一个质数 $p$ 而言，$p$ 的次数就是 $\max\{F_{x_i}(p)\}$。</p>
<p>这个 $\max$ 显然不好求，我们用Min-Max容斥进行转换，得到答案为：</p>
<p>$$\sum_{S\in\{1,2\cdots m\},S\not =\varnothing}(-1)^{|S|-1}\min\{F_{S_i}(p)\}$$</p>
<p>然后可以枚举这个min是否大于等于某个值 $k$：</p>
<p>$$\sum_{k=1}^{n}\sum_{S\in\{1,2\cdots m\},S\not =\varnothing}(-1)^{|S|-1}[\min\{F_{S_i}(p)\}\geq k]$$</p>
<p>注意，上面的式子显然要从 $k=1$ 开始。</p>
<p>要使得最小值大于等于 $k$，这些环长都必须是 $p^k$ 的倍数。</p>
<p>那么现在就是枚举 $x=p^k$，然后看有多少个这样的集合符合情况。</p>
<p>假设这个集合所对应的排列的大小为 $ix$，符合条件的集合有 $F(i)$ 个，那么我们可以从 $n$ 个数中选出 $ix$ 个数，剩下的 $n-ix$ 个随便连，也就是 $F(i)\binom{n}{ix}(n-ix)!$。</p>
<p>现在来看对于一个 $x$，如何求出这个 $F(i)$。$F(i)$ 的定义为从 $[1,i]$ 中选择 $j$ 个长度均为 $x$ 的倍数，那么贡献就是 $(-1)^{j-1}$ 的贡献和。</p>
<p>考虑枚举长度为 $jx$ 的环有多少个，那么复杂度为 $O(\frac{n^2}{x^2}\log \frac{n}{x})$。</p>
<p>考虑枚举当前最小的点所在的环中有多少个点，那么有：$F(i)=-\sum_{j=1}^iF(j)\binom{ix-1}{jx-1}(jx-1)!$。就可以做到时间复杂度 $O(\frac{n^2}{x^2})$。</p>
<p>总的时间复杂度 $O(\sum_{p^k}\frac{n^2}{(p^{k})^2})\leq O(n^2\sum_{i=1}^n\frac{1}{i^2}=O(n^2\zeta(2)))=O(n^2)$</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">7505</span>;</span><br><span class="line">ll m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%m1)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%m1;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fac[N],c[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> bo[N];</span><br><span class="line"><span class="type">int</span> pri[N],cnt,p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%m2;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>; c[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j]=c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            c[i][j]&gt;=m2?c[i][j]-=m2:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bo[i])</span><br><span class="line">        &#123;</span><br><span class="line">            pri[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j*=i) p[j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;pri[j]*i&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            bo[pri[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N],sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=m2<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> m=n/x;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i)</span><br><span class="line">            f[i]=(f[i]-(f[i-j]*c[i*x<span class="number">-1</span>][j*x<span class="number">-1</span>]%m2*fac[j*x<span class="number">-1</span>])%m2+m2)%m2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,m) sum=(sum+(f[i]*c[n][i*x]%m2*fac[n-i*x]))%m2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//FO(exercise);</span></span><br><span class="line">    n=<span class="built_in">read</span>(); m1=<span class="built_in">read</span>(); m2=m1<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(p[i])</span><br><span class="line">            ans=ans*<span class="built_in">Pow</span>(p[i],<span class="built_in">solve</span>(i))%m1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>容斥原理</tag>
        <tag>组合数学</tag>
        <tag>Min-Max容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>K Paths[CF981H]</title>
    <url>/2020/04/08/K-Paths-CF981H/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/981/problem/H">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵树，选 $k$ 条路径，使得每条边在这 $k$ 条路径中的出现次数只能是 $0,1,k$ 中的其中一种。</p>
<p>路径点数至少为 $2$，可以选重复的路径，且路径有顺序。求满足条件的方案数模 $998244353$。</p>
<p>$n\leq 10^5$，时限4s。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题比上一题友好一点。</p>
<p>显然枚举这 $k$ 条路径的并集的两个端点 $u,v$，假设他们不是祖先关系。</p>
<p>那么要在 $u,v$ 的子树中选 $k$ 个点，设方案数为 $f_u,f_v$，那么这条路径的贡献就是 $f_u\times f_v$。</p>
<p>如果不考虑祖先关系，所有路径的贡献就是：</p>
<p>$$\sum_{i\not = j}f_i\times f_j=\frac{(\sum f_i)^2-\sum {(f_i^2)}}{2}$$</p>
<p>转换成求每个 $f_u$。</p>
<p>为了满足题意，这 $k$ 个点不能有某两个在其中一个儿子 $v$ 的子树中。</p>
<p>那么对于 $u$ 的每个儿子 $v$，最多能选一个点，剩下的点只能是 $u$ 。那么如果在子树中选了 $w$ 个点，由基础的组合数学可得贡献为 $P_{k}^w$。</p>
<p>对于每个儿子 $v$ 的贡献写成生成函数就是 $(1+siz_vx)$。</p>
<p>那么在子树中选 $w$ 个的方案数为 $[x^w]\prod_{v\in son_u}(1+siz_vx)$。</p>
<p>这一部分可以用分治ntt解决。</p>
<p>接下来考虑是祖先关系的情况。假设 $u$ 是 $v$ 的祖先，$w$ 是 $u$ 的儿子和 $v$ 的祖先。</p>
<p>那么 $u$ 的生成函数就变成了：</p>
<p>$$\frac{(\prod (1+siz_{son}x))(1+(n-siz_u)x)}{1+siz_wx}$$</p>
<p>在 $u$ 处产生的贡献就是：<br>$$\sum_v f_v\sum_{i=0}^kP_{k}^i[x^i]\frac{(\prod (1+siz_{son}x))(1+(n-siz_u)x)}{1+siz_wx}\=\sum_{i=0}^kP_{k}^i[x^i]\frac{(\prod (1+siz_{son}x))(1+(n-siz_u)x)}{(\sum_v f_v)(1+siz_{w(v)}x)}\=\sum_{i=0}^kP_{k}^i<a href="\sum_vf_v">x^i</a>(1+(n-siz_u)x)\prod_{son\not =w}(1+siz_{son}x)$$</p>
<p>这个十分经典，还是在分治FFT的时候算一下就可以了。</p>
<p>最后注意 $k=1$ 的特判。</p>
<p>时间复杂度 $O(n\log^2n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line">ll W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll wn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        W[i]=<span class="number">1</span>; wn=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*wn%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">    w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">    ll s1,s2,s,h[N],sh[N];</span><br><span class="line">    <span class="type">int</span> siz[N];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; w; <span class="type">int</span> now;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,Poly &amp;f,Poly &amp;g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)</span><br><span class="line">        &#123;</span><br><span class="line">            f.<span class="built_in">clear</span>(); f.<span class="built_in">pb</span>(<span class="number">1</span>); f.<span class="built_in">pb</span>(siz[w[l]]);</span><br><span class="line">            ll sum=<span class="built_in">Add</span>(sh[w[l]],h[w[l]]);</span><br><span class="line">            g.<span class="built_in">clear</span>(); g.<span class="built_in">pb</span>(sum); g.<span class="built_in">pb</span>(<span class="built_in">Mul</span>(sum,now));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        Poly lf,lg,rf,rg;</span><br><span class="line">        <span class="built_in">solve</span>(l,mid,lf,lg); <span class="built_in">solve</span>(mid+<span class="number">1</span>,r,rf,rg);</span><br><span class="line">        <span class="type">int</span> len=<span class="number">1</span>,m=lf.<span class="built_in">size</span>()+rf.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;len&lt;m;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        lf.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(lf,len,<span class="number">1</span>);</span><br><span class="line">        lg.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(lg,len,<span class="number">1</span>);</span><br><span class="line">        rf.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(rf,len,<span class="number">1</span>);</span><br><span class="line">        rg.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(rg,len,<span class="number">1</span>);</span><br><span class="line">        f.<span class="built_in">resize</span>(len); g.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>)</span><br><span class="line">            f[i]=lf[i]*rf[i]%mod,</span><br><span class="line">            g[i]=<span class="built_in">Add</span>(<span class="built_in">Mul</span>(lf[i],rg[i]),<span class="built_in">Mul</span>(lg[i],rf[i]));</span><br><span class="line">        <span class="built_in">ntt</span>(f,len,<span class="number">-1</span>); <span class="built_in">ntt</span>(g,len,<span class="number">-1</span>);</span><br><span class="line">        f.<span class="built_in">resize</span>(m); g.<span class="built_in">resize</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">        w.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre)</span><br><span class="line">        &#123;</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            w.<span class="built_in">pb</span>(v);</span><br><span class="line">            sh[u]=<span class="built_in">Add</span>(sh[u],<span class="built_in">Add</span>(h[v],sh[v]));</span><br><span class="line">        &#125;</span><br><span class="line">        now=n-siz[u];</span><br><span class="line">        <span class="keyword">if</span>(!w.<span class="built_in">size</span>()) w.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">        Poly f,g;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">0</span>,w.<span class="built_in">size</span>()<span class="number">-1</span>,f,g);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(k,(<span class="type">int</span>)f.<span class="built_in">size</span>()<span class="number">-1</span>))</span><br><span class="line">            h[u]=<span class="built_in">Add</span>(h[u],<span class="built_in">Mul</span>(fac[k]*inv[k-i]%mod,f[i]));</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(k,(<span class="type">int</span>)g.<span class="built_in">size</span>()<span class="number">-1</span>))</span><br><span class="line">            s=<span class="built_in">Add</span>(s,<span class="built_in">Mul</span>(fac[k]*inv[k-i]%mod,g[i]));</span><br><span class="line">        s1=<span class="built_in">Add</span>(s1,h[u]); s2=<span class="built_in">Add</span>(s2,h[u]*h[u]%mod);</span><br><span class="line">        s=<span class="built_in">Dec</span>(s,sh[u]*h[u]%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Add</span>(s,<span class="built_in">Mul</span>(<span class="built_in">Pow</span>(<span class="number">2</span>,mod<span class="number">-2</span>),<span class="built_in">Dec</span>(s1*s1%mod,s2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="number">1ll</span>*n*(n<span class="number">-1</span>)/<span class="number">2</span>%mod)&amp;<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PolyInit</span>();</span><br><span class="line">    <span class="built_in">init</span>(k);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) Tree::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Tree::<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree[CF1010F]</title>
    <url>/2020/04/07/Tree-CF1010F/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/1010/problem/F">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一棵有根二叉树，现在你要在上面填数。</p>
<p>根节点为 $1$，且已经填上了数字 $x$。</p>
<p>树边可以任意断掉，最后保留存在能到根节点路径的节点所形成的子树。</p>
<p>对于子树中的这些节点 $u$，满足它所有儿子所填的数之和小于等于 $u$ 填的数。</p>
<p>问最后有多少种形态。两种形态不同当且仅当子树的节点集合不同；或者集合相同，但存在一个节点 $u$，使得在两种方案中所填之数不同。</p>
<p>模 $998244353$。</p>
<p>$n\leq 10^5$，时限7s。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题也是够毒瘤了QwQ。</p>
<p>先来看看不能断树边该怎么算。</p>
<p>设 $a_u$ 为节点 $u$ 所填的数字。对于所有的 $u$ ，要使得满足它所有儿子所填的数之和小于等于 $u$ 填的数，我们转换条件，设：$b_u=a_u-\sum_{v\in son_u}a_v$。</p>
<p>那么就会有 $b_u\geq 0$，且可以发现，每个不同的 $b$ 一一对应这不同的 $a$。</p>
<p>并且还有 $\sum_{i=1}^nb_i=n$。</p>
<p>那么有插板法可得总方案数为 $\binom{n+x-1}{n}$。这个 $n$ 表示树的节点个数。</p>
<p>现在题目转换成，对于每个 $i$，求有多少个包含 $1$ 号点的连通子图，且大小为 $i$。</p>
<p>显然我们可以树形DP，设 $f_{u,i}$ 表示子树 $u$ 中节点个数为 $i$ 的方案数。</p>
<p>当有两个儿子的时候，有：$f_{u,i}=\sum_{j+k=i-1}f_{v,j}\times f_{w,k},f_{u,0}=1$。</p>
<p>设 $f_u$ 的OGF为 $F_u$，上式写成生成函数的形式是：$F_u=xF_vF_w+1$。</p>
<p>当 $u$ 为空的时候，$F_u=1$。</p>
<p>显然上式用FFT优化，但显然还是没有用的。</p>
<p>那就先考虑链吧？这个很简单。</p>
<p>链中每个点插多一个子树呢？</p>
<p>那么我对于每个点 $u$，设插进去的这个子树算出来的生成函数乘以 $x$ 后的式子为 $g_u$。</p>
<p>对于这条链，考虑从上往下计算，则有：$F_u=F_{son_u}g_u+1$</p>
<p>我们不妨将这条链从上往下标号为 $1,2\cdots k$。那么最终的生成函数就是：</p>
<p>$$F=(g_1(g_2(g_3\cdots)+1))+1\=\sum_{i=0}^k\prod_{j=1}^ig_j$$</p>
<p>考虑分治计算这个东西，设当前的分治结构为 $[l,r]$，$s=\prod_{i=l}^rg_i$，$F=\sum_{i=l-1}^r\prod_{j=l}^ig_j$，那么有：</p>
<p>$$s_{[l,r]}=s_{[l,mid]}\times s_{[mid+1,r]}\\F_{[l,r]}=(F_{[l,mid]}-1)\times s_{[mid+1,r]}+F_{[mid+1,r]}$$</p>
<p>可以用ntt优化上面的乘法。</p>
<p>那么可以先树链剖分进行链分治，对于每条链，我们按照上面的方法算。设链顶的节点的子树大小为 $siz$ ，那么上面的方法的复杂度就是 $O(siz\log ^2siz)$。</p>
<p>由于每个节点往上跳只会统计最多 $\log n$ 次，那么总的复杂度就是 $O(n\log ^3n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;W&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="keyword">namespace</span> P&#123;</span><br><span class="line">    <span class="type">int</span> R[M]; ll W[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll wn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            W[i]=<span class="number">1</span>; wn=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*wn%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                    w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">                    a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">                    a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> opt)</span> </span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,opt);&#125;</span><br><span class="line">    <span class="keyword">inline</span> Poly <span class="keyword">operator</span>*(Poly A,Poly B)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;len&lt;=k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=<span class="number">1ll</span>*A[i]*B[i]%mod;</span><br><span class="line">        <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">        A.<span class="built_in">resize</span>(k);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> Poly <span class="keyword">operator</span>+(<span class="type">const</span> Poly &amp;A,<span class="type">const</span> Poly &amp;B)</span><br><span class="line">    &#123;</span><br><span class="line">        Poly C=A;</span><br><span class="line">        C.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) C[i]=<span class="built_in">Add</span>(C[i],B[i]);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> P;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">    <span class="type">int</span> son[N],siz[N],oth[N]; </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        siz[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">            oth[u]^=v;</span><br><span class="line">            siz[u]+=siz[v];</span><br><span class="line">            <span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">        &#125;</span><br><span class="line">        oth[u]^=son[u];</span><br><span class="line">    &#125;</span><br><span class="line">    Poly p[N],w[N];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,Poly &amp;f,Poly &amp;g)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r)&#123;f=g=w[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        Poly lf,lg,rf,rg;</span><br><span class="line">        <span class="built_in">solve</span>(l,mid,lf,lg); <span class="built_in">solve</span>(mid+<span class="number">1</span>,r,rf,rg);</span><br><span class="line">        g=lg*rg; f=rf*lg+lf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Poly <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=u;v;v=son[v])</span><br><span class="line">        &#123;</span><br><span class="line">            p[v].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(oth[v]) p[v]=<span class="built_in">dfs2</span>(oth[v]);</span><br><span class="line">            <span class="keyword">if</span>(p[v].<span class="built_in">empty</span>()) p[v].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">            p[v][<span class="number">0</span>]++; p[v].<span class="built_in">insert</span>(p[v].<span class="built_in">begin</span>(),<span class="number">0</span>);</span><br><span class="line">            w[++m].<span class="built_in">swap</span>(p[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        Poly f,g;</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">1</span>,m,f,g);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    Poly f;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        f=<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">        ll ans=<span class="number">0</span>,now=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(now,f[i]));</span><br><span class="line">            now=<span class="built_in">Mul</span>(now,<span class="built_in">Mul</span>(<span class="built_in">Add</span>(x,i),<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PolyInit</span>();</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    ll x; <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x); x%=mod;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) Tree::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,Tree::<span class="built_in">work</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>FFT</tag>
        <tag>组合数学</tag>
        <tag>树链剖分</tag>
        <tag>链分治</tag>
      </tags>
  </entry>
  <entry>
    <title>氪金手游[CTS2019]</title>
    <url>/2020/04/07/%E6%B0%AA%E9%87%91%E6%89%8B%E6%B8%B8-CTS2019/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3124">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>mdzz…刚开始没看到权值只能在 $[1,3]$ 之间…导致自闭了很久…</p>
<p>这题还挺简单的。</p>
<p>首先如果把题目的有向变成无向，那么就是一棵无根树。</p>
<p>假设权值已经固定了。</p>
<p>再假设它是一个外向树的结构，那么显然可以树形DP一下：</p>
<p>设 $f_u$ 表示子树内答案，有：$f_u=\prod_{v\in son_u}f_v\frac{w_u}{\sum_{v\in tree_u} w_v}$。</p>
<p>但是现在权值 $w_i$ 不固定，那么 $\sum_{v\in tree_u} w_v$ 也不固定，那么在DP的时候还需要记多一维表示子树的 $w_v$ 的和，这个还是 $O(n)$ 级别。那么时间复杂度 $O(n^2)$。</p>
<p>想到这里，你就会获得0分的好成绩。。。</p>
<p>那么当这棵树不是外向树的时候的概率该怎么算呢？</p>
<p>考虑容斥原理，假设你至少有 $i$ 条内向边改成了外向，其他内向边随意，那么对答案的贡献为 $(-1)^i$。</p>
<p>那么随意的外向边相当于断开，那么 $\sum_{v\in tree_u} w_v$ 这里就不需要算这棵断开了的子树。</p>
<p>只需要在树形DP的时候容斥，遇到一条内向边就考虑它是否改成外向，还是断开两种情况就可以了。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3005</span>;</span><br><span class="line">ll inv[N],a[N][<span class="number">4</span>];</span><br><span class="line">ll f[N][N],g[N];</span><br><span class="line"><span class="type">int</span> n,num[N],siz[N];</span><br><span class="line"><span class="type">int</span> ver[N],val[N],ne[N],head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> y,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++tot]=y; val[tot]=<span class="number">1</span>; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">    ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">3</span>) f[u][i]=a[u][i]*i%mod;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; V; ll t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">        <span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">           <span class="built_in">dfs</span>(v,u),V.<span class="built_in">pb</span>(v),num[v]=val[i];</span><br><span class="line">    <span class="built_in">sort</span>(<span class="built_in">all</span>(V),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> siz[x]&lt;siz[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:V)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u]*<span class="number">3</span>) <span class="built_in">fo</span>(j,<span class="number">1</span>,siz[v]*<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t=f[u][i]*f[v][j]%mod;</span><br><span class="line">            <span class="keyword">if</span>(num[v]) g[i+j]=<span class="built_in">Add</span>(g[i+j],t);</span><br><span class="line">            <span class="keyword">else</span> g[i+j]=<span class="built_in">Dec</span>(g[i+j],t),g[i]=<span class="built_in">Add</span>(g[i],t);</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u]*<span class="number">3</span>) f[u][i]=g[i],g[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,siz[u]*<span class="number">3</span>) f[u][i]=<span class="built_in">Mul</span>(f[u][i],inv[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,N<span class="number">-1</span>) inv[i]=<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>);</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="number">3</span>) s+=(a[i][j]=<span class="built_in">read</span>());</span><br><span class="line">        s=<span class="built_in">Pow</span>(s,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">fo</span>(j,<span class="number">1</span>,<span class="number">3</span>) a[i][j]=<span class="built_in">Mul</span>(a[i][j],s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n*<span class="number">3</span>) ans=<span class="built_in">Add</span>(ans,f[<span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>珍珠[CTS2019]</title>
    <url>/2020/04/06/%E7%8F%8D%E7%8F%A0-CTS2019/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3120">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设第 $i$ 个颜色出现了 $a_i$ 次，那么当且仅当 $\sum_{i=1}^d\left \lfloor \frac{a_i}{2}\right \rfloor\leq m$ 时满足条件。</p>
<p>原式经转换得：$\sum a_i-a_i\bmod 2\leq 2m$。</p>
<p>因为有 $\sum_{i=1}^da_i=n$，那么有 $\sum_{i=1}^da_i\bmod 2\leq n-2m$。</p>
<p>那么设 $g_j$ 表示 $\sum_{i=1}^da_i\bmod 2=j$ 的方案数，最后 $\sum_{j=0}^{n-2m}g_j$ 就是答案。</p>
<p>这个 $g_j$ 很不好求，可以容斥一下，变成求至少为 $j$ 的方案数，设为 $f_i$。</p>
<p>那么有：$f_i=\sum_{j=i}^d\binom{j}{i}g_j$。</p>
<p>二项式反演得到：$g_i=\sum_{j=i}^d(-1)^{j-i}\binom{j}{i}f_j$，即：</p>
<p>$$g_i=\frac{1}{i!}\sum_{j=i}^d\frac{(-1)^{j-i}}{(j-i)!}\times j!f_j$$</p>
<p>显然是一个卷积形式，ntt即可，转换为求所有的 $f_i$。</p>
<p>那么就是在 $d$ 个颜色中钦定 $i$ 个，使得这 $i$ 个颜色都选了奇数个，其他任意的方案数。这里有 $\binom{d}{i}$ 种情况。</p>
<p>如果只要出现这 $i$ 个颜色当中出现了一个选了偶数，则这个方案贡献为 $0$，否则为 $1$。</p>
<p>如果颜色的出现次数为 $a_1,a_2\cdots,a_d$，则一共有 $\frac{n!}{\prod_{i=1}^da_i!}$ 种情况。这启发我们可以使用EGF来进行计数。</p>
<p>考虑那 $i$ 个颜色的EGF对应的序列是这样的：$\{0,1,0,1,0\cdots\}$，也就是 $\frac{e^x-e^{-x}}{2}$。</p>
<p>其他颜色的EGF对应的序列是这样的：$\{1,1,1,1\cdots\}$，为 $e^x$。</p>
<p>那么这一部分的答案为 $n! \left [ x ^ n \right ] (\frac{e^x-e^{-x}}{2})^i(e^x)^{d-i}$。</p>
<p>那么有：</p>
<p>$$f_i=\binom{d}{i}n<img src="%5Cfrac%7Be%5Ex-e%5E%7B-x%7D%7D%7B2%7D" alt="x^n">^i(e^x)^{d-i}\=\frac{d!}{2^ii!(d-i)!}n<img src="e%5Ex-e%5E%7B-x%7D" alt="x^n">^ie^{(d-i)x}\=\frac{d!}{2^ii!(d-i)!}n![x^n]\sum_{j=0}^i(-1)^{i-j}\binom{i}{j}e^{jx}e^{-(i-j)x}e^{(d-i)x}\=\frac{d!}{2^ii!(d-i)!}n![x^n]\sum_{j=0}^i(-1)^{i-j}\binom{i}{j}e^{(d-2(i-j))x}\=\frac{d!}{2^ii!(d-i)!}n!\sum_{j=0}^i(-1)^{i-j}\binom{i}{j}\frac{(d-2(i-j))^n}{n!}\=\frac{d!}{2^ii!(d-i)!}\sum_{j=0}^i(-1)^{i-j}\binom{i}{j}(d-2(i-j))^n\=\frac{d!}{2^i(d-i)!}\sum_{j=0}^i\frac{1}{j!}\times \frac{(-1)^{i-j}(d-2(i-j))^n}{(i-j)!}$$</p>
<p>这一部分也是一个卷积形式，ntt计算出 $f_i$ 即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;W&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll g=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">270000</span>;</span><br><span class="line"><span class="keyword">namespace</span> Poly&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> R[M]; ll W[M];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll wn;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            W[i]=<span class="number">1</span>; wn=<span class="built_in">Pow</span>(g,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">            <span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*wn%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n/<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        ll w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    w=W[i+k]*a[i+j+k]%mod;</span><br><span class="line">                    a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w);</span><br><span class="line">                    a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">        w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=<span class="built_in">Mul</span>(a[i],w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Poly;</span><br><span class="line"><span class="type">int</span> d,n,m;</span><br><span class="line">ll A[N],B[N],fac[N],inv[N],f[N],C[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PolyInit</span>();</span><br><span class="line">    d=<span class="built_in">read</span>(); n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-2</span>*m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>)&amp;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-2</span>*m&gt;=d) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Pow</span>(d,n))&amp;<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;len&lt;=d+d+<span class="number">2</span>;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,d) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[d]=<span class="built_in">Pow</span>(fac[d],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,d,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,d) A[i]=inv[i],B[i]=<span class="built_in">Mul</span>(<span class="built_in">Pow</span>(mod<span class="number">-1</span>,i),<span class="built_in">Mul</span>(inv[i],<span class="built_in">Pow</span>(<span class="built_in">Dec</span>(d,<span class="number">2</span>*i),n)));</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len) A[i]=A[i]*B[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,d) f[i]=<span class="built_in">Mul</span>(fac[d],inv[d-i])*<span class="built_in">Mul</span>(A[i],<span class="built_in">Pow</span>(<span class="built_in">Pow</span>(<span class="number">2</span>,i),mod<span class="number">-2</span>))%mod*fac[i]%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,d) C[d-i]=<span class="built_in">Mul</span>(<span class="built_in">Pow</span>(mod<span class="number">-1</span>,i),inv[i]);</span><br><span class="line">    <span class="built_in">ntt</span>(f,len,<span class="number">1</span>); <span class="built_in">ntt</span>(C,len,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">0</span>,len) f[i]=f[i]*C[i]%mod;</span><br><span class="line">    <span class="built_in">ntt</span>(f,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">fo</span>(i,d,d+n<span class="number">-2</span>*m) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(f[i],inv[i-d]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
        <tag>FFT</tag>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>随机立方体[CTS2019]</title>
    <url>/2020/04/06/%E9%9A%8F%E6%9C%BA%E7%AB%8B%E6%96%B9%E4%BD%93-CTS2019/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个 $n\times m\times l$ 的立方体，立方体中每个格子上都有一个数，如果某个格子上的数比三维坐标<strong>至少有一维</strong>相同的其他格子上的数都要大的话，我们就称它是极大的。</p>
<p>现在将 $1\sim n\times m\times l$ 这 $n\times m\times l$ 个数等概率随机填入 $n\times m\times l$ 个格子（即任意数字出现在任意格子上的概率均相等），使得每个数恰出现一次，求恰有 $k$ 个极大的数的概率。对 $998244353$ 取模。</p>
<p>$T\leq 10,n,m,l\leq 5\times 10^6,k\leq 100$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$k\leq100$？似乎就是用来迷惑人的吧。。。</p>
<p>“恰有”非常难搞，那就考虑容斥，变成钦定 $k$ 个为极大，设此时答案为 $f_k$。</p>
<p>那么二项式反演一下，可得到最后的答案为 ：$\sum_{i=k}^{\min\{n,m,l\}}(-1)^{i-k}\binom{i}{k}f_i$。</p>
<p>设 $w=\min\{n,m,l\}$，接下来考虑如何求 $f _ k$。</p>
<p>第一步是要钦定 $k$ 个极大的点，且这 $k$ 个极大的点已经按从小到大的顺序排好。</p>
<p>显然，这 $k$ 个极大的点的 $x$ 坐标都互不相同，$y,z$ 同理。那么也就是有 $\binom{n}{i}\binom{m}{i}\binom{l}{i}(i!)^3$ 种情况。</p>
<p>然后在 $1\sim nml$ 中选一些数，填到跟这 $k$ 个点有关系的点上去。什么叫有关系，就是坐标跟这 $k$ 个中的任意一点至少有一维相同的点就能有关系。这些点有多少个呢？显然用总方案减去不合法的，即没有一维和这 $k$ 个点相同。设为 $s_k$，则有：$s_k=nml-(n-k)(m-k)(l-k)$。那么选的方案数就是 $\binom{nml}{s_k}$。</p>
<p>接着，除了这 $s_k$ 个点以外的点就可以乱选了，也就是 $(nml-s_k)!$ 种。</p>
<p>最后要把这 $s_k$ 中颜色填上去，使得钦定的 $k$ 个点为极大点，设这时的答案为 $g_k$。</p>
<p>那么有：</p>
<p>$$f_i=\frac{\binom{nml}{s_k}(nml-s_k)!\binom{n}{i}\binom{m}{i}\binom{l}{i}(i!)^3g_i}{(nml)!}$$</p>
<p>除以 $(nml)!$ 是因为我们算的是概率。</p>
<p>接下来就只需要看这个 $g_k$ 如何算了，考虑有 $g_{k-1}$ 递推过来</p>
<p>考虑从大到小填这个极大值进去。首先极大值这个位置已经确定了，现在我们还有 $s_k-1$ 个数可以选择，需要选一些数使得最后剩下 $s_{k-1}$ 个数，那么就有 $\frac{(s_k-1)!}{s_{k-1}!}$ 种情况。</p>
<p>最后有 $g_k=\prod_{i=1}^k{\frac{(s_i-1)!}{s_{i-1}!}}$。</p>
<p>代入答案，化简得：</p>
<p>$$Ans=\sum_{i=k}^{w}(-1)^{i-k}\binom{i}{k}\binom{n}{i}\binom{m}{i}\binom{l}{i}(i!)^3\prod_{j=1}^i\frac{1}{s_j}$$</p>
<p>线性处理 $\prod_{j=1}^is_j$ 的逆元即可。</p>
<p>时间复杂度 $O(Tw)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>+<span class="number">5</span>;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n-m&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Mul</span>(fac[n],<span class="built_in">Mul</span>(inv[m],inv[n-m]));</span><br><span class="line">&#125;</span><br><span class="line">ll sum,ss,ans,s[N],g[N];</span><br><span class="line"><span class="type">int</span> n,m,l,k,w;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inv[n-i]*inv[m-i]%mod*inv[l-i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>(<span class="number">5000000</span>);</span><br><span class="line">    CASET</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); l=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">        sum=<span class="built_in">Mul</span>(l,<span class="built_in">Mul</span>(n,m));</span><br><span class="line">        w=<span class="built_in">min</span>(<span class="built_in">min</span>(n,m),l);</span><br><span class="line">        ss=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,<span class="number">1</span>,w) s[i]=<span class="built_in">Dec</span>(sum,<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(n-i,m-i),l-i)),ss=<span class="built_in">Mul</span>(ss,s[i]);</span><br><span class="line">        ss=<span class="built_in">Pow</span>(ss,mod<span class="number">-2</span>); g[w]=ss;</span><br><span class="line">        <span class="built_in">fd</span>(i,w,<span class="number">1</span>) g[i<span class="number">-1</span>]=g[i]*s[i]%mod;</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fo</span>(i,k,w) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(((i-k)&amp;<span class="number">1</span>)?mod<span class="number">-1</span>:<span class="number">1</span>,<span class="built_in">C</span>(i,k)),g[i])*<span class="built_in">calc</span>(i)%mod);</span><br><span class="line">        ans=<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(ans,fac[n]),<span class="built_in">Mul</span>(fac[m],fac[l]));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
        <category>CTSC</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>组合数学</tag>
        <tag>二项式反演</tag>
      </tags>
  </entry>
  <entry>
    <title>USACO 2020 US Open Gold</title>
    <url>/2020/04/04/USACO-2020-US-Open-Gold/</url>
    <content><![CDATA[<p>USACO 2020 US Open Gold题解。</p>
<span id="more"></span>

<h3 id="Haircut"><a href="#Haircut" class="headerlink" title="Haircut"></a>Haircut</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个数组，对于每个 $i\in[0,n)$，若将 $\geq i$  的数全部变成 $i$，求逆序对个数。</p>
<p>$n\leq 10^5$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>考虑一个逆序对 $(a_j,a_k)$ 在哪些 $i$ 有贡献，显然是在 $[a_k+1,n)$ 处会产生贡献，然后树状数组随便算就好了。</p>
<h3 id="Favorite-Colors"><a href="#Favorite-Colors" class="headerlink" title="Favorite Colors"></a>Favorite Colors</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>一个有向图，需要给点染上颜色。颜色从 $1$ 开始标号。若存在边 $(b,a),(c,a)$，则 $b,c$ 必须颜色相同。</p>
<p>求在满足颜色数最大的时候，的最大字典序。</p>
<p>$n\leq 2\times 10^5$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>考虑在 $a$ 处考虑，对于连向 $a$ 的两个点 $b,c$ 而言，我们可以把他们看成一个点。把这两个点的信息合并到一起。然后如果合并后这个点也有两个或以上连向它的点，则也要把这些点合并。因此开一个队列记录有哪些 $a$ 是需要对连向它的点进行合并的。</p>
<p>合并用启发式合并即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> fa[N],vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[x].<span class="built_in">size</span>()&lt;s[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:s[y]) s[x].<span class="built_in">insert</span>(v),fa[v]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[y]) adj[x].<span class="built_in">pb</span>(v);</span><br><span class="line">	adj[y].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="keyword">if</span>(adj[x].<span class="built_in">size</span>()&gt;<span class="number">1</span>) q.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(fcolor);</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=i; s[i].<span class="built_in">insert</span>(i);</span><br><span class="line">		<span class="keyword">if</span>(adj[i].<span class="built_in">size</span>()&gt;<span class="number">1</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u,v,w;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>();</span><br><span class="line">		<span class="keyword">if</span>(adj[u].<span class="built_in">size</span>()&lt;=<span class="number">1</span>) &#123;q.<span class="built_in">pop</span>(); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		v=fa[adj[u].<span class="built_in">back</span>()];</span><br><span class="line">		adj[u].<span class="built_in">pop_back</span>();</span><br><span class="line">		w=fa[adj[u].<span class="built_in">back</span>()];</span><br><span class="line">		<span class="keyword">if</span>(v==w) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">merge</span>(v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[fa[i]]) vis[fa[i]]=++cnt;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,vis[fa[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>一个 $n$ 阶置换，定义这个置换的次数为 $(1,2,\cdots,n)$ 按照该置换进行操作，用最少的大于 $0$ 的操作数，使得所有的 $i$ 最后都回到原来的位置上。</p>
<p>问所有的 $k$ 的和，满足存在至少一个置换的次数为 $k$。答案对 $m$ 取模。</p>
<p>$n\leq 10^4$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>显然一个置换的次数为所有环长的LCM。</p>
<p>刚开始想的时候还以为要搞什么Min-Max容斥之类的。</p>
<p>结果你发现只需要一个贪心，对于某个 $p^k$ 而言，假设出现在了LCM中，那么只需要一个单独的环，长度为 $p^k$ 即可。其他的环大可不必有 $p$ 的倍数，而多出来的用自环就可以搞定。</p>
<p>也就是判断一个 $k$ 是否合法可以先将其质因数分解：$k=\prod_{i=1}^mp_i^{q_i}$。然后判断是否满足 $\sum_{i=1}^mp_i^{q_i}\leq n$ 即可。</p>
<p>那么考虑枚举质因子进行 DP，设 $f_{i,j}$ 表示考虑到第 $i$ 个质数，当前总和为 $j$ 的所有的 $k$ 的和，然后枚举 $i^l$ 进行转移。</p>
<p>时间复杂度 $O(\frac{n}{\ln n}n\log n)=O(n^2)$。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2000</span>;</span><br><span class="line">ll mod;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line">ll f[N][M];</span><br><span class="line"><span class="type">int</span> pri[M],cnt,n;</span><br><span class="line"><span class="type">bool</span> bo[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bo[i]) &#123;pri[++cnt]=i;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*pri[j]&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			bo[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(exercise);</span><br><span class="line">	n=<span class="built_in">read</span>(); mod=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,cnt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j]=<span class="built_in">Add</span>(f[i][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>,t=pri[j];t&lt;=i;k++,t*=pri[j])</span><br><span class="line">				f[i][j]=<span class="built_in">Add</span>(f[i][j],<span class="built_in">Mul</span>(f[i-t][j<span class="number">-1</span>],t));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">Add</span>(ans,f[i][cnt]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Add</span>(ans,<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>树状数组</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>IIIDX[九省联考2018]</title>
    <url>/2020/04/02/IIIDX-%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2472">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵树，$i$ 的父亲是 $\left\lfloor \frac{i}{k}\right\rfloor$ 一个乱序的数组 $d$，大小均为 $n$。将数组中的数扔进树中的点做点权，使得 $d_i\geq d_{fa_i}$。输出满足条件的最大字典序。</p>
<p>$n\leq 5\times 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果 $d_i$ 互不相同，那么对于相同层数的点从小到大贪心一下即可。50pts。</p>
<p>但是如果 $d_i$ 有相同的，因为可以有等于的限制，所以上面的贪心就行不通了。</p>
<p>考虑换一种贪心，对于一棵子树 $u$，我们需要选择最大 $d_i$ 满足剩下的还能选择的 $d$ 中至少有 $siz_u$ 个。那也就是将 $d_i$ 从大到小排序，设 $f_i$ 表示还剩下 $f_i$ 个大于等于 $d_i$ 的 $d$ 可以选择，初始时 $f_i=i$。对于子树 $u$ 而言，需要找到最小的 $i$ 满足 $f_i\geq siz_u$，但是这个 $i$ 并不一定是最优的，显然最优的是最大的 $j$ 满足 $d_i=d_j$（实际上就是把所有的 $d_i$ 相同的搞到一起考虑）。然后将 $f[j,n]$ 都减去 $siz_u$，表示我会先预留 $siz_u$ 个位置给子树 $u$ 中的所有点。然后继续处理 $u+1$。</p>
<p>需要用的操作是区间加，查询第一个大于某个值的下标。这个用线段树即可实现。</p>
<p>需要注意的是处理到 $u$ 时，需要把 $fa_u$ 预留的位置所做的贡献删掉。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="type">int</span> n; db k;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line"><span class="type">int</span> mi[N&lt;&lt;<span class="number">2</span>],tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mi[u]+=d; tag[u]+=d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tag[u]==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">pushtag</span>(lc,tag[u]); <span class="built_in">pushtag</span>(rc,tag[u]);</span><br><span class="line">	tag[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;mi[u]=l,tag[u]=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(ls); <span class="built_in">build</span>(rs);</span><br><span class="line">	mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,d);</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">add</span>(ls,L,R,d);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">add</span>(rs,L,R,d);</span><br><span class="line">	mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> mi[u]&gt;=d?l:l+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> d&lt;=mi[rc]?<span class="built_in">ask</span>(ls,d):<span class="built_in">ask</span>(rs,d); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> bo[N];</span><br><span class="line"><span class="type">int</span> fa[N],d[N],siz[N],las[N],ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[i]=<span class="number">1.</span>*i/k;</span><br><span class="line">		++siz[i];</span><br><span class="line">		siz[fa[i]]+=siz[i];</span><br><span class="line">		las[i]=i;</span><br><span class="line">		<span class="keyword">if</span>(i!=n&amp;&amp;d[i]==d[i+<span class="number">1</span>]) las[i]=las[i+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u=fa[i];</span><br><span class="line">		<span class="keyword">if</span>(u&amp;&amp;!bo[u]) bo[u]=<span class="number">1</span>,<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,ans[u],n,siz[u]<span class="number">-1</span>);</span><br><span class="line">		ans[i]=las[<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,siz[i])];</span><br><span class="line">		<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,ans[i],n,-siz[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,d[ans[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>林克卡特树[九省联考2018]</title>
    <url>/2020/04/02/%E6%9E%97%E5%85%8B%E5%8D%A1%E7%89%B9%E6%A0%91-%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2478">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>稍微转换一下，考虑 $k$ 比较小的情况，发现就是找 $k+1$ 条互不相交的路径，使得链的权值之和最大。</p>
<p>那么60分的DP做法就呼之欲出了，设 $f_{i,j,0/1/2}$ 表示以 $i$ 为根节点的子树中，选了 $j$ 条路径，没有一条链传给父亲，有一条链传给父亲，子树有两条链在 $i$ 处结合的最大价值。</p>
<p>然后转移只需要分三种情况讨论一下。</p>
<p>这种选 $k$ 次的一般都会满足单调性，也就是设答案为 $f(k)$，则 $f(k)-f(k-1)$ 不递减。证明并不会，只能意会QwQ。</p>
<p>那么就可以用wqs二分了，二分斜率 $mid$，然后转换成只需要判断是否可以选出 $k+1$ 条路径，满足路径都大于等于这个斜率 $mid$，那么将每条路径的贡献减去 $mid$，变成判断是否可以选出 $k+1$ 条大于等于 $0$ 的路径，且价值和最大，就可以了。</p>
<p>这个可以用60分的DP解决，少了 $j$ 这一维的转移即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line">ll l,r,mid;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	ll v; <span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.v==B.v) <span class="keyword">return</span> A.k&lt;B.k;</span><br><span class="line">		<span class="keyword">return</span> A.v&lt;B.v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B) &#123;<span class="keyword">return</span> (node)&#123;A.v+B.v,A.k+B.k&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> node <span class="keyword">operator</span>+(<span class="type">const</span> node &amp;A,<span class="type">const</span> ll &amp;B) &#123;<span class="keyword">return</span> (node)&#123;A.v+B,A.k&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> node <span class="title">change</span><span class="params">(<span class="type">const</span> node &amp;A)</span> </span>&#123;<span class="keyword">return</span> (node)&#123;A.v-mid,A.k+<span class="number">1</span>&#125;;&#125;</span><br><span class="line">node f[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],val[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> z,<span class="type">int</span> y,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u][<span class="number">0</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	f[u][<span class="number">1</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	f[u][<span class="number">2</span>]=(node)&#123;-mid,<span class="number">1</span>&#125;;<span class="comment">//!!!</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		f[u][<span class="number">2</span>]=<span class="built_in">max</span>(f[u][<span class="number">2</span>]+f[v][<span class="number">0</span>],<span class="built_in">change</span>(f[u][<span class="number">1</span>]+f[v][<span class="number">1</span>]+val[i]));</span><br><span class="line">		f[u][<span class="number">1</span>]=<span class="built_in">max</span>(f[u][<span class="number">1</span>]+f[v][<span class="number">0</span>],f[u][<span class="number">0</span>]+f[v][<span class="number">1</span>]+val[i]);</span><br><span class="line">		f[u][<span class="number">0</span>]=f[u][<span class="number">0</span>]+f[v][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	f[u][<span class="number">0</span>]=<span class="built_in">max</span>(<span class="built_in">max</span>(f[u][<span class="number">0</span>],f[u][<span class="number">2</span>]),<span class="built_in">change</span>(f[u][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	r=<span class="number">1000000ll</span>*n; l=-r;</span><br><span class="line">	<span class="keyword">for</span>(;l&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(f[<span class="number">1</span>][<span class="number">0</span>].k&gt;k) l=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mid=l; <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[<span class="number">1</span>][<span class="number">0</span>].v+mid*k);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>wqs二分</tag>
      </tags>
  </entry>
  <entry>
    <title>遗迹[JOISC 2020 Day2]</title>
    <url>/2020/03/30/%E9%81%97%E8%BF%B9-JOISC-2020-Day2/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3276">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先来看看给一个 $a_i$，最后柱子的高度 $b_i$ 可以怎么算。</p>
<p>显然可以从后面倒着枚举 $i$，然后从 $a_i$ 倒着枚举到 $0$ 找到一个 $j$ ，使得 $[1,j]$ 已经全部在 $i$ 后面使用过了。那么这个$b_i=j$。</p>
<p>这样就可以进行DP了，显然是倒着来的。</p>
<p>为了方便，我们设两个 $i$ 是不相同的，这样做就不需要处理是否出现过 $i$，那么只要最后答案除以 $2^n$ 就可以了。</p>
<p>设 $f _ {i,j} $ 表示从后往前考虑到第 $i$ 位时，$[1,j]$ 已经全部使用过，$j+1$ 没有使用的方案数。</p>
<ul>
<li>若这一位的 $b_i$ 为 $0$：</li>
</ul>
<p>那么这一位的 $a_i$ 则必须选在 $[1,j]$ 中的数，假设后面有 $m$ 个位置答案为 $0$，也就是说，已经有 $m$ 个位置选了 $[1,j]$ 中的数，且 $[1,j]$ 中所有数至少过一次（不然不可能 $[1,j]$ 全部数都使用过），也就是还有 $2j-(m+j)=j-m$ 个数可以选。</p>
<p>因此有：$f_{i,j}=f_{i+1,j}\times (j-m)$。</p>
<ul>
<li>若这一位最后不为 $0$：</li>
</ul>
<p>如果这一位最终不为 $j+1$，则只能以后再考虑。</p>
<p>如果这一位最终的 $b_i$ 为 $j+1$，那么再枚举这个 $j$ 转移到的 $j+k$，也就是当 $j+1$ 已经使用过后，$[1,j+k]$ 都将被使用过。下面考虑这个系数是什么。</p>
<p>设 $m$ 为 $[i+1,2n]$ 中，$b$ 不为 $0$ 的数的个数。</p>
<p>此时需要把 “如果这一位最终不为 $j+1$，则只能以后再考虑。”​的情况考虑进去。也就是需要搞出后面的数是如何让 $[j+1,j+k]$ 都使用过的方案数。那么 $[i+1,2n]$ 最终的 $b_i$ 中，$[j+2,j+k]$ 的数都只能且必须出现 $1$ 次，也就是 $\binom{m-j}{k-1}$。</p>
<p>然后考虑 $a_i$ 能选的方案数，显然是 $2+((j+k)-(j+2)+1)=k+1$ 中情况。</p>
<p>然后还剩下一个 $s_{k-1}$，其中 $s_{m}$ 表示在 $[1,m]$ ，每个数能选两次，一共选 $m$ 个，最终的 $b_i$ 在 $[1,m]$ 均出现的方案数。</p>
<p>这个 $s_{m}$ 显然也可以DP解决。设 $g_{i,j}$ 表示考虑到第 $i$ 个数，最终的 $b_i$ 在 $[1,j]$ 均出现的方案数。</p>
<p>那么考虑第 $i$ 个数选了多少个，有： $g_{i,j}=g_{i-1,j}+g_{i-1,j-1}\times 2j+g_{i-1,j-2}\times j(j-1)$。</p>
<p>则有：$s_m=g_{m,m}$。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1205</span>;</span><br><span class="line"><span class="type">int</span> n,p[N],cnt[N];</span><br><span class="line">ll fac[N],inv[N],g[N][N],f[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>); <span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%mod*inv[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc_g</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,i)</span><br><span class="line">	&#123;</span><br><span class="line">		g[i][j]=g[i<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">if</span>(j&gt;<span class="number">0</span>) g[i][j]=<span class="built_in">Add</span>(g[i][j],<span class="built_in">Mul</span>(g[i<span class="number">-1</span>][j<span class="number">-1</span>],<span class="number">2</span>*j));</span><br><span class="line">		<span class="keyword">if</span>(j&gt;<span class="number">1</span>) g[i][j]=<span class="built_in">Add</span>(g[i][j],<span class="built_in">Mul</span>(g[i<span class="number">-1</span>][j<span class="number">-2</span>],j*(j<span class="number">-1</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc_f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">2</span>*n+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">2</span>*n,<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(!p[i])</span><br><span class="line">		&#123;</span><br><span class="line">			m=<span class="number">2</span>*n-i-cnt[i+<span class="number">1</span>];</span><br><span class="line">			<span class="built_in">fo</span>(j,m,n) f[i][j]=<span class="built_in">Mul</span>(f[i+<span class="number">1</span>][j],j-m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,n) f[i][j]=f[i+<span class="number">1</span>][j];</span><br><span class="line">			m=cnt[i+<span class="number">1</span>];</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,m)</span><br><span class="line">				<span class="keyword">if</span>(f[i+<span class="number">1</span>][j])</span><br><span class="line">					<span class="built_in">fo</span>(k,<span class="number">1</span>,n-j)</span><br><span class="line">						f[i][j+k]=<span class="built_in">Add</span>(f[i][j+k],<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(f[i+<span class="number">1</span>][j],<span class="built_in">C</span>(m-j,k<span class="number">-1</span>)),<span class="built_in">Mul</span>(k+<span class="number">1</span>,g[k<span class="number">-1</span>][k<span class="number">-1</span>])));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[<span class="built_in">read</span>()]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">2</span>*n,<span class="number">0</span>) cnt[i]=cnt[i+<span class="number">1</span>]+p[i];</span><br><span class="line">	<span class="built_in">init</span>(<span class="number">2</span>*n); <span class="built_in">calc_g</span>(n); <span class="built_in">calc_f</span>(n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">Mul</span>(f[<span class="number">1</span>][n],<span class="built_in">Pow</span>((mod+<span class="number">1</span>)/<span class="number">2</span>,n)));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>治疗计划[JOISC 2020 Day4]</title>
    <url>/2020/03/27/%E6%B2%BB%E7%96%97%E8%AE%A1%E5%88%92-JOISC-2020-Day4/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3282">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看起来似乎无从下手，那么就考虑一个类似DP的东东吧。</p>
<p>设 $d_i$ 表示 $[1,r_i]$ 中所有人都没有被感染的最小花费。</p>
<p>那么 $d_i$ 能对 $d_j$ 产生贡献当且仅当 $r_i-l_j+1\geq |T_i-T_j|$。</p>
<p>满足条件的 $i,j$ 连一条边，剩下的是一个形如最短路的形式。</p>
<p>因此如果可以优化这个建图，问题就不大了。</p>
<p>绝对值比较恶心，那么先按 $T_i$  从小到大排好序。</p>
<p>然后枚举 $i$，根据限制在线段树上套个set优化连边就好了。</p>
<p>时间复杂度 $O(n\log^2n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>为什么我比别人慢这么多QwQ</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">4e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line">	<span class="type">int</span> t,l,r,v;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> query &amp;A,<span class="type">const</span> query &amp;B) &#123;<span class="keyword">return</span> A.t&lt;B.t;&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u; ll dis;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B) &#123;<span class="keyword">return</span> A.dis&gt;B.dis;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">ll dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tnode</span>&#123;</span><br><span class="line">	<span class="type">int</span> i,val;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Tnode &amp;A,<span class="type">const</span> Tnode &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.val!=B.val) <span class="keyword">return</span> A.val&lt;B.val;</span><br><span class="line">		<span class="keyword">return</span> A.i&lt;B.i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SGT</span>&#123;</span><br><span class="line">	set&lt;Tnode&gt; s[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[u].<span class="built_in">insert</span>((Tnode)&#123;p,v&#125;);</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		p&lt;=mid?<span class="built_in">add</span>(ls,p,v):<span class="built_in">add</span>(rs,p,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> v,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> w;s[u].<span class="built_in">size</span>()&amp;&amp;(*s[u].<span class="built_in">begin</span>()).val&lt;=v;s[u].<span class="built_in">erase</span>(s[u].<span class="built_in">begin</span>()))</span><br><span class="line">			&#123;</span><br><span class="line">				w=s[u].<span class="built_in">begin</span>()-&gt;i;</span><br><span class="line">				<span class="keyword">if</span>(dis[w]&gt;dis[i]+p[w].v)</span><br><span class="line">				&#123;</span><br><span class="line">					dis[w]=dis[i]+p[w].v;</span><br><span class="line">					q.<span class="built_in">push</span>((node)&#123;w,dis[w]&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">ask</span>(ls,L,R,v,i);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">ask</span>(rs,L,R,v,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">SGT t[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(p[i].l==<span class="number">1</span>) q.<span class="built_in">push</span>((node)&#123;i,p[i].v&#125;),dis[i]=p[i].v; </span><br><span class="line">		<span class="keyword">else</span> dis[i]=inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">top</span>().u; q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u]=<span class="number">1</span>;</span><br><span class="line">		t[<span class="number">0</span>].<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,u<span class="number">-1</span>,p[u].r-p[u].t+<span class="number">1</span>,u);</span><br><span class="line">		t[<span class="number">1</span>].<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,u+<span class="number">1</span>,n,p[u].r+p[u].t+<span class="number">1</span>,u);</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=inf;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(p[i].r==m) ans=<span class="built_in">min</span>(ans,dis[i]);</span><br><span class="line">	<span class="keyword">if</span>(ans==inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="built_in">read</span>(); n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i].t=<span class="built_in">read</span>(),p[i].l=<span class="built_in">read</span>(),p[i].r=<span class="built_in">read</span>(),p[i].v=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		t[<span class="number">0</span>].<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,p[i].l-p[i].t),</span><br><span class="line">		t[<span class="number">1</span>].<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,i,p[i].l+p[i].t);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,<span class="built_in">dijkstra</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>线段树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>变色龙之恋[JOISC 2020 Day2]</title>
    <url>/2020/03/26/%E5%8F%98%E8%89%B2%E9%BE%99%E4%B9%8B%E6%81%8B-JOISC-2020-Day2/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3274">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>刚开始觉得似乎无从下手。</p>
<p>那就从最简单的开始搞吧。假设我现在只询问两只变色龙。</p>
<p>那么这个询问的答案只能是 $1$ 或者 $2$。</p>
<p>当且仅当 $x,y$ 颜色相同，或只有某个喜欢另一个时答案为 $1$。也就是说， 若 $x$ 和其他点都询问一次，答案为 $1$ 则向这个点连一条边，则 $x$ 只会连出去 $1$ 或 $3$ 条边。</p>
<p>当只连出去 $1$ 条边的时候，这条边所对应的点就是原色相同的点啦。</p>
<p>当连出去 $3$ 条边的时候，假设是 $y_1,y_2,y_3$。我们询问 $(x,y_i,y_j)$，那么 $y_i$ 当且仅当喜欢 $x$，$y_j$ 和 $x$ 同颜色的时候答案为 $1$。然后我们可以把这两条边都标记一次。对于每个点都这样做，最后被标记 $2$ 次的边所连接的两个点就是同色的了。</p>
<p>现在得到了一个询问次数 $O(n^2)$ 的做法。</p>
<p>考虑这个算法的瓶颈在于第一部分，即查询每个点 $x$ 与其相连的所有 $y$。</p>
<p>考虑优化这一部分。</p>
<p>这个图是一个二分图，试试用一下这个性质？</p>
<p>假设你已经知道了所有点属于二分图的哪个集合。</p>
<p>考虑对于一个独立集 $A$ 询问的结果，这个答案一定等于 $|A|$。否则这个答案一定不为 $|A|$。</p>
<p>那也就是说明对于一个点 $x$，和一个独立集，可以判断点 $x$ 是否和独立集有边相连了。</p>
<p>那么可以二分处理即可。</p>
<p>但是我们不知道所有点属于二分图的哪个集合哇？也就是说不能直接来，因为不满足询问的点是独立集这个条件。</p>
<p>那么边做边黑白染色就好了。</p>
<p>询问次数 $O(n\log n)$，常数有点小大。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;chameleon.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans[N][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; Q,w[<span class="number">2</span>],v[N];</span><br><span class="line"><span class="type">int</span> now,t;</span><br><span class="line"><span class="type">int</span> fa[N]; <span class="type">bool</span> c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">col</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?<span class="number">0</span>:c[x]^<span class="built_in">col</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==fa[x]?x:<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	c[<span class="built_in">find</span>(x)]=<span class="number">1</span>^<span class="built_in">col</span>(x)^<span class="built_in">col</span>(y);</span><br><span class="line">	fa[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">bool</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[now].<span class="built_in">size</span>()&gt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!opt)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.<span class="built_in">clear</span>(),Q.<span class="built_in">pb</span>(now); <span class="built_in">fo</span>(k,l,r) Q.<span class="built_in">pb</span>(w[t][k]);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">Query</span>(Q)&gt;r-l+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		v[now].<span class="built_in">pb</span>(w[t][l]);</span><br><span class="line">		v[w[t][l]].<span class="built_in">pb</span>(now);</span><br><span class="line">		<span class="built_in">merge</span>(now,w[t][l]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">rand</span>()&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">dfs</span>(l,mid,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,!opt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(l,mid,!opt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="number">2</span>*n;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) fa[i]=i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">20030227</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) id[i]=i;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">swap</span>(id[i],id[<span class="built_in">rand</span>()%m+<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//fo(i,1,m) cerr&lt;&lt;id[i]&lt;&lt;endl;</span></span><br><span class="line">	<span class="built_in">fo</span>(tim,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i=id[tim];</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>) w[k].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,tim<span class="number">-1</span>) w[<span class="built_in">col</span>(id[j])].<span class="built_in">pb</span>(id[j]);</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">1</span>) t=k,now=i,<span class="built_in">dfs</span>(<span class="number">0</span>,w[k].<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(v[i].<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">			ans[i][v[i][<span class="number">0</span>]]=ans[v[i][<span class="number">0</span>]][i]=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">fo</span>(k,j+<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line">					Q.<span class="built_in">clear</span>(),Q.<span class="built_in">pb</span>(i),Q.<span class="built_in">pb</span>(v[i][j]),Q.<span class="built_in">pb</span>(v[i][k]);</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">Query</span>(Q)==<span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						ans[i][v[i][j]]++,ans[v[i][j]][i]++,</span><br><span class="line">						ans[i][v[i][k]]++,ans[v[i][k]][i]++;</span><br><span class="line">						flag=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">fo</span>(j,i+<span class="number">1</span>,m) <span class="keyword">if</span>(ans[i][j]&gt;=<span class="number">2</span>) <span class="built_in">Answer</span>(i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>交互题</tag>
      </tags>
  </entry>
  <entry>
    <title>首都城市[JOISC 2020 Day4]</title>
    <url>/2020/03/25/%E9%A6%96%E9%83%BD%E5%9F%8E%E5%B8%82-JOISC-2020-Day4/</url>
    <content><![CDATA[<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一棵 $n$ 个节点的树，点有 $k$ 种颜色。</p>
<p>现在要求选出最小的颜色集合，使得在颜色集合中的点形成一个连通块。输出该集合的大小。</p>
<p>$n,k\leq 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="做法1"><a href="#做法1" class="headerlink" title="做法1"></a>做法1</h4><p>一个显然的 $O(k^2)$ 做法是将颜色当成点，如果选了某个颜色 $i$ 之后必须选颜色 $j$，则 $i$ 向 $j$ 连一条有向边。</p>
<p>然后跑Tarjan缩点，答案就是缩点后的图中出度为 $0$ 的点的 $size-1$ 的最小值。</p>
<p>对于每种颜色，我们发现，它要连出去的颜色显然是对该颜色的点建虚树后，在虚树中的节点颜色。</p>
<p>然后就可以用树上倍增来优化一下建图。发现你这样建图还是会满足和原图的强联通分量的形状是相同的。这样建完之后再一样的跑Tarjan即可。</p>
<h4 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h4><p>一个点分治神仙做法，并不太会。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><h4 id="做法1-1"><a href="#做法1-1" class="headerlink" title="做法1"></a>做法1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000010</span>;</span><br><span class="line"><span class="type">int</span> n,k,cnt,col[N];</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> ver[M],ne[M],tot,head[M];</span><br><span class="line">	<span class="type">int</span> dfn[M],low[M],tim,sum[M];</span><br><span class="line">	<span class="type">int</span> st[M],top,bel[M],scc_cnt;</span><br><span class="line">	<span class="type">bool</span> in[M],bo[M];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dfn[u]=low[u]=++tim;</span><br><span class="line">		in[u]=<span class="number">1</span>; st[++top]=u;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			v=ver[i];</span><br><span class="line">			<span class="keyword">if</span>(!dfn[v])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">				low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(in[v]) low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(low[u]==dfn[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v;</span><br><span class="line">			++scc_cnt;</span><br><span class="line">			<span class="keyword">do</span></span><br><span class="line">			&#123;</span><br><span class="line">				v=st[top--]; in[v]=<span class="number">0</span>;</span><br><span class="line">				bel[v]=scc_cnt;</span><br><span class="line">			&#125;<span class="keyword">while</span>(v!=u);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(u,<span class="number">1</span>,cnt)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(bel[u]!=bel[ver[i]])</span><br><span class="line">					bo[bel[u]]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k) sum[bel[i]]++;</span><br><span class="line">		<span class="type">int</span> ans=k;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,scc_cnt) <span class="keyword">if</span>(!bo[i]) ans=<span class="built_in">min</span>(ans,sum[i]<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">tarjan</span>();</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> tim,dfn[N],dep[N];</span><br><span class="line">	<span class="type">int</span> f[N][<span class="number">19</span>],id[N][<span class="number">19</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dep[u]=dep[pre]+<span class="number">1</span>; dfn[u]=++tim;</span><br><span class="line">		f[u][<span class="number">0</span>]=pre;</span><br><span class="line">		id[u][<span class="number">0</span>]=++cnt;</span><br><span class="line">		Graph::<span class="built_in">add</span>(id[u][<span class="number">0</span>],col[u]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;f[u][i]=f[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];i++)</span><br><span class="line">		&#123;</span><br><span class="line">			id[u][i]=++cnt;</span><br><span class="line">			Graph::<span class="built_in">add</span>(id[u][i],id[u][i<span class="number">-1</span>]);</span><br><span class="line">			Graph::<span class="built_in">add</span>(id[u][i],id[f[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre) <span class="built_in">dfs</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(dep[f[y][i]]&gt;=dep[x]) y=f[y][i];</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">		<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Gadd</span><span class="params">(<span class="type">int</span> col,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> z=<span class="built_in">lca</span>(x,y);</span><br><span class="line">		Graph::<span class="built_in">add</span>(col,id[z][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">fd</span>(i,<span class="number">18</span>,<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(f[x][i]&amp;&amp;dep[f[x][i]]&gt;=dep[z])</span><br><span class="line">			&#123;</span><br><span class="line">				Graph::<span class="built_in">add</span>(col,id[x][i]);</span><br><span class="line">				x=f[x][i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(f[y][i]&amp;&amp;dep[f[y][i]]&gt;dep[z])</span><br><span class="line">			&#123;</span><br><span class="line">				Graph::<span class="built_in">add</span>(col,id[y][i]);</span><br><span class="line">				<span class="comment">//DEBUG(i);</span></span><br><span class="line">				y=f[y][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">all</span>(v[i]),[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">			<span class="comment">//DEBUG(v[i].size());</span></span><br><span class="line">			<span class="keyword">if</span>(!v[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">			v[i].<span class="built_in">pb</span>(v[i][<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,v[i].<span class="built_in">size</span>()<span class="number">-2</span>) <span class="built_in">Gadd</span>(i,v[i][j],v[i][j+<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); cnt=k;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) Tree::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) Tree::v[col[i]=<span class="built_in">read</span>()].<span class="built_in">pb</span>(i);</span><br><span class="line">	Tree::<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	Tree::<span class="built_in">solve</span>();</span><br><span class="line">	Graph::<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>点分治</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 84[CF1327]</title>
    <url>/2020/03/24/Educational-Codeforces-Round-84-CF1327/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>小学数学题。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>并不会证明？</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>移到角落然后一起移上去就可以了。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>每个段分开来考虑就好了。</p>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>小数数学题。</p>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>考虑每一位的贡献，最后乘起来就好了。</p>
<p>现在题目变成 $m$ 个限制，每个限制形如 $[l,r]$ 不全为 $1$ 或者必须全为 $1$。</p>
<p>那么设 $f_i$ 表示考虑到第 $i$ 位，且该位选 $0$ 的方案数。若该位必须选 $1$，则 $f_i=0$。</p>
<p>然后two-pointer维护合法区间即可。</p>
<p>时间复杂度 $O(k(n+m))$。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><p>为什么会有这么sb的题。。。</p>
<p>AC自动机上状压DP即可。太智障了，懒得写了。</p>
]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>星座3[JOISC 2020 Day3]</title>
    <url>/2020/03/23/%E6%98%9F%E5%BA%A73-JOISC-2020-Day3/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3277">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个 $n\times n$ 的坐标系，每个横坐标上从小往上有一些高楼，高度为 $a_i$。有 $m$ 个星星，给出坐标及价值。现在删掉一些星星使得不存在一个平行于坐标轴的长方形，满足该长方形内有两个以上的星星，且没有高楼出现。求出最少的价值和。</p>
<p>$n,m\leq 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>补集转换，变成求出最大的价值和，使得不存在一个长方形。</p>
<p>考虑最高的那个高楼的 $a_i$，然后你会发现如果存在星星的纵坐标高于 $a_i$，那么最多只能有一个。</p>
<p>否则就会分成左右两边互不干扰的两部分。</p>
<p>这样就可以建出笛卡尔树，然后就可以在上面进行DP了。</p>
<p>设 $f_{u,i}$ 表示节点 $u$ 的子树内，保留第 $i$ 个星星的最大值。$g_u$ 表示节点 $u$ 的子树中，不保留纵坐标大于 $a_u$ 的最大值。</p>
<p>然后 $f_{u}$ 用线段树合并即可转移。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">5e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="type">int</span> ls[K],rs[K],rt[N],cnt;</span><br><span class="line">	ll t[K];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,ll d)</span></span>&#123;<span class="keyword">if</span>(u) t[u]+=d;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u||!t[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushtag</span>(ls[u],t[u]);</span><br><span class="line">		<span class="built_in">pushtag</span>(rs[u],t[u]);</span><br><span class="line">		t[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> t[u];</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">return</span> p&lt;=mid?<span class="built_in">ask</span>(ls[u],l,mid,p):<span class="built_in">ask</span>(rs[u],mid+<span class="number">1</span>,r,p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="built_in">pushdown</span>(x); <span class="built_in">pushdown</span>(y);</span><br><span class="line">		ls[x]=<span class="built_in">merge</span>(ls[x],ls[y]);</span><br><span class="line">		rs[x]=<span class="built_in">merge</span>(rs[x],rs[y]);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,ll d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) u=++cnt;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(t[u]=<span class="built_in">max</span>(t[u],d));</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		p&lt;=mid?<span class="built_in">add</span>(ls[u],l,mid,p,d):<span class="built_in">add</span>(rs[u],mid+<span class="number">1</span>,r,p,d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SGT;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> f[N][M],fa[N][M],a[N],ne[N][<span class="number">2</span>],Lg[N];</span><br><span class="line">ll g[N];</span><br><span class="line">vector&lt;pii&gt; s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> a[x]&gt;a[y]?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k=Lg[r-l+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">cmp</span>(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> u=<span class="built_in">getmax</span>(l,r);</span><br><span class="line">	ne[u][<span class="number">0</span>]=<span class="built_in">build</span>(l,u<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ne[u][<span class="number">0</span>]) fa[ne[u][<span class="number">0</span>]][<span class="number">0</span>]=u;</span><br><span class="line">	ne[u][<span class="number">1</span>]=<span class="built_in">build</span>(u+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">if</span>(ne[u][<span class="number">1</span>]) fa[ne[u][<span class="number">1</span>]][<span class="number">0</span>]=u;</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getf</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">getf</span>(ne[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">dfs</span>(ne[u][i]);</span><br><span class="line">	g[u]=g[ne[u][<span class="number">0</span>]]+g[ne[u][<span class="number">1</span>]];</span><br><span class="line">	<span class="built_in">pushtag</span>(rt[ne[u][<span class="number">0</span>]],g[ne[u][<span class="number">1</span>]]);</span><br><span class="line">	<span class="built_in">pushtag</span>(rt[ne[u][<span class="number">1</span>]],g[ne[u][<span class="number">0</span>]]);</span><br><span class="line">	rt[u]=<span class="built_in">merge</span>(rt[ne[u][<span class="number">0</span>]],rt[ne[u][<span class="number">1</span>]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:s[u]) <span class="built_in">add</span>(rt[u],<span class="number">1</span>,q,v.fi,g[u]+v.se);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:p[u]) g[u]=<span class="built_in">max</span>(g[u],<span class="built_in">ask</span>(rt[u],<span class="number">1</span>,q,v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) Lg[i]=Lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	m=Lg[n];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),f[i][<span class="number">0</span>]=i;</span><br><span class="line">	<span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>)</span><br><span class="line">			f[i][j]=<span class="built_in">cmp</span>(f[i][j<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> rt=<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">getf</span>(rt);</span><br><span class="line">	<span class="type">int</span> z,x,y,v;</span><br><span class="line">	q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		z=x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),v=<span class="built_in">read</span>();</span><br><span class="line">		s[x].<span class="built_in">pb</span>(<span class="built_in">mp</span>(i,v));</span><br><span class="line">		<span class="built_in">fd</span>(j,m,<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">if</span>(fa[z][j]&amp;&amp;y&gt;a[fa[z][j]])</span><br><span class="line">				z=fa[z][j];</span><br><span class="line">		p[z].<span class="built_in">pb</span>(i);</span><br><span class="line">		ans+=v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(rt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans-g[rt]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>倍增</tag>
        <tag>启发式合并</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforce Global Round 7[CF1326]</title>
    <url>/2020/03/23/Codeforce-Global-Round-7-CF1326/</url>
    <content><![CDATA[<p>Codeforce Global Round 7总结。</p>
<span id="more"></span>

<h3 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h3><p>23333…</p>
<h3 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h3><p>直接递推即可。</p>
<h3 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个长度为 $n$ 的排列 $a_n$。要求将这个序列分成互不相交的 $k$ 段。记第 $p$ 段的左端点和右端点分别为 $l_p,r_p$。要求最大化 $\sum_{i=1}^k\max_{j=l_i}^{r_i}\{a_j\}$。</p>
<p>输出<strong>最大化的值</strong>和<strong>可以最大化该值的方案数</strong>。方案数对 $998244353$ 取模。</p>
<p>$n\leq 2\times 10^5$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>最大化的值显然是 $\sum_{i=n-k+1}^ni$。</p>
<p>也就是说，每一段中肯定包含且仅包含一个这 $k$ 个点中的其中一个。</p>
<p>然后乘法原理。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>在一个字符串中，选一个前缀和后缀，满足其拼接起来是回文串，输出一个长度不超过 $n$ 的最长的回文串。</p>
<p>$|S|\leq 10^5$。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>枚举前后缀当中的最小值，满足前缀的反串等于后缀。这时候变成查询以某个串结尾的最长的不超过某个值的回文串长度。PAM上倍增跳fail链即可。</p>
<h3 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h3><h3 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h3><a href="/2020/03/23/Wise-Men-CF1326F/" title="链接">链接</a>]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Wise Men[CF1326F]</title>
    <url>/2020/03/23/Wise-Men-CF1326F/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.ml/contest/1326/problem/F1">F1</a></p>
<p><a href="https://codeforces.ml/contest/1326/problem/F2">F2</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个人，告诉你这 $n$ 个人互相之间是否认识，然后将这 $n$ 个人排成一列，记为 $p_i$，设 $b_i=[p_{i}\ know \ p_{i+1}]$，对于 $b$ 的 $2^{n-1}$ 种情况，求有多少个排列对应这种情况。</p>
<p>$n\leq 2^{18}$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这毒瘤数数题谁想得到啊。。</p>
<p>不过这种一般都能想到是容斥。难道真的是要比谁想象力丰富吗qwq</p>
<p>那就容斥吧。设 $f_s$ 表示当 $s$ 的第 $i$ 位为 $1$ 时，$i$ 和 $i+1$ 必须认识，当 $s$ 的第 $i$ 位为 $0$ 时，$i$ 和 $i+1$ 不必须认识。</p>
<p>那么最终的答案就是这个 $f$ 的超集和反演/高维差分。</p>
<p>这样子容斥的好处是，每一段 $1$ 之间的计算就不会受影响了。因为 $0$ 的条件变成了可以随便选。因此我们考虑每一个连续的段分开计算，最后再合并在一起。</p>
<p>而连续的 $k$ 个 $1$ 代表的是 $k+1$ 个点，这些点相邻之间认识，所形成的一条链。</p>
<p>而这些连续段代表的节点个数加起来是 $n$。这显然是一个整数划分的形式，当 $n=18$ 时为 $P_{18}=385$。</p>
<p>也就是说我们实际上只需要考虑 $385$ 种情况即可。</p>
<p>设 $g_s$ 表示对于集合 $s$ 中的点，有多少种排列使得相邻之间认识，这个可以用状压DP算出。</p>
<p>那么对于整数划分 $\sum_{i=1}^kx_i=n$ 而言，答案为 $\sum <em>{|S_i|=x_i}[|\bigcup S_i|=n]\prod</em>{i=1}^k g_{S_i}$。</p>
<p>这就很像WC2018的州区划分了。</p>
<p>设新的 $g_{i,s}=g_s\times [|s|=i]$，去掉其中一个限制。那么答案就是若干个 $g_{x_i}$ 做或卷积后对应位置相乘，然后再逆变换回来后的第 $2^n-1$ 位。</p>
<p>显然 $g_i$ 可以预先FWT好。</p>
<p>可以发现，最后的IFWT只需要求的是其中一位。用子集反演稍微理解一下/死记硬背/找规律可以发现：</p>
<p>$IFWT_A[n]=\sum A_i\times (-1)^{|n\ xor\ i|}$</p>
<p>那么对于一个整数划分 $\sum_{i=1}^kx_i=n$，就可以在 $O((k+1)2^n)$ 的时间内求出答案。</p>
<p>状压DP和预处理 $FWT_{g_i}$ 的时间都是 $O(n^22^n)$ 的。</p>
<p>设 $n$ 的整数划分的个数总和为 $S_n$，则时间复杂度为 $O((S_n+n^2)2^n)$。</p>
<p>当 $n=18$ 时打表可得 $S_{18}=1596$。CF时限4s，不慌不慌。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=(<span class="number">1</span>&lt;&lt;<span class="number">19</span>)+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,cnt,cnt2;</span><br><span class="line"><span class="type">bool</span> bo[N][N];</span><br><span class="line">ll dp[M][N]; <span class="type">int</span> num[M];</span><br><span class="line">ll f[N][M],g[N][M],ans[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fwt</span><span class="params">(ll *a,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				a[i+j+k]+=a[j+k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt<span class="number">-1</span>) num[i]=num[i-<span class="built_in">lowbit</span>(i)]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) dp[<span class="number">1</span>&lt;&lt;i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i)</span><br><span class="line">				<span class="built_in">fo</span>(k,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">					<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;k)&amp;i)</span><br><span class="line">						<span class="keyword">if</span>(k!=j&amp;&amp;bo[k][j])</span><br><span class="line">							dp[i][j]+=dp[i^(<span class="number">1</span>&lt;&lt;j)][k];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;i) g[num[i]][i]+=dp[i][j];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fwt</span>(g[i],cnt+<span class="number">1</span>);</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="built_in">fwt</span>(f[<span class="number">0</span>],cnt+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[N],a[N],tot;</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;tot)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> s=<span class="number">0</span>,now=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,tot)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,b[i]<span class="number">-2</span>) s|=(<span class="number">1</span>&lt;&lt;now),now++;</span><br><span class="line">			now++;</span><br><span class="line">		&#125;</span><br><span class="line">		v.<span class="built_in">pb</span>(s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,tot)</span><br><span class="line">		<span class="keyword">if</span>(!used[i])</span><br><span class="line">			<span class="keyword">if</span>(!(i&amp;&amp;a[i]==a[i<span class="number">-1</span>]&amp;&amp;!used[i<span class="number">-1</span>]))</span><br><span class="line">			&#123;</span><br><span class="line">				used[i]=<span class="number">1</span>;</span><br><span class="line">				b[k]=a[i];</span><br><span class="line">				<span class="built_in">find</span>(k+<span class="number">1</span>);</span><br><span class="line">				b[k]=<span class="number">0</span>;</span><br><span class="line">				used[i]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot=m;</span><br><span class="line">	v.<span class="built_in">clear</span>(); <span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>) sum+=f[m][i]*(((n-num[i])&amp;<span class="number">1</span>)?(<span class="number">-1</span>):<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:v) ans[u]=sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> res,<span class="type">int</span> top,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!res)<span class="keyword">return</span> <span class="built_in">solve</span>(top<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,m,res)</span><br><span class="line">	&#123;</span><br><span class="line">		Sum++;</span><br><span class="line">		a[top]=i;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,cnt<span class="number">-1</span>) f[top][j]=f[top<span class="number">-1</span>][j]*g[i][j];</span><br><span class="line">		<span class="built_in">dfs</span>(res-i,top+<span class="number">1</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	a[top]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n); cnt=(<span class="number">1</span>&lt;&lt;n); cnt2=<span class="number">1</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line">	<span class="type">char</span> ss[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//scanf(&quot;%s&quot;,ss);</span></span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,n<span class="number">-1</span>) bo[i][j]=ss[j]==<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(n,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">DEBUG</span>(Sum);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-2</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,cnt2<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(!(j&gt;&gt;i&amp;<span class="number">1</span>))</span><br><span class="line">				ans[j]-=ans[j^(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt2<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>状压DP</tag>
        <tag>FWT</tag>
        <tag>高维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的 Joitter 交友[JOISC 2020 Day2]</title>
    <url>/2020/03/22/%E6%9C%89%E8%B6%A3%E7%9A%84-Joitter-%E4%BA%A4%E5%8F%8B-JOISC-2020-Day2/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3275">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 个点的有向图，$m$ 次加边。对于每次加边后，求图经过尽可能多的转换后，图的边数。</p>
<p>一次转换为：选择三个不同的点 $x,y,z$，使得 $(x,y),(y,z),(z,y)$ 在当前的图中存在，那么在当前的图中，如果没有 $(x,z)$ 这一条边，则新加一条。</p>
<p>$n\leq 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>JOI的题好毒瘤啊。。。不过看起来也不是很难？</p>
<p>考虑一个连通块，在这里两个点相连当且仅当他们之间两个方向的路径都存在。那么这个连通块中的点在转换后都会互相连了。因此一个块中，块内的点的贡献就是 $Size\times (Size-1)$。</p>
<p>可以发现，如果两个块之间存在方向不同的两条边，那么就会合成一个块。</p>
<p>因此下面只需要考虑只单条路径的贡献，以及如何合并两个连通块。</p>
<p>思考一下发现，如果存在一条 $(x,y)$ 的路径，那么贡献就是 $Size_y$。有很多条连向 $y$ 的路径，$Size_y$ 就会被算多次。设集合 $v_y$ 表示有多少个点跟连通块 $y$ 中的点相连，那么贡献就是 $Size_y\times |v_y|$。</p>
<p>下面考虑合并两个连通块，假设这两个连通块是 $x,y$，且 $y$ 合并到 $x$ 中。</p>
<p>可以发现，合并之后：</p>
<p>1，$x,y$ 之间的边不能留，先删掉再说。</p>
<p>2，连接 $y$ 的点，会变成连 $x$，这时需要枚举连接 $y$ 的点。</p>
<p>3，连接 $y$ 的连通块，会变成连 $x$，这时需要枚举连接 $y$ 的连通块。</p>
<p>4，若存在另一个连通块 $u$，使得 $(u,x),(y,u)$ 或者 $(u,y),(x,u)$ 之间有连边，那么合并以后，$x+y$ 的连通块就会和 $u$ 之间有两个方向的边，而这样这两个连通块也会合并。因此还需记多一个 $y$ 连出去的连通块集合，然后递归处理。</p>
<p>综上，对于每个连通块 $x$，我们需要记录：$x$ 内的集合，连向 $x$ 的点的集合，连向 $x$ 的连通块集合，被 $x$ 连向的连通块集合。</p>
<p>合并的话启发式合并即可。</p>
<p>集合不需要比较大小，因此可用哈希表，直接上 unordered_set 就好了。</p>
<p>时间复杂度 $O(n\log n)$，假设 $n,m$ 同阶。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> fa[N],siz[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; v[N],g[N],t[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*siz[x]*(siz[x]<span class="number">-1</span>+v[x].<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans-=<span class="built_in">calc</span>(x)+<span class="built_in">calc</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(siz[x]+v[x].<span class="built_in">size</span>()&lt;siz[y]+v[y].<span class="built_in">size</span>()) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:t[y]) <span class="keyword">if</span>(t[u].<span class="built_in">count</span>(x)) q.<span class="built_in">pb</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:g[y]) <span class="keyword">if</span>(g[u].<span class="built_in">count</span>(x)) q.<span class="built_in">pb</span>(u);</span><br><span class="line"></span><br><span class="line">	g[x].<span class="built_in">erase</span>(y); g[y].<span class="built_in">erase</span>(x);</span><br><span class="line">	t[x].<span class="built_in">erase</span>(y); t[y].<span class="built_in">erase</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:t[y]) t[x].<span class="built_in">insert</span>(u),g[u].<span class="built_in">erase</span>(y),g[u].<span class="built_in">insert</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:g[y]) g[x].<span class="built_in">insert</span>(u),t[u].<span class="built_in">erase</span>(y),t[u].<span class="built_in">insert</span>(x);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:v[y]) <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=x) v[x].<span class="built_in">insert</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:s[y]) <span class="keyword">if</span>(v[x].<span class="built_in">count</span>(u)) v[x].<span class="built_in">erase</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:s[y]) s[x].<span class="built_in">insert</span>(u);</span><br><span class="line"></span><br><span class="line">	siz[x]+=siz[y];</span><br><span class="line">	fa[y]=x;</span><br><span class="line">	ans+=<span class="built_in">calc</span>(x);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:q) <span class="keyword">if</span>(<span class="built_in">find</span>(u)!=<span class="built_in">find</span>(x)) <span class="built_in">merge</span>(<span class="built_in">find</span>(u),<span class="built_in">find</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(fx==fy) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(!v[fy].<span class="built_in">count</span>(x)) v[fy].<span class="built_in">insert</span>(x),ans+=siz[fy];<span class="comment">//v</span></span><br><span class="line">	<span class="keyword">if</span>(t[fx].<span class="built_in">count</span>(fy)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!t[fy].<span class="built_in">count</span>(fx)) t[fx].<span class="built_in">insert</span>(fy),g[fy].<span class="built_in">insert</span>(fx);<span class="comment">//t,g</span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">merge</span>(fx,fy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fa[i]=i,siz[i]=<span class="number">1</span>,s[i].<span class="built_in">insert</span>(i);</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">update</span>(x,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>哈希</tag>
        <tag>并查集</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>淳平的形态形成场[牛客挑战赛33F]</title>
    <url>/2020/03/20/%E6%B7%B3%E5%B9%B3%E7%9A%84%E5%BD%A2%E6%80%81%E5%BD%A2%E6%88%90%E5%9C%BA-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B33F/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/contest/1115/F">链接</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$n$ 个点带点权的简单无向图，定义这张图的权值：一个连通块的权值为这个连通块里的点的点权的最大值，而这张图的权值为这张图所有连通块的权值的最小值。</p>
<p>求对于图所有的连边情况的权值之和。 模 $998244353$。</p>
<p>$n\leq 5\times 10^5$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>好毒瘤啊。。。这种多项式题还是需要多做才行。 </p>
<p>为了方便，将权值排序。然后假设第 $i$ 个权值就是 $i$。设 $h_n=2^{\binom{n}{2}}$ 表示 $n$ 个点的无向图个数。</p>
<p>设 $g_i$ 表示图的权值为 $i$ 的时候的答案。然后你会发现这样非常不好算。</p>
<p>考虑改一下状态，设 $g_i$ 表示权值大于 $i$ 时的答案。</p>
<p>也就是说，没有一个连通块的权值小于等于 $i$。</p>
<p>那么再容斥一下，假设一个图中出现了 $k$ 个连通块，且它们的权值都小于等于 $i$。显然这张图的贡献是 $(-1)^k$。然后设 $f_i$ 表示 $\sum_{|V|=i}(-1)^{|V|_k}$，也就是统计节点个数为 $i$ 的，有 $k$ 个连通块，则贡献是 $(-1)^k$ 的情况。</p>
<p>那么 $g_i=\sum_{j=0}^i\binom{i}{j}f_jh_{n-j}$</p>
<p>转移一下得：$\frac{g_i}{i!}=\sum_{j=0}^{i}\frac{1}{(i-j)!}\frac{f_jh_{n-j}}{j!}$。</p>
<p>那么求出了 $f_i$ 之后，就只剩一个fft了。</p>
<p>这个 $f_i$ 跟无向连通图的求法似乎差不多呢。设 $t_n$ 为 $n$ 个点无向连通图的个数。</p>
<p>那么根据生成函数那套理论，会有 $\sum_{i=0}\frac{t^i}{i!}=h,\sum_{i=0}\frac{(-1)^it^i}{i!}=f$</p>
<p>也就是：$e^t=h,e^{-t}=f$，即：$h\times f=1$。</p>
<p>多项式求逆即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353ll</span>;</span><br><span class="line"><span class="type">const</span> ll G=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">int</span> R[N];</span><br><span class="line">ll A[N],B[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre_ntt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m,L;</span><br><span class="line">	<span class="keyword">for</span>(m=<span class="number">1</span>,L=<span class="number">0</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>) L++;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> len,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++) <span class="keyword">if</span>(i&gt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ll wn=<span class="built_in">Pow</span>(G,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">-1</span>) wn=<span class="built_in">Pow</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ll w=<span class="number">1</span>,x,y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++,w=w*wn%mod)</span><br><span class="line">                x=a[j+k],y=a[i+j+k]*w%mod,</span><br><span class="line">                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll invn=<span class="built_in">Pow</span>(len,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len;i++) a[i]=a[i]*invn%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Pmul</span><span class="params">(ll *c,ll *a,ll *b,<span class="type">int</span> na,<span class="type">int</span> nb,<span class="type">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">pre_ntt</span>(na+nb);</span><br><span class="line">	k=na+nb;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,na) A[i]=a[i]; <span class="built_in">fo</span>(i,na+<span class="number">1</span>,len) A[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,nb) B[i]=b[i]; <span class="built_in">fo</span>(i,nb+<span class="number">1</span>,len) B[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,k) c[i]=A[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len) A[i]=B[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pinv</span><span class="params">(ll *a,ll *b,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(b[<span class="number">0</span>]=<span class="built_in">Pow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">	<span class="built_in">Pinv</span>(a,b,(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> len=<span class="built_in">pre_ntt</span>(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) A[i]=a[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,((n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>) B[i]=b[i];</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) B[i]=(<span class="number">2ll</span>-A[i]*B[i]%mod+mod)%mod*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(B,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) b[i]=B[i];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len) A[i]=B[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll fac[N],inv[N],a[N],b[N],c[N],g[N],h[N],ans;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) a[i]=<span class="built_in">Pow</span>(<span class="number">2</span>,<span class="number">1ll</span>*i*(i<span class="number">-1</span>)/<span class="number">2</span>)*inv[i]%mod;</span><br><span class="line">	<span class="built_in">Pinv</span>(a,h,<span class="number">1</span>+n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) b[i]=h[i]*a[n-i]%mod*fac[n-i]%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) c[i]=inv[i];</span><br><span class="line">	<span class="built_in">Pmul</span>(g,b,c,n,n,m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) g[i]=g[i]*fac[i]%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(p[i],g[i<span class="number">-1</span>]-g[i]+mod));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Cow at Large[USACO 2018 January Platinum]</title>
    <url>/2020/03/18/Cow-at-Large-USACO-2018-January-Platinum/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2386">loj</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>假设先固定根节点。如果根节点是一个叶节点，显然答案为 $1$。因此下面考虑的是根节点的度数不为 $1$ 的情况。</p>
<p>显然根节点的最优策略为一直往某个叶子结点走。</p>
<p>假设某个叶节点上有农民，就说明，这条路径一定不能经过这个叶节点到根路径的中点。</p>
<p>那么就会有一个贪心的策略，每次选一个离根节点最近的叶子结点，然后在中点处做个标记，且这个中点的子树中所有的叶节点都不能选了。最后的答案就是标记点的个数。</p>
<p>这样我们就得到了一个 $O(n^2)$ 做法。</p>
<p>下面来看看那些到根的路径中有标记点的点满足什么性质。记 $f_i$ 表示离点 $i$ 最近的叶节点，那么当且仅当 $f_i\leq dep_i$ 时，点 $i$ 在某个标记点的子树中。</p>
<p>但是我们统计的是标记点的个数啊。考虑是否可以转换成跟标记点子树中的点有关的东西。</p>
<p>可以发现，这些标记点不会存在祖先关系。也就是说，一棵子树的贡献是 $1$。</p>
<p>但是怎么在不知道这个树是什么样的情况下，给节点定点权，使得所有点的权值加起来为 $1$ 呢？</p>
<p>考虑度数 $d_i$，当一棵树有 $x$ 个点的时候，$\sum d_i=2x-2$，这个树的根节点会多统计一条，也就是说，子树中是：$\sum d_i=2x-1$，即：$\sum(2-d_i)=1$。</p>
<p>这个做法也太清奇了。。。</p>
<p>那么现在就变成，每个点的点权 $a_i$ 为 $2-d_i$，对于每个节点 $x$，计算 $\sum_{f_y\leq dis_{x,y}}a_i$ 的和。</p>
<p>剩下的就很简单了。点分治，然后做个前缀和，对于每个子树点的贡献减去即可。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">70005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> d[N],ans[N],f[N];</span><br><span class="line"><span class="type">int</span> siz[N],mx[N],dep[N],rt;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	d[x]++; d[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; mx[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;!vis[ver[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">getroot</span>(v,u,s);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			mx[u]=<span class="built_in">max</span>(mx[u],siz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[u],s-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(mx[rt]&gt;mx[u]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[N],st[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;!vis[ver[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,top) sum[<span class="built_in">min</span>(<span class="built_in">max</span>(<span class="number">0</span>,f[st[i]]-dep[st[i]]),s+<span class="number">1</span>)]+=d[st[i]];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,s) sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,top) ans[st[i]]+=opt*sum[dep[st[i]]];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,s+<span class="number">1</span>) sum[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top=<span class="number">0</span>; dep[u]=<span class="number">0</span>; <span class="built_in">dfs</span>(u,<span class="number">0</span>); <span class="built_in">calc</span>(s,<span class="number">1</span>);</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v,Siz;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v=ver[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			Siz=siz[v]&gt;siz[u]?s-siz[u]:siz[v];</span><br><span class="line">			top=<span class="number">0</span>; dep[v]=<span class="number">1</span>; <span class="built_in">dfs</span>(v,u); <span class="built_in">calc</span>(Siz,<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v,Siz;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v=ver[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			Siz=siz[v]&gt;siz[u]?s-siz[u]:siz[v];</span><br><span class="line">			rt=<span class="number">0</span>; <span class="built_in">getroot</span>(v,<span class="number">0</span>,Siz); <span class="built_in">divide</span>(rt,Siz);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(d[i]==<span class="number">1</span>) q.<span class="built_in">push</span>(i),f[i]=<span class="number">0</span>,vis[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(!vis[v=ver[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				f[v]=f[u]+<span class="number">1</span>;</span><br><span class="line">				vis[v]=<span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); mx[<span class="number">0</span>]=inf;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[i]=<span class="number">2</span>-d[i];</span><br><span class="line">	rt=<span class="number">0</span>; <span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>,n); <span class="built_in">divide</span>(rt,n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(d[i]==<span class="number">1</span>) ans[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>USACO</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title>牛牛喜欢看小姐姐[牛客挑战赛37F]</title>
    <url>/2020/03/17/%E7%89%9B%E7%89%9B%E5%96%9C%E6%AC%A2%E7%9C%8B%E5%B0%8F%E5%A7%90%E5%A7%90-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B37F/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/contest/4381/F">牛客</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>毒瘤数学题。</p>
<p>由裴蜀定理，不定方程 $ax+by=c$ 有整数解当且仅当 $\gcd(a,b)|c$。那么当一个小姐姐的步长为 $a_i$，能否走到 $x$ 的充要条件为 $\gcd(a_i,m)|x$。为了方便，下面的 $a_i$ 都变为 $\gcd(a_i,m)$。注意到 $a_i$ 都是 $m$ 的因子。而 $10^{18}$ 以内的因子个数是 $10^5$ 级别的。</p>
<p>考虑到只选 $s$ 个比较难统计。我们容斥一下，变成统计选至少 $s$ 个的答案。那么最后的答案就是至少 $s$ 个减去至少 $s+1$ 个。</p>
<p>那么现在就变成从 $n$ 个 $a_i$ 中选出 $s$ 个不同的数，记为 $b_i$。判断一个 $x$ 是否合法，当且仅当 $lcm(a_{b_1},a_{b_2}\cdots a_{b_s})|x$。我们需要统计出所有的满足条件的 $x$。对于这样一种方案，我们记集合： $A(lcm(a_{b_1},a_{b_2},\cdots,a_{b_s}))=\{lcm(a_{b_1},a_{b_2}\cdots a_{b_s})|x,x\in[1,k]\}$。也就是所有满足条件的集合。</p>
<p>此时答案为：$\left | \bigcup_{b_1,b_2\cdots b_s}A(lcm(a_{b_1},a_{b_2}\cdots a_{b_s})) \right |$</p>
<p>集合的并集比较难处理。试试考虑用最普通的容斥原理，变成处理交集的情况？</p>
<p>一个点 $x$ 同时在一堆 $A(y_i)$ 中当且仅当 $lcm(y_i)|x$。</p>
<p>那么就有：$\left | \bigcap A(x_i) \right |=\left |A(lcm(x_i))  \right |$。因此交集的情况就好处理了。</p>
<p>只需要对于每个 $x$，算出容斥系数 $f_x$，答案就是 $\sum_{x|m}f_x|A_x|=\sum_{x|m}f_x\left \lfloor \frac{k}{x} \right \rfloor$。</p>
<p>这个 $x$ 实际上只有在 $x|m$ 的情况时才有意义，也就是 $10^5$ 级别。</p>
<p>现在的情况是，每次在 $\binom{n}{s}$ 个数中选出 $k$ 个数，这些数的lcm必须等于 $x$，贡献是 $(-1)^{k+1}$。</p>
<p>这个必须等于 $x$ 非常烦，考虑设 $g_x$ 为选出 $k$ 个数，这些数的lcm必须为 $x$ 的因数的答案。</p>
<p>发现这个 $f$ 的高维前缀和就是 $g$，那么算出 $g$ 之后高维差分一下就可以了。</p>
<p>显然，设 $y$ 为这 $\binom{n}{s}$ 个数中，是 $x$ 因数的个数。</p>
<p>那么有 $g_x=\sum_{i=1}^y\binom{y}{i}(-1)^{i+1}=(-1)(\sum_{i=0}^y\binom{y}{i}(-1)^i)+1=[y\not=0]$</p>
<p>考虑这个 $y$ 到底是什么，这 $\binom{n}{s}$ 个数是 $s$ 个数的lcm，这个 $lcm(a_{b_1},a_{b_2}\cdots a_{b_s})$ 要是 $x$ 的因数，也就是 $a_{b_i}$ 都要是 $x$ 的因数。显然当 $\sum_{i=1}^n[a_i|x]\geq s$ 时， $y\not =0$。</p>
<p>而这个 $\sum_{i=1}^n[a_i|x]$ 显然是一个高维前缀和的形式。</p>
<p>那么我们只需要用Pollard-Rho对 $m$ 进行质因数分解，暴力枚举出所有的因数，用哈希或者unordered_map 存起来。然后算高维前缀和以及高维差分就可以了。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a,ll b,<span class="type">const</span> ll &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(a%=p,b%=p;b;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) &#123;ans+=a; <span class="keyword">if</span>(ans&gt;=p) ans-=p;&#125;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>; a+=a; <span class="keyword">if</span>(a&gt;=p) a-=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll a,ll b,<span class="type">const</span> ll &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>,a=<span class="built_in">mul</span>(a,a,p)) <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=<span class="built_in">mul</span>(ans,a,p);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> !y?x:<span class="built_in">gcd</span>(y,x%y);&#125;</span><br><span class="line"><span class="function">ll <span class="title">ex_gcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123;x=<span class="number">1</span>; y=<span class="number">0</span>; <span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll d=<span class="built_in">ex_gcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x; <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y,d;</span><br><span class="line">    d=<span class="built_in">ex_gcd</span>(a,m,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+m)%m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> MillerRabin&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> prime[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">61</span>,<span class="number">7</span>,<span class="number">41</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">19</span>&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> m=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> t; ll r;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">witness</span><span class="params">(<span class="type">int</span> a,ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ll b=<span class="built_in">Pow</span>(a,r,n);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++,b=<span class="built_in">mul</span>(b,b,n)) <span class="keyword">if</span>(b==n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isprime</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(n==prime[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(n%prime[i]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		r=n<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(t=<span class="number">0</span>;!(r&amp;<span class="number">1</span>);r&gt;&gt;=<span class="number">1</span>) t++;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) <span class="keyword">if</span>(!<span class="built_in">witness</span>(prime[i],n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">if</span>(!<span class="built_in">witness</span>(<span class="built_in">rand</span>()%(n<span class="number">-1</span>)+<span class="number">1</span>,n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> MillerRabin::isprime;</span><br><span class="line">ll p[<span class="number">70</span>]; <span class="type">int</span> w[<span class="number">70</span>]; <span class="type">int</span> pn;</span><br><span class="line"><span class="keyword">namespace</span> PollardRho&#123;</span><br><span class="line">    <span class="function">ll <span class="title">rho</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        ll c=<span class="built_in">rand</span>()%(n<span class="number">-2</span>)+<span class="number">2</span>,x=<span class="built_in">rand</span>()%n,y=x,d;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">2</span>;i++;)</span><br><span class="line">        &#123;</span><br><span class="line">            x=(<span class="built_in">mul</span>(x,x,n)+c)%n;</span><br><span class="line">            d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(y-x),n);</span><br><span class="line">            <span class="keyword">if</span>(d!=<span class="number">1</span>&amp;&amp;d!=n) <span class="keyword">return</span> d;</span><br><span class="line">            <span class="keyword">if</span>(y==x) <span class="keyword">return</span> n;</span><br><span class="line">            <span class="keyword">if</span>(i==k) y=x,k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isprime</span>(n)) <span class="keyword">return</span> (<span class="type">void</span>)(p[++pn]=n);</span><br><span class="line">        ll d=n; <span class="keyword">for</span>(;d==n;) d=<span class="built_in">rho</span>(n);</span><br><span class="line">        <span class="built_in">find</span>(d); <span class="built_in">find</span>(n/d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> PollardRho::find;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line">unordered_map&lt;ll,<span class="type">int</span>&gt; ma;</span><br><span class="line"></span><br><span class="line">ll d[N]; <span class="type">int</span> dn;</span><br><span class="line">ll n,m,k,s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,ll now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;pn) &#123;d[++dn]=now; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,w[k]) <span class="built_in">dfs</span>(k+<span class="number">1</span>,now),now*=p[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">find</span>(m);</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+pn+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=pn;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i;j&lt;pn&amp;&amp;p[j+<span class="number">1</span>]==p[i];j++);</span><br><span class="line">		w[++k]=j-i+<span class="number">1</span>; p[k]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,k+<span class="number">1</span>,pn) p[i]=<span class="number">0</span>;</span><br><span class="line">	pn=k;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+dn+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,dn) ma[d[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">ll f[N],h[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(ll s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,dn) x=ma[d[i]],f[x]=(h[x]&gt;=s);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,pn)</span><br><span class="line">		<span class="built_in">fd</span>(j,dn,<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">if</span>(d[j]%p[i]==<span class="number">0</span>)</span><br><span class="line">				f[ma[d[j]]]-=f[ma[d[j]/p[i]]];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,dn) ans+=f[ma[d[i]]]*(k/d[i]);</span><br><span class="line">	<span class="keyword">return</span> ans+(n&gt;=s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc_h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) h[ma[<span class="built_in">gcd</span>(<span class="built_in">read</span>(),m)]]++;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,pn)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,dn)</span><br><span class="line">			<span class="keyword">if</span>(d[j]%p[i]==<span class="number">0</span>)</span><br><span class="line">				h[ma[d[j]]]+=h[ma[d[j]/p[i]]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); s=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">get</span>(m);</span><br><span class="line">	<span class="built_in">calc_h</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(s)-<span class="built_in">solve</span>(s+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>数论</tag>
        <tag>哈希</tag>
        <tag>高维前缀和</tag>
        <tag>PollardRho</tag>
      </tags>
  </entry>
  <entry>
    <title>独特的城市[JOI 2019 Final]</title>
    <url>/2020/03/17/%E7%8B%AC%E7%89%B9%E7%9A%84%E5%9F%8E%E5%B8%82-JOI-2019-Final/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/3014">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>似乎跟树的直径有点关系。不管了，先画出一条直径。</p>
<p>先考虑比较简单的，假设我们不考虑颜色的限制，只需维护有几个点满足条件。</p>
<p>可以发现，对于一个点 $i$，对该点有所贡献的所有点都会出现在 $i$ 到直径某个端点中的路径中。那么就可以尝试对于这两个端点dfs，那么满足条件的点必然在他到根的路径中。然后拿一个什么东西去维护这些点。</p>
<p>假设当前dfs到点 $u$，准备去dfs点 $v$。那么对于这个 $v$ 而言，$u$ 是有可能有贡献的，把它加到那个集合里。但是这时 $v$ 的兄弟会对 $v$ 的答案产生限制。记 $v$ 的所有兄弟离他们的子树中叶子结点的最大值为 $mx$，那么答案集合中的距离 $v$ 小于等于 $mx$ 的点都变得不合法，并且都 $v$ 的子树的所有点也会不合法。那么就可以把这些点从这个集合删去。</p>
<p>对于一个点统计答案的时候，记 $u$ 的所有儿子离其子树中叶节点的距离最大值为 $x$，那么答案集合中的距离 $u$ 小于等于 $x$ 的点都变得不合法，也同样删去。</p>
<p>这个集合可以用栈来维护。</p>
<p>离子树叶节点的距离最大值用长链剖分即可。</p>
<p>最后来考虑颜色的限制，也就是满足条件的集合中有多少种不同的颜色。</p>
<p>用个桶维护一下不就好了嘛。。。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,t,ans[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) d[i]=<span class="number">0</span>;</span><br><span class="line">	d[u]=<span class="number">1</span>; q.<span class="built_in">push</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> u;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			v=ver[i];</span><br><span class="line">			<span class="keyword">if</span>(!d[v]) &#123;d[v]=d[u]+<span class="number">1</span>; q.<span class="built_in">push</span>(v);&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s=u;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(d[i]&gt;d[s]) s=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>,s);</span><br><span class="line">	<span class="built_in">bfs</span>(s,t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[N],len[N],son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	len[u]=<span class="number">1</span>; dep[u]=dep[pre]+<span class="number">1</span>; son[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			len[u]=<span class="built_in">max</span>(len[u],len[v]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(!son[u]||len[son[u]]&lt;len[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st[N],top;</span><br><span class="line"><span class="type">int</span> w[N],col[N],now;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st[++top]=x;</span><br><span class="line">	w[col[x]]++;</span><br><span class="line">	<span class="keyword">if</span>(w[col[x]]==<span class="number">1</span>) now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(w[col[st[top]]]==<span class="number">1</span>) now--;</span><br><span class="line">	w[col[st[top]]]--;</span><br><span class="line">	top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!son[u]) &#123;ans[u]=<span class="built_in">max</span>(ans[u],now); <span class="built_in">add</span>(u); <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="type">int</span> mx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(v==son[u]||v==pre) <span class="keyword">continue</span>;</span><br><span class="line">		mx=<span class="built_in">max</span>(mx,len[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;top&amp;&amp;dep[u]-dep[st[top]]&lt;=mx;) <span class="built_in">del</span>();</span><br><span class="line">	<span class="built_in">add</span>(u);</span><br><span class="line">	<span class="built_in">solve</span>(son[u],u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		<span class="keyword">if</span>(v==son[u]||v==pre) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(;top&amp;&amp;dep[u]-dep[st[top]]&lt;=len[son[u]];) <span class="built_in">del</span>();</span><br><span class="line">		<span class="built_in">add</span>(u);</span><br><span class="line">		<span class="built_in">solve</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(;top&amp;&amp;dep[u]-dep[st[top]]&lt;=len[son[u]];) <span class="built_in">del</span>();</span><br><span class="line">	ans[u]=<span class="built_in">max</span>(ans[u],now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(s,t);</span><br><span class="line">	top=now=<span class="number">0</span>; <span class="built_in">dfs</span>(s,<span class="number">0</span>); <span class="built_in">solve</span>(s,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m) w[i]=<span class="number">0</span>;</span><br><span class="line">	top=now=<span class="number">0</span>; <span class="built_in">dfs</span>(t,<span class="number">0</span>); <span class="built_in">solve</span>(t,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">find</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) col[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>州区划分[WC2018]</title>
    <url>/2020/03/16/%E5%B7%9E%E5%8C%BA%E5%88%92%E5%88%86-WC2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2340">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>懒得写了。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>判断是否有欧拉回路随便做。</p>
<p>然后设 $g_s=\sum_{i\in s}val_i$，$h_s=[无回路]\times \sum_{i\in s}val_i$</p>
<p>那么状压DP，有 $f_s=\frac{1}{g_s}\sum_{t\subseteq s}f_th_{s-t}$</p>
<p>这个自己卷自己看起来有点难搞啊。</p>
<p>可以发现： $t\subseteq s$ 等价于枚举 $i,j$，使得 $i \ or \ j=s,|i|+|j|=|s|$。</p>
<p>那么就可以对于每个 $|i|$，都搞一个FMT或卷积就好了。</p>
<p>时间复杂度 $O(n^22^n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353ll</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> x[N*N],y[N*N];</span><br><span class="line"><span class="type">int</span> fa[N],d[N];</span><br><span class="line">ll w[<span class="number">1</span>&lt;&lt;N],iw[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="type">int</span> n,m,p,cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x!=fa[x]?fa[x]=<span class="built_in">find</span>(fa[x]):x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">find</span>(x); y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) <span class="keyword">if</span>(d[i]&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> rt=<span class="number">-1</span>,x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s)</span><br><span class="line">		&#123;</span><br><span class="line">			x=<span class="built_in">find</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(rt==<span class="number">-1</span>) rt=x;</span><br><span class="line">			<span class="keyword">if</span>(rt!=x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll g[N+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;N],f[N+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FWT</span><span class="params">(ll *f,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				(f[i+j+k]+=opt*f[j+k]+mod)%=mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">fo</span>(s,<span class="number">1</span>,cnt<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;s)</span><br><span class="line">			&#123;</span><br><span class="line">				w[s]=w[s^(<span class="number">1</span>&lt;&lt;i)]+w[<span class="number">1</span>&lt;&lt;i];</span><br><span class="line">				sum[s]=sum[s^(<span class="number">1</span>&lt;&lt;i)]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">fo</span>(s,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) fa[i]=i,d[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(((<span class="number">1</span>&lt;&lt;x[i])&amp;s)&amp;&amp;((<span class="number">1</span>&lt;&lt;y[i])&amp;s))</span><br><span class="line">		&#123;</span><br><span class="line">			d[x[i]]++; d[y[i]]++;</span><br><span class="line">			<span class="built_in">merge</span>(x[i],y[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		w[s]=<span class="built_in">Pow</span>(w[s],p); iw[s]=<span class="built_in">Pow</span>(w[s],mod<span class="number">-2</span>);</span><br><span class="line">		f[sum[s]][s]=w[s]*<span class="built_in">check</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); p=<span class="built_in">read</span>(); cnt=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x[i]=<span class="built_in">read</span>()<span class="number">-1</span>,y[i]=<span class="built_in">read</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) w[<span class="number">1</span>&lt;&lt;i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	g[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">FWT</span>(g[<span class="number">0</span>],cnt,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">FWT</span>(f[i],cnt,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(s,<span class="number">0</span>,cnt<span class="number">-1</span>)</span><br><span class="line">				g[i][s]=<span class="built_in">Add</span>(g[i][s],<span class="built_in">Mul</span>(g[j][s],f[i-j][s]));</span><br><span class="line">		<span class="built_in">FWT</span>(g[i],cnt,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(s,<span class="number">0</span>,cnt<span class="number">-1</span>) g[i][s]=(sum[s]==i?<span class="built_in">Mul</span>(g[i][s],iw[s]):<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(i!=n) <span class="built_in">FWT</span>(g[i],cnt,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,g[n][cnt<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>NOIWC</category>
      </categories>
      <tags>
        <tag>状压DP</tag>
        <tag>FWT</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title>通道[WC2018]</title>
    <url>/2020/03/13/%E9%80%9A%E9%81%93-WC2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2339">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>三棵树，求 $d_1(i,j)+d_2(i,j)+d_3(i,j)$ 的最大值。其中 $d$ 表示距离。</p>
<p>$n\leq 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>似乎有乱搞做法。。不管了。</p>
<h4 id="一棵树"><a href="#一棵树" class="headerlink" title="一棵树"></a>一棵树</h4><p>是个OIer都会。</p>
<h4 id="两棵树"><a href="#两棵树" class="headerlink" title="两棵树"></a>两棵树</h4><p>$d(i,j)$ 可以表示为 $dis_i+dis_j-2\times dis_{lca(i,j)}$，其中 $dis_i$ 表示点 $i$ 到根节点的距离。</p>
<p>考虑枚举 $T_1$ 中的 $lca$，那么 $i,j$ 需要从以 $lca$ 为根的子树中选出来，且不能是同一棵子树，或者有一个是 $lca$。</p>
<p>类似于树形DP，考虑每次将一个子树添加进去，然后维护答案。</p>
<p>这时答案为：$dis_i+dis_j+d_2(i,j)-2\times dis_{lca}$。后面是个常数，我们只需要维护前面的最大值。</p>
<p>考虑树的直径的一个重要性质，若记集合中任意两个最远的点为 $u,v$，那么对于两个集合 $A,B$，$A\bigcup B$ 的 $u,v$ 一定出自于 $A_u,A_v,B_u,B_v$ 中的任意两个。证明的话可以先证明连通的情况，不连通情况的建个虚树。</p>
<p>那么如果没有 $dis_i$ 和 $dis_j$，$d_2(i,j)$ 的最大值用个结构体维护一下就好了。</p>
<p>可以看做在 $T_2$ 中，新建一个点 $i’$，由 $i$ 和 $i’$ 连一条权值为 $dis_i$ 的边，这样就变成树的直径了。因此加上 $dis_i+dis_j$ 也是正确的。</p>
<p>时间复杂度 $O(n)$。</p>
<p><strong>以我的水平就只能想到这里了。</strong></p>
<h4 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h4><p>对 $T_3$ 考虑分治。</p>
<p>然而点分治合并两个子树信息的时候不一定搞得了。</p>
<p>然后就考虑边分治。。。</p>
<p>枚举一条边 $i$，将树拆成两部分，然后黑白染色。黑白两部分间的贡献递归去算。</p>
<p>那么题目转换成黑白两集合各选一个点 $x,y$，那么这棵树的贡献就是 $d_1x+d_1y-val_i$。</p>
<p>看看 $T_1,T_2$ 能不能沿用前面的方法。</p>
<p>但是现在多了一个 $d1$，还有黑白的颜色，以及能不能选上这个点的限制条件。</p>
<p>考虑设 $w_x=d_1x+d_2x$，那么 $T_2$ 中的贡献则变为 $w_x+w_y-2\times d_2lca$。</p>
<p>而黑白集合还是可以一样的维护。即用 $f_{u,0/1}$ 表示两个集合的直径。</p>
<p>但是一次dp是 $O(n)$ 的。</p>
<p>那么建个虚树就好了。</p>
<p>还有一个问题，边分治在菊花图的时候会死得很惨。</p>
<p>此时需要用到多叉树转二叉树，并且不能改变距离的限制，因此不能用左二子右兄弟法。</p>
<p>对于每个度数大于2（除父亲节点）的节点 $i$，添加两个点 $l,r$，连边 $(i,l/r,0)$，然后将子节点分成一半连向 $l,r$，然后再处理 $l,r$ 即可。</p>
<p>这样复杂度就能有保证了。</p>
<p>因此我们需要：</p>
<ul>
<li>将 $T_1$ 转成二叉树，然后边分治。</li>
<li>在 $T_2$ 中建虚树，然后枚举虚树中的点作为 $lca$ ，然后将子树信息 $O(1)$ 合并。建虚树求LCA需要用 $O(n\log n)-O(1)$ 的ST表做法。</li>
<li>在 $T_3$ 中用 $O(n\log n)-O(1)$ 的ST表做法快速求LCA即可。</li>
</ul>
<p>若用 $O(n)$ 时间建虚树，时间复杂度 $O(n\log n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>写了我一个上午…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">600010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line"><span class="type">const</span> ll Inf=<span class="number">4e18</span>;</span><br><span class="line"><span class="type">int</span> lg[N];</span><br><span class="line"><span class="keyword">namespace</span> T3&#123;</span><br><span class="line">	<span class="type">int</span> ne[N],head[N],ver[N],tot=<span class="number">1</span>,dep[N];</span><br><span class="line">	ll val[N],dis[N];</span><br><span class="line">	<span class="type">int</span> cnt,fir[N],f[M][N/<span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll z,<span class="type">int</span> y,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dep[u]=dep[pre]+<span class="number">1</span>; f[<span class="number">0</span>][++cnt]=u; fir[u]=cnt;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+val[i];</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">				f[<span class="number">0</span>][++cnt]=u;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,M<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">				f[j][i]=<span class="built_in">cmp</span>(f[j<span class="number">-1</span>][i],f[j<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x=fir[x]; y=fir[y];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="type">int</span> k=lg[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cmp</span>(f[k][x],f[k][y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">d</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> -Inf; <span class="keyword">return</span> dis[x]+dis[y]-(dis[<span class="built_in">lca</span>(x,y)]&lt;&lt;<span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> top[<span class="number">2</span>],s[<span class="number">2</span>][N];</span><br><span class="line">ll w[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">namespace</span> T2&#123;</span><br><span class="line">	ll ans;</span><br><span class="line">	<span class="type">int</span> ne[N],head[N],ver[N],tot=<span class="number">1</span>,dep[N];</span><br><span class="line">	<span class="type">int</span> dfn[N],tim,low[N];</span><br><span class="line">	ll val[N],dis[N];</span><br><span class="line">	<span class="type">int</span> cnt,fir[N],f[M][N/<span class="number">3</span>];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(ll z,<span class="type">int</span> y,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="type">void</span> _add(<span class="type">int</span> x,<span class="type">int</span> y,ll z)</span><br><span class="line">	&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dep[u]=dep[pre]+<span class="number">1</span>; f[<span class="number">0</span>][++cnt]=u; fir[u]=cnt;</span><br><span class="line">		dfn[u]=++tim;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+val[i];</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">				f[<span class="number">0</span>][++cnt]=u;</span><br><span class="line">			&#125;</span><br><span class="line">		low[u]=tim;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,M<span class="number">-1</span>)</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt+<span class="number">1</span>-(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">				f[j][i]=<span class="built_in">cmp</span>(f[j<span class="number">-1</span>][i],f[j<span class="number">-1</span>][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))]);</span><br><span class="line">		<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">		tot=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		x=fir[x]; y=fir[y];</span><br><span class="line">		<span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="type">int</span> k=lg[y-x+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cmp</span>(f[k][x],f[k][y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> b[N],m,opt[N],st[N];</span><br><span class="line">	ll va[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		ll dis;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!A.u) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!B.u) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> A.dis&lt;B.dis;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> node <span class="title">make_node</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll d)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (node)&#123;<span class="built_in">min</span>(u,v),<span class="built_in">max</span>(u,v),d&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> node <span class="title">make_node</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (node)&#123;<span class="built_in">min</span>(u,v),<span class="built_in">max</span>(u,v),T3::<span class="built_in">d</span>(u,v)+va[u]+va[v]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> node <span class="title">merge</span><span class="params">(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		node ans=<span class="built_in">max</span>(A,B);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">make_node</span>(A.u,B.u),<span class="built_in">make_node</span>(A.u,B.v)),<span class="built_in">max</span>(<span class="built_in">make_node</span>(A.v,B.u),<span class="built_in">make_node</span>(A.v,B.v))));</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">diameter</span><span class="params">(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!A.u&amp;&amp;!A.v) <span class="keyword">return</span> -Inf; <span class="keyword">if</span>(!B.u&amp;&amp;!B.v) <span class="keyword">return</span> -Inf;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="built_in">make_node</span>(A.u,B.u),<span class="built_in">make_node</span>(A.u,B.v)),<span class="built_in">max</span>(<span class="built_in">make_node</span>(A.v,B.u),<span class="built_in">make_node</span>(A.v,B.v))).dis;</span><br><span class="line">	&#125;</span><br><span class="line">	node dp[N][<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		dp[u][<span class="number">0</span>]=dp[u][<span class="number">1</span>]=(node)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span>(vis[u]) dp[u][opt[u]]=(node)&#123;u,u,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		&#123;</span><br><span class="line">			v=ver[i];</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,<span class="built_in">max</span>(<span class="built_in">diameter</span>(dp[u][<span class="number">0</span>],dp[v][<span class="number">1</span>]),<span class="built_in">diameter</span>(dp[u][<span class="number">1</span>],dp[v][<span class="number">0</span>]))-dis[u]*<span class="number">2</span>);</span><br><span class="line">			dp[u][<span class="number">0</span>]=<span class="built_in">merge</span>(dp[u][<span class="number">0</span>],dp[v][<span class="number">0</span>]);</span><br><span class="line">			dp[u][<span class="number">1</span>]=<span class="built_in">merge</span>(dp[u][<span class="number">1</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build_tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(i,<span class="number">1</span>,top[j]) b[++m]=s[j][i];</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) vis[b[i]]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(i,<span class="number">1</span>,top[j]) opt[s[j][i]]=j;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(i,<span class="number">1</span>,top[j]) va[s[j][i]]=w[j][i]+dis[s[j][i]];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>) b[++m]=<span class="built_in">lca</span>(b[i],b[i+<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">sort</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> dfn[x]&lt;dfn[y];&#125;);</span><br><span class="line">		m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) head[b[i]]=<span class="number">0</span>; tot=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(;top&amp;&amp;low[st[top]]&lt;dfn[b[i]];--top);</span><br><span class="line">			<span class="keyword">if</span>(top) _add(st[top],b[i],dis[b[i]]-dis[st[top]]);</span><br><span class="line">			st[++top]=b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) va[b[i]]=opt[b[i]]=vis[b[i]]=head[b[i]]=<span class="number">0</span>;</span><br><span class="line">		m=<span class="number">0</span>; tot=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">build_tree</span>();</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(b[<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> T1&#123;</span><br><span class="line">	<span class="type">int</span> pre_n;</span><br><span class="line">	<span class="type">int</span> ne[N],head[N],ver[N],tot=<span class="number">1</span>;</span><br><span class="line">	ll val[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=z; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; son[N]; ll value[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">				son[u].<span class="built_in">pb</span>(v); value[v]=val[i];</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) head[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> N=n,w[<span class="number">2</span>],d=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">			<span class="keyword">if</span>(son[i].<span class="built_in">size</span>()&lt;=<span class="number">2</span>) <span class="keyword">for</span>(<span class="keyword">auto</span> v:son[i]) <span class="built_in">add</span>(i,v,value[v]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w[<span class="number">0</span>]=++N; w[<span class="number">1</span>]=++N;</span><br><span class="line">				<span class="built_in">add</span>(i,w[<span class="number">0</span>],<span class="number">0</span>); <span class="built_in">add</span>(i,w[<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:son[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d=<span class="number">1</span>-d; son[w[d]].<span class="built_in">pb</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		n=N;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> siz[N],minn,edge;</span><br><span class="line">	ll dis[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v,tmp;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;!vis[i&gt;&gt;<span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">getroot</span>(v,u,s);</span><br><span class="line">				siz[u]+=siz[v];</span><br><span class="line">				tmp=<span class="built_in">max</span>(siz[v],s-siz[v]);</span><br><span class="line">				<span class="keyword">if</span>(tmp&lt;minn) minn=tmp,edge=i;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> now;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u&lt;=pre_n)</span><br><span class="line">		&#123;</span><br><span class="line">			++top[now];</span><br><span class="line">			s[now][top[now]]=u;</span><br><span class="line">			w[now][top[now]]=dis[u];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(!vis[i&gt;&gt;<span class="number">1</span>]&amp;&amp;(v=ver[i])!=pre)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+val[i];</span><br><span class="line">				<span class="built_in">getdis</span>(v,u);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		minn=inf; <span class="built_in">getroot</span>(u,<span class="number">0</span>,s);</span><br><span class="line">		<span class="keyword">if</span>(minn&gt;=inf) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> j=edge,s1=siz[ver[j]],s2=s-s1;</span><br><span class="line">		vis[j&gt;&gt;<span class="number">1</span>]=<span class="number">1</span>; top[<span class="number">0</span>]=top[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		dis[ver[j]]=dis[ver[j^<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">		now=<span class="number">0</span>; <span class="built_in">getdis</span>(ver[j],<span class="number">0</span>);</span><br><span class="line">		now=<span class="number">1</span>; <span class="built_in">getdis</span>(ver[j^<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">		ll tmp=val[j]+T2::<span class="built_in">solve</span>();</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,tmp);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">fo</span>(i,<span class="number">1</span>,top[j]) w[j][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">divide</span>(ver[j],s1); <span class="built_in">divide</span>(ver[j^<span class="number">1</span>],s2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pre_n=n;</span><br><span class="line">		<span class="built_in">rebuild</span>();</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">divide</span>(<span class="number">1</span>,n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n&lt;&lt;<span class="number">1</span>) lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> x,y; ll z;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">read</span>(),T1::<span class="built_in">add</span>(x,y,z);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) T2::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) T3::<span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	T3::<span class="built_in">pre</span>(); T2::<span class="built_in">pre</span>(); T1::<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
        <category>NOIWC</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>边分治</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>Border 的四种求法[BJWC2018]</title>
    <url>/2020/03/13/Border-%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%B1%82%E6%B3%95-BJWC2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.luogu.com.cn/problem/P4482">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求 $S[l,r]$ 的border。$n,m\leq 2\times 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>码农题。。</p>
<h4 id="重要的性质"><a href="#重要的性质" class="headerlink" title="重要的性质"></a>重要的性质</h4><ul>
<li>题目允许离线。</li>
<li>判断一个子串 $S[l,i]$ 是否是 $S[l,r]$ 的border的方法为：$i-l+1\leq lcp(i,r)$ 且 $i\in[l,r)$</li>
</ul>
<h4 id="分析做法"><a href="#分析做法" class="headerlink" title="分析做法"></a>分析做法</h4><p>$lcp(i,r)$ 显然是SAM的fail树中 $i,r$ 的LCA的 $len$ 值。</p>
<p>假设我们枚举LCA，那么判断条件就变为 $i-l+1\leq len_{lca}$ ， $l\leq i &lt; r$，也就是 $l\leq i \leq \min\{len_{lca}+l-1,r-1\}$。除此之外还要满足 $i$ 在 $lca$ 的子树内。</p>
<p>我们需要在 $lca$ 的子树中找到一个 $i$，使得满足上述条件且值最大。那么在fail树上用线段树合right集合，然后在线段树上二分就好了。</p>
<p>但是枚举 $lca$ 的复杂度是 $O(n)$ 的。</p>
<p>考虑树链剖分，然后进行链分治。</p>
<p>考虑在 $r$ 处一直向根跳，跳到的点就是需要进行枚举LCA的点。</p>
<p>显然他跳过最多 $\log n$ 条轻链。</p>
<p>对于每条重链而言，这个 $r$ 所经过的点的是一个前缀。</p>
<p>假设你现在只有一条重链，一个询问。那么分两类讨论：对于这个询问所在的点 $r$ 而言，能贡献给他的 $i$ 都满足在他的子树内，因此用上面所说的线段树合并去处理即可；对于这条重链中，在这个点 $r$ 上面的每个点 $j$，考虑哪些 $i$ 是能对这个 $j$ 有贡献的。显然只有 $j$ 本身，或者是他轻儿子的子树中的所有点。</p>
<p>假设你现在只有一条重链，很多个询问。那么就可以把询问离线，对于重链从上往下做：</p>
<p>考虑第二种情况怎么算。考虑最暴力的方法，将 $j$ 的所有轻儿子的子树的所有点赋予某个权值，然后加进去某个数据结构里，然后询问的时候在这个数据结构里搞搞。实际上这个暴力是没有问题的，因为一个点往上最多有 $\log n$ 条轻链，也就是最多会被加进数据结构里 $\log n$ 次。</p>
<p>再看看这个数据结构能是什么。这个点实际上有两个权值，一个是 $i+len_j-1$，另一个是 $i$。满足 $i-len_j+1\leq l$，且 $l\leq i \leq r-1$，需要找最大的 $i$。</p>
<p><del>那么用树套树随便搞一下就好了。</del>有这种想法的怕不是数据结构学傻了（</p>
<p>用 $i$ 做下标，$i-len_j+1$ 做权值，开个线段树，询问的时候在线段树上记录一个区间最小值，在不超过 $\log n$ 个线段树的节点中用线段树上二分就可以了。</p>
<p>所以我们需要：SAM+树链剖分+线段树+线段树合并<del>就可以了</del>。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>也就4k嘛。接下来那篇更长。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">7.5e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">2e9</span>;</span><br><span class="line"><span class="type">int</span> ans[N&gt;&gt;<span class="number">1</span>],n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> S1&#123;</span><br><span class="line">	<span class="type">int</span> ls[M],rs[M],mx[M],cnt;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		u=++cnt;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(mx[u]=p);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		p&lt;=mid?<span class="built_in">ins</span>(ls[u],l,mid,p):<span class="built_in">ins</span>(rs[u],mid+<span class="number">1</span>,r,p);</span><br><span class="line">		mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="type">int</span> u=++cnt;</span><br><span class="line">		ls[u]=<span class="built_in">merge</span>(ls[x],ls[y]);</span><br><span class="line">		rs[u]=<span class="built_in">merge</span>(rs[x],rs[y]);</span><br><span class="line">		mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u||L&gt;R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> mx[u];</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R&amp;&amp;rs[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=<span class="built_in">query</span>(rs[u],mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">			<span class="keyword">return</span> tmp?tmp:<span class="built_in">query</span>(ls[u],l,mid,L,R);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> L&lt;=mid?<span class="built_in">query</span>(ls[u],l,mid,L,R):<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> S2&#123;</span><br><span class="line">	<span class="type">int</span> mi[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n&lt;&lt;<span class="number">2</span>) mi[i]=inf;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p&lt;l||p&gt;r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) &#123;mi[u]=v; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		p&lt;=mid?<span class="built_in">add</span>(ls,p,v):<span class="built_in">add</span>(rs,p,v);</span><br><span class="line">		mi[u]=<span class="built_in">min</span>(mi[lc],mi[rc]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mi[u]=inf;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		p&lt;=mid?<span class="built_in">del</span>(ls,p):<span class="built_in">del</span>(rs,p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mi[u]&gt;L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> mi[u]&lt;=L?l:<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R&amp;&amp;mi[rc]&lt;=L)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=<span class="built_in">query</span>(rs,L,R);</span><br><span class="line">			<span class="keyword">return</span> tmp?tmp:<span class="built_in">query</span>(ls,L,R);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> L&lt;=mid?<span class="built_in">query</span>(ls,L,R):<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> lc</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> rc</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> ls</span></span><br><span class="line">	<span class="meta">#<span class="keyword">undef</span> rs</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> l,r,id;</span><br><span class="line">	&#125;;</span><br><span class="line">	vector&lt;node&gt; q[N];</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	<span class="type">int</span> siz[N],top[N],son[N],fa[N],val[N],rt[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[u]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(p[u]) S1::<span class="built_in">ins</span>(rt[u],<span class="number">1</span>,n,p[u]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			fa[v]=u;</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">			rt[u]=S1::<span class="built_in">merge</span>(rt[u],rt[v]);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[son[u]]&lt;=siz[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		top[u]=tp; <span class="keyword">if</span>(son[u]) <span class="built_in">dfs</span>(son[u],tp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=son[u]) <span class="built_in">dfs</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;x;x=fa[top[x]]) q[x].<span class="built_in">pb</span>((node)&#123;l,r,id&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[u]) S2::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[u],p[u]-len+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">ins</span>(v,len);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[u]) S2::<span class="built_in">del</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[u]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="built_in">del</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">		<span class="type">int</span> l,r,id,tmp;</span><br><span class="line">		vec.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> v=u;v;v=son[v]) vec.<span class="built_in">pb</span>(v);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[v]) S2::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[v],p[v]-val[v]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> w:adj[v]) <span class="keyword">if</span>(son[v]!=w) <span class="built_in">ins</span>(w,val[v]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> qu:q[v])</span><br><span class="line">			&#123;</span><br><span class="line">				l=qu.l,r=qu.r,id=qu.id;</span><br><span class="line">				tmp=S1::<span class="built_in">query</span>(rt[v],<span class="number">1</span>,n,l,<span class="built_in">min</span>(l+val[v]<span class="number">-1</span>,r<span class="number">-1</span>));</span><br><span class="line">				<span class="keyword">if</span>(l&lt;=tmp&amp;&amp;tmp&lt;r) ans[id]=<span class="built_in">max</span>(ans[id],tmp-l+<span class="number">1</span>);</span><br><span class="line">				tmp=S2::<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">if</span>(l&lt;=tmp&amp;&amp;tmp&lt;r) ans[id]=<span class="built_in">max</span>(ans[id],tmp-l+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p[v]) S2::<span class="built_in">del</span>(<span class="number">1</span>,<span class="number">1</span>,n,p[v]);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> w:adj[v]) <span class="keyword">if</span>(son[v]!=w) <span class="built_in">del</span>(w);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:vec) <span class="keyword">for</span>(<span class="keyword">auto</span> w:adj[v]) <span class="keyword">if</span>(son[v]!=w) <span class="built_in">solve</span>(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],len[N],fa[N],siz,las;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz=las=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> p=las,cur=++siz;</span><br><span class="line">		len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> clone=++siz;</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">				fa[clone]=fa[q];</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">				fa[q]=fa[cur]=clone;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur; ::p[las]=id;</span><br><span class="line">		<span class="keyword">return</span> las;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,siz) Tree::<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz) Tree::val[i]=len[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> m,pos[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	SAM::<span class="built_in">init</span>();</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pos[i]=SAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>,i);</span><br><span class="line">	SAM::<span class="built_in">build_tree</span>();</span><br><span class="line">	Tree::<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	Tree::<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	S2::<span class="built_in">init</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">		Tree::<span class="built_in">jump</span>(pos[r],l,r,i);</span><br><span class="line">	&#125;</span><br><span class="line">	Tree::<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(); <span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>luogu</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>SAM</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>String Set Queries[CF710F]</title>
    <url>/2020/03/11/String-Set-Queries-CF710F/</url>
    <content><![CDATA[<p>fflush(stdout) 搞了我好久。。。</p>
<span id="more"></span>

<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://codeforces.com/contest/710/problem/F">链接</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>维护一个字符串集合，支持：</p>
<ul>
<li><p>插入一个字符串</p>
</li>
<li><p>删除一个原有的字符串</p>
</li>
<li><p>询问一个字符串，问字符串集合中的元素在该字符串中出现次数之和。</p>
</li>
</ul>
<p>强制在线。</p>
<p>$\sum |S|\leq 3\times 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这个trick真的太妙了…</p>
<p>首先删除是假的，因为满足可减性，把删掉的字符串形成的集合的贡献删掉就可以了。</p>
<p>这个东东显然可以用AC自动机/SAM维护。</p>
<p>但是不支持强制在线啊。。。</p>
<p><del>那么你就可以写一个广义SAM+LCT就好了</del></p>
<p>trick：对字符串进行二进制分组。</p>
<p>也就是说，我们维护 $\log |S|$ 个AC自动机，第 $i$ 个自动机中存 $2^i$ 个字符串。</p>
<p>每次插入时维护一个自动机。</p>
<p>枚举第 $i$ 个自动机，看是否为空，若为空，则插入，然后getfail。</p>
<p>否则将当前自动机和第 $i$ 个自动机合并。合并AC自动机跟合并Trie类似。</p>
<p>每个字符串都只会改变 $\log |S|$ 个位置。</p>
<p>因此时间复杂度 $O(|S|\log |S|)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">19</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC_Auto</span>&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],fail[N],cnt,val[N],rt[M]; <span class="type">bool</span> bo[N];</span><br><span class="line">	<span class="built_in">AC_Auto</span>() &#123;cnt=<span class="number">1</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		bo[x]|=bo[y];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!ne[y][i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(!ne[x][i]) ne[x][i]=ne[y][i];</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">dfs</span>(ne[x][i],ne[y][i]); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getfail</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		q.<span class="built_in">push</span>(x); fail[x]=val[x]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u,p,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S;i++)</span><br><span class="line">				<span class="keyword">if</span>(v=ne[u][i])</span><br><span class="line">				&#123;</span><br><span class="line">					q.<span class="built_in">push</span>(v); p=fail[u];</span><br><span class="line">					<span class="keyword">for</span>(;p&amp;&amp;!ne[p][i];p=fail[p]);</span><br><span class="line">					fail[v]=p?ne[p][i]:x;</span><br><span class="line">					val[v]=val[fail[v]]+bo[v];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),u=++cnt,p=u;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			ne[u][s[i]-<span class="string">&#x27;a&#x27;</span>]=++cnt;</span><br><span class="line">			u=ne[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		bo[u]=<span class="number">1</span>; u=p;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,M<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(!rt[i])&#123;rt[i]=u; <span class="built_in">getfail</span>(rt[i]); <span class="keyword">break</span>;&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="built_in">dfs</span>(u,rt[i]); rt[i]=<span class="number">0</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),c,u;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,M<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(rt[j])</span><br><span class="line">			&#123;</span><br><span class="line">				u=rt[j];</span><br><span class="line">				<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">				&#123;</span><br><span class="line">					c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">					<span class="keyword">if</span>(ne[u][c]) u=ne[u][c];</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span>(;u&amp;&amp;!ne[u][c];u=fail[u]);</span><br><span class="line">						u=u?ne[u][c]:rt[j];</span><br><span class="line">					&#125;</span><br><span class="line">					ans+=val[u];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;A,B;</span><br><span class="line"><span class="type">char</span> t[<span class="number">300010</span>]; <span class="type">int</span> opt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		opt=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>) A.<span class="built_in">ins</span>(t);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>) B.<span class="built_in">ins</span>(t);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A.<span class="built_in">ask</span>(t)-B.<span class="built_in">ask</span>(t));</span><br><span class="line">		<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>二进制分组</tag>
      </tags>
  </entry>
  <entry>
    <title>密涅瓦的谜题[牛客挑战赛31E]</title>
    <url>/2020/03/11/%E5%AF%86%E6%B6%85%E7%93%A6%E7%9A%84%E8%B0%9C%E9%A2%98-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B31E/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/contest/880/E">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个长度为 $n$ 的串，$q$ 次询问，给定一个 $m$：每次在 $n$ 的所有子串中（包括空串）选出一个，然后按顺序拼接起来形成一个大字符串。一共进行 $m$ 次，求形成了多少个不同的大字符串。对 $10^9+7$ 取模。</p>
<p>$n,q\leq 10^5,m\leq 10^{10}$。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>为了不重复计数，对于一个字符串，我们要让它匹配到尽量远。也就是说，若有 $T=s_1s_2\cdots s_m$，那么对于某个 $s_is_{i+1}$ 这个片段来说，我们要让 $s_i$ 伸展的尽量远。</p>
<p>那么接下来就可以DP了。设字符集为 $\sigma$。</p>
<p>用 $f_{i,j}$ 表示考虑到第 $i$ 个串时，最后的字母为 $j$ 的方案数是多少。为了方便，当 $j=\sigma$ 时表示最后的字母为空的答案。</p>
<p>得出DP方程：$f_{i,j}=\sum f_{i-1,k}\times A_{k,j}$，其中 $A_{k,j}$ 为从字母 $k$ 转移到字母 $j$ 有多少种情况。</p>
<p>初始状态为 $f_{0,\sigma}=1$，答案为 $\sum f_{n,i}$。</p>
<p>这个 $A_{k,j}$ 可以在SAM上用 $O(n\sigma)$ 的时间用一个简单的DP算出来。</p>
<p>那么就得到了一个 $O(nm\sigma)$ 的做法。</p>
<p>这个转移显然是个矩阵乘法的形式。可以用快速幂做到 $O(n\sigma+m\sigma^3)$。仍然过不了。</p>
<p>复杂度瓶颈主要出现在询问上，考虑优化这部分。</p>
<p>显然答案可以表示为：</p>
<p>$Ans=\begin{bmatrix}0 &amp; \cdots &amp; 0 &amp; 1\end{bmatrix}\times A^n\times \begin{bmatrix}1\\ 1\\ \vdots\\ 1\end{bmatrix}$</p>
<p>分块，预处理出当 $n=0,1,2\cdots\sqrt m$ 时前半部分的答案，以及当 $n=0,\sqrt m,2\sqrt m\cdots$ 时后半部分的答案。</p>
<p>那么对于一个询问 $k$，设 $k=x\sqrt m+y$，就可以用这两部分在 $O(\sigma)$ 的时间内合并了。</p>
<p>时间复杂度 $O(n\sigma+\sqrt m\sigma^2+q\sigma)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7ll</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span>&#123;y%=(mod<span class="number">-1</span>);ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;<span class="keyword">return</span> ans;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line">	ll a[S+<span class="number">1</span>][S+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">matrix</span>() &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">	ll *<span class="keyword">operator</span> [](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;A,B;</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix A,matrix B)</span><br><span class="line">&#123;</span><br><span class="line">	matrix C;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,S) <span class="built_in">fo</span>(j,<span class="number">0</span>,S) <span class="built_in">fo</span>(k,<span class="number">0</span>,S) C[i][j]=<span class="built_in">Add</span>(C[i][j],<span class="number">1ll</span>*A[i][k]*B[k][j]%mod);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">matrix <span class="title">Pow</span><span class="params">(matrix A,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	matrix C;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,S) C[i][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,A=A*A) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) C=C*A;</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> las=<span class="number">1</span>,siz=<span class="number">1</span>,len[N],ne[N][S],fa[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=siz;i++) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),fa[i]=len[i]=<span class="number">0</span>;</span><br><span class="line">		las=siz=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> cur=++siz;</span><br><span class="line">		len[cur]=len[las]+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> p=las;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[q]==len[p]+<span class="number">1</span>) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> clone=++siz;</span><br><span class="line">				len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				fa[clone]=fa[q];</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">				fa[cur]=fa[q]=clone;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> base[N],a[N],f[N][S+<span class="number">1</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz) ++base[len[i]];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz) base[i]+=base[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,siz) a[base[len[i]]--]=i;</span><br><span class="line">		<span class="type">int</span> u;</span><br><span class="line">		<span class="built_in">fd</span>(i,siz,<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			u=a[i]; f[u][S]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,S<span class="number">-1</span>)</span><br><span class="line">				<span class="keyword">if</span>(ne[u][j])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">fo</span>(k,<span class="number">0</span>,S) f[u][k]=<span class="built_in">Add</span>(f[u][k],f[ne[u][j]][k]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> f[u][j]=<span class="built_in">Add</span>(f[u][j],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S<span class="number">-1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,S) A[j][i]=ne[<span class="number">1</span>][i]?f[ne[<span class="number">1</span>][i]][j]:<span class="number">0</span>;</span><br><span class="line">		A[S][S]=<span class="number">1</span>; B=<span class="built_in">Pow</span>(A,M);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> SAM;</span><br><span class="line">ll p[M+<span class="number">1</span>][S+<span class="number">1</span>],s[M+<span class="number">1</span>][S+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n; <span class="type">char</span> t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">	SAM::<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) SAM::<span class="built_in">extend</span>(t[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	<span class="built_in">dp</span>(n);</span><br><span class="line">	</span><br><span class="line">	p[<span class="number">0</span>][S]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,M<span class="number">-1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,S) <span class="built_in">fo</span>(k,<span class="number">0</span>,S) p[i][k]=<span class="built_in">Add</span>(p[i][k],p[i<span class="number">-1</span>][j]*A[j][k]%mod);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,S) s[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,M) <span class="built_in">fo</span>(j,<span class="number">0</span>,S) <span class="built_in">fo</span>(k,<span class="number">0</span>,S) s[i][j]=<span class="built_in">Add</span>(s[i][j],s[i<span class="number">-1</span>][k]*B[j][k]%mod);</span><br><span class="line">	<span class="type">int</span> x,y; ll ans,k;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		k=<span class="built_in">read</span>(); x=k/M; y=k%M; ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,S) ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(p[y][i],s[x][i]));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>SAM</tag>
        <tag>矩阵乘法</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 83[CF1312]</title>
    <url>/2020/03/10/Educational-Codeforces-Round-83-CF1312/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1312">链接</a></p>
<span id="more"></span>

<p>这场比赛问题简单，但还是暴露的很多问题的。</p>
<p>G和E都花了太长时间了。证明自己的思维还是太慢。</p>
<h3 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h3><p>求正 $n$ 边形中选出 $m$ 个顶点是否能组成正 $m$ 边形。</p>
<p>显然：$m|n$。</p>
<h3 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h3><p>构造一种方案，将数组重排后，使得不存在 $i-a_i = j-a_j$ 的情况。</p>
<p>显然从大到小输出即可。</p>
<p>求方案数？</p>
<h3 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h3><p>一个数组，可以选择一个 $m$，然后对于每个 $i\in[1,m]$，将数组的某个位置减去 $k^i$。问是否存在一个 $m$，使得数组全为 $0$？</p>
<p>从大到小暴力即可。</p>
<h3 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h3><p>太长了，懒得写了。</p>
<p>先特判 $n=2$ 的情况。</p>
<p>枚举最大的那个的值以及位置，再枚举左右相等的那个点谁，然后组合数化简一下即可。</p>
<h3 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>一个数列 $a$，每次可以将两个相邻且相等的数合成一个，权值加 $1$。</p>
<p>问数列 $a$ 最短能变成多少。</p>
<p>$n\leq 500$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>区间DP，看区间 $[i,j]$ 能否合成一个数 $k$，然后再一次 DP/bfs 就可以了。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h3 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h3><p>留坑。。。</p>
<h3 id="Problem-G"><a href="#Problem-G" class="headerlink" title="Problem G"></a>Problem G</h3><p>为什么最后这道题这么简单啊。。。</p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>太长了，不写了。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>设在 $S$ 中的点为关键点。</p>
<p>显然考虑按dfs进行DP，设 $f_i$ 表示到 $i$ 这个节点的最短时间， $d_i$ 为深度，$s_i$ 为到考虑到当前的dfs序为止时，$i$ 的子树中的有多少个关键点。</p>
<p>若点 $i$ 不是关键点，有：$f_i=\min\{f_j+d_i-d_j\}$，其中 $j$ 为 $i$ 祖先。</p>
<p>若点 $i$ 是关键点，就会多一种转移： $f_i=\min\{f_j+s_j\}$，其中 $j$ 为 $i$ 祖先。</p>
<p>第二种转移需要支持区间 $+1$。即遇到一个关键点的时候需要令 $s_j$ 加上 $1$。</p>
<p>因此只需要实现一个单点覆盖和区间加，查询区间最大值的数据结构即可。</p>
<p>线段树/set/可删堆可以很轻松的维护。</p>
<p>时间复杂度 $O(n\log n)$。</p>
]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
        <tag>树形DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 82[CF1303]</title>
    <url>/2020/03/02/Educational-Codeforces-Round-82-CF1303/</url>
    <content><![CDATA[<h2 id="比赛链接"><a href="#比赛链接" class="headerlink" title="比赛链接"></a>比赛链接</h2><p><a href="https://codeforces.ml/contest/1303">链接</a></p>
<span id="more"></span>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="Problem-A-C"><a href="#Problem-A-C" class="headerlink" title="Problem A~C"></a>Problem A~C</h3><p>SB题，不写了。</p>
<h3 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>懒得写了。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>显然贪心地从低位到高位维护当前能组成多少个 $2^i$ 即可。</p>
<h3 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给两个字符串 $s,t$，要求在 $s$ 中选出至多两个互不重合的子序列，按顺序排列后组成 $t$。问是否可行。</p>
<p>$|S|,|T|\leq 400$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>显然先枚举 $t$ 在哪个位置断开。</p>
<p>然后DP，设 $f[i][j][k]$ 表示前 $i$ 位两个子串分别匹配到第 $j,k$ 位是否可行。</p>
<p>时间复杂度 $O(n^4)$。需要优化。</p>
<p>因为DP值只有 $0,1$ 两种情况，因此可以降一维，设 $f[i][j]$ 为前 $i$ 为第一个子串匹配到第 $j$ 位时，第二个子串最大匹配到的位置。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="type">int</span> n,m,f[N][N];</span><br><span class="line"><span class="type">char</span> s[N],t[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> y)</span></span>&#123;x=<span class="built_in">max</span>(x,y);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">		n=<span class="built_in">strlen</span>(s+<span class="number">1</span>); m=<span class="built_in">strlen</span>(t+<span class="number">1</span>);</span><br><span class="line">		<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(k,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,n+<span class="number">1</span>) <span class="built_in">fo</span>(j,<span class="number">0</span>,m+<span class="number">1</span>) f[i][j]=<span class="number">-1</span>;</span><br><span class="line">			f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="built_in">min</span>(k,i))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i&gt;j&amp;&amp;f[i<span class="number">-1</span>][j]&gt;=<span class="number">0</span>) <span class="built_in">getmax</span>(f[i][j],f[i<span class="number">-1</span>][j]+(f[i<span class="number">-1</span>][j]&gt;=m-k?<span class="number">0</span>:(t[k+<span class="number">1</span>+f[i<span class="number">-1</span>][j]]==s[i]?<span class="number">1</span>:<span class="number">0</span>)));</span><br><span class="line">					<span class="keyword">if</span>(j&amp;&amp;f[i<span class="number">-1</span>][j<span class="number">-1</span>]&gt;=<span class="number">0</span>&amp;&amp;s[i]==t[j]) <span class="built_in">getmax</span>(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			flag|=(f[n][k]==m-k);</span><br><span class="line">			<span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(flag?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>懒得写了。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>考虑某个点改变颜色后，对于原来的颜色集合，相当于删除操作，对于改变后的颜色的集合，相当于添加操作。</p>
<p>删除操作可以用时间倒流，变成添加操作，因此只需考虑添加。</p>
<p>对于每种颜色分开考虑，若加上一个点，考虑此时连通块数量的变化情况。</p>
<p>若这个点有 $x$ 个连通块与之相邻，则新增的连通块数为 $1-x$。</p>
<p>并查集+时间倒流即可。</p>
<h3 id="Problem-G"><a href="#Problem-G" class="headerlink" title="Problem G"></a>Problem G</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>一棵树，有点权。任选 $u,v$，求从 $u$ 到 $v$ 路径所形成的点权的序列的后缀和的和的最大值。</p>
<p>$n\leq 1.5\times 10^5$，时限 $6s$。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>一个序列 $\{a_1,a_2,\cdots,a_k\}$ 的权值为：$\sum_{i=1}^ki\times a_i$。考虑如何在树上求最大值。</p>
<p>跟树上路径有关系的，显然点分治。</p>
<p>这时只需考虑一个序列，在某根节点处被截成两段，且统计最大值。</p>
<p>考虑在 $m$ 处被截断，截成 $\{a_1,a_2,\cdots,a_m\}$ 和 $\{a_{m+1},a_{m+2},\cdots,a_k\}$。</p>
<p>考虑如何用两段的信息合并成一段的，有：</p>
<p>$$\sum_{i=1}^ki\times a_i\=\sum_{i=1}^mi\times a_i+\sum_{i=m+1}^{k}i\times a_i\=\sum_{i=1}^mi\times a_i+\sum_{i=m+1}^k(i-m)\times a_i+m\sum_{i=m+1}^ka_i$$</p>
<p>对于某一序列 $\{a_1,a_2,\cdots,a_k\}$，设 $s=\sum_{i=1}^ki\times a_i,v=\sum_{i=1}^ka_i$。</p>
<p>那么两段序列的信息合成一段就是：$s_1+s_2+m_1v_2$。</p>
<p>考虑点分治时，需要从某两棵不同的子树中统计答案。</p>
<p>如图所示：</p>
<p><img src="/Educational-Codeforces-Round-82-CF1303/G1.png" alt="G1"></p>
<p>将子树按顺序从左到右排成一列，假设枚举到某棵子树，不妨设序列的前半部分出现在后面的子树中（否则反过来再做一遍即可）。</p>
<p>那么如果把后半部分的 $(s_2,v_2)$ 看做插入；把前半部分看做询问 $s_2+m_1v_2$ 的最大值，最后加上 $s_1$ 的值。显然 $s_2+m_1v_2$ 是一个直线的形式。将 $m_1$ 看作 $x$，$v_2$ 为斜率 $k$，$s_2$ 为纵截距 $b$。</p>
<p>也就是求若干条线段在 $x=m_1$ 处的最大值。 </p>
<p>李超线段树，插入整个线段维护即可。</p>
<p>点分治时间复杂度 $O(n\log n)$，李超线段树复杂度 $O(\log n)$，总复杂度 $O(n\log ^2n)$。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">150010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	ll k,b;</span><br><span class="line">	<span class="function">ll <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> k*x+b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	line mx[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mx[u].k=mx[u].b=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">init</span>(ls); <span class="built_in">init</span>(rs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> mx[u].<span class="built_in">f</span>(x);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(mx[u].<span class="built_in">f</span>(x),(x&lt;=mid)?<span class="built_in">ask</span>(ls,x):<span class="built_in">ask</span>(rs,x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,line A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(mx[u].<span class="built_in">f</span>(l)&lt;=A.<span class="built_in">f</span>(l)&amp;&amp;mx[u].<span class="built_in">f</span>(r)&lt;=A.<span class="built_in">f</span>(r)) &#123;mx[u]=A; <span class="keyword">return</span>;&#125;</span><br><span class="line">		<span class="keyword">if</span>(mx[u].<span class="built_in">f</span>(l)&gt;=A.<span class="built_in">f</span>(l)&amp;&amp;mx[u].<span class="built_in">f</span>(r)&gt;=A.<span class="built_in">f</span>(r)) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mx[u].<span class="built_in">f</span>(mid)&lt;A.<span class="built_in">f</span>(mid)) <span class="built_in">swap</span>(mx[u],A);</span><br><span class="line">		<span class="keyword">if</span>(A.k&lt;mx[u].k) <span class="built_in">add</span>(ls,A);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(rs,A);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll val[N],ans;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> siz[N],mxsiz[N],rt;</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],cnt;</span><br><span class="line"><span class="type">int</span> st[N],len[N],from[N],top;</span><br><span class="line">ll sum[N],val1[N],val2[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; mxsiz[u]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v]&amp;&amp;v!=fa[u])</span><br><span class="line">		&#123;</span><br><span class="line">			fa[v]=u;</span><br><span class="line">			<span class="built_in">getroot</span>(v,cnt);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			mxsiz[u]=<span class="built_in">max</span>(mxsiz[u],siz[v]);</span><br><span class="line">		&#125;</span><br><span class="line">	mxsiz[u]=<span class="built_in">max</span>(mxsiz[u],cnt-siz[u]);</span><br><span class="line">	<span class="keyword">if</span>(mxsiz[rt]&gt;mxsiz[u]) rt=u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll v1,ll v2,ll s,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u]=dep[fa[u]]+<span class="number">1</span>;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		<span class="keyword">if</span>(!vis[v]&amp;&amp;v!=fa[u])</span><br><span class="line">		&#123;</span><br><span class="line">			fa[v]=u; flag=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(v,v1+s+val[v],v2+<span class="number">1ll</span>*dep[u]*val[v],s+val[v],id);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(!flag)</span><br><span class="line">	&#123;</span><br><span class="line">		st[++top]=u; cnt=<span class="built_in">max</span>(cnt,dep[u]);</span><br><span class="line">		len[top]=dep[u]; val1[top]=v1; val2[top]=v2; from[top]=id; sum[top]=s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	st[top=<span class="number">0</span>]=<span class="number">-1</span>; dep[u]=<span class="number">1</span>; cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!vis[v]) fa[v]=u,<span class="built_in">dfs</span>(v,<span class="number">0ll</span>+val[u]*<span class="number">2</span>+val[v],val[v],val[v]+val[u],v);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,top) sum[i]-=val[u],ans=<span class="built_in">max</span>(ans,val1[i]),ans=<span class="built_in">max</span>(ans,val2[i]+sum[i]+val[u]);</span><br><span class="line">	st[top+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">	SGT::<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j;i&lt;=top;i=j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i;from[i]==from[j];j++) ans=<span class="built_in">max</span>(ans,SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,len[j])+val1[j]);</span><br><span class="line">		<span class="keyword">for</span>(j=i;from[i]==from[j];j++) SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,(line)&#123;sum[j],val2[j]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	SGT::<span class="built_in">init</span>(<span class="number">1</span>,<span class="number">1</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=top,j;i;i=j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=i;from[i]==from[j];j--) ans=<span class="built_in">max</span>(ans,SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,len[j])+val1[j]);</span><br><span class="line">		<span class="keyword">for</span>(j=i;from[i]==from[j];j--) SGT::<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,cnt,(line)&#123;sum[j],val2[j]&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">calc</span>(u);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(vis[v]||siz[v]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		fa[v]=<span class="number">0</span>; rt=<span class="number">0</span>; <span class="built_in">getroot</span>(v,siz[v]); <span class="built_in">solve</span>(rt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) val[i]=<span class="built_in">read</span>();</span><br><span class="line">	mxsiz[rt=<span class="number">0</span>]=(<span class="type">int</span>)<span class="number">1e9</span>;</span><br><span class="line">	<span class="built_in">getroot</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">solve</span>(rt);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>点分治</tag>
        <tag>并查集</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>Easy Math Problem[hdu6607]</title>
    <url>/2020/02/28/Easy-Math-Problem-hdu6607/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6607">链接</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>求 $\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^k\text{lcm}(i,j)[\gcd(i,j)\in \mathbb{P}]\pmod{10^9+7}$.</p>
<p>$n\leq 10^{10}$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h4><p>化简一波：</p>
<p>$$\sum_{i=1}^n\sum_{j=1}^n\gcd(i,j)^k\text{lcm}(i,j)[\gcd(i,j)\in \mathbb{P}]\=\sum_{d=1}^nd^{k-1}[d\in \mathbb{P}]\sum_{i=1}^n\sum_{j=1}^nij[\gcd(i,j)==d]\=\sum_{d=1}^nd^{k+1}[d\in \mathbb{P}]\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{n}{d}}ij[\gcd(i,j)==1]$$</p>
<p>设 $f(n)=\sum_{i=1}^n\sum_{j=1}^{n}ij[\gcd(i,j)==1]$。</p>
<p>则会有：$f(n)=2\sum_{i=1}^ni\sum_{j=1}^{i-1}j[\gcd(i,j)==1]+\sum_{i=1}^ni^2[\gcd(i,i)==1]$</p>
<p>由经典恒等式：$\sum_{j=1}^{n-1}j[\gcd(n,j)==1]=\frac{n\varphi(n)-[n==1]}{2}$ 可得：</p>
<p>$$f(n)=2(\sum_{i=1}^ni\frac{i\varphi(i)-[i==1]}{2})-1=\sum_{i=1}^{n}i^2\varphi(i)$$</p>
<p>故原式可化简为 ：$\sum_{d=1}^nd^{k+1}[d\in \mathbb{P}]f(\left \lfloor \frac{n}{d} \right \rfloor)$</p>
<p>显然整除分块。现在变成求两部分。</p>
<h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>对于所有的 $\left \lfloor \frac{n}{i} \right \rfloor$，求 $f(\left \lfloor \frac{n}{i} \right \rfloor)$。</p>
<p>显然杜教筛。</p>
<p>设函数 $g(i)=i^2$，则有：</p>
<p>$$(f*g)(n)=\sum_{d|n}f(d)g(\frac{n}{d})=\sum_{d|n}d^2\varphi(i)\frac{n^2}{d^2}=n^2\sum_{d|n}\varphi(d)=n^3$$</p>
<p>设 $S(i)=\sum_{i=1}^nf(i)$，那么就有：$S(n)g(1)=\sum_{i=1}^n(f*g)(i)-\sum_{i=2}^ng(i)S(\left \lfloor \frac{n}{i} \right \rfloor)$</p>
<p>即：$S(n)=\sum_{i=1}^ni^3-\sum_{i=1}^ni^2S(\left \lfloor \frac{n}{i} \right \rfloor)$。</p>
<p>这样就可以求出来了。</p>
<p>时间复杂度 $O(n^{\frac{2}{3}})$。</p>
<h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h4><p>对于所有的 $\left \lfloor \frac{n}{i} \right \rfloor$，求 $\sum_{i=1}^ni^{k+1}[i\in \mathbb{P}]$。</p>
<p>Min25筛模板题。</p>
<p>求 $g(n,0)$ 的时候需要求自然数的 $k+1$ 次幂和，拉格朗日插值即可。</p>
<p>时间复杂度 $O(k\sqrt{n}+\frac{n^{\frac{3}{4}}}{\log n})$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y%mod; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll inv4=<span class="built_in">Pow</span>(<span class="number">4</span>,mod<span class="number">-2</span>);</span><br><span class="line"><span class="type">const</span> ll inv6=<span class="built_in">Pow</span>(<span class="number">6</span>,mod<span class="number">-2</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">500010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">111</span>;</span><br><span class="line">ll pri[N&gt;&gt;<span class="number">3</span>],phi[N],sg[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;pri[++tot]=i; phi[i]=i<span class="number">-1</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;(t=(ll)pri[j]*i)&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[t]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) &#123;phi[t]=phi[i]*pri[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">			phi[t]=phi[i]*(pri[j]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) sg[i]=<span class="built_in">Add</span>(sg[i<span class="number">-1</span>],<span class="number">1ll</span>*i*i%mod*phi[i]%mod);</span><br><span class="line">&#125;</span><br><span class="line">ll fac[K],inv[K];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_fac</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll n,ans,Sqr; <span class="type">int</span> k;</span><br><span class="line">map&lt;ll,ll&gt; ma;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S3</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n%=mod;</span><br><span class="line">	n=n*(n+<span class="number">1</span>)/<span class="number">2</span>%mod;</span><br><span class="line">	<span class="keyword">return</span> n*n%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S2</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n%=mod;</span><br><span class="line">	<span class="keyword">return</span> n*(n+<span class="number">1</span>)%mod*(n*<span class="number">2</span>+<span class="number">1</span>)%mod*inv6%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;N) <span class="keyword">return</span> sg[n];</span><br><span class="line">	<span class="keyword">if</span>(ma[n]!=<span class="number">0</span>) <span class="keyword">return</span> ma[n];</span><br><span class="line">	ll ans=<span class="built_in">S3</span>(n);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j=n/(n/i);</span><br><span class="line">		ans=<span class="built_in">Dec</span>(ans,<span class="built_in">S</span>(n/i)%mod*(<span class="built_in">S2</span>(j)-<span class="built_in">S2</span>(i<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ma[n]=ans;</span><br><span class="line">&#125;</span><br><span class="line">ll pre[K],suf[K],y[K];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Lagrange</span><span class="params">(ll n,<span class="type">int</span> k,ll sum=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n%=mod; pre[<span class="number">0</span>]=<span class="number">1</span>; suf[k+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) pre[i]=<span class="built_in">Mul</span>(pre[i<span class="number">-1</span>],(n-i+mod)%mod);</span><br><span class="line">	<span class="built_in">fd</span>(i,k,<span class="number">1</span>) suf[i]=<span class="built_in">Mul</span>(suf[i+<span class="number">1</span>],(n-i+mod)%mod);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) sum=<span class="built_in">Add</span>(sum,<span class="built_in">Mul</span>(pre[i<span class="number">-1</span>],suf[i+<span class="number">1</span>])*<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(y[i],inv[i<span class="number">-1</span>]),<span class="built_in">Mul</span>(inv[k-i],((k-i)&amp;<span class="number">1</span>)?mod<span class="number">-1</span>:<span class="number">1</span>))%mod);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> id1[M],id2[M];</span><br><span class="line">ll g[M],w[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Min25</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k+<span class="number">2</span>) y[i]=<span class="built_in">Add</span>(y[i<span class="number">-1</span>],<span class="built_in">Pow</span>(i,k));</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j=n/(n/i); w[++m]=n/i;</span><br><span class="line">		<span class="keyword">if</span>(w[m]&lt;=Sqr) id1[w[m]]=m; <span class="keyword">else</span> id2[n/w[m]]=m;</span><br><span class="line">		g[m]=<span class="built_in">Lagrange</span>(w[m],k+<span class="number">2</span>)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll qm=<span class="number">0</span>;</span><br><span class="line">	g[m+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,tot)</span><br><span class="line">	&#123;</span><br><span class="line">		ll tmp=pri[i]*pri[i],p=<span class="built_in">Pow</span>(pri[i],k),t;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;tmp&lt;=w[j];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			t=w[j]/pri[i];</span><br><span class="line">			t=(t&lt;=Sqr)?id1[t]:id2[n/t];</span><br><span class="line">			g[j]=<span class="built_in">Dec</span>(g[j],p*(g[t]-qm+mod)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">		qm=<span class="built_in">Add</span>(qm,p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init_prime</span>(N<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">init_fac</span>(K<span class="number">-5</span>);</span><br><span class="line">	CASET</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">		Sqr=<span class="built_in">sqrt</span>(n); ans=<span class="number">0</span>; ma.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">Min25</span>();</span><br><span class="line">		<span class="keyword">for</span>(ll i=<span class="number">1</span>,j,l=m,h;i&lt;=n;i=j+<span class="number">1</span>,l--)</span><br><span class="line">		&#123;</span><br><span class="line">			j=n/(n/i);</span><br><span class="line">			h=(g[l]-g[l+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">S</span>(n/i),h));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>拉格朗日插值</tag>
        <tag>Min25筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的函数[loj6053]</title>
    <url>/2020/02/27/%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0-loj6053/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义一函数 $f$：</p>
<p>$$f(n)=\begin{cases}<br>1 &amp; \text{ if } n=1 \\<br>p \bigoplus c &amp; \text{ if } n=p^c,p\in \mathbb{P} \\<br>f(a)f(b) &amp; \text{ if } n=ab,\gcd(a,b)=1<br>\end{cases}$$</p>
<p>求 $\sum_{i=1}^{n}f(i)$ 的值。</p>
<p>$n\leq 10^{10}$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然是Min25筛。</p>
<p>来看看Min25筛的前提条件：</p>
<ul>
<li>$f$ 是积性函数。这个显然。</li>
<li>$f(p^k)$ 可以很快算出来，这个也显然。</li>
<li>$\sum_{i=1}^n[i\in \mathbb{P}]f(i)$ 能被 $\sum_{i=1}^n[i\in \mathbb{P}] i^k$ 表示出来。显然当 $i&gt;2,i\in \mathbb{P}$ 时，有：$f(i)=i-1$。那么把 $f(2)$ 也当做 $2-1$，最后加上 $2$。因此有：$\sum_{i=1}^n[i\in \mathbb{P}]f(i)=\sum_{i=1}^n[i\in \mathbb{P}]i^1-i^0$。算两个 $i^k$ 即可。</li>
</ul>
<p>时间复杂度 $O(\frac{n^{\frac{3}{4}}}{\log n})$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000000</span>;</span><br><span class="line">ll n,m,Sqr,pri[N],sp[N],id1[N],id2[N],w[N];</span><br><span class="line">ll h[N],g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;pri[++tot]=i; sp[tot]=(sp[tot<span class="number">-1</span>]+i)%mod;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;<span class="number">1ll</span>*i*pri[j]&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>||pri[j]&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll t=(n&lt;=Sqr)?id1[n]:id2[::n/n];</span><br><span class="line">	ll ans=(mod+(g[t]-sp[j<span class="number">-1</span>])-(h[t]-(j<span class="number">-1</span>))%mod)%mod;</span><br><span class="line">	<span class="keyword">if</span>(j==<span class="number">1</span>) ans+=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=tot&amp;&amp;pri[k]*pri[k]&lt;=n;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll tmp=pri[k];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">1</span>;tmp*pri[k]&lt;=n;q++,tmp*=pri[k])</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,<span class="built_in">Add</span>(pri[k]^(q+<span class="number">1</span>),<span class="built_in">Mul</span>(pri[k]^q,<span class="built_in">S</span>(n/tmp,k+<span class="number">1</span>))));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n); Sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="built_in">init_prime</span>(Sqr);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j=n/(n/i); w[++m]=n/i;</span><br><span class="line">		h[m]=(w[m]<span class="number">-1</span>)%mod;</span><br><span class="line">		g[m]=(w[m]%mod)*((w[m]+<span class="number">1</span>)%mod)%mod*inv2%mod<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(w[m]&lt;=Sqr) id1[w[m]]=m;</span><br><span class="line">		<span class="keyword">else</span> id2[j]=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll k=pri[i]*pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;k&lt;=w[j];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t=(w[j]/pri[i]&lt;=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];</span><br><span class="line">			h[j]=<span class="built_in">Add</span>(h[j],(mod-(h[t]-(i<span class="number">-1</span>)%mod))%mod);</span><br><span class="line">			g[j]=<span class="built_in">Add</span>(g[j],mod<span class="number">-1ll</span>*pri[i]*(g[t]-sp[i<span class="number">-1</span>]+mod)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="built_in">S</span>(n,<span class="number">1</span>)+<span class="number">1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>loj</category>
      </categories>
      <tags>
        <tag>Min25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>破忒头的匿名信[2020 CCPC Wannafly WC Day2]</title>
    <url>/2020/02/27/%E7%A0%B4%E5%BF%92%E5%A4%B4%E7%9A%84%E5%8C%BF%E5%90%8D%E4%BF%A1-2020-CCPC-Wannafly-WC-Day2/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/contest/4010/K">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然DP，设 $f_i$ 为考虑前 $i$ 位的最小值是什么。</p>
<p>考虑AC自动机上一直跳fail链，遇到一个是结尾的点就说明存在一个后缀在词典中出现。</p>
<p>但是这样时间复杂度是 $O(n^2)$ 的，然而过了。。。</p>
<p>这里有一个很重要的性质：一条fail链中，是结尾的节点不超过 $\sqrt n$ 个。</p>
<p>证明显然。最差的情况是：$a,aa,aaa,\cdots$。</p>
<p>那么只需在AC自动机中记录fail链中最早遇到的节点就可以了。</p>
<p>时间复杂度 $O(n\sqrt n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> AC&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],val[N],len[N],fail[N],cnt,anc[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="number">0</span>,c,n=<span class="built_in">strlen</span>(s);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			c=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!ne[u][c]) ne[u][c]=++cnt;</span><br><span class="line">			u=ne[u][c];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!val[u]) val[u]=v;</span><br><span class="line">		<span class="keyword">else</span> val[u]=<span class="built_in">min</span>(val[u],v);</span><br><span class="line">		len[u]=n;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getfail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> u,v;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			anc[u]=val[fail[u]]?fail[u]:anc[fail[u]];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S;i++)</span><br><span class="line">				<span class="keyword">if</span>(v=ne[u][i])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(!u) fail[v]=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">else</span> fail[v]=ne[fail[u]][i];</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> ne[u][i]=ne[fail[u]][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ll f[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">work</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,u=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i]=inf;</span><br><span class="line">			u=ne[u][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=u;j;j=anc[j])</span><br><span class="line">				f[i]=<span class="built_in">min</span>(f[i],f[i-len[j]]+val[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f[n]==inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">return</span> f[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) &#123;<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); AC::<span class="built_in">ins</span>(s,<span class="built_in">read</span>());&#125;</span><br><span class="line">	AC::<span class="built_in">getfail</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,AC::<span class="built_in">work</span>(s));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 621[CF1307]</title>
    <url>/2020/02/26/Codeforces-Round-621-CF1307/</url>
    <content><![CDATA[<p><a href="<http://codeforces.com/contest/1307">链接</a></p>
<span id="more"></span>

<h3 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h3><p>暴力贪心即可。</p>
<h3 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h3><p>显然一直用最大值跳，跳到总和大于 $x$ 就可以了。</p>
<p>注意特判最大值 $&gt;x$ 的情况。</p>
<h3 id="Problem-C"><a href="#Problem-C" class="headerlink" title="Problem C"></a>Problem C</h3><p>显然出现次数最多时，该字符串的长度只为 $1$ 或 $2$。</p>
<p>前缀和计算一下就好了。</p>
<h3 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h3><p>一道好题。</p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给 $n$ 个点 $m$ 条边的无向图。现在你需要在图中加上一条不是自环的边，使得最短路最大。这条边的两个顶点必须在给定的集合 $S$ 内。</p>
<p>$n,m\leq 2\times 10^5,|S|\leq n$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>分类讨论：</p>
<p>1，这条边无法影响添加前的答案，此时答案为 $dis_{1,n}$</p>
<p>2，这条能影响答案：</p>
<p>设 $f_i$ 表示点 $i$ 到 $1$ 的距离，$g_i$ 表示点 $i$ 到 $n$ 的距离。这个可以用BFS求出。</p>
<p>题目转换成，给 $|S|$ 个点，每个点有两个值 $f_i,g_i$ ，需要选两个点，使得 $\min(f_i+g_j,f_j+g_i)+1$ 最大。</p>
<p>不妨假设 $f_i+g_j\leq f_j+g_i$，亦即 $f_i-g_i\leq f_j-g_j$。</p>
<p>因此对于每个点，按 $f_i-g_i$ 从小到大排序。枚举点 $i$，求出前缀最大的 $g_j$即可。</p>
<p>时间复杂度 $O(n\log n+m)$。</p>
<h4 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> f[N],g[N],a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> *dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) dis[i]=inf;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(q.<span class="built_in">push</span>(s);!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">			<span class="keyword">if</span>(dis[v]==inf)</span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans,mx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,k) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>,f); <span class="built_in">bfs</span>(n,g);</span><br><span class="line">	ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+k+<span class="number">1</span>,[&amp;](<span class="type">const</span> <span class="type">int</span> &amp;x,<span class="type">const</span> <span class="type">int</span> &amp;y)&#123;<span class="keyword">return</span> f[x]-g[x]&lt;f[y]-g[y];&#125;);</span><br><span class="line">	mx=f[a[<span class="number">1</span>]];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,k)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,mx+g[a[i]]);</span><br><span class="line">		mx=<span class="built_in">max</span>(mx,f[a[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">min</span>(ans+<span class="number">1</span>,f[n]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-E"><a href="#Problem-E" class="headerlink" title="Problem E"></a>Problem E</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>令一道好题。</p>
<p>$m$ 头奶牛，每头奶牛的类型为 $f_i$，能吃 $h_i$ 个草。$n$ 个草坪从左到右排列，每个草坪当中长了类型为 $g_i$ 的奶牛才能吃的一单位的草，被牛吃后不再长草。</p>
<p>奶牛从左或者从右边出发，一直吃下去，直到吃了 $h_i$ 个草后，睡在那个位置。</p>
<p>一种合法的吃草方案为安排一些奶牛吃草，每只奶牛走的时候不能跨过睡着的奶牛。</p>
<p>两种方案不同当且仅当存在某只奶牛在一种方案出现而在另一种方案不出现或者某只奶牛的出发点不同。</p>
<p>求出合法的吃草方案中，最多能选出多少奶牛，以及此时的情况总数对 $10^9+7$ 取模后的值。</p>
<p>$n,m\leq 5000$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>听说有 $O(n)$ 或 $O(n\log n)$ 做法。。。</p>
<p>显然的是，相同类型的奶牛只能最多放两只。</p>
<p>不妨试试枚举分界点 $k$。</p>
<p>从左边走的和从右边走的都不能跨过 $k$。然后对于每种奶牛的类型算方案数，相乘起来加进贡献里。</p>
<p>设 $l$ 为只能从左边走的奶牛数量，$r$ 为只能从右边走的奶牛数量，$b$ 为都能走的奶牛数量。</p>
<p>分类讨论一下：</p>
<ul>
<li><p>用两只奶牛走的方案数，$l\cdot b+r\cdot b+b\cdot (b-1)$。</p>
</li>
<li><p>只用一只奶牛走的方案数，$l+r+2b$。</p>
</li>
</ul>
<p>当 $l\cdot b+r\cdot b+b\cdot (b-1)&gt;0$ 的时候就必须用两只。</p>
<p>暴力计算，时间复杂度 $O(n^2)$。</p>
<p>但是这样算会算重，因为一种方案可能对应多个分界点。</p>
<p>强行将分界点靠左，也就是枚举左边的集合中，跑得最远的奶牛是哪个，这样就不会算重了。</p>
<p>需要注意一些细节。</p>
<h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5003</span>;</span><br><span class="line"><span class="type">int</span> n,m,w[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f[N],L[N],R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) w[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),f[x].<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">	f[<span class="number">0</span>].<span class="built_in">pb</span>(<span class="number">0</span>); L[<span class="number">0</span>].<span class="built_in">pb</span>(<span class="number">0</span>); R[<span class="number">0</span>].<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(f[i].<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">sort</span>(<span class="built_in">all</span>(f[i]));</span><br><span class="line">			<span class="type">int</span> k,l;</span><br><span class="line">			k=<span class="number">0</span>; l=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">				<span class="keyword">if</span>(w[j]==i&amp;&amp;l&lt;f[i].<span class="built_in">size</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					k++;</span><br><span class="line">					<span class="keyword">if</span>(f[i][l]==k) L[i].<span class="built_in">pb</span>(j),l++;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,l,f[i].<span class="built_in">size</span>()<span class="number">-1</span>) L[i].<span class="built_in">pb</span>(n+<span class="number">1</span>);</span><br><span class="line">			k=<span class="number">0</span>; l=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">fd</span>(j,n,<span class="number">1</span>)</span><br><span class="line">				<span class="keyword">if</span>(w[j]==i&amp;&amp;l&lt;f[i].<span class="built_in">size</span>())</span><br><span class="line">				&#123;</span><br><span class="line">					k++;</span><br><span class="line">					<span class="keyword">if</span>(f[i][l]==k) R[i].<span class="built_in">pb</span>(j),l++;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,l,f[i].<span class="built_in">size</span>()<span class="number">-1</span>) R[i].<span class="built_in">pb</span>(<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="type">int</span> siz=<span class="number">0</span>; ll sum=<span class="number">1</span>;</span><br><span class="line">	ll l,r,lr,s,tmp; <span class="type">int</span> sz;</span><br><span class="line">	<span class="built_in">fo</span>(x,<span class="number">0</span>,n)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> k:L[x])</span><br><span class="line">			<span class="keyword">if</span>(k!=n+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sz=<span class="number">0</span>; s=<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">					<span class="keyword">if</span>(f[i].<span class="built_in">size</span>())</span><br><span class="line">					&#123;</span><br><span class="line">						l=r=lr=<span class="number">0</span>;</span><br><span class="line">						<span class="built_in">fo</span>(j,<span class="number">0</span>,f[i].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(L[i][j]&lt;k&amp;&amp;R[i][j]&gt;k) lr++;</span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span>(L[i][j]&lt;=k) l++;<span class="comment">//!!!</span></span><br><span class="line">							<span class="keyword">else</span> <span class="keyword">if</span>(R[i][j]&gt;k) r++;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span>(i==x) &#123;r+=lr; l=lr=<span class="number">0</span>;&#125;</span><br><span class="line">						<span class="keyword">if</span>((tmp=l*r+l*lr+r*lr+lr*(lr<span class="number">-1</span>))&gt;<span class="number">0</span>) sz+=<span class="number">2</span>,s=<span class="built_in">Mul</span>(s,tmp%mod);</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span>((tmp=l+r+lr*<span class="number">2</span>)&gt;<span class="number">0</span>) sz++,s=<span class="built_in">Mul</span>(s,tmp%mod);</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">if</span>(x) sz++;</span><br><span class="line">				<span class="keyword">if</span>(!sz) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(sz&gt;siz) siz=sz,sum=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(sz==siz) sum=<span class="built_in">Add</span>(sum,s);</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,siz,sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-F"><a href="#Problem-F" class="headerlink" title="Problem F"></a>Problem F</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>一棵树中，有些给定的点作为中转站，可以加满油。车的油箱容量为 $k$ ，初始是满的。每走一条边消耗 $1$。容量为 $0$ 时不能继续走。</p>
<p>$m$ 次询问，问是否能从 $u_i$ 走到 $v_i$。</p>
<p>$n,m\leq 2\times 10^5$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>记一个中转站 $i$ 向外走 $\leq \frac{k}{2}$ 步后（可以走到边上）形成的集合是 $S_i$，若 $S_i$ 和 $S_j$ 的交集不为空则两点间可以互相到达，能互相到达这个条件满足传递性，因此可以用并查集合并之。</p>
<p>每次询问的时候亦可以把起点与终点当做一个临时的中转站。</p>
<p>但是这个 $\frac{k}{2}$ 步比较麻烦，它可以走到一条边的中点上。因此在每条边的中点处多加一个点，变成走 $k$ 步即可。</p>
<p>这个走 $k$ 步可以用BFS实现。</p>
<p>那么首先判断一下两点间的距离是否 $\leq 2k$，如果是，直接输出’YES’就好了。</p>
<p>否则就都向对方跳 $k$ 步，然后判断跳完后两点是否在同一个集合内就可以了。</p>
<p>这个跳 $k$ 步可以用树剖或者倍增实现。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<h4 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,anc[N],k,r,rt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line"><span class="type">int</span> f[N],dis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	adj[x].<span class="built_in">pb</span>(y); adj[y].<span class="built_in">pb</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (f[x]==x)?x:f[x]=<span class="built_in">find</span>(f[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="built_in">find</span>(x); y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x!=y) f[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n*<span class="number">2</span>) f[i]=i,dis[i]=inf;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,r) x=<span class="built_in">read</span>(),dis[x]=<span class="number">0</span>,q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">merge</span>(u,v);</span><br><span class="line">			<span class="keyword">if</span>(dis[v]==inf)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[v]=dis[u]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(dis[v]!=k) q.<span class="built_in">push</span>(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> g[N][<span class="number">19</span>],siz[N],dep[N],fa[N],son[N],top[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	siz[u]=<span class="number">1</span>; dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">	fa[u]=g[u][<span class="number">0</span>]=pre;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=dep[u];i++) g[u][i]=g[g[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(v!=pre)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">		<span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top[u]=tp;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) <span class="built_in">dfs2</span>(son[u],tp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:adj[u]) <span class="keyword">if</span>(!top[v]) <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(;top[x]!=top[y];x=fa[top[x]])</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])</span><br><span class="line">			<span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">		<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;k)</span><br><span class="line">			x=g[x][i];</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=dep[x]-dep[z]) <span class="keyword">return</span> <span class="built_in">jump</span>(x,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">jump</span>(y,dep[x]+dep[y]-(dep[z]&lt;&lt;<span class="number">1</span>)-k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>(); r=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x,y,z,_x,_y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(); y=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(x,i+n); <span class="built_in">add</span>(i+n,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(_,<span class="number">1</span>,<span class="built_in">read</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),z=<span class="built_in">lca</span>(x,y);</span><br><span class="line">		<span class="keyword">if</span>(dep[x]+dep[y]-(dep[z]&lt;&lt;<span class="number">1</span>)&lt;=k*<span class="number">2</span>) &#123;<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		_x=<span class="built_in">jump</span>(x,y,z); _y=<span class="built_in">jump</span>(y,x,z);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="built_in">find</span>(_x)==<span class="built_in">find</span>(_y)?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>贪心</tag>
        <tag>bfs</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>Clock Tree[USACO 2020 February Silver]</title>
    <url>/2020/02/25/Clock-Tree-USACO-2020-February-Silver/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个 $n$ 个点的树，点有点权 $a_i$，每次选择一个相连的点，每走一次到该点，该点的点权变为 $(a_i+1)\bmod k$。</p>
<p>可以从任意点开始，任意点结束，能重复经过多次。</p>
<p>问有多少个出发点，满足最后存在一种方案使得点权均为 $0$。</p>
<p>原题：$n\leq 2500,k=12$</p>
<p>加强版：$n\leq 2\times 10^6,k\leq 10^9$。</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="Part-0-n-leq-2500-，必须走回出发点"><a href="#Part-0-n-leq-2500-，必须走回出发点" class="headerlink" title="Part 0:$n\leq 2500$，必须走回出发点"></a>Part 0:$n\leq 2500$，必须走回出发点</h4><p>首先必须明白一点，如果一条边的两端点全是 $0$，我们也还是可以走的。因为来回走 $k$ 次不就好了嘛。 </p>
<p>假设枚举出发点，然后以该出发点为根。看子树内是否满足。</p>
<p>比较像树形DP的形式。</p>
<p>考虑DP的本质，是将一个大问题变成若干个子问题。</p>
<p>能否设置一个状态，表示子树内，除了这个点以外的点全变为 $0$ 后，该点还要变多少次才能变为 $0$。</p>
<p>转移的时候让父亲和儿子相互抵消，使得儿子变为 $0$，然后父亲此时的状态可以 $O(1)$ 计算。</p>
<p>显然是可以的。设为 $f_i$。</p>
<p>那么有：$f_u\equiv -a_u-\sum_{v\in son_u}f_v(\bmod k)$</p>
<p>最后必须满足 $f_{root}$ 为 $0$ ，$root$ 才能满足条件。</p>
<p>枚举 $root$，$O(n)$ 树形DP，计算是否可行。</p>
<h4 id="Part-1-n-leq-2500"><a href="#Part-1-n-leq-2500" class="headerlink" title="Part 1:$n\leq 2500$"></a>Part 1:$n\leq 2500$</h4><p>是否能把上面的思路转移过来呢？</p>
<p>试一下吧。</p>
<p>还是枚举根节点（出发点）。</p>
<p>考虑最后一次经过根节点的情况，如果要满足条件，那么只能剩下一条 $k-1$ 的链，且此时根节点为 $0$。</p>
<p>如图所示：</p>
<p><img src="/Clock-Tree-USACO-2020-February-Silver/1.png" alt="1"></p>
<p>那么可以发现，如果让链上最后两个 $k-1$ 相互抵消，那么一直抵消下去，最后最多剩下一个 $k-1$，再让这个 $k-1$ 和根节点相互抵消，此时根节点变为了 $1$。也就是说，根节点还需要 $k-1$ 次才变为 $0$。这种情况也是可以的，即 $f_{root}=k-1$。</p>
<p>时间复杂度 $O(n^2)$。</p>
<p><strong>到这里就做完了原题。</strong></p>
<h4 id="Part-2-n-leq-10-6"><a href="#Part-2-n-leq-10-6" class="headerlink" title="Part 2:$n\leq 10^6$"></a>Part 2:$n\leq 10^6$</h4><p>显然换根DP就好了。</p>
<p>时间复杂度 $O(n)$，需要两遍dfs，常数有点大。</p>
<h4 id="Part-3-n-leq-2-times-10-6"><a href="#Part-3-n-leq-2-times-10-6" class="headerlink" title="Part 3:$n\leq 2\times 10^6$"></a>Part 3:$n\leq 2\times 10^6$</h4><p>考虑转移方程到底是什么：$f_u\equiv -a_u-\sum_{v\in son_u}f_v(\bmod k)$。</p>
<p>假设以 $1$ 为根节点。</p>
<p>那么处于奇数层的 $u$ 的贡献是 $+a_u$，偶数层的 $u$ 的贡献是 $-a_u$。</p>
<p>而显然偶数层的点的最终答案是一样的。</p>
<p>奇数层的答案是偶数层的相反数。</p>
<p>因此直接暴算就好了，维护一下层数的奇偶性，就dfs也不用了。</p>
<p><del>这还是树形DP吗？</del></p>
<p>注意 $n=1$ 的特判。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,k,a[N];</span><br><span class="line">ll s1[<span class="number">2</span>],s2[<span class="number">2</span>],ans,tmp;</span><br><span class="line"><span class="type">bool</span> d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,(a[<span class="number">1</span>]?<span class="number">0</span>:<span class="number">1</span>))&amp;<span class="number">0</span>;</span><br><span class="line">	s1[<span class="number">0</span>]++; s2[<span class="number">0</span>]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		d[i]=d[<span class="built_in">read</span>()]^<span class="number">1</span>;</span><br><span class="line">		s1[d[i]]+=i,s2[d[i]]+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	tmp=(s2[<span class="number">1</span>]%k-s2[<span class="number">0</span>]%k+k)%k;</span><br><span class="line">	<span class="keyword">if</span>(tmp==<span class="number">0</span>||tmp==k<span class="number">-1</span>) ans+=s1[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span>(tmp==<span class="number">0</span>||tmp==  <span class="number">1</span>) ans+=s1[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans)&amp;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Min25筛</title>
    <url>/2020/02/25/Min25%E7%AD%9B/</url>
    <content><![CDATA[<p>Min25筛总结。</p>
<span id="more"></span>

<h3 id="一些记号"><a href="#一些记号" class="headerlink" title="一些记号"></a>一些记号</h3><p>1，记 $[A]$ 为表示式 $A$ 的真假。若 $A$ 为真则为 $1$，否则为 $0$。</p>
<p>2，记 $\mathbb{P}$ 为质数集合。</p>
<p>3，记 $P_i$ 为质数集合中第 $i$ 小的数。</p>
<p>4，记 $\min_i(p)$ 为 $i$ 的最小质因子。</p>
<p>5，记 $\pi(n)$ 为 $n$ 以内的质数个数。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这个东东其实不是筛法。。。只是每个人都这么叫。</p>
<p>Min25筛是用来解决一些求积性函数前缀和的问题。设该函数为 $f(i)$，前提为：1， $f(i)$ 为积性函数；2， $\sum_{i=1}^n[i\in\mathbb{P}]f(i)$ 可以通过 $\sum_{i=1}^n[i\in\mathbb{P}]i^k$ 很容易地表示出来，或者直接快速算；3，$f(p^k)$ 可以快速计算。</p>
<p>时间复杂度为 $O(\frac{n^{\frac{3}{4}}}{\log n})$，空间复杂度为 $O(\sqrt n)$。</p>
<p>大概能算一两次 $10^{11}$ 到 $10^{12}$ 的样子。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h4><p>先来看看 $\sum_{i=1}^n[i\in \mathbb{P}]f(i)$ 怎么算。</p>
<p>根据前提条件，这个要用 $\sum_{i=1}^n[i\in \mathbb{P}]i^k$ 表示出来。</p>
<p>也就是 $\sum_{i=1}^n[i\in \mathbb{P}]i^k$ 怎么算。</p>
<p>设 $g(n,j)=\sum_{i=1}^{n}[i\in \mathbb{P}<del>or</del>\min_i(p)&gt; P_j]$，再看看这个怎么算。</p>
<p>相当于<strong>埃氏筛</strong>筛前 $n$ 个数中，筛完第 $j$ 个质数后，剩下的那些数的和。</p>
<p>考虑这个 $g(n,j)$ 是怎么转移的。如果从 $g(n,j-1)$ 转移过来的话，那么我们需要减掉第 $j$ 次埃氏筛过程中删掉的那些数的和。</p>
<p>也就是 $\min_{i}(p)=P_j$ 的 $i^k$ 的和。</p>
<p>分类讨论：</p>
<ul>
<li>若 $P_j^2 &gt; n$，那么第 $j$ 次埃氏筛就不会筛掉任何数，有 $g(n,j)=g(n,j-1)$。</li>
<li>若 $P_j^2\leq n$，那么第 $j$ 次埃氏筛筛的数就是 $\min_{i}(p)=P_j$ 的 $i^k$ 的和，也就是 $P_j^k(g(\left \lfloor \frac{n}{P_j} \right \rfloor,j-1)-g(P_{j-1},j-1))$。可以理解为先把一个 $P_j$ 提取出来，剩下的 $\left \lfloor \frac{n}{P_j} \right \rfloor$ 中 $\min_i(p)\geq P_j$ 的和。用 $g(\left \lfloor \frac{n}{P_j} \right \rfloor,j-1)$ 减掉前面的质数就好了。</li>
</ul>
<p>那么这个 $g(n,j)$ 可以通过 $g(*,j-1)$ 来算了。</p>
<p>即：</p>
<p>$$g(n,j)=\begin{cases}<br>g(n,j-1) &amp; \text{ if } P_j^2&gt;n \\<br>g(n,j-1)-P_j^k\left ( g(\left \lfloor \frac{n}{P_j} \right \rfloor,j-1)-g(P_{j-1},j-1) \right ) &amp; \text{ otherwise }<br>\end{cases}$$</p>
<p>而这个 $j$ 只需要考虑 $\sqrt n$ 以内的数就可以了。</p>
<p>考虑 $g(n,j)$ 怎么转移成 $\sum_{i=1}^n[i\in \mathbb{P}]i^k$，显然有 $\sum_{i=1}^n[i\in \mathbb{P}]i^k=g(n,\pi( \left \lfloor  \sqrt n\right \rfloor))$。</p>
<h4 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h4><p>现在再看看如何算 $\sum_{i=1}^nf(i)$。</p>
<p>设 $S(n,j)=\sum_{i=1}^{n}[\min_i(p)\geq P_j]f(i)$。</p>
<p>那么显然有：$\sum_{i=1}^nf(i)=S(n,1)+f(1)$。</p>
<p>考虑这个 $S(n,j)=\sum_{i=1}^{n}[\min_i(p)\geq P_j]f(i)$ 怎么算。</p>
<p>前面算质数算得这么辛苦，现在要用上了吧。。。</p>
<p>所以还是分类讨论一下。</p>
<ul>
<li>当 $i$ 是质数的时候，答案的和为 $\sum_{i=1}^{n}[i\in \mathbb{P}~and ~i\geq P_j]f(i)$，差分一下变成：$\sum_{i=1}^n[i \in \mathbb{P}]f(i)-\sum_{i=1}^{P_{j-1}}[i\in \mathbb{P}]f(i)$，前面一个显然是可以用 $g(n,\pi( \left \lfloor  \sqrt n\right \rfloor))$ 快速计算，后面一个也可以用 $g(P_{j-1},j-1)$ 快速计算。</li>
<li>当 $i$ 是合数的时候，由于 $f(i)$ 为积性函数，那么通过枚举最小质因子以及最小质因子的次数，删掉这个最小质因子，也就是：$\sum_{k=j}^{\sqrt n}\sum_{P_k^{q+1}\leq n}(f(P_k^q)S(\left \lfloor \frac{n}{P_k^q} \right \rfloor,k+1)+f(P_{k}^{q+1}))$。有一个 $f(P_{k}^{q+1})$ 是因为 $P_k^{q+1}$ 也被删掉了，需要补回来。</li>
</ul>
<p>因此，我们得到了：</p>
<p>$$S(n,j)=\left ( g(n,\pi( \left \lfloor  \sqrt n\right \rfloor)) \right )-g(P_{j-1},j-1))+ \sum_{k=j}^{\sqrt n}\sum_{P_k^{q+1}\leq n}(f(P_k^q)S(\left \lfloor \frac{n}{P_k^q} \right \rfloor,k+1)+f(P_{k}^{q+1}))$$</p>
<h4 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h4><p>最后来看看，需要的 $g$ 有哪些？</p>
<p>有两类，一类是 $g(\frac{n}{i},\pi( \left \lfloor  \sqrt \frac{n}{i}\right \rfloor))$，令一类是 $g(P_{j},j)$。第一类可以按照 Part 1 ，整除分块预处理出所有的 $g(\frac{n}{i},0)=\sum_{i=2}^{\frac{n}{i}}i^k$，然后枚举质数去计算。第二类实际上就是 $\sum_{i=1}^jf(P_i)^k$，而我们只需要用到 $\sqrt n$ 以内的质数，因此在筛的质数顺便算一算就可以了。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(\frac{n^{\frac{3}{4}}}{\log n})$</p>
<p>不会证。。。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="普通积性函数的前缀和"><a href="#普通积性函数的前缀和" class="headerlink" title="普通积性函数的前缀和"></a>普通积性函数的前缀和</h4><p>如 $\mu,\varphi$ 等。</p>
<p>$\mu$：当 $i$ 为质数时，$\mu(i)=-1$ ，</p>
<p>因此 $\sum_{i=1}^n[i\in \mathbb{P}]\mu(i)=-\sum_{i=1}^n[i\in \mathbb{P}]i^0$</p>
<p>$\varphi$：当 $i$ 为质数时，$\varphi(i)=i-1$，</p>
<p>因此 $\sum_{i=1}^n[i\in\mathbb{P}]\varphi(i)=(\sum_{i=1}^n[i\in \mathbb{P}]i^1)-(\sum_{i=1}^n[i\in \mathbb{P}]i^0)$</p>
<h4 id="LOJ-6053"><a href="#LOJ-6053" class="headerlink" title="LOJ 6053"></a><a href="https://loj.ac/problem/6053">LOJ 6053</a></h4><a href="/2020/02/27/%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0-loj6053/" title="题解见此">题解见此</a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll inv2=(mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	y%=(mod<span class="number">-1</span>);</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000000</span>;</span><br><span class="line">ll n,m,Sqr,pri[N],sp[N],id1[N],id2[N],w[N];</span><br><span class="line">ll h[N],g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_prime</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;pri[++tot]=i; sp[tot]=(sp[tot<span class="number">-1</span>]+i)%mod;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot&amp;&amp;<span class="number">1ll</span>*i*pri[j]&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i*pri[j]]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll n,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>||pri[j]&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll t=(n&lt;=Sqr)?id1[n]:id2[::n/n];</span><br><span class="line">	ll ans=(mod+(g[t]-sp[j<span class="number">-1</span>])-(h[t]-(j<span class="number">-1</span>))%mod)%mod;</span><br><span class="line">	<span class="keyword">if</span>(j==<span class="number">1</span>) ans+=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=j;k&lt;=tot&amp;&amp;pri[k]*pri[k]&lt;=n;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll tmp=pri[k];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">1</span>;tmp*pri[k]&lt;=n;q++,tmp*=pri[k])</span><br><span class="line">			ans=<span class="built_in">Add</span>(ans,<span class="built_in">Add</span>(pri[k]^(q+<span class="number">1</span>),<span class="built_in">Mul</span>(pri[k]^q,<span class="built_in">S</span>(n/tmp,k+<span class="number">1</span>))));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n); Sqr=<span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="built_in">init_prime</span>(Sqr);</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>,j;i&lt;=n;i=j+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		j=n/(n/i); w[++m]=n/i;</span><br><span class="line">		h[m]=(w[m]<span class="number">-1</span>)%mod;</span><br><span class="line">		g[m]=(w[m]%mod)*((w[m]+<span class="number">1</span>)%mod)%mod*inv2%mod<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(w[m]&lt;=Sqr) id1[w[m]]=m;</span><br><span class="line">		<span class="keyword">else</span> id2[j]=m;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll k=pri[i]*pri[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m&amp;&amp;k&lt;=w[j];j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t=(w[j]/pri[i]&lt;=Sqr)?id1[w[j]/pri[i]]:id2[n/(w[j]/pri[i])];</span><br><span class="line">			h[j]=<span class="built_in">Add</span>(h[j],(mod-(h[t]-(i<span class="number">-1</span>)%mod))%mod);</span><br><span class="line">			g[j]=<span class="built_in">Add</span>(g[j],mod<span class="number">-1ll</span>*pri[i]*(g[t]-sp[i<span class="number">-1</span>]+mod)%mod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(<span class="built_in">S</span>(n,<span class="number">1</span>)+<span class="number">1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Min25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛37</title>
    <url>/2020/02/22/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B37/</url>
    <content><![CDATA[<p>为什么打着打着溜了还能涨rating啊…</p>
<span id="more"></span>

<p><a href="https://ac.nowcoder.com/acm/contest/4381">链接</a></p>
<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>sb 数学题，输出 $2^{2n-3}$ 即可。</p>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>随便选几个质数，哈希判断一下就好了。</p>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>按题意递归即可，注意爆long long。</p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>笛卡尔坐标系中 $n$ 个点，求三个点组成的三角形的面积在 $[L,R]$ 范围内的个数。</p>
<p>$n\leq 3000$，不存在重点或三点共线。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>整场比赛就这题蛮好的。。。</p>
<p>显然算面积用叉积即可。</p>
<p>枚举每一条线段，判断有多少个点符合条件。</p>
<p>如果其他 $n-2$ 个点和该线段的距离是有序的话，那么就可以二分了。</p>
<p>跟线段扯上关系的显然是极角。考虑从小到大枚举极角。</p>
<p>将点按 $x,y$ 为第一二关键字排序后，枚举线段，这样就可以保证线段从左到右，方向确定。再按极角排序，这样就能保证极角在 $[-\frac{\pi}{2},\frac{\pi}{2})$ 内。</p>
<p>于是按顺序枚举极角，每次用两次二分计算答案。做完这个极角以后，发现相对顺序变了的只有这两个点。因此交换这两个点在序列中的位置即可。</p>
<p>时间复杂度 $O(n^2\log n)$。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Abs(x) ((x)&gt;0?(x):-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3005</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> point &amp;A,<span class="type">const</span> point &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.x!=B.x) <span class="keyword">return</span> A.x&lt;B.x;</span><br><span class="line">		<span class="keyword">return</span> A.y&lt;B.y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> point <span class="keyword">operator</span>-(<span class="type">const</span> point &amp;A,<span class="type">const</span> point &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (point)&#123;A.x-B.x,A.y-B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">cross</span><span class="params">(<span class="type">const</span> point &amp;A,<span class="type">const</span> point &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.x*B.y-B.x*A.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">area2</span><span class="params">(<span class="type">const</span> point &amp;A,<span class="type">const</span> point &amp;B,<span class="type">const</span> point &amp;C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Abs</span>(<span class="built_in">cross</span>(A-B,A-C));</span><br><span class="line">&#125;</span><br><span class="line">point p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line">	<span class="type">int</span> i,j; db ang;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> line &amp;A,<span class="type">const</span> line &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> A.ang&lt;B.ang;</span><br><span class="line">		<span class="comment">//return cross(p[A.j]-p[A.i],p[B.j]-p[B.i])&gt;0;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">line a[N*N];</span><br><span class="line"><span class="type">int</span> n,m,id[N],pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pos[i]=id[i]=i;</span><br><span class="line">	<span class="type">int</span> x,y,l,r,mid,ans;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		&#123;</span><br><span class="line">		x=a[i].i, y=a[i].j;</span><br><span class="line">		<span class="keyword">if</span>(pos[x]&gt;pos[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		l=<span class="number">1</span>; r=pos[x];</span><br><span class="line">		<span class="keyword">for</span>(;l+<span class="number">1</span>&lt;r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">area2</span>(p[x],p[y],p[id[mid]])&lt;=S) r=mid;</span><br><span class="line">			<span class="keyword">else</span> l=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(r&gt;=<span class="number">2</span>&amp;&amp;<span class="built_in">area2</span>(p[x],p[y],p[id[r<span class="number">-1</span>]])&lt;=S) r--;</span><br><span class="line">		sum+=pos[x]-r;</span><br><span class="line">		l=pos[y]; r=n;</span><br><span class="line">		<span class="keyword">for</span>(;l+<span class="number">1</span>&lt;r;)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">area2</span>(p[x],p[y],p[id[mid]])&lt;=S) l=mid;</span><br><span class="line">			<span class="keyword">else</span> r=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(l&lt;n&amp;&amp;<span class="built_in">area2</span>(p[x],p[y],p[id[l+<span class="number">1</span>]])&lt;=S) l++;</span><br><span class="line">		sum+=l-pos[y];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">swap</span>(pos[x],pos[y]);</span><br><span class="line">		<span class="built_in">swap</span>(id[pos[x]],id[pos[y]]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">ll L,R;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); L=<span class="built_in">read</span>(); R=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i].x=<span class="built_in">read</span>(),p[i].y=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,i+<span class="number">1</span>,n)</span><br><span class="line">		a[++m]=(line)&#123;i,j,<span class="built_in">atan2</span>(p[j].y-p[i].y,p[j].x-p[i].x)&#125;;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">solve</span>(R*<span class="number">2</span>)-<span class="built_in">solve</span>(L*<span class="number">2</span><span class="number">-1</span>))/<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><a href="/2020/03/17/%E7%89%9B%E7%89%9B%E5%96%9C%E6%AC%A2%E7%9C%8B%E5%B0%8F%E5%A7%90%E5%A7%90-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B37F/" title="链接">链接</a>]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>绝地反击[JSOI 2018]</title>
    <url>/2020/02/20/%E7%BB%9D%E5%9C%B0%E5%8F%8D%E5%87%BB-JSOI-2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5316">bzoj</a></p>
<span id="more"></span>

<p>暂时速度排rank4..</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个平面直角坐标系上 $n$ 艘飞船，同时开始移动，需要移动到 $x^2+y^2=R^2$ 的圆中形成该圆的 $n$ 等分点。求飞船移动时间最大值的最小值，精度六位小数。</p>
<p>$n\leq 200$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大值最小，显然先二分答案 $W$。</p>
<p>这时候，每个飞船在 $W$ 的时间内，在这个圆上的能走到的点是一个连续的区间。</p>
<p>假设固定了这 $n$ 个等分点，那么就可以把飞船看做X集合，点看做Y集合，飞船 $i$ 能到点 $j$，则 $X_i$ 向 $Y_j$ 连一条边，做二分图最大匹配即可。</p>
<p>但是这个 $n$ 等分点可以随意旋转，似乎无法判断是否可行。</p>
<p>假设某种旋转角度是可行的，那么继续随意旋转，直到某个 $n$ 等分点和某个区间的边界重合，这时候点和飞船的配对还是一样的。</p>
<p>那么就说明，一种合法的情况中，会有至少一个点在某个区间的端点中。</p>
<p>这样的点至多有 $2n$ 个，对应着至多 $2n$ 个偏转角度。</p>
<p>一个十分显然的做法是，枚举这 $2n$ 个偏转角度，然后做二分图最大匹配。</p>
<p>这样的话，时间复杂度为 $O(n^3\sqrt n \log M)$，其中 $\log M$ 为二分的次数，大约在 $25$ 左右。</p>
<p>这样就会获得 $50pts$ 。</p>
<p>但是若用扫描线，从小到大枚举这 $2n$ 个偏转角度呢？</p>
<p>这样每次的状态和前面的状态相比，相当于减少或增加了一条边。</p>
<p>显然可以利用上一次网络流算的答案。</p>
<p>那么退流，至多修改三条边，再跑一遍网络流就好了。</p>
<p>一次退流再推一次的时间复杂度好像是 $O(n)$ 的。</p>
<p>时间复杂度 $O(不会证)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">405</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> db Pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">namespace</span> G&#123;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	<span class="type">int</span> val[M],ver[M],ne[M],head[N],cur[N],tot,d[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,s,t) head[i]=cur[i]=<span class="number">0</span>;</span><br><span class="line">		tot=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(;!que.<span class="built_in">empty</span>();que.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,s,t) d[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,s,t) cur[i]=head[i];</span><br><span class="line">		d[s]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(que.<span class="built_in">push</span>(s);!que.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=que.<span class="built_in">front</span>(); que.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(!d[v=ver[i]]&amp;&amp;val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>; que.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u==t||flow==<span class="number">0</span>) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u],v;i&amp;&amp;res;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(d[v=ver[i]]==d[u]+<span class="number">1</span>&amp;&amp;(r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i]))))</span><br><span class="line">			&#123;</span><br><span class="line">				res-=r; val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> &amp;flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">bfs</span>();flow+=<span class="built_in">dfs</span>(s,inf));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> &amp;flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[y],pre;i;pre=i,i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==x)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==head[y]) head[y]=ne[i];</span><br><span class="line">				<span class="keyword">else</span> ne[pre]=ne[i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[x],pre;i;pre=i,i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==y)</span><br><span class="line">			&#123;</span><br><span class="line">				flag=(!val[i]);</span><br><span class="line">				<span class="keyword">if</span>(i==head[x]) head[x]=ne[i];</span><br><span class="line">				<span class="keyword">else</span> ne[pre]=ne[i];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) <span class="keyword">return</span>;</span><br><span class="line">		flow--;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[s];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==x)</span><br><span class="line">			&#123;</span><br><span class="line">				val[i]^=<span class="number">1</span>; val[i^<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[t];i;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(ver[i]==y)</span><br><span class="line">			&#123;</span><br><span class="line">				val[i]^=<span class="number">1</span>; val[i^<span class="number">1</span>]^=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">bfs</span>()) flow+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> G;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">db K,x[N],y[N],rad;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	db ang; <span class="type">int</span> x,y,opt;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(A.ang-B.ang)&lt;eps) <span class="keyword">return</span> A.opt&gt;B.opt;</span><br><span class="line">		<span class="keyword">return</span> A.ang&lt;B.ang;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(db W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	m=<span class="number">0</span>; <span class="built_in">init</span>();</span><br><span class="line">	db dis,l,r,ang,b;</span><br><span class="line">	<span class="type">int</span> L,R;</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) <span class="built_in">add</span>(s,i,<span class="number">1</span>),<span class="built_in">add</span>(i+n,t,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		dis=<span class="built_in">sqrt</span>(x[i]*x[i]+y[i]*y[i]);</span><br><span class="line">		<span class="keyword">if</span>(K+W&lt;dis||dis&lt;K-W) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(dis+K&gt;W))</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">1</span>,n) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			ang=<span class="built_in">atan2</span>(x[i],y[i]);</span><br><span class="line">			b=<span class="built_in">acos</span>((dis*dis+K*K-W*W)/(dis*K*<span class="number">2</span>));</span><br><span class="line">			l=ang-b; r=ang+b;</span><br><span class="line">			<span class="keyword">for</span>(;l&lt;<span class="number">0</span>;l+=<span class="number">2</span>*Pi);</span><br><span class="line">			<span class="keyword">for</span>(;r&lt;<span class="number">0</span>;r+=<span class="number">2</span>*Pi);</span><br><span class="line">			L=l/rad; R=r/rad; L++; R++;</span><br><span class="line">			q[++m]=(node)&#123;l-rad*(L<span class="number">-1</span>),i,L,<span class="number">1</span>&#125;;</span><br><span class="line">			q[++m]=(node)&#123;r-rad*(R<span class="number">-1</span>),i,R,<span class="number">-1</span>&#125;;</span><br><span class="line">			<span class="keyword">if</span>(l&lt;=r) <span class="built_in">fo</span>(j,L+<span class="number">1</span>,R) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">fo</span>(j,L+<span class="number">1</span>,n) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">				<span class="built_in">fd</span>(j,R,<span class="number">1</span>) <span class="built_in">add</span>(i,j+n,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">dinic</span>(flow);</span><br><span class="line">	<span class="keyword">if</span>(flow&gt;=n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">sort</span>(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(q[i].opt==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">add</span>(q[i].x,q[i].y+n,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">bfs</span>()) flow+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">			<span class="keyword">if</span>(flow&gt;=n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">del</span>(q[i].x,q[i].y+n,flow);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%lf&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">	rad=<span class="number">2.0</span>*Pi/n;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;x[i],&amp;y[i]);</span><br><span class="line">	db l=<span class="number">0</span>,r=<span class="number">282.8432</span>,mid;</span><br><span class="line">	s=<span class="number">0</span>,t=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;l+eps&lt;r;)</span><br><span class="line">	&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2.</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.8lf&quot;</span>,r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
        <tag>计算几何</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>飞机调度[JSOI2016]</title>
    <url>/2020/02/19/%E9%A3%9E%E6%9C%BA%E8%B0%83%E5%BA%A6-JSOI2016/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5326">bzoj</a></p>
<p><a href="https://loj.ac/problem/2077">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑一架飞机，飞了某个航班后，还能飞哪个航班。</p>
<p>假设把一条航班看做点，能从航班 $i$ 到达航班 $j$ 的连一条有向边 $(i,j)$，则航班之间形成了一个 DAG。</p>
<p>则我们只需要求这个DAG的最小路径覆盖，这十分模板。</p>
<p>现在只需考虑两个航班 $i,j$ 之间是否存在有向边。那就是 $i$ 飞完后，在航班 $i$ 的中点加完油后，再沿着最短路飞往 $j$ 的起点，看时间是否赶得上。</p>
<p>因此只需求出两点间最短路径，Floyd 即可。</p>
<p>时间复杂度 $O(n^3)$，假设 $n,m$ 同阶。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1300010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],ne[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="type">int</span> d[N],cur[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="built_in">fo</span>(i,s,t) d[i]=<span class="number">0</span>;</span><br><span class="line">		q.<span class="built_in">push</span>(s); d[s]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(d[v=ver[i]]==<span class="number">0</span>&amp;&amp;val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">		<span class="type">int</span> res=flow,r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u],v;i&amp;&amp;res;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(d[v=ver[i]]==d[u]+<span class="number">1</span>&amp;&amp;val[i])</span><br><span class="line">			&#123;</span><br><span class="line">				r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,val[i]));</span><br><span class="line">				<span class="keyword">if</span>(!r) <span class="keyword">continue</span>;</span><br><span class="line">				res-=r;</span><br><span class="line">				val[i]-=r; val[i^<span class="number">1</span>]+=r;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">bfs</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(i,s,t) cur[i]=head[i];</span><br><span class="line">			flow+=<span class="built_in">dfs</span>(s,inf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Dinic::s;</span><br><span class="line"><span class="keyword">using</span> Dinic::t;</span><br><span class="line"><span class="keyword">using</span> Dinic::dinic;</span><br><span class="line"><span class="keyword">using</span> Dinic::add;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tim[K][K],f[K][K],d[K],p[K],x[K],y[K];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> d[i]+tim[x[i]][y[i]]+p[y[i]]+f[y[i]][x[j]]&lt;=d[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) p[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n) tim[i][j]=<span class="built_in">read</span>(),f[i][j]=tim[i][j]+p[j];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i][i]-=p[i];</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">1</span>,n) <span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">fo</span>(j,<span class="number">1</span>,n)</span><br><span class="line">		<span class="keyword">if</span>(f[i][j]&gt;f[i][k]+f[k][j])</span><br><span class="line">			f[i][j]=f[i][k]+f[k][j];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x[i]=<span class="built_in">read</span>(),y[i]=<span class="built_in">read</span>(),d[i]=<span class="built_in">read</span>();</span><br><span class="line">	s=<span class="number">0</span>; t=<span class="number">2</span>*m+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">add</span>(s,i,<span class="number">1</span>),<span class="built_in">add</span>(i+m,t,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">fo</span>(j,<span class="number">1</span>,m)</span><br><span class="line">		<span class="keyword">if</span>(i!=j&amp;&amp;<span class="built_in">check</span>(i,j))</span><br><span class="line">			<span class="built_in">add</span>(i,j+m,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m-<span class="built_in">dinic</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>loj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>营救皮卡丘[ZJOI2011]</title>
    <url>/2020/02/18/%E8%90%A5%E6%95%91%E7%9A%AE%E5%8D%A1%E4%B8%98-ZJOI2011/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2324">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们考虑一个人从某个点 $i$ 到另外一个比该点编号大的点 $j$ 的情况。</p>
<p>但是这时候我们不能经过编号大于 $i$ 和 $j$ ，因此需预处理出不经过 编号比 $i,j$ 大的点，从 $i$ 到 $j$ 的最短路。这个用Floyd即可实现。</p>
<p>这样做就保证了答案的合法性。</p>
<p>现在问题变成有 $k$ 条从 $0$ 号点的路径，除了该点外不经过重复的点，边有边权及费用，每个点经过一次的模型。</p>
<p>这就类似于最小路径覆盖了。</p>
<p>对于每个非 $0$ 点拆点。</p>
<p>首先是 $(s,0,k,0)$，表示最多不超过 $k$ 个人在上面走。</p>
<p>然后是 $(i’,t,1,0),(s,i,1,0)$，代表每个点至少经过一遍，经过以后可以继续走。</p>
<p>接着对于 $i&lt;j$ 的情况，连边 $(i,j’,1,dis_{i,j})$，表示从 $i$ 走到 $j$ 的最小费用为 $dis_{i,j}$。</p>
<p>跑最小费用最大流即可。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">100000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s,t;</span><br><span class="line">	<span class="type">int</span> ver[M],val[M],cost[M],ne[M],head[N],tot=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=v; cost[tot]=c; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; cost[tot]=-c;ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	ll h[N],dis[N];</span><br><span class="line">	<span class="type">bool</span> vis[N];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) h[i]=inf;</span><br><span class="line">		queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">		<span class="keyword">for</span>(h[s]=<span class="number">0</span>,q.<span class="built_in">push</span>(s);!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;h[v=ver[i]]&gt;h[u]+cost[i])</span><br><span class="line">				&#123;</span><br><span class="line">					h[v]=h[u]+cost[i];</span><br><span class="line">					<span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			vis[u]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">		<span class="type">int</span> u; ll dis;</span><br><span class="line">		<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)&#123;<span class="keyword">return</span> A.dis&gt;B.dis;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> pv[N],pe[N];</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	<span class="function">ll <span class="title">MCMF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">spfa</span>(s,t);</span><br><span class="line">		<span class="type">int</span> flow=<span class="number">0</span>; ll co=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;;)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dis[i]=inf;</span><br><span class="line">			<span class="keyword">for</span>(dis[s]=<span class="number">0</span>,q.<span class="built_in">push</span>((node)&#123;s,dis[s]&#125;);!q.<span class="built_in">empty</span>();)</span><br><span class="line">			&#123;</span><br><span class="line">				node now=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="type">int</span> u=now.u;</span><br><span class="line">				<span class="keyword">if</span>(dis[u]&lt;now.dis) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i])</span><br><span class="line">				&#123;</span><br><span class="line">					v=ver[i];</span><br><span class="line">					<span class="keyword">if</span>(dis[v]+h[v]&gt;dis[u]+h[u]+cost[i])</span><br><span class="line">						dis[v]=dis[u]+h[u]+cost[i]-h[v],</span><br><span class="line">						q.<span class="built_in">push</span>((node)&#123;v,dis[v]&#125;),</span><br><span class="line">						pv[v]=u,pe[v]=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dis[t]==inf) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) h[i]+=dis[i];</span><br><span class="line">			<span class="type">int</span> tmp=<span class="number">0x3fffffff</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t;u!=s;u=pv[u]) tmp=<span class="built_in">min</span>(tmp,val[pe[u]]);</span><br><span class="line">			flow+=tmp; co+=h[t]*tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> u=t,i;u!=s;u=pv[u]) i=pe[u],val[i]-=tmp,val[i^<span class="number">1</span>]+=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> co;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,K,dis[N][N],s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); K=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) dis[i][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),y=<span class="built_in">read</span>(),dis[x][y]=dis[y][x]=<span class="built_in">min</span>(dis[x][y],<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">fo</span>(k,<span class="number">0</span>,n) <span class="built_in">fo</span>(i,<span class="number">0</span>,n) <span class="built_in">fo</span>(j,<span class="number">0</span>,n)</span><br><span class="line">		<span class="keyword">if</span>((k&lt;=i||k&lt;=j)&amp;&amp;dis[i][j]&gt;dis[i][k]+dis[k][j])</span><br><span class="line">			dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">	Graph::n=<span class="number">2</span>*n+<span class="number">2</span>; s=Graph::s=<span class="number">2</span>*n+<span class="number">2</span>; t=Graph::t=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) Graph::<span class="built_in">add</span>(s,i,<span class="number">1</span>,<span class="number">0</span>),Graph::<span class="built_in">add</span>(i+n,t,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	Graph::<span class="built_in">add</span>(s,<span class="number">0</span>,K,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) <span class="built_in">fo</span>(j,i+<span class="number">1</span>,n) Graph::<span class="built_in">add</span>(i,j+n,<span class="number">1</span>,dis[i][j]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,Graph::<span class="built_in">MCMF</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的游戏[SCOI2012]</title>
    <url>/2020/02/18/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B8%B8%E6%88%8F-SCOI2012/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2756">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一看到棋盘，先黑白染色再说。</p>
<p>若棋盘中格子是奇数，则答案不满足单调性。不过此时次数可以直接解出来，或判断无解。</p>
<p>下面讨论格子总数为偶数的情况：</p>
<p>若全染成 $x$ 可以，则全染成 $x+1$ 也可以。</p>
<p>因此二分答案一波，看看能不能让答案为 $x$。</p>
<p>一次染色显然会让黑和白格子的总数都加一。</p>
<p>因此若白色和黑子格子里的数总数不相等，则必定无解。</p>
<p>新建源汇，边权为 $x-a_{i,j}$，白点黑点相邻的连边，边权为 $\infty$，表示可以同时加上很多个 $1$。</p>
<p>跑最大流，看是否满流即可。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1610</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 20000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 100000000000000000ll</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">bool</span> f=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Dinic&#123;</span><br><span class="line">	<span class="type">int</span> s,t;</span><br><span class="line">	<span class="type">int</span> ver[M],ne[M],head[N],tot=<span class="number">1</span>,cur[N],d[N]; ll val[M];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,ll z)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ver[++tot]=y; val[tot]=z; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">		ver[++tot]=x; val[tot]=<span class="number">0</span>; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=t;i++) d[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;!q.<span class="built_in">empty</span>();q.<span class="built_in">pop</span>());</span><br><span class="line">		<span class="keyword">for</span>(q.<span class="built_in">push</span>(s),d[s]=<span class="number">1</span>;!q.<span class="built_in">empty</span>();)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">				<span class="keyword">if</span>(val[i]&amp;&amp;!d[v=ver[i]])</span><br><span class="line">				&#123;</span><br><span class="line">					d[v]=d[u]+<span class="number">1</span>; q.<span class="built_in">push</span>(v);</span><br><span class="line">					<span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,ll flow)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u==t||!flow) <span class="keyword">return</span> flow;</span><br><span class="line">		ll res=flow,r; <span class="type">int</span> v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u];i&amp;&amp;res;i=ne[i])</span><br><span class="line">			<span class="keyword">if</span>(val[i]&amp;&amp;d[v=ver[i]]==d[u]+<span class="number">1</span>&amp;&amp;(r=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(res,(ll)val[i]))))</span><br><span class="line">				res-=r,val[i]-=r,val[i^<span class="number">1</span>]+=r;</span><br><span class="line">		<span class="keyword">return</span> flow-res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> ll <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ll flow=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;<span class="built_in">bfs</span>();flow+=<span class="built_in">dfs</span>(s,inf)) <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=t;i++) cur[i]=head[i];</span><br><span class="line">		<span class="keyword">return</span> flow;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;=t;i++) head[i]=<span class="number">0</span>; tot=<span class="number">1</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Dinic;</span><br><span class="line"><span class="type">int</span> n,m; ll a[<span class="number">44</span>][<span class="number">44</span>];</span><br><span class="line"><span class="type">int</span> fx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*m+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x&gt;<span class="number">0</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;y&lt;=m;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">build</span><span class="params">(ll tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((i+j)&amp;<span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">id</span>(i,j),t,tmp-a[i][j]),sum+=tmp-a[i][j];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">add</span>(s,<span class="built_in">id</span>(i,j),tmp-a[i][j]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,x,y;k&lt;<span class="number">4</span>;k++)</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(x=i+fx[k],y=j+fy[k]))</span><br><span class="line">						<span class="built_in">add</span>(<span class="built_in">id</span>(i,j),<span class="built_in">id</span>(x,y),inf);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span> </span>&#123;ll sum=<span class="built_in">build</span>(x); <span class="keyword">return</span> <span class="built_in">dinic</span>()==sum;&#125;</span><br><span class="line">ll sum[<span class="number">2</span>],maxx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> T=<span class="built_in">read</span>();T--;)</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		s=<span class="number">0</span>; t=n*m+<span class="number">1</span>;</span><br><span class="line">		sum[<span class="number">0</span>]=sum[<span class="number">1</span>]=maxx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">				a[i][j]=<span class="built_in">read</span>(),sum[(i+j)&amp;<span class="number">1</span>]+=a[i][j],maxx=<span class="built_in">max</span>(maxx,a[i][j]);</span><br><span class="line">		<span class="keyword">if</span>((n*m)&amp;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum[<span class="number">0</span>]-sum[<span class="number">1</span>]&lt;maxx) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">			ll num1=<span class="built_in">build</span>(sum[<span class="number">0</span>]-sum[<span class="number">1</span>]);ll num2=<span class="built_in">dinic</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(num1==num2)?num2:<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum[<span class="number">0</span>]!=sum[<span class="number">1</span>]) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">			ll l=maxx,r=maxx+maxx+<span class="number">1</span>,mid;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">			&#123;</span><br><span class="line">				mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			l=r+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(l&gt;=maxx+maxx) &#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">			<span class="built_in">build</span>(l);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">dinic</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流</title>
    <url>/2020/02/14/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<p>网络流建模总结。</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>网络流，费用流。</p>
<h2 id="一，简单点的"><a href="#一，简单点的" class="headerlink" title="一，简单点的"></a>一，简单点的</h2><h3 id="1，二分图相关问题"><a href="#1，二分图相关问题" class="headerlink" title="1，二分图相关问题"></a>1，二分图相关问题</h3><p>设 $|X|+|Y|=n$</p>
<p>二分图最大匹配：$(S,x_i,1),(x_i,y_j,1),(y_j,T,1)$，设答案为 $t$。</p>
<p>最大独立集：$n-t$</p>
<h3 id="2，多源多汇"><a href="#2，多源多汇" class="headerlink" title="2，多源多汇"></a>2，多源多汇</h3><p>直接新建超级源汇即可。</p>
<h3 id="3，节点容量"><a href="#3，节点容量" class="headerlink" title="3，节点容量"></a>3，节点容量</h3><p>直接拆点即可。</p>
<h3 id="4，最小路径覆盖"><a href="#4，最小路径覆盖" class="headerlink" title="4，最小路径覆盖"></a>4，最小路径覆盖</h3><p>前提：DAG。</p>
<p>对于每个点拆点，二分图中一条增广路径代表DAG上一条路径。</p>
<p>跑最大匹配，Y集合中若某个点不存在一个匹配则为一条路径的起点。</p>
<p>因此答案即为 $n$ - 最大匹配数。</p>
<h2 id="二，不那么简单的"><a href="#二，不那么简单的" class="headerlink" title="二，不那么简单的"></a>二，不那么简单的</h2><h3 id="1，无源汇有上下界可行流"><a href="#1，无源汇有上下界可行流" class="headerlink" title="1，无源汇有上下界可行流"></a>1，无源汇有上下界可行流</h3><p>首先每条边必须得跑下界。</p>
<p>然后考虑一个附加流，每条的边权为上界与下界的差。</p>
<p>每条边最终的流量=网络流中反向边权值+下界。</p>
<p>对于每个点必须满足流量平衡，设 $d_u$ 为入边下界之和-出边下界之和，若 $d_u&gt;0$ 则表明需要流多一点，$d_u&lt;0$ 则表明可以流少一点。</p>
<p>因此新建超级源汇，若 $d_u&lt;0$，则连边 $(u,t,-d_u)$，否则连边 $(s,u,d_u)$。当且仅当源点的出边满流时有解。</p>
<h3 id="2，有源汇有上下界可行流"><a href="#2，有源汇有上下界可行流" class="headerlink" title="2，有源汇有上下界可行流"></a>2，有源汇有上下界可行流</h3><p>加入一条下界为 $0$，上界为 $\infty$ 的从 $t$ 到 $s$ 的边，变成上面的做法。</p>
<h3 id="3，有源汇有上下界最大或最小流"><a href="#3，有源汇有上下界最大或最小流" class="headerlink" title="3，有源汇有上下界最大或最小流"></a>3，有源汇有上下界最大或最小流</h3><p>先按照 1,2 的方法处理。然后删掉 1,2 中新加的边，在残量网络中跑最大流，两次答案相加即为答案。</p>
<p>最小流的话就把源汇反过来跑最大流就好了。</p>
<p>费用流同理。</p>
<h3 id="4，最大权闭合子图"><a href="#4，最大权闭合子图" class="headerlink" title="4，最大权闭合子图"></a>4，最大权闭合子图</h3><p>有向无环图，选了某个节点 $i$，则 $i$ 的后继必须选。问一种选择的方案使得选了的节点权值和最大。</p>
<p>假设先全部选了正的，然后最小割建图，$s$ 连节点权值为正的点，$t$ 连节点权值为负的点，减去最小割的答案即可。</p>
<h2 id="三，比较难的"><a href="#三，比较难的" class="headerlink" title="三，比较难的"></a>三，比较难的</h2><h3 id="1，混合图的欧拉回路判定"><a href="#1，混合图的欧拉回路判定" class="headerlink" title="1，混合图的欧拉回路判定"></a>1，混合图的欧拉回路判定</h3><p>混合图：既有有向，又有无向边的图。</p>
<p>欧拉回路：每条边只能且必须经过一次，最终回到起点的路径。</p>
<p>首先随便给无向边定向。</p>
<p>然后设 $d_i=出度-入度$，每给一个无向边反向都会使得某个点的 $d$ 减二，某个点的 $d$ 加二。因此若 $d_i$ 为奇数则一定无解。</p>
<p>若所有 $d_i$ 均为偶数，则将原图的无向边建边，容量为 $1$。然后新建源汇，容量为 $|\frac{d_i}{2}|$ 即可。</p>
<h3 id="2，混合图的欧拉路径判定"><a href="#2，混合图的欧拉路径判定" class="headerlink" title="2，混合图的欧拉路径判定"></a>2，混合图的欧拉路径判定</h3><p>若这没有 $d_i$ 为奇数的点，转成 1。</p>
<p>若有且只有两个 $d_i$ 为奇数的点，且一个为整，一个为负。则连一条边，变成 1。</p>
<p>其他情况无解。</p>
<h3 id="3，最大密度子图"><a href="#3，最大密度子图" class="headerlink" title="3，最大密度子图"></a>3，最大密度子图</h3><p>每个边有边权，点有点权，要去选出一个子图，使得 $\frac{\sum_{i\in E}e_i}{\sum_{i\in V} v_i}$ 最大。</p>
<p>显然0/1分数规划，二分答案 $mid$，有：$\frac{\sum_{i\in E}e_i}{\sum_{i\in V} v_i}\geq mid$，即 $e-mid\times v\geq 0$。</p>
<p>一条边选了，则它的两个点都必须选。</p>
<p>十分像最大权闭合子图的形式！</p>
<p>对于原图的每条边看做一个点，做最大权闭合子图即可判断 $mid$ 是否合法。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2020/02/07/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>生成函数知识点总结。</p>
<span id="more"></span>

<h2 id="简单的介绍"><a href="#简单的介绍" class="headerlink" title="简单的介绍"></a>简单的介绍</h2><p>对于一个序列 $\{a_0,a_1\cdots\}$，我们想把这个数列表示出来，把它写成一个函数的形式。因此就有了以下的两种形式：</p>
<ul>
<li><p>普通型生成函数(OGF)：$f(x)=\sum_{i=0}a_ix^i$ ，主要用来解决无标号，组合问题。</p>
</li>
<li><p>指数级生成函数(EGF)：$f(x)=\sum_{i=0}\frac{a_i}{i!}x^i$ ，主要用来解决有标号，排列问题。</p>
</li>
</ul>
<p><strong>主要和多项式各种运算搭配使用。</strong></p>
<p>一些例子：</p>
<p>OGF：</p>
<ul>
<li><p>$\{ 1,1,1,\cdots\}$ 的OGF为：$\sum_{i=0}x^i=\frac{1}{1-x}$</p>
</li>
<li><p>$\{ 1,a,a^2,\cdots\}$ 的OGF为：$\sum_{i=0}a^ix^i=\frac{1}{1-ax}$</p>
</li>
<li><p>$\{ 1,-1,1,-1,\cdots\}$ 的OGF为：$\sum_{i=0}(-1)^ix^i=\frac{1}{1+x}$</p>
</li>
<li><p>$\frac{1}{1-x}$ 求 $n$ 次导得到的是杨辉三角第 $n+1$ 列的数。</p>
</li>
</ul>
<p>EGF：</p>
<ul>
<li>$\{1,1,1,\cdots\}$的EGF为：$\sum_{i=0}\frac{x^i}{i!}=e^x$</li>
<li>$\frac{e^x+e^{-x}}{2}=\sum_{i=0}\frac{x^{2i}}{(2i)!}$</li>
<li>$\frac{e^x-e^{-x}}{2}=\sum_{i=0}\frac{x^{2i+1}}{(2i+1)!}$</li>
<li>$\ln(1-x)=-\sum_{i=1}\frac{x^i}{i}$</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="图计数问题"><a href="#图计数问题" class="headerlink" title="图计数问题"></a>图计数问题</h3><p>以下问题，$n\leq 10^5$。模$998244353$。</p>
<h4 id="带标号无向图数量"><a href="#带标号无向图数量" class="headerlink" title="带标号无向图数量"></a>带标号无向图数量</h4><p>$f_i=2^{\binom{i}{2}}$</p>
<h4 id="带标号无向连通图数量"><a href="#带标号无向连通图数量" class="headerlink" title="带标号无向连通图数量"></a>带标号无向连通图数量</h4><p>设答案为$g_i$，其生成函数为$G$，第1题的生成函数是$F$，那么一个无向图就是由一些无向连通图组合起来的。</p>
<p>那么可以枚举一个无向图是由多少个连通图组成的，假设为$i$，那么答案跟$F^i(x)$所对应的系数有关系。因为无序，所以要除一个$i!$，因此有：</p>
<p>$F(x)=\sum_{i=0}^{\infty}\frac{G^i(x)}{i!}=e^{G(x)}$</p>
<p>同时求$\ln$得$G(x)=\ln F(x)$</p>
<p>多项式求$\ln$即可。</p>
<h4 id="带标号DAG数量"><a href="#带标号DAG数量" class="headerlink" title="带标号DAG数量"></a>带标号DAG数量</h4><p>很明显先dp，设$f_i$为$i$个点带标号的DAG数量。$f_0=1$。先假设有$j$个点度数为0，符合上述条件的$j$个点的集合有$\binom{i}{j}$个；这$j$个点可以任意向其他$i-j$个点连边，方案数有$2^{j(i-j)}$个；剩下的$i-j$个点也必须是个DAG，方案数为$f_{i-j}$乘法原理得方案数为$\binom{i}{j}2^{j(i-j)}f_{i-j}$，可是剩下的$i-j$个点中也还是有一些度数为0的点的，那么容斥一下就好了。</p>
<p>得到dp方程式：$f_i=\sum_{j=1}^i(-1)^{j-1}\binom{i}{j}2^{j(i-j)}f_{i-j}$</p>
<p>时间复杂度$O(n^2)$</p>
<p>考虑优化，式子右边很像一个卷积形式，但是$2^{j(i-j)}$很难化简。。。</p>
<p>可以发现，$2^{j(i-j)}={2^{j^2}}\times {2^{-ij}}$，有没有办法把$-ij$化成只跟$j$和$i-j$和$i$有关的东西乘起来呢？</p>
<p>初中知识：$(i-j)^2=i^2+j^2-2ij$</p>
<p>因此$2^{i(i-j)}={2^{i^2}}\times {2^{-ij}}=(\sqrt{2})^{i^2-(i-j)^2-j^2}$</p>
<p>那$\sqrt{2}$在模$998244353$意义下是什么来的呀？</p>
<p>不用怕，$2$在模$998244353$意义下有二次剩余的呢。</p>
<p>因此$dp$式可化成：</p>
<p>$$\frac{f_i}{(\sqrt{2})^{i^2}i!}=\sum_{j=1}^i\frac{(-1)^{j-1}}{(\sqrt{2})^{j^2}j!}\times \frac{f_{i-j}}{(\sqrt{2})^{({i-j})^2}(i-j)!}$$</p>
<p>设$F(i)=\frac{f_i}{(\sqrt{2})^{i^2}i!}$,$G(i)=\frac{(-1)^{i-1}}{(\sqrt{2})^{i^2}i!}(i\geq1)，G(0)=0$</p>
<p>那么$F=GF+1$，即$F=\frac{1}{1-G}$</p>
<p>多项式求逆，时间复杂度$O(n \log n)$</p>
<h4 id="带标号的DAG数量，要求图弱连通"><a href="#带标号的DAG数量，要求图弱连通" class="headerlink" title="带标号的DAG数量，要求图弱连通"></a>带标号的DAG数量，要求图弱连通</h4><p>和第二题是一样的。设$H(x)$为该题答案的指数型生成函数，$F(x)$为第三题的指数型生成函数，那么$F(x)=e^{H(x)}$，$H(x)=\ln F(x)$，多项式求$\ln$即可。</p>
<h3 id="拉格朗日反演"><a href="#拉格朗日反演" class="headerlink" title="拉格朗日反演"></a>拉格朗日反演</h3><p>若两个函数 $F(x),G(x)$ 满足：$F(G(x))=x$。</p>
<p>则有：$[x^n]G(x)=\frac{1}{n}[x^{n-1}] (\frac{x}{F(x)})^n$</p>
<p>证明：懒得证了，会用就行。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>序列[CCPC Wannafly WC Day7]</title>
    <url>/2020/02/06/%E5%BA%8F%E5%88%97-CCPC-Wannafly-WC-Day7/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/contest/4138/A">链接</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然考虑数对 $(i,j)$ 给哪些数字产生了贡献。</p>
<p>不妨设 $p_i &lt; p_j$（大于的同理），</p>
<p>这一数对给 $(p_i,p_j)$ 这个区间都贡献了 $w=2^{i-1}\times 2^{n-j}$。</p>
<p>因为这两个数选了以后，中间的不能选，两边的随便选。</p>
<p>因此只需维护一个差分数组 $f$，给 $f_{p_i+1}+=w,f_{p_j}-=w$。</p>
<p>那么枚举 $j$，用平衡树找到满足 $i&lt;j$ 且 $p_i&lt;p_j$ 中所有的 $i$ 。</p>
<p>对于 $f_{p_i+1}+=w$，只需要在平衡树上给 $p_i$ 打一个 $+2^{n-j}$ 的标记，最后乘上 $2^{i-1}$ 就可以了。</p>
<p>对于 $f_{p_j} -= w$，只需要在平衡树上记录 $2^{i-1}$ 的和就可以了。</p>
<p>时间复杂度 $O(n\log n)$。</p>
<p>听说有线段树做法？</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;<span class="comment">//module</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(T &amp;x,T y)</span></span>&#123;x+=y; <span class="keyword">if</span>(x&gt;=mod) x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mul</span><span class="params">(T &amp;x,T y)</span></span>&#123;(x*=y)%=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200005</span></span><br><span class="line"><span class="keyword">namespace</span> Treap&#123;</span><br><span class="line">	<span class="type">int</span> son[N][<span class="number">2</span>],val[N],siz[N],rnd[N],cnt;</span><br><span class="line">	ll t[N],w[N],sz[N],Val[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> va)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> u=++cnt;</span><br><span class="line">		val[u]=v; siz[u]=<span class="number">1</span>; rnd[u]=<span class="built_in">rand</span>();</span><br><span class="line">		sz[u]=Val[u]=va;</span><br><span class="line">		<span class="keyword">return</span> u;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,ll tag)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(u) <span class="built_in">Add</span>(t[u],tag),<span class="built_in">Add</span>(w[u],tag);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!t[u]) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">pushtag</span>(son[u][j],t[u]);</span><br><span class="line">		t[u]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		siz[u]=siz[son[u][<span class="number">0</span>]]+siz[son[u][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">		sz[u]=(Val[u]+sz[son[u][<span class="number">0</span>]]+sz[son[u][<span class="number">1</span>]])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line">		<span class="built_in">pushdown</span>(x); <span class="built_in">pushdown</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(rnd[x]&lt;rnd[y]) &#123;son[x][<span class="number">1</span>]=<span class="built_in">merge</span>(son[x][<span class="number">1</span>],y);<span class="built_in">pushup</span>(x);<span class="keyword">return</span> x;&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;son[y][<span class="number">0</span>]=<span class="built_in">merge</span>(x,son[y][<span class="number">0</span>]);<span class="built_in">pushup</span>(y);<span class="keyword">return</span> y;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_val</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(val[u]&lt;=k) x=u,<span class="built_in">split_val</span>(son[x][<span class="number">1</span>],k,son[x][<span class="number">1</span>],y);</span><br><span class="line">		<span class="keyword">else</span> y=u,<span class="built_in">split_val</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split_rank</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span> <span class="built_in">void</span>(x=y=<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=siz[son[u][<span class="number">0</span>]]) y=u,<span class="built_in">split_rank</span>(son[y][<span class="number">0</span>],k,x,son[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">else</span> x=u,<span class="built_in">split_rank</span>(son[x][<span class="number">1</span>],k-siz[son[u][<span class="number">0</span>]]<span class="number">-1</span>,son[x][<span class="number">1</span>],y);</span><br><span class="line">		<span class="built_in">pushup</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x,y,z;</span><br><span class="line">		<span class="built_in">split_val</span>(u,val[v],x,y);</span><br><span class="line">		u=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,v),y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">pushdown</span>(u);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">dfs</span>(son[u][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,u);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">1</span>) <span class="built_in">print</span>(son[u][i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Treap;</span><br><span class="line">ll f[N],p2[N],i2[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> &amp;u,<span class="type">int</span> l,<span class="type">int</span> r,ll w,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">split_val</span>(u,l<span class="number">-1</span>,x,y);</span><br><span class="line">	<span class="built_in">split_val</span>(y,r,y,z);</span><br><span class="line">	<span class="keyword">if</span>(y&amp;&amp;siz[y]) f[pos]=(f[pos]+(mod-w)*sz[y])%mod,<span class="built_in">pushtag</span>(y,w);</span><br><span class="line">	u=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x,y),z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt,n,a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) siz[i]=son[i][<span class="number">0</span>]=son[i][<span class="number">1</span>]=rnd[i]=sz[i]=t[i]=w[i]=<span class="number">0</span>;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">newnode</span>(a[i],p2[i<span class="number">-1</span>]);</span><br><span class="line">	rt=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">solve</span>(rt,<span class="number">1</span>,a[i]<span class="number">-2</span>,p2[n-i],a[i]);</span><br><span class="line">		<span class="built_in">ins</span>(rt,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(rt);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">Add</span>(f[a[i]+<span class="number">1</span>],w[i]*p2[i<span class="number">-1</span>]%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">FO</span>(A);</span><br><span class="line">	<span class="built_in">srand</span>(<span class="number">19260817</span>+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	p2[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),p2[i]=p2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,(n&gt;&gt;<span class="number">1</span>)) <span class="built_in">swap</span>(a[i],a[n-i+<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">Add</span>(f[i],f[i<span class="number">-1</span>]),<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>异或询问[2020 CCPC Wannafly WC Day6]</title>
    <url>/2020/02/06/%E5%BC%82%E6%88%96%E8%AF%A2%E9%97%AE-2020-CCPC-Wannafly-WC-Day6/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一序列 $a$，定义 $f(x)=\sum_{i=1}^n[a_i\leq x]$，$q$ 组询问，求 $\sum_{i=l}^rf(i\ xor\ x)^2\bmod 998244353$</p>
<p>$n,q\leq 10^5,0\leq a_i,l,r,x &lt; 2^{30}$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先不考虑 $x$ 的限制。</p>
<p>设 $g(n)=\sum_{i=0}^nf(i)^2$，变成求 $g(r)-g(l-1)$。</p>
<p>这个 $g$ 可以二分算出来。时间复杂度 $O(\log n)$</p>
<p>然后考虑 $x$ 的限制。</p>
<p>发现当 $x$ 前几位相同时，$i\ xor\ x$是一段连续的区间。</p>
<p>枚举前 $k$ 位相同即可。</p>
<p>时间复杂度 $O(n\log n\log a_i)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,w) for(int i=(j),end_i=(w);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,w) for(int i=(j),end_i=(w);i&gt;=end_i;i--)</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;<span class="comment">//module</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(T &amp;x,T y)</span></span>&#123;x+=y; <span class="keyword">if</span>(x&gt;=mod) x-=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Mul</span><span class="params">(T &amp;x,T y)</span></span>&#123;(x*=y)%=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line">ll s[N],b[N],a[N];</span><br><span class="line"><span class="type">int</span> n,q,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> y=<span class="built_in">upper_bound</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,x)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ll w=<span class="built_in">upper_bound</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,b[y])-a<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> (s[y<span class="number">-1</span>]+(ll)(x-b[y]+<span class="number">1</span>)*w%mod*w)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (mod+<span class="built_in">ask</span>(y)-<span class="built_in">ask</span>(x<span class="number">-1</span>))%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> u=<span class="number">0</span>,t=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fd</span>(i,<span class="number">30</span>,<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		u=(x&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">		t=d|(u&lt;&lt;i);</span><br><span class="line">		<span class="keyword">if</span>(r&gt;&gt;i&amp;<span class="number">1</span>) <span class="built_in">Add</span>(ans,<span class="built_in">ask</span>(t,t+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>)),d|=((<span class="number">1</span>&lt;&lt;i)^(u&lt;&lt;i));</span><br><span class="line">		<span class="keyword">else</span> d|=(u&lt;&lt;i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Add</span>(ans,<span class="built_in">ask</span>(d,d));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=b[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>);</span><br><span class="line">	m=<span class="built_in">unique</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>)-b<span class="number">-1</span>;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		w=<span class="built_in">upper_bound</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,b[i])-a<span class="number">-1</span>;</span><br><span class="line">		s[i]=(s[i<span class="number">-1</span>]+(ll)(b[i+<span class="number">1</span>]-b[i])*w%mod*w)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//fo(i,1,m-1) printf(&quot;%d &quot;,s[i]);</span></span><br><span class="line">	<span class="type">int</span> l,r,x;</span><br><span class="line">	<span class="built_in">fo</span>(_,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(); x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(<span class="built_in">calc</span>(r,x)-<span class="built_in">calc</span>(l<span class="number">-1</span>,x)+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>卡拉巴什的字符串[2020 CCPC Wannafly WC Day2]</title>
    <url>/2020/02/05/%E5%8D%A1%E6%8B%89%E5%B7%B4%E4%BB%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-2020-CCPC-Wannafly-WC-Day2/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>设 $lcp(s,i,j)$ 在字符串 $s$ 中后缀 $i$ 和 后缀 $j$ 的最长公共前缀。</p>
<p>给一字符串 $s$，对于每个前缀 $s[1,k]$，求 $\mbox{mex}{(lcp(s[1,k],i,j)|1\leq i &lt; j \leq k)}$。</p>
<p>$n\leq 10^6$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>若某个 $lcp(i,j)$ 为 $x$，将前面的字符都减少一个，则变为 $x-1$。</p>
<p>因此若集合中有 $x$，则 $1,2,\cdots,x$ 都存在。</p>
<p>显然若集合中有 $0$，则答案为 $\max{(lcp(i,j)|1\leq i &lt; j\leq k)}+1$。</p>
<p>当集合中没有 $0$ 时，任意两个后缀的最长公共前缀均大于等于 $1$，只有字符串中都是一个字母的情况。</p>
<p>除去这种情况后，只需考虑结尾在 $k$ 位的字符串。假设倒序枚举 $j$，使得 $s[1,k]$ 中存在多个 $s[j,k]$。</p>
<p>考虑后缀自动机，若一个字符串所在的节点中，$right$ 集合大小 $\geq 2$ 就可以了。</p>
<p>考虑后缀自动机的性质，$fa[x]$ 的 $right$ 集合大小必定大于 $x$ 的大小，又由于刚加进去的点的 $right$ 集合一定是 $1$，因此 $len[fa[x]]$ 即为所求。</p>
<p>时间复杂度 $O(n)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S 26</span></span><br><span class="line"><span class="keyword">namespace</span> SAM&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],fa[N],len[N],siz,las;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=siz;i++) <span class="built_in">memset</span>(ne[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(ne[i])),len[i]=fa[i]=<span class="number">0</span>;</span><br><span class="line">		siz=las=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> cur=++siz,p=las;</span><br><span class="line">		len[cur]=len[p]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;p&amp;&amp;!ne[p][c];p=fa[p]) ne[p][c]=cur;</span><br><span class="line">		<span class="keyword">if</span>(!p) fa[cur]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> q=ne[p][c];</span><br><span class="line">			<span class="keyword">if</span>(len[p]+<span class="number">1</span>==len[q]) fa[cur]=q;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> clone=++siz;</span><br><span class="line">				len[clone]=len[p]+<span class="number">1</span>;</span><br><span class="line">				fa[clone]=fa[q];</span><br><span class="line">				<span class="built_in">memcpy</span>(ne[clone],ne[q],<span class="built_in">sizeof</span>(ne[q]));</span><br><span class="line">				<span class="keyword">for</span>(;p&amp;&amp;ne[p][c]==q;p=fa[p]) ne[p][c]=clone;</span><br><span class="line">				fa[cur]=fa[q]=clone;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		las=cur;</span><br><span class="line">		<span class="keyword">return</span> len[fa[las]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T,n,ans;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(;T--;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">		SAM::<span class="built_in">init</span>();</span><br><span class="line">		n=<span class="built_in">strlen</span>(s); ans=<span class="number">0</span>;</span><br><span class="line">		<span class="type">bool</span> bo=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i) ans=<span class="built_in">max</span>(ans,SAM::<span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>)+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(s[i]!=s[<span class="number">0</span>]) bo=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans*bo);</span><br><span class="line">			<span class="built_in">printf</span>((i==n<span class="number">-1</span>)?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Palindromic Magic[CF1081H]</title>
    <url>/2020/02/04/Palindromic-Magic-CF1081H/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给两个字符串 $A,B$，求本质不同的字符串个数，满足该字符串由 $A$ 的一个非空回文子串和 $B$ 的一个非空回文子串拼接而成。</p>
<p>$|A|,|B|\leq 2\times 10^5$</p>
<span id="more"></span>

<h3 id="记号与定义"><a href="#记号与定义" class="headerlink" title="记号与定义"></a>记号与定义</h3><p>为了方便，以下为一些记号及定义：</p>
<p>1，记两个字符串 $a,b$ 按顺序拼接而成的字符串为 $ab$.</p>
<p>2，记 $s^R$为 $s$ 按位翻转后的结果。</p>
<p>3，记 $\mbox border(a)$ 为一个最长的字符串，满足该字符串既是 $a$ 的前缀，也是 $a$ 的后缀。</p>
<p>4，记周期 $u$ 为对于任意的 $i$ 满足 $s_i=s_{i+u}$，则 $u$ 为字符串的一个周期。</p>
<p>5，定义循环串为：设最小的 $u$，满足 $u$ 为 $s$ 的周期，且 $u||S|$，$u\not = |S|$，则 $s$ 为循环串。</p>
<p>6，定义双回文串：$s=ab$，其中 $a,b$ 为非空回文串，则 $s$ 为双回文串。</p>
<p>7，定义非严格双回文串：严格双回文或者非空回文串。</p>
<h3 id="简单性质"><a href="#简单性质" class="headerlink" title="简单性质"></a>简单性质</h3><p>这些性质都比较显然。</p>
<p>1，若 $s$ 为回文串，则 $\mbox {border(s)}$ 为回文串。</p>
<p>2，若 $t=\mbox {border(s)}$，且 $2|t|\geq |s|$，则 $s$ 为回文当且仅当 $t$ 为回文。</p>
<p>3，若 $a,b$ 均为 $s$ 周期，且 $a+b\leq |s|$，则 $\gcd(a,b)$ 是 $s$ 的周期。</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><h4 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h4><p>描述</p>
<p>$s=x_1x_2=y_1y_2=z_1z_2$，且 $|x_1|&lt;|y_1|&lt;|z_1|$，若 $x_2,y_1,y_2,z_1$ 均为非空回文串，则 $x_1,z_2$ 也是回文串。</p>
<p>证明：</p>
<p><img src="/Palindromic-Magic-CF1081H/1.png" alt="0"></p>
<h4 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h4><p>描述：</p>
<p>若 $s$ 为双回文串，设 $a$ 为最长回文前缀，$b$ 为最长回文后缀，$s=ax=yb$，则 $x,y$ 至少有一个为回文串。</p>
<p>证明：</p>
<p>由引理1推得。</p>
<h4 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h4><p>若 $s$ 有两种及以上不同的弱双回文拆分，则 $s$ 为循环串。</p>
<h4 id="引理4"><a href="#引理4" class="headerlink" title="引理4"></a>引理4</h4><p>设 $s=x_1y_1=x_2y_2=\cdots=x_my_m$ ， $\forall i\in[1,m)$， 若 $|x_i|&lt;|x_{i+1}|$，则 $x_i=\mbox{border}(x_{i+1})$ 和 $y_{i+1}=\mbox {border}(y_i)$ 至少一个成立。</p>
<p>不会证。。。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>好了写了这么多终于到重要部分了。。。</p>
<p>如果不是求本质不同，就是问有多少种是直接拼起来的话，那么答案就是 $a$ 和 $b$ 的本质不同的回文串的个数的乘积。</p>
<p>那么多出来的情况就是满足有多种双回文拆分的字符串。</p>
<p>由引理3可得：这个字符串是<strong>循环串</strong>。</p>
<p>由引理4可得：若这个字符串的一种拆分为 $s=xy$，且 $x$ 变为 $\mbox{border}(x)$ 或者 $y$ 变为 $\mbox{border}(y)$ 后仍能形成 $s$，就要减去这种情况。</p>
<p>所以答案就是( $a$ 和 $b$ 的本质不同的回文串的个数的乘积）- ($x$ 变为 $\mbox{border}(x)$后仍能形成 $s$ 的方案数) - ($y$ 变为 $\mbox{border}(y)$后仍能形成 $s$ 的方案数) + ($x$ 变为 $\mbox{border}(x)$ 且 $y$ 变为 $\mbox{border}(y)$ 后仍能形成 $s$ 的方案数)。</p>
<p>分三类讨论：</p>
<h4 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h4><p>此时要算： $a$ 和 $b$ 的本质不同的回文串的个数的乘积</p>
<p>这个是个人都会算，对 $a,b$ 串建出 $\mbox PAM$ 后，节点个数-2 就是本质不同的回文串个数了。</p>
<h4 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h4><p>此时要算：($x$ 变为 $\mbox{border}(x)$后仍能形成 $s$ 的方案数) + ($y$ 变为 $\mbox{border}(y)$后仍能形成 $s$ 的方案数) </p>
<p>$y$ 的情况和 $x$ 类似，我们只需考虑 $x$。</p>
<p>设 $x=\mbox{border}(x)w$，转换成求满足 $wS$，满足 $S,wS$ 为非空的回文串，且 $wS$ 在 $b$ 串中出现过的方案数。</p>
<p>由于 $w$ 为 $x$ 的最小正周期，所以 $w$ 不为循环串。</p>
<p>因此分类讨论一下可得：</p>
<h5 id="分类1"><a href="#分类1" class="headerlink" title="分类1"></a>分类1</h5><p>当 $|w|\leq |S|$ 时：</p>
<p>此时 $|w|\leq \frac{|wS|}{2}$，又因为 $wS$ 一定是循环串，因此 $w$ 为 $wS$ 的一个周期。</p>
<p>若 $S\not =\mbox{border}(wS)$，则 $wS$ 存在一个小于 $w$ 的周期，因此 $w$ 为循环串，不可能。</p>
<p>因此只需满足 $S=\mbox{border}(wS)$即可。</p>
<p>用哈希算个数即可。</p>
<h5 id="分类2"><a href="#分类2" class="headerlink" title="分类2"></a>分类2</h5><p>当 $|w|&gt;|S|$ 时：</p>
<p>因为 $w$ 不为循环串，由引理3得 $w$ 最多存在一种双回文拆分，又由于 $wS,S$ 为回文串，则$w=ST$，由引理2可得知，只需要找到 $w$ 的最长回文前后缀，就可以找到 $S$，这个显然可以正反串都建立 $PAM$ 后在 $fail$ 树上倍增即可。然后还是用哈希找到是否存在 $wS$ 就可以了。注意 $S$ 不能为空串的情况。 </p>
<h4 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h4><p>此时要算：$x$ 变为 $\mbox{border}(x)$ 且 $y$ 变为 $\mbox{border}(y)$ 后仍能形成 $s$ 的方案数。</p>
<p>设 $x=w_x\mbox{border}(x),y=\mbox{border}(y)w_y$，直接用哈希算出 $w_x=w_y$ 的情况就可以啦。</p>
<h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>因此需要 $PAM$ + 哈希 + 倍增。</p>
<p>时间复杂度 $O(n\log n)$</p>
<p>代码<del>也就</del>250行<del>而已</del>。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pli pair<span class="string">&lt;ll,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pil pair<span class="string">&lt;int,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pll pair<span class="string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> com complex<span class="string">&lt;db&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair((x),(y))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-(x)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bit(x,i) (((x)&gt;&gt;(i))&amp;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S=<span class="number">26</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll m1=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll m2=<span class="number">998244853</span>;</span><br><span class="line"><span class="type">const</span> ll base=<span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add1</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y%m1; x%=m1; <span class="keyword">return</span> (x+m1)%m1;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec1</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y%m1; <span class="keyword">return</span> (x%m1+m1)%m1;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul1</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> ((x*y%m1)+m1)%m1;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add2</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y%m2; x%=m2; <span class="keyword">return</span> (x+m2)%m2;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec2</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y%m2; <span class="keyword">return</span> (x%m2+m2)%m2;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul2</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> ((x*y%m2)+m2)%m2;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hint</span>&#123;</span><br><span class="line">	ll a1,a2;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> +(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> Hint &amp;B) &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Add1</span>(A.a1,B.a1),<span class="built_in">Add2</span>(A.a2,B.a2)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> +(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> ll &amp;B)   &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Add1</span>(A.a1,B),<span class="built_in">Add2</span>(A.a2,B)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> -(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> Hint &amp;B) &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Dec1</span>(A.a1,B.a1),<span class="built_in">Dec2</span>(A.a2,B.a2)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> -(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> ll &amp;B)   &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Dec1</span>(A.a1,B),<span class="built_in">Dec2</span>(A.a2,B)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> *(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> Hint &amp;B) &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Mul1</span>(A.a1,B.a1),<span class="built_in">Mul2</span>(A.a2,B.a2)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> Hint <span class="keyword">operator</span> *(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> ll &amp;B)   &#123;<span class="keyword">return</span> (Hint)&#123;<span class="built_in">Mul1</span>(A.a1,B),<span class="built_in">Mul2</span>(A.a2,B)&#125;;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Hint &amp;A,<span class="type">const</span> Hint &amp;B) &#123;<span class="keyword">if</span>(A.a1!=B.a1) <span class="keyword">return</span> A.a1&lt;B.a1; <span class="keyword">return</span> A.a2&lt;B.a2;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HASH&#123;<span class="comment">//双哈希</span></span><br><span class="line">	Hint pw[N];</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pw[<span class="number">0</span>]=(Hint)&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) pw[i]=pw[i<span class="number">-1</span>]*base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> Hint <span class="title">Hash</span><span class="params">(Hint *h,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> h[r]-(h[l<span class="number">-1</span>]*pw[r-l+<span class="number">1</span>]);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> HASH::pw;</span><br><span class="line"><span class="keyword">using</span> HASH::Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PAM</span>&#123;</span><br><span class="line">	<span class="type">int</span> ne[N][S],fail[N],len[N],cnt,las,pos[N],ri[N];</span><br><span class="line">	<span class="type">int</span> s[N],n;</span><br><span class="line">	<span class="type">int</span> f[N][M+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		fail[<span class="number">0</span>]=fail[<span class="number">1</span>]=<span class="number">1</span>; len[cnt=<span class="number">1</span>]=<span class="number">-1</span>; las=<span class="number">1</span>;</span><br><span class="line">		s[n=<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getfail</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;s[n<span class="number">-1</span>-len[x]]!=s[n];x=fail[x]);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		s[++n]=c;</span><br><span class="line">		<span class="type">int</span> p=<span class="built_in">getfail</span>(las);</span><br><span class="line">		<span class="keyword">if</span>(!ne[p][c])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> u=++cnt,q=<span class="built_in">getfail</span>(fail[p]);</span><br><span class="line">			len[u]=len[p]+<span class="number">2</span>; fail[u]=ne[q][c]; ne[p][c]=u;</span><br><span class="line">		&#125;</span><br><span class="line">		las=ne[p][c];</span><br><span class="line">		pos[n]=las;</span><br><span class="line">		ri[pos[n]]=n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) <span class="built_in">extend</span>(s[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt) f[i][<span class="number">0</span>]=fail[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,M)</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,cnt)</span><br><span class="line">				f[j][i]=f[f[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> x=pos[r];</span><br><span class="line">		<span class="keyword">if</span>(len[x]&lt;=l) <span class="keyword">return</span> len[x];</span><br><span class="line">		<span class="built_in">fd</span>(i,M,<span class="number">0</span>) <span class="keyword">if</span>(len[f[x][i]]&gt;l) x=f[x][i];</span><br><span class="line">		<span class="keyword">return</span> len[fail[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> len)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">ask</span>(r,len)==len;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line">PAM la,ra,lb,rb;</span><br><span class="line">Hint ha[N],hb[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(a+<span class="number">1</span>); m=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line">	HASH::<span class="built_in">init</span>(<span class="built_in">max</span>(n,m)+<span class="number">2</span>);</span><br><span class="line">	ha[<span class="number">0</span>]=hb[<span class="number">0</span>]=(Hint)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		ha[i]=ha[i<span class="number">-1</span>]*base+(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>),hb[i]=hb[i<span class="number">-1</span>]*base+(b[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">	la.<span class="built_in">build</span>(a); lb.<span class="built_in">build</span>(b);</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>); <span class="built_in">reverse</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>);</span><br><span class="line">	ra.<span class="built_in">build</span>(a); rb.<span class="built_in">build</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Work1&#123;</span><br><span class="line">	<span class="comment">//x-&gt;border(x) or y-&gt;border(y)</span></span><br><span class="line">	<span class="comment">//dec</span></span><br><span class="line">	map&lt;Hint,<span class="type">int</span>&gt; ma,mb,wa,wb;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="type">int</span> t;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,la.cnt)<span class="comment">//A</span></span><br><span class="line">		&#123;</span><br><span class="line">			ma[<span class="built_in">Hash</span>(ha,la.ri[i]-la.len[i]+<span class="number">1</span>,la.ri[i])]++;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>((t=la.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span>(la.len[i]&lt;=(la.len[t]&lt;&lt;<span class="number">1</span>))<span class="comment">// |T|&lt;=2|S|</span></span><br><span class="line">					wa[<span class="built_in">Hash</span>(ha,la.ri[i]-(la.len[i]-la.len[t])+<span class="number">1</span>,la.ri[i])]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,lb.cnt)<span class="comment">//B</span></span><br><span class="line">		&#123;</span><br><span class="line">			mb[<span class="built_in">Hash</span>(hb,lb.ri[i]-lb.len[i]+<span class="number">1</span>,lb.ri[i])]++;</span><br><span class="line">			<span class="keyword">if</span>((t=lb.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">				<span class="keyword">if</span>(lb.len[i]&lt;=(lb.len[t]&lt;&lt;<span class="number">1</span>))<span class="comment">// |T|&lt;=2|S|</span></span><br><span class="line">					wb[<span class="built_in">Hash</span>(hb,lb.ri[i]-lb.len[i]+<span class="number">1</span>,lb.ri[i]-lb.len[t])]++;<span class="comment">//!!!!!</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="type">int</span> l,r,t,bor,len;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,la.cnt)</span><br><span class="line">		<span class="keyword">if</span>((t=la.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			l=la.ri[i]-(la.len[i]-la.len[t])+<span class="number">1</span>;</span><br><span class="line">			r=la.ri[i];</span><br><span class="line">			len=r-l+<span class="number">1</span>;</span><br><span class="line">			ans-=wb[<span class="built_in">Hash</span>(ha,l,r)];</span><br><span class="line"></span><br><span class="line">			bor=la.<span class="built_in">ask</span>(r,len);</span><br><span class="line">			<span class="keyword">if</span>(len==bor) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(ra.<span class="built_in">check</span>(n-l+<span class="number">1</span>,len-bor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mb.<span class="built_in">count</span>(<span class="built_in">Hash</span>(ha,l,r)*pw[len-bor]+<span class="built_in">Hash</span>(ha,l,r-bor))) ans--;<span class="comment">//w+S</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bor=ra.<span class="built_in">ask</span>(n-l+<span class="number">1</span>,len);</span><br><span class="line">			<span class="keyword">if</span>(la.<span class="built_in">check</span>(r,len-bor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(mb.<span class="built_in">count</span>(<span class="built_in">Hash</span>(ha,l,r)*pw[bor]+<span class="built_in">Hash</span>(ha,l,l+bor<span class="number">-1</span>))) ans--;<span class="comment">//w+S</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,lb.cnt)</span><br><span class="line">		<span class="keyword">if</span>((t=lb.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			l=lb.ri[i]-lb.len[i]+<span class="number">1</span>;</span><br><span class="line">			r=lb.ri[i]-lb.len[t];</span><br><span class="line">			len=r-l+<span class="number">1</span>;</span><br><span class="line">			ans-=wa[<span class="built_in">Hash</span>(hb,l,r)];</span><br><span class="line"></span><br><span class="line">			bor=lb.<span class="built_in">ask</span>(r,len);</span><br><span class="line">			<span class="keyword">if</span>(len==bor) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(rb.<span class="built_in">check</span>(m-l+<span class="number">1</span>,len-bor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ma.<span class="built_in">count</span>(<span class="built_in">Hash</span>(hb,r-bor+<span class="number">1</span>,r)*pw[len]+<span class="built_in">Hash</span>(hb,l,r))) ans--;<span class="comment">//S+w</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			bor=rb.<span class="built_in">ask</span>(m-l+<span class="number">1</span>,len);</span><br><span class="line">			<span class="keyword">if</span>(lb.<span class="built_in">check</span>(r,len-bor))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ma.<span class="built_in">count</span>(<span class="built_in">Hash</span>(hb,l+bor,r)*pw[len]+<span class="built_in">Hash</span>(hb,l,r))) ans--;<span class="comment">//S+w</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Work2&#123;</span><br><span class="line">	<span class="comment">// x-&gt;border(x) and y-&gt;border(y)</span></span><br><span class="line">	<span class="comment">// add</span></span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	map&lt;Hint,<span class="type">int</span>&gt; fa,fb;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span><span class="comment">//S=XaYb</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,la.cnt)</span><br><span class="line">			<span class="keyword">if</span>((t=la.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">				fa[<span class="built_in">Hash</span>(ha,la.ri[i]-(la.len[i]-la.len[t])+<span class="number">1</span>,la.ri[i])]++;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,lb.cnt)</span><br><span class="line">			<span class="keyword">if</span>((t=lb.fail[i])&gt;=<span class="number">2</span>)</span><br><span class="line">				fb[<span class="built_in">Hash</span>(hb,lb.ri[i]-lb.len[i]+<span class="number">1</span>,lb.ri[i]-lb.len[t])]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> v:fa) ans+=(ll)v.se*fb[v.fi];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ans=<span class="number">1ll</span>*(la.cnt<span class="number">-1</span>)*(lb.cnt<span class="number">-1</span>);</span><br><span class="line">	Work1::<span class="built_in">work</span>();</span><br><span class="line">	Work2::<span class="built_in">work</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="built_in">work</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>哈希</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>NIM游戏[牛客挑战赛36G]</title>
    <url>/2020/01/30/NIM%E6%B8%B8%E6%88%8F-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B36G/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://ac.nowcoder.com/acm/problem/54837">链接</a></p>
<span id="more"></span>

<h3 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h3><p>$n$ 个栈，第 $i$ 个栈有 $a_i$ 个石子，一共有 $b_i$ 中排列方式。选择一个栈后可任意决定其排列方式。</p>
<p>玩$\mbox{NIM}$游戏，每个人每次在某个栈中取走若干石子，不能取的人输。</p>
<p>求有多少种选栈的方案使得先手必败。</p>
<p>两个方案不同当且仅当存在一个栈仅出现在其中一个方案中或在两个方案中栈中物品的排列方式不同。</p>
<p>$n\leq 10^7,a_i\leq 10^5$</p>
<p>时限3s。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>设 $m=\max\{a_i\}$</p>
<p>要先手必败，那么异或和为0。</p>
<p>显而易见的，答案就是所有的 $(b_ix^{a_i}+1)$ 的异或卷积的常数项。</p>
<p>暴力$\mbox{FWT}$，复杂度 $O(m^2\log m)$。</p>
<p>但是我们发现每个函数都只有两项有数。</p>
<p>分析下$\mbox{FWT}$的性质发现自己想不到…</p>
<p>如果是算卷积，可以分治$\mbox{FFT}$。</p>
<p>那不妨试试分治$\mbox{FWT}$ ?</p>
<p>我们同时处理次数连续的区间：</p>
<p>分治的过程中，二进制表示下，前面若干位是相同的。</p>
<p>所以，当 $x$ 的次数的范围是 $[l,l+2^k)$ 的时候，做完$\mbox{FWT}$以后，$x$ 的次数在 $[0,2^k)\bigcup[l,l+2^k)$ 这个范围内有数。</p>
<p>那么就设 $fa$ 为次数是 $[0,2^k)$ 的答案，$fb$ 为 $[l,l+2^k)$ 的答案。</p>
<p>分治时，若一个分支是 $[l,l+2^k)$，则求的是 $[l+2^{k-1})$ 和 $[l+2^{k-1},l+2^k)$ 的答案。</p>
<p>分四类讨论一下就可以得到新的 $fa,fb$ 的值。</p>
<p>每次分治，$\mbox{FWT}$的次数减少一半。</p>
<p>时间复杂度 $T(m)=2T(m/2)+O(m\log m)$，即 $O(m\log ^2 m)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j);i&lt;(k);i++)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1</span>&lt;&lt;<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll inv2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fwt</span><span class="params">(<span class="type">int</span> n,ll *a,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>,p=(i&lt;&lt;<span class="number">1</span>);j&lt;n;j+=p)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>,l=j+k,r=l+i;k&lt;i;k++,l++,r++)</span><br><span class="line">			&#123;</span><br><span class="line">				x=a[l],y=a[r]; a[l]=x+y,a[r]=x-y;</span><br><span class="line">				a[l]&gt;=mod?(a[l]-=mod):<span class="number">0</span>;</span><br><span class="line">				a[r]&lt;<span class="number">0</span>?(a[r]+=mod):<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(t!=<span class="number">1</span>) (a[l]*=inv2)%=mod,(a[r]*=inv2)%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll fa[N],fb[N],la[N],lb[N],ra[N],rb[N],g1[N],g2[N],g3[N],g4[N];</span><br><span class="line">ll a[N],b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m) &#123;fa[l]=a[l]; fb[l]=b[l]; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="type">int</span> r=l+m;</span><br><span class="line">	<span class="built_in">solve</span>(l,m&gt;&gt;<span class="number">1</span>); <span class="built_in">solve</span>(r,m&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=i+l,k=i+r;i&lt;m;i++,j++,k++) la[i]=fa[j],ra[i]=fb[j],lb[i]=fa[k],rb[i]=fb[k];</span><br><span class="line">	<span class="built_in">fwt</span>(m,la,<span class="number">1</span>); <span class="built_in">fwt</span>(m,ra,<span class="number">1</span>); <span class="built_in">fwt</span>(m,lb,<span class="number">1</span>); <span class="built_in">fwt</span>(m,rb,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,m) g1[i]=la[i]*lb[i]%mod,g2[i]=la[i]*rb[i]%mod,g3[i]=ra[i]*lb[i]%mod,g4[i]=ra[i]*rb[i]%mod;</span><br><span class="line">	<span class="built_in">fwt</span>(m,g1,<span class="number">-1</span>); <span class="built_in">fwt</span>(m,g2,<span class="number">-1</span>); <span class="built_in">fwt</span>(m,g3,<span class="number">-1</span>); <span class="built_in">fwt</span>(m,g4,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=i+l,k=i+r;i&lt;m;i++,j++,k++) fa[j]=g1[i],fb[j]=g3[i],fb[k]=g2[i],fa[k]=g4[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,N) a[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> q,m,x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		q=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		x=(a[q]+b[q]*m)%mod;</span><br><span class="line">		y=(a[q]*m+b[q])%mod;</span><br><span class="line">		a[q]=x; b[q]=y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">0</span>,N/<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,(fa[<span class="number">0</span>]+fb[<span class="number">0</span>]+mod<span class="number">-1</span>)%mod);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>博弈论</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Triple[CF1119H]</title>
    <url>/2020/01/29/Triple-CF1119H/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="https://codeforces.com/problemset/problem/1119/H">链接</a></p>
<span id="more"></span>

<p>给三年整数 $x,y,z$，然后有 $n$ 个数组，第 $i$ 个数组有 $x$ 个 $a_i$，$y$ 个 $b_i$，$z$ 个 $c_i$。</p>
<p>一种方案为：从 $n$ 个数组中各选择 $1$ 个数。</p>
<p>对于每个 $t\in[0,2^k)$，求出有多少种方案，使得该方案中的数的异或和为 $t$，对 $998244353$ 取模。</p>
<p>$1\leq n \leq 10^5,1\leq k \leq 17$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一个显然的做法是每个数组对应一个生成函数，都做一次 $\mbox{FWT}$。时间复杂度 $O(nk2^k)$，显然不行。</p>
<p>但这个生成函数只有三个位置有数，比较特殊。</p>
<p>考虑将 $\{ a_i,b_i,c_i\}$ 变为 $\{0,a_i\bigoplus b_i,a_i\bigoplus c_i\}$，最后异或上 $\bigoplus_{i=1}^n a_i$ 就是答案。</p>
<p>那么 $\mbox{FWT}$ 以后就只剩下四种答案：$x+y+z$,$x+y-z$,$x-y+z$,$x-y-z$。</p>
<p>最后乘起来的结果就是 $(x+y+z)^{a_1}(x+y-z)^{a_2}(x-y+z)^{a_3}(x-y-z)^{a_4}$</p>
<p>求出了 $a_1,a_2,a_3,a_4$ 就可以了。</p>
<p>首先有 $a_1+a_2+a_3+a_4=n$</p>
<p>我们发现当 $x=0,y=1,z=0$ 的时候答案只跟 $y$ 有关，由于$FWT(A+B)=FWT(A)+FWT(B)$，那么对于每个 $i$ ，将 $f[a_i\bigoplus b_i]$ 加 $1$ 后，$FWT$ 一下，求出的 $f_i$ 就有： $a_1+a_2-a_3-a_4=f_i$。</p>
<p>同理对 $z$ 进行同样的处理，有 $a_1-a_2+a_3-a_4=f_i$。</p>
<p>还差一个方程就可以解出来了。</p>
<p>可以发现，我们上面处理的是 $a$^$b$ 和 $a$^$c$ 的，还有一个 $b$^$c$ 没有处理。</p>
<p>考虑变为 $\{a_i\bigoplus b_i,0,c_i\bigoplus b_i\}$，这时候会有四种答案：$x+y+z,x+y-z,-x+y+z,-x+y-z$</p>
<p>将 $f[b_i\bigoplus c_i]$ 加 $1$ 后 $FWT$，就相当于 $a_1-a_2+a_4-a_3=f_i$</p>
<p>于是便可以解出 $a_1,a_2,a_3,a_4$。</p>
<p>然后快速幂，再 $UFWT$ 一下就好了。</p>
<p>时间复杂度 $O((n+2^k)k)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long</span><br><span class="line">const int N=1&lt;&lt;20;</span><br><span class="line">const ll mod=998244353;</span><br><span class="line">const ll inv2=(mod+1)/2;</span><br><span class="line">const ll inv4=inv2*inv2%mod;</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">	int x=0; char ch=getchar(); bool f=0;</span><br><span class="line">	for(;ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;;ch=getchar()) if(ch==&#x27;-&#x27;) f=1;</span><br><span class="line">	for(;ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;;ch=getchar()) x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);</span><br><span class="line">	return f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line">inline ll Pow(ll x,int y)</span><br><span class="line">&#123;</span><br><span class="line">	ll ans=1;</span><br><span class="line">	for(;y;y&gt;&gt;=1,x=x*x%mod) if(y&amp;1) ans=ans*x%mod;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">inline void fwt(int n,ll *a,int t)</span><br><span class="line">&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	for(int i=1;i&lt;n;i&lt;&lt;=1)</span><br><span class="line">		for(int j=0;j&lt;n;j+=(i&lt;&lt;1))</span><br><span class="line">			for(int k=0;k&lt;i;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				x=a[j+k],y=a[i+j+k];</span><br><span class="line">				a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">				if(t!=1) (a[j+k]*=inv2)%=mod,(a[i+j+k]*=inv2)%=mod;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line">int n,k,m,a,b,c,s;</span><br><span class="line">ll x,y,z,d1,d2,d3,d4,f1[N],f2[N],f3[N],g[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	n=read(); k=read();</span><br><span class="line">	m=1&lt;&lt;k;</span><br><span class="line">	x=read(),y=read(),z=read();</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a=read(),b=read(),c=read();</span><br><span class="line">		f1[a^b]++,f2[a^c]++,f3[b^c]++;</span><br><span class="line">		s^=a;</span><br><span class="line">	&#125;</span><br><span class="line">	fwt(m,f1,1); fwt(m,f2,1); fwt(m,f3,1);</span><br><span class="line">	d1=(x+y+z)%mod; d2=(mod+x+y-z)%mod;</span><br><span class="line">	d3=(x-y+z+mod)%mod; d4=(x-y-z+mod+mod)%mod;</span><br><span class="line">	for(int i=0;i&lt;m;i++)</span><br><span class="line">		g[i]=</span><br><span class="line">			Pow(d1,((ll)n+f1[i]+f2[i]+f3[i])%mod*inv4%mod)*</span><br><span class="line">			Pow(d2,((ll)n+f1[i]-f2[i]-f3[i]+mod*2)%mod*inv4%mod)%mod*</span><br><span class="line">			Pow(d3,((ll)n-f1[i]+f2[i]-f3[i]+mod*2)%mod*inv4%mod)%mod*</span><br><span class="line">			Pow(d4,((ll)n-f1[i]-f2[i]+f3[i]+mod*2)%mod*inv4%mod)%mod;</span><br><span class="line">	fwt(m,g,-1);</span><br><span class="line">	for(int i=0;i&lt;m;i++) printf(&quot;%lld &quot;,g[i^s]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Distance Between Sweethearts</title>
    <url>/2020/01/29/Distance-Between-Sweethearts/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://codeforces.com/gym/101955/problem/I">链接</a></p>
<span id="more"></span>

<p>给定六个不大于 $2000$ 的整数，$UI_{g},UA_{g},UG_{g},UI_{b},UA_{b},UG_{b}$，</p>
<p>求和：$\max\{|I_b-I_g|,|A_b-A_g|,|G_b-G_g|\}\bigoplus I_b\bigoplus A_b\bigoplus G_b\bigoplus I_g\bigoplus A_g\bigoplus G_g$，且满足：</p>
<p> $I_{g}\in\{0,UI_{g}\},A_{g}\in\{0,UA_{g}\},G_{g}\in\{0,UG_{g}\}$</p>
<p>$I_{b}\in\{0,UI_{b}\},A_{b}\in\{0,UA_{b}\},G_{b}\in\{0,UG_{b}\}$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>那个 $\max$ 比较烦人，把那个 $\max$ 扔掉，假设为 $k=\max\{x,y,z\}$。</p>
<p>要求出 $f_i$，表示在最大值为 $k$ 的情况下 $I_b\bigoplus A_b\bigoplus G_b\bigoplus I_g\bigoplus A_g\bigoplus G_g=i$ 的方案数。</p>
<p>但这样显然没法做，因为我们无法确定最大值是否为 $k$。</p>
<p>为了确定最大值为 $k$，我们可以利用 $[1,k-1]$ 的答案。</p>
<p>也就是把 $f_i$ 的状态改为 ：在最大值 $\leq k$ 的情况下 $I_b\bigoplus A_b\bigoplus G_b\bigoplus I_g\bigoplus A_g\bigoplus G_g=i$ 的方案数。</p>
<p>把六个异或的顺序改一改：$(I_b\bigoplus I_g)\bigoplus (G_b\bigoplus G_g)\bigoplus (A_b\bigoplus A_g)=i$</p>
<p>只需要看统计 $I_b\bigoplus I_g$ 的出现次数($G,A$ 同理)，然后 $\mbox {FWT}$ 就可以了。</p>
<p>此时可以把 $I_b,I_g$ 相差不超过 $k$ 的统计一下就好了。</p>
<p>时间复杂度 $O(n^2\log n)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2048</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fwt</span><span class="params">(<span class="type">int</span> n,ll *a,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				x=a[j+k],y=a[i+j+k];</span><br><span class="line">				a[j+k]=x+y,a[i+j+k]=x-y;</span><br><span class="line">				<span class="keyword">if</span>(t!=<span class="number">1</span>) a[j+k]=a[j+k]/<span class="number">2</span>,a[i+j+k]=a[i+j+k]/<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(ll *a,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="built_in">min</span>(x,y-z)) a[i^(i+z)]++;</span><br><span class="line">&#125;</span><br><span class="line">ll cnt[<span class="number">3</span>][N],a[<span class="number">3</span>][N],las[N];</span><br><span class="line">ull ans;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>],g[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> _=<span class="built_in">read</span>(),T=<span class="number">1</span>;T&lt;=_;T++)</span><br><span class="line">	&#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">read</span>(),b[<span class="number">1</span>]=<span class="built_in">read</span>(),b[<span class="number">2</span>]=<span class="built_in">read</span>();</span><br><span class="line">		g[<span class="number">0</span>]=<span class="built_in">read</span>(),g[<span class="number">1</span>]=<span class="built_in">read</span>(),g[<span class="number">2</span>]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,N<span class="number">-1</span>) cnt[<span class="number">0</span>][i]=cnt[<span class="number">1</span>][i]=cnt[<span class="number">2</span>][i]=las[i]=<span class="number">0</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,<span class="number">2000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="built_in">get</span>(cnt[j],b[j],g[j],i);</span><br><span class="line">			<span class="keyword">if</span>(i) <span class="built_in">fo</span>(j,<span class="number">0</span>,<span class="number">2</span>) <span class="built_in">get</span>(cnt[j],g[j],b[j],i);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) <span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">2</span>) a[k][j]=cnt[k][j];</span><br><span class="line">			<span class="built_in">fo</span>(k,<span class="number">0</span>,<span class="number">2</span>) <span class="built_in">fwt</span>(N,a[k],<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) a[<span class="number">0</span>][j]=a[<span class="number">0</span>][j]*a[<span class="number">1</span>][j]*a[<span class="number">2</span>][j];</span><br><span class="line">			<span class="built_in">fwt</span>(N,a[<span class="number">0</span>],<span class="number">-1</span>);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,N<span class="number">-1</span>) ans+=(a[<span class="number">0</span>][j]-las[j])*(j^i),las[j]=a[<span class="number">0</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %llu\n&quot;</span>,T,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>FWT</title>
    <url>/2020/01/29/FWT/</url>
    <content><![CDATA[<p>$\mbox{FWT}$ 知识点总结</p>
<span id="more"></span>

<h2 id="FWT及FMT"><a href="#FWT及FMT" class="headerlink" title="FWT及FMT"></a>FWT及FMT</h2><h3 id="先来看看FMT"><a href="#先来看看FMT" class="headerlink" title="先来看看FMT"></a>先来看看FMT</h3><p>我们记得，$\mbox{FFT}$做的是这样的卷积：$\sum_{i+j=k}A_iB_j=C_k$</p>
<p>但如果我们把符号换一下呢？</p>
<p>比如说或/与卷积：$\sum_{i|j=k}A_iB_j=C_k,\sum_{i&amp;j=k}A_iB_j=C_k$</p>
<p>还是像fft的思路，考虑一个数组，有个变换，使得数组变换后能实现对应位置相乘。</p>
<p>即：$FMT(A)[x]\cdot FMT(B)[x]=FMT(C)[x]$.</p>
<p>当是或卷积时，$FMT(A)[x]=\sum_{i|x}A_i$.</p>
<p>因为：$(\sum_{i|x}A_i)(\sum_{j|x}B_j)=\sum_{i|x,j|x}A_iB_j=\sum_{k|x}(\sum_{i|j=k}A_iB_j)=\sum_{k|x}C_k$</p>
<p>那如何快速求 $FMT(A)$ 及其逆变换呢？</p>
<p>与卷积与或卷积类似：$FMT(A)[x]=\sum_{x|i}A_i$</p>
<p>考虑基于枚举二进制位的分治，假设第 $i$ 位的二进制已经处理完了，然后看加上第 $i+1$ 位后答案应该是怎么样的：如果这一位是 0，那么不变，否则因为是枚举子集，加上 $i+1$ 位不取的结果即可。</p>
<p>那么逆变换就是把正变换的贡献减去即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//或卷积模板,opt=1时为正变换，-1时为逆变换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FMT</span><span class="params">(<span class="type">int</span> * a, <span class="type">int</span> n, <span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=i&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;n;j+=p)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">                A[i + j + k]+=opt*A[j + k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或卷积的正变换其实就是高维前缀和（子集和），逆变换就是子集反演。</p>
<p>与卷积和或卷积类似了。</p>
<p>时间复杂度$O(n\log n)$</p>
<h2 id="再来看看FWT"><a href="#再来看看FWT" class="headerlink" title="再来看看FWT"></a>再来看看FWT</h2><p>定义 $k$ 进制不进位加法：$a\bigoplus b=(a+b) \% k$，减法类似。</p>
<p>FWT实际上就是求：$C_k=\sum_{i\bigoplus j=k}A_iB_j$</p>
<h3 id="2进制FWT"><a href="#2进制FWT" class="headerlink" title="2进制FWT"></a>2进制FWT</h3><p>此时不进位加法即为异或。以下 $n$ 满足 $n=2^x$</p>
<p>还是像fft的思路，考虑一个数组竖着排成一列变成一个 $n \times 1$ 的矩阵，然后有个变换，使得数组变换后能实现对应位置相乘。这个变换的实现就是令数组<strong>左乘</strong>一个 $n*n$ 的矩阵（可以回去看看fft的过程）。假设这个矩阵是 $T$，第 $i$ 行第 $j$ 列的数是 $T_{i,j}$</p>
<p>然后我们令$FWT(A)=TA$</p>
<p>因为要满足对应位置相乘，这里就是$FWT(A)[x]\cdot FWT(B)[x]=FWT(C)[x]$</p>
<p>由于$FWT(A)[x]=\sum_{i=0}^nT_{x,i}A_i$</p>
<p>代入上式得：$\sum_{i=0}^{n-1}T_{x,i}A_i\sum_{j=0}^{n-1}T_{x,j}B_j=\sum_{k=0}^{n-1}T_{x,k}C_k$</p>
<p>同时因为 $C_k=\sum_{i\bigoplus j=k}A_iB_j$</p>
<p>代入得：</p>
<p>$$\sum_{i=0}^{n-1}\sum_{j=0}^{n-1}T_{x,i}T_{x,j}A_iB_j=\sum_{k=0}^{n-1}\sum_{i\bigoplus j=k}T_{x,k}A_iB_j$$</p>
<p>因此满足 $T_{x,i}T_{x,j}=T_{x,i\bigoplus j}=T_{x,(i+j)\bmod 2}$ 即可。</p>
<p>因为 $T_{x,i}$ 满足上述性质，把 $i$ 写成二进制形式：$i=\overline{i_0i_1\dots i_m}(2)$</p>
<p>因此 $T_{x,i}$ 可以等于 $\Pi <em>{j=0}^m T</em>{x_j,i_j}$ </p>
<p>同时还需要快速算出 $FWT(A)$:</p>
<p>不妨设 $i$ 在二进制中最高位为 $i_1$，舍去最高位后为 $i_0$.</p>
<p>考虑分治：</p>
<p>$$FWT(A)<em>n[i]\=\sum</em>{k=0}^{n-1}T_{i,k}A_k\=T_{i_1,0}\sum_{k=0}^{n/2-1}T_{i_0,k_0}A_{k}+T_{i_1,1}\sum_{k=n/2}^{n-1}T_{i_0,k_0}A_k\=T_{i_1,0}FWT(A_0)<em>{\frac{n}{2}}[i]+T</em>{i_1,1}FWT(A_1)_{\frac{n}{2}}[i]$$</p>
<p>其中 $A_0$ 为 $A$ 的前 $n/2$ 位，$A_1$ 为后 $n/2$ 位。</p>
<p>因此只要能找到合适的 $T_{x,i}$，就能实现了。</p>
<p>只需考虑 $0\le x,i &lt; 2$ 的情况即可。</p>
<p>满足：</p>
<p> $$T_{0,0}\times T_{0,0}=T_{0,0}\\T_{0,0}\times T_{0,1}=T_{0,1}\\T_{0,1}\times T_{0,1}=T_{0,0}\\T_{1,0}\times T_{1,0}=T_{1,0}\\T_{1,0}\times T_{1,1}=T_{1,1}\\T_{1,1}\times T_{1,1}=T_{1,0}\$$</p>
<p>考虑写成矩阵形式，构造可得：</p>
<p>$$\begin{bmatrix} T_{0,0}&amp;T_{0,1}\\ T_{1,0}&amp;T_{1,1}\end{bmatrix}=\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}=\begin{bmatrix}\frac{1}{2}&amp;\frac{1}{2}\\\frac{1}{2}&amp;-\frac{1}{2}\end{bmatrix}^{-1}$$</p>
<p>带进程序里即可。</p>
<p>一个2进制FWT的模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				ll x = a[j+k],y = a[i+j+k];</span><br><span class="line">				a[j+k] = x+y; a[i+j+k] = x-y+mod;</span><br><span class="line">				<span class="keyword">if</span>(a[j+k] &gt;= mod) a[j+k] -= mod;</span><br><span class="line">				<span class="keyword">if</span>(a[i+j+k] &gt;= mod) a[i+j+k] -= mod;</span><br><span class="line">				<span class="keyword">if</span>(t == <span class="number">-1</span>) a[j+k] = (a[j+k]*inv2)%mod,a[i+j+k] = (a[i+j+k]*inv2)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2进制 $\mbox{FWT}$ 的正变换实际上就是 $FWT[i]=\sum_{j}A_j(-1)^{|i&amp;j|}$.</p>
<h3 id="k进制FWT"><a href="#k进制FWT" class="headerlink" title="k进制FWT"></a>k进制FWT</h3><p>以下 $n$ 满足 $n=k^x$</p>
<p>前面同理，但还是要满足 $T_{x,i}T_{x,j}=T_{x,i\bigoplus j}=T_{x,(i+j)\bmod k}$，以及把 $i$ 写成 $k$ 进制形式：$i=\overline{i_0i_1\dots i_m}(k) $后，$T_{x,i}=\Pi <em>{j=0}^m T</em>{x_j,i_j}$ </p>
<p>因此只需考虑 $T_{x,i}(0\le x,i &lt; k)$ 即可。</p>
<p>想到1的 $k$ 次单位根：$T_{x,i}=\omega_{k}^{xi}$</p>
<p>那么：$\omega _{k}^i\omega _{k}^j=\omega_k^{(i+j)\bmod k}=\omega_k^{i\bigoplus j}$</p>
<p>由于矩阵需要存在逆矩阵，即要求满秩。</p>
<p>不妨想到范德蒙德矩阵：</p>
<p>$$\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; \dots &amp; 1\\<br>1 &amp; \omega _ k^1 &amp; \omega _ k^2 &amp; \dots &amp;\omega _ k^{k-1} \\<br>1 &amp; \omega _ k^2 &amp; \omega _ k^4 &amp; \dots &amp; \omega _ k^{2(k-1)}\\<br>\vdots &amp; \vdots &amp; \vdots &amp; \dots &amp; \vdots\\<br>1 &amp; \omega _ k^{k-1} &amp; \omega _ k^{2(k-1)} &amp; \dots &amp; \omega _ k^{(k-1)(k-1)}<br>\end{bmatrix}$$</p>
<p>逆矩阵和fft的一样。</p>
<p>这样子就能做任意进制的FWT了。</p>
<p>难度在求单位根上。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>1，UVA13277</p>
<p>模板题没啥好说的。</p>
<p>2，HDU6596</p>
<p>模板题 $\times 2$。</p>
<p>3，HDU6618</p>
<p>3进制FWT+倍增+状压，<a href="/2019/12/27/Good-Numbers-hdu6618/" title="见此">见此</a></p>
<p>4，<a href="/2020/01/29/Distance-Between-Sweethearts/" title="Distance Between Sweethearts">Distance Between Sweethearts</a></p>
<p>5，CF1119H</p>
<p>思维难度较大，<a href="/2020/01/29/Distance-Between-Sweethearts/" title="见此">见此</a></p>
<p>6，牛客挑战赛36G</p>
<p>分治FWT，<a href="/2020/01/30/NIM%E6%B8%B8%E6%88%8F-%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B36G/" title="见此">见此</a></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Acesrc and String Theory[hdu6661]</title>
    <url>/2020/01/16/Acesrc-and-String-Theory-hdu6661/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6661">HDU 6661</a></p>
<span id="more"></span>

<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个由小写字母组成的字符串，和一个 $k$，求有多少个非空子串满足这个子串是由某个字符串重复 $k$ 次组成的。</p>
<p>$|S|\leq 3\times 10^5,\sum |S|\leq 10^6,k\leq 20$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题是 $\mbox{NOI2016}$ 优秀的拆分的强化版。</p>
<p>一个合法的子串一定是形如 $AA\cdots A$ ($k$个$A$) ，那么我们试着枚举 $A$ 的长度 $i$。</p>
<p>类似“优秀的拆分”的做法，我们每隔 $i$ 个位置放一个隔板。如当 $i=3$ 时的一个例子：</p>
<p><img src="/Acesrc-and-String-Theory-hdu6661/0.png" alt="0"></p>
<p>可以发现，一个合法的子串一定刚好横跨了 $k$ 个隔板，我们试着枚举这些隔板是哪几个，设为 $b_i$。</p>
<p>设 $m_1=\min(i,LCP(Suf_{b_k},Suf_{b_{k+1}})),m_2=\min(i,LCS(Pre_{b_k},Pre_{b_{k+1}}))$</p>
<p>其中$\mbox{LCP}=\mbox{Longest Common Prefix},\mbox{LCS}=\mbox{Longest Common Suffix}$</p>
<p>若 $m_1+m_2&gt;i$，则对答案有 $m_1+m_2-i$ 的贡献。</p>
<p>还是上面的例子，当 $k=2$ ，取前两个隔板的情况为：</p>
<p><img src="/Acesrc-and-String-Theory-hdu6661/1.png" alt="1"></p>
<p>求最长公共前后缀用 $\mbox{SA}$ + $\mbox{ST}$表就可以做到 $O(n\log n)-O(1)$。</p>
<p>总的时间复杂度 $O(n\log n+k\sum_{i=1}^{\frac{n}{k}}\frac{n}{i})=O(kn\log n)$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>());</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Log[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SA</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,base[N],wx[N],wy[N],sa[N],rank[N],height[N];</span><br><span class="line">    <span class="type">char</span> s[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getsa</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> *x = wx,*y = wy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) base[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) base[x[i] = s[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++) base[i] += base[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--base[x[i]]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i,j=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;j&lt;&lt;=<span class="number">1</span>,m=p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(p=<span class="number">0</span>,i=n-j;i&lt;n;i++) y[p++] = i;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(sa[i]&gt;=j) y[p++] = sa[i]-j;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) base[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) base[x[y[i]]]++;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) base[i] += base[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) sa[--base[x[y[i]]]] = y[i];</span><br><span class="line">            <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>,p=<span class="number">1</span>,x[sa[<span class="number">0</span>]] = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                x[sa[i]] = (y[sa[i]]==y[sa[i<span class="number">-1</span>]] &amp;&amp; y[sa[i]+j]==y[sa[i<span class="number">-1</span>]+j])?p<span class="number">-1</span>:p++;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc_height</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rank[sa[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j,k=<span class="number">0</span>;i&lt;n;height[rank[i++]]=k)</span><br><span class="line">            <span class="keyword">for</span>(k?k--:<span class="number">0</span>,j=sa[rank[i]<span class="number">-1</span>];s[i+k]==s[j+k];k++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> f[N][<span class="number">22</span>];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get_st</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) f[i][<span class="number">0</span>]=height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,k=<span class="number">1</span>;j&lt;=<span class="number">19</span>;++j,k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i+k*<span class="number">2</span><span class="number">-1</span>&lt;=n;++i)</span><br><span class="line">                f[i][j]=<span class="built_in">min</span>(f[i][j<span class="number">-1</span>],f[i+k][j<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x=rank[x<span class="number">-1</span>]; y=rank[y<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y); x++;</span><br><span class="line">        <span class="type">int</span> k=Log[y-x+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(f[x][k],f[y-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in">sizeof</span>(sa));</span><br><span class="line">        <span class="built_in">memset</span>(height,<span class="number">0</span>,<span class="built_in">sizeof</span>(height));</span><br><span class="line">        <span class="built_in">memset</span>(rank,<span class="number">0</span>,<span class="built_in">sizeof</span>(rank));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">getsa</span>(s,n+<span class="number">1</span>,<span class="number">28</span>);</span><br><span class="line">        <span class="built_in">calc_height</span>(s,n);</span><br><span class="line">        <span class="built_in">get_st</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">SA A,B;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> bl[N],n,k;</span><br><span class="line">ll sum[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1ll</span>*n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="built_in">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,m1,m2;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(bl[<span class="number">1</span>]=i;bl[<span class="number">1</span>]+(i*(k<span class="number">-1</span>))&lt;=n;bl[<span class="number">1</span>]+=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=k;j++) bl[j]=bl[j<span class="number">-1</span>]+i;</span><br><span class="line">            m1=m2=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;k&amp;&amp;m1+m2&gt;i;j++) m1=<span class="built_in">min</span>(m1,A.<span class="built_in">lcp</span>(bl[j],bl[j+<span class="number">1</span>])),m2=<span class="built_in">min</span>(m2,B.<span class="built_in">lcp</span>(n-bl[j]+<span class="number">1</span>,n-bl[j+<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(m1+m2&gt;i) ans+=m1+m2-i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;N;i++) Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> _=<span class="built_in">read</span>();_--;)</span><br><span class="line">    &#123;</span><br><span class="line">        k=<span class="built_in">read</span>(); <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s); n=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) A.s[i]=s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) B.s[i]=s[n-i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">        A.n=B.n=n,A.s[n]=B.s[n]=<span class="number">0</span>,A.<span class="built_in">work</span>(),B.<span class="built_in">work</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>后缀数组</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2019多校6</title>
    <url>/2020/01/15/hdu2019%E5%A4%9A%E6%A0%A16/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=853">2019 Multi-University Training Contest 6</a></p>
<span id="more"></span>

<h3 id="Problem-A-Salty-Fish"><a href="#Problem-A-Salty-Fish" class="headerlink" title="Problem A Salty Fish"></a>Problem A Salty Fish</h3><a href="/2020/01/14/Salty-Fish-hdu6634/" title="Salty Fish[hdu6634]">Salty Fish[hdu6634]</a>

<h3 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h3><a href="/2019/12/29/Nonsense-Time-hdu6635/" title="Nonsense Time[hdu6635]">Nonsense Time[hdu6635]</a>

<h3 id="Problem-E-Snowy-Smile"><a href="#Problem-E-Snowy-Smile" class="headerlink" title="Problem E Snowy Smile"></a>Problem E Snowy Smile</h3><p>线段树维护最大字段和。</p>
<h3 id="Problem-F-Faraway"><a href="#Problem-F-Faraway" class="headerlink" title="Problem F Faraway"></a>Problem F Faraway</h3><p>拆开绝对值，然后暴力。</p>
<h3 id="Problem-H-TDL"><a href="#Problem-H-TDL" class="headerlink" title="Problem H TDL"></a>Problem H TDL</h3><p>签到题，暴力即可。</p>
<h3 id="Problem-I-Three-Investigators"><a href="#Problem-I-Three-Investigators" class="headerlink" title="Problem I Three Investigators"></a>Problem I Three Investigators</h3><a href="/2020/01/03/Three-Investigators-hdu6642/" title="Three Investigators[hdu6642]">Three Investigators[hdu6642]</a>

<h3 id="Problem-L-Stay-Real"><a href="#Problem-L-Stay-Real" class="headerlink" title="Problem L Stay Real"></a>Problem L Stay Real</h3><p>签到题，堆。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
  </entry>
  <entry>
    <title>Salty Fish[hdu6634]</title>
    <url>/2020/01/14/Salty-Fish-hdu6634/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵有根树，树上每个节点有 $a_i$ 个苹果。$m$ 个摄像机，每个摄像机可以看到 $x_i$ 的子树中所有与 $x_i$ 距离不超过 $k_i$ 的点中的苹果，可以花钱 $c_i$ 使该摄像机失效。求最终没有被看到的苹果数 - 花费的钱的最大值。</p>
<p>$n,m\leq 3\times 10^5$ , $\sum n,\sum m\leq 10^6$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><p>假设全部先选了所有的苹果，然后考虑放弃那些比较合适。</p>
<p>考虑最小割建图，$S$ 连每个摄像机，边权为 $c_i$；每个摄像机连对应的树上的点，边权为 $\infty$；每个树上的点连 $T$，权值为 $a_i$。</p>
<p>那么减去最小割就是答案了。</p>
<p>显然不能直接跑网络流，尽管线段树优化建图也不行。</p>
<p>那就只能模拟网络流了。</p>
<h4 id="模拟网络流"><a href="#模拟网络流" class="headerlink" title="模拟网络流"></a>模拟网络流</h4><p>贪心处理。</p>
<p>从叶节点往上推，把摄像机挂在树上。</p>
<p>每遇到一个摄像机都用当前深度最大的点去跟它抵消。</p>
<p>那么对于每个节点 $i$ 只需要记 $f_{i,j}$ 表示深度为 $j$ 的所有点还剩多少流量。</p>
<p>可以用 $\mbox{map}$ 维护。</p>
<p>合并的时候用启发式合并。这个只跟深度有关，因此长链剖分即可。</p>
<p>每个摄像机只会删除，不会令 $\mbox{map}$ 中的元素增加。</p>
<p>时间复杂度 $O((n+m)\log n)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> d,c;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt; f[N];</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt;::iterator it;</span><br><span class="line">vector&lt;node&gt; q[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> n,m,cnt;</span><br><span class="line"><span class="type">int</span> ver[N],ne[N],head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mx[N],son[N],dep[N],id[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		v=ver[i];</span><br><span class="line">		<span class="built_in">dfs</span>(v,u);</span><br><span class="line">		<span class="keyword">if</span>(mx[son[u]]&lt;mx[v]) son[u]=v;</span><br><span class="line">		mx[u]=<span class="built_in">max</span>(mx[u],mx[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	mx[u]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) <span class="built_in">dfs</span>(son[u]),id[u]=id[son[u]];</span><br><span class="line">	<span class="keyword">else</span> id[u]=++cnt;</span><br><span class="line">	f[id[u]][dep[u]]+=a[u];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">	<span class="keyword">if</span>((v=ver[i])!=son[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		<span class="keyword">for</span>(it=f[id[v]].<span class="built_in">begin</span>();it!=f[id[v]].<span class="built_in">end</span>();it++)</span><br><span class="line">			f[id[u]][(*it).fi]+=(*it).se;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d,c;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,q[u].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		d=q[u][i].d,c=q[u][i].c;</span><br><span class="line">		it=f[id[u]].<span class="built_in">upper_bound</span>(dep[u]+d);</span><br><span class="line">		<span class="keyword">if</span>(it==f[id[u]].<span class="built_in">begin</span>()) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">for</span>(it--;c;)</span><br><span class="line">		&#123;</span><br><span class="line">			ll w=<span class="built_in">min</span>((ll)c,(*it).se);</span><br><span class="line">			(*it).se-=w; ans-=w; c-=w;</span><br><span class="line">			<span class="keyword">if</span>(!(*it).se)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(it==f[id[u]].<span class="built_in">begin</span>()) &#123;f[id[u]].<span class="built_in">erase</span>(it); <span class="keyword">break</span>;&#125;</span><br><span class="line">				<span class="type">int</span> t=(*it).fi;</span><br><span class="line">				it--;</span><br><span class="line">				f[id[u]].<span class="built_in">erase</span>(t);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) head[i]=mx[i]=dep[i]=son[i]=id[i]=<span class="number">0</span>,q[i].<span class="built_in">clear</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,cnt) f[i].<span class="built_in">clear</span>();</span><br><span class="line">	ans=cnt=tot=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> _=<span class="built_in">read</span>(),x,k,c;_--;)</span><br><span class="line">	&#123;</span><br><span class="line">		n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),i);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>(),ans+=a[i];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,m) x=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),c=<span class="built_in">read</span>(),q[x].<span class="built_in">pb</span>((node)&#123;k,c&#125;);</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Hotel[POI2014]</title>
    <url>/2020/01/03/Hotel-POI2014/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵树，求所有三个不同的点，两两距离相同的方案数。</p>
<p>$n\leq 5000$</p>
<p>加强版：$n\leq 10^5$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>两个点可以在 $\mbox {LCA }$处统计，尝试着三个点也在 $\mbox LCA$ 那里统计答案？</p>
<p>三个点两两距离相同，说明必定存在一个点，使得这个点到这三个点距离均为 $d$。</p>
<p><img src="/Hotel-POI2014/1.png" alt="1"></p>
<p>那么假设 $3$ 号点与 $\mbox {LCA}$ 的距离为 $j$，那么蓝点到 $\mbox{LCA}$ 的距离为 $d-j$。</p>
<p>因此可以设 $f_{i,j}$ 表示 $i$ 号点的子树中与 $i$ 距离为 $j$ 的点有多少个，设 $g_{i,j}$ 表示 $i$ 号点的子树中，某两个点到第三点的距离为 $d$，第三点到 $\mbox{LCA}$ 的距离为 $d-j$ 的方案数。</p>
<p>依次考虑每个儿子 $k$，DP方程大概长这样：</p>
<p>$$g_{i,j}=g’<em>{i,j}+g</em>{k,j+1}+f_{i,j}\times f_{k,j-1},\\f_{i,j+1}=f’<em>{i,j+1}+f</em>{k,j}$$</p>
<p>统计答案：$g_{i,0}+\sum{f_{i,j}g_{k,j-1}}+\sum{f_{i,j-1}g_{k,j}}$</p>
<p>每一个 $k$ 的时间是 $O(len_k)$ 的。</p>
<p>显然可以 $O(n^2)$ DP一下。</p>
<p>既然复杂度跟 $len_k$ 相关，那么长链剖分一下就可以了。</p>
<p>重儿子的转移：$f_{son_i}=f_i+1,g_{son_i}=g_i-1$</p>
<p>预留够足够的空间就可以了。</p>
<p>时间复杂度 $O(n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 100010</span></span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,len[N],son[N];</span><br><span class="line">ll tmp[N&lt;&lt;<span class="number">2</span>],*f[N],*g[N],*id=tmp,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			<span class="keyword">if</span>(len[son[u]]&lt;len[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	len[u]=len[son[u]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) g[son[u]]=g[u]<span class="number">-1</span>,f[son[u]]=f[u]+<span class="number">1</span>,<span class="built_in">dfs2</span>(son[u],u);</span><br><span class="line">	ans+=g[u][<span class="number">0</span>]; f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;ver[i]!=son[u])</span><br><span class="line">		&#123;</span><br><span class="line">			f[v]=id; id+=len[v]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">			g[v]=id; id+=len[v]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,len[v]<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans+=g[u][j+<span class="number">1</span>]*f[v][j];</span><br><span class="line">				<span class="keyword">if</span>(j!=len[v]<span class="number">-1</span>) ans+=g[v][j+<span class="number">1</span>]*f[u][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fo</span>(j,<span class="number">0</span>,len[v]<span class="number">-1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				g[u][j+<span class="number">1</span>]+=f[u][j+<span class="number">1</span>]*f[v][j];</span><br><span class="line">				<span class="keyword">if</span>(j) g[u][j<span class="number">-1</span>]+=g[v][j];</span><br><span class="line">				f[u][j+<span class="number">1</span>]+=f[v][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>]=id; id+=len[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	g[<span class="number">1</span>]=id; id+=len[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Dominant Indices[CF1009F]</title>
    <url>/2020/01/03/Dominant-Indices-CF1009F/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一棵有根树，定义 $d_{u,i}$ 表示以 $u$ 为根的子树内离 $u$ 的距离为 $i$ 的节点个数。</p>
<p>对于每个节点 $u$，求出使 $d_{u,j}$ 最大的 $j$，且 $j$ 的编号最小。</p>
<p>$n\leq 10^6$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p> $d_{u,i}=\sum_{v\in Son_u}d_{v,i-1}$</p>
<p>这个东东实现一次的复杂度是 $O(\sum_{v\in son_u}len_v)$ 的（其中 $len_v$ 为 $v$ 的子树中离 $v$ 的最远距离）。</p>
<p>可以用<a href="/2020/01/03/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/" title="长链剖分">长链剖分</a>解决。</p>
<p>如果我们用重儿子继承，即先算重儿子的 $d$ 值，那么 $d_{u,i}=d_{son_u,i-1}$。</p>
<p>相当于数组移动了 $1$ 位。那么用指针实现，令 $f_{son_u}=f_{u}+1$ 即可。</p>
<p>每个长链只会被统计一次答案，且统计的时间为长链的长。</p>
<p>因此复杂度是 $O(n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>());</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans[N];</span><br><span class="line"><span class="type">int</span> ver[N&lt;&lt;<span class="number">1</span>],ne[N&lt;&lt;<span class="number">1</span>],head[N],tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ver[++tot]=y; ne[tot]=head[x]; head[x]=tot;</span><br><span class="line">	ver[++tot]=x; ne[tot]=head[y]; head[y]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len[N],son[N];</span><br><span class="line"><span class="type">int</span> tmp[N],*f[N],*id=tmp;<span class="comment">//指针实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			<span class="keyword">if</span>(len[son[u]]&lt;len[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	len[u]=len[son[u]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(son[u]) f[son[u]]=f[u]+<span class="number">1</span>,<span class="built_in">dfs2</span>(son[u],u),ans[u]=ans[son[u]]+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u],v;i;i=ne[i])</span><br><span class="line">		<span class="keyword">if</span>((v=ver[i])!=pre&amp;&amp;ver[i]!=son[u])</span><br><span class="line">		&#123;</span><br><span class="line">			f[v]=id; id+=len[v];</span><br><span class="line">			<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;len[v];j++)</span><br><span class="line">			&#123;</span><br><span class="line">				f[u][j+<span class="number">1</span>]+=f[v][j];</span><br><span class="line">				<span class="keyword">if</span>(f[u][ans[u]]&lt;f[u][j+<span class="number">1</span>]||(f[u][ans[u]]==f[u][j+<span class="number">1</span>]&amp;&amp;ans[u]&gt;j+<span class="number">1</span>)) ans[u]=j+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(f[u][ans[u]]==<span class="number">1</span>) ans[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">add</span>(<span class="built_in">read</span>(),<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	f[<span class="number">1</span>]=id; id+=len[<span class="number">1</span>];<span class="comment">//用多少空间就加多少</span></span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>长链剖分</title>
    <url>/2020/01/03/%E9%95%BF%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>长链剖分学习笔记。</p>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>长链剖分，顾名思义，就是每条链都很长嘛！</p>
<p>跟树链剖分名字比较像，那他们有什么不同呢？</p>
<p>树链剖分重儿子靠子树大小。</p>
<p>那长链剖分靠啥呢？当然是靠<strong>最深的点谁更深</strong>啦。</p>
<p>那么求出 $len_u$ 表示最深的点到 $u$ 的距离就可以啦~</p>
<p>好了，我们已经会对一棵树进行长链剖分了。</p>
<p>长链剖分有点类似于 dsu on tree，解决的是一些跟树上启发式合并相关的题。</p>
<p>长链剖分需要题目满足一些跟深度有关的性质。比如树形dp合并时dp数组的下标只需要用到 $len_v$ 个之类的。</p>
<p>这个东西这样讲感觉比较难懂。具体看例题吧。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>任何节点的 $k$ 级祖先所在长链长度大于 $k$ 。</p>
<p>证明十分显然。</p>
<h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p>任何节点往上跳经过的长链条数最多为 $O(\sqrt{n})$ 条。</p>
<p>证明：每次跳长链长最多 $+1$，最坏情况为一直 $+1$。因此最多跳 $O(\sqrt{n})$ 条。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>dp题一般是先长链剖分，然后指针实现。</p>
<ol>
<li><a href="/2020/01/03/Dominant-Indices-CF1009F/" title="Dominant Indices[CF1009F]">Dominant Indices[CF1009F]</a></li>
<li><a href="/2020/01/03/Hotel-POI2014/" title="Hotel[POI2014]">Hotel[POI2014]</a></li>
<li><a href="/2020/01/14/Salty-Fish-hdu6634/" title="Salty Fish[hdu6634]">Salty Fish[hdu6634]</a></li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Three Investigators[hdu6642]</title>
    <url>/2020/01/03/Three-Investigators-hdu6642/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个长度为 $n$ 的序列，对于每个前缀，求最多 $5$ 个互不相交的不下降子序列的元素和的最大值。</p>
<p>$n\leq 10^5,a_i\in[1,10^9]$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>$5$ 这个东西很有用，最终的复杂度很可能就是跟 $2^5$ 之类的相关。</p>
<p>把 $a_i$ 拆成 $a_i$ 个 $a_i$，那么答案转变成统计元素数量的最大值。</p>
<p>发现这个东西就是杨氏图表前 $5$ 层的长度之和。</p>
<p>杨表的插入过程如下：</p>
<p>1，若当前层没有元素比 $x$ 大，则把 $x$ 插在末尾。</p>
<p>2，否则用比 $x$ 大的最小的数 $y$ 代替 $x$，然后将 $y$ 插入下一层中。</p>
<p>那么用 $\mbox{map}$ 处理杨表，每次插入 $a_i$ 个 $a_i$，每层最多会使 $2$ 个数字拆开，因此时间复杂度 $O(2^5n\log n)$。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S 5</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>());</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,ll&gt; a[S];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,ll num,<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;=S) <span class="keyword">return</span>;</span><br><span class="line">	a[k][u]+=num; ans+=num;</span><br><span class="line">	<span class="keyword">for</span>(map&lt;<span class="type">int</span>,ll&gt;::iterator it;num;)</span><br><span class="line">	&#123;</span><br><span class="line">		it=a[k].<span class="built_in">lower_bound</span>(u+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(it==a[k].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">		ll d=<span class="built_in">min</span>((*it).second,num);</span><br><span class="line">		num-=d; ans-=d;</span><br><span class="line">		<span class="built_in">add</span>(k+<span class="number">1</span>,d,(*it).first);</span><br><span class="line">		<span class="keyword">if</span>((*it).second==d) a[k].<span class="built_in">erase</span>(it); <span class="keyword">else</span> a[k][(*it).first]-=d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> T=<span class="built_in">read</span>();T;T--,ans=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S;i++) a[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">read</span>(),x,n=i;i;i--) x=<span class="built_in">read</span>(),<span class="built_in">add</span>(<span class="number">0</span>,x,x),<span class="built_in">printf</span>((i==<span class="number">1</span>)?<span class="string">&quot;%lld\n&quot;</span>:<span class="string">&quot;%lld &quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>杨氏图表</tag>
      </tags>
  </entry>
  <entry>
    <title>猎人杀[pkuwc2018]</title>
    <url>/2020/01/03/%E7%8C%8E%E4%BA%BA%E6%9D%80-pkuwc2018/</url>
    <content><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://loj.ac/problem/2541">loj</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一道很不错的思维题。</p>
<p>想来想去想不到什么直接的做法。</p>
<p>先看看 $n\leq 20$ 该怎么做吧。</p>
<p>状态压缩，设 $f_S$ 表示 $S$ 集合先于 $1$ 号猎人死亡的概率。</p>
<p>直接 DP 就可以了。</p>
<p>接着继续想，还是想不到什么直接做的做法。</p>
<p>那么只能试试容斥了。</p>
<p>把 $f_S$ 的状态改一改，变成至少是 $S$ 中的人在 $1$ <strong>之后</strong>死的概率。</p>
<p>那么答案即为：$\sum_S (-1)^Sf_S$</p>
<p>而 $f_S$ 显然与不在 $S$ 的且不是 $1$ 的猎人无关。</p>
<p>则 $f_S=\frac{w_1}{w_1+\sum_{i\in S} w_i}$</p>
<p>有一个很重要的数据范围是 $\sum_{i=1}^nw_i\leq 10^5$</p>
<p>那就是说 $f_S$ 的分母不会超过 $10^5$。</p>
<p>那或许可以试着枚举 $j$，然后求出所有满足 $\sum_{i\in S}w_i=j$ 的集合的 $(-1)^S$ 的和？</p>
<p>考虑每个 $w_i$ 的贡献，选相当于乘 $-1$，不会相当于乘 $1$。则可以设以下生成函数：$(1-x^{w_i})$</p>
<p>$j$ 的答案即为 $\prod_{i=2}^n (1-x^{w_i})$ 的第 $j$ 项的系数。</p>
<p>分治FFT 即可。</p>
<p>时间复杂度 $O(n\log ^2n)$</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一道思维较好的容斥。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[N],n;</span><br><span class="line"><span class="type">int</span> siz[<span class="number">32</span>],m;</span><br><span class="line"><span class="type">int</span> len,L,R[N];</span><br><span class="line">ll a[<span class="number">32</span>][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="keyword">if</span>(i&gt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ll wn=<span class="built_in">Pow</span>(G,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">-1</span>) wn=<span class="built_in">Pow</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			ll w=<span class="number">1</span>,x,y;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++,w=w*wn%mod)</span><br><span class="line">				x=a[j+k],y=a[i+j+k]*w%mod,</span><br><span class="line">				a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll invn=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*invn%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pre_ntt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(L=<span class="number">0</span>,len=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,L++); L--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++) R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		siz[++m]=w[l];</span><br><span class="line">		a[m][<span class="number">0</span>]=<span class="number">1</span>; a[m][w[l]]=mod<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;w[l];i++) a[m][i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(l,mid); <span class="built_in">solve</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="type">int</span> ml=m<span class="number">-1</span>,mr=m,s=siz[ml]+siz[mr];</span><br><span class="line">	<span class="built_in">pre_ntt</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=siz[ml]+<span class="number">1</span>;i&lt;len;i++) a[ml][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=siz[mr]+<span class="number">1</span>;i&lt;len;i++) a[mr][i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ntt</span>(a[ml],len,<span class="number">1</span>); <span class="built_in">ntt</span>(a[mr],len,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) a[ml][i]=a[ml][i]*a[mr][i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(a[ml],len,<span class="number">-1</span>);</span><br><span class="line">	siz[--m]=s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>; ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum+=(w[i]=<span class="built_in">read</span>());</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">2</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=sum;i++) (ans+=a[<span class="number">1</span>][i]*w[<span class="number">1</span>]%mod*<span class="built_in">Pow</span>(w[<span class="number">1</span>]+i,mod<span class="number">-2</span>))%=mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>bzoj</category>
        <category>loj</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>期望</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title>party[bzoj5404]</title>
    <url>/2020/01/02/party-bzoj5404/</url>
    <content><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=5404">bzoj5404</a></p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="分析数据范围"><a href="#分析数据范围" class="headerlink" title="分析数据范围"></a>分析数据范围</h4><p>首先一看 $c$ 比较小，再看颜色数也只有 $1000$，这些十分有用，以后必定会用到。</p>
<h4 id="分析题意"><a href="#分析题意" class="headerlink" title="分析题意"></a>分析题意</h4><p>为了尽快到齐，那就一定会到达这 $c$ 的人的 $LCA$ 处。</p>
<p>这时我们需要求出每个人到达 $LCA$ 的特产有哪些。</p>
<h4 id="考虑第1步做法"><a href="#考虑第1步做法" class="headerlink" title="考虑第1步做法"></a>考虑第1步做法</h4><p>我们并不关心这些特产的出现次数，只关心有没有出现就可以了。</p>
<p>那就是状态压缩，每一位表示有没有，然后or起来就可以了。</p>
<p>这个东东可以用 bitset 搞一搞，一次的时间是 $O(\frac{m}{w})$，其中 $w$ 为 $64$，大概是在 $15$ 左右。 </p>
<p>那么如何求出一个点到它某个祖先的出现颜色的集合呢？</p>
<p>维护树上前缀和？显然不行，这个or操作不支持删除。</p>
<p>那么只能暴力树剖了，然后上线段树，时间复杂度 $O(q\frac{m}{w}\log^2n)$，不太行。</p>
<p>这时需要一个技巧：我们可以<strong>维护每个点到其重链顶端的路径的集合</strong>。</p>
<p>那么就只需要一直跳重链，跳到最后和 $LCA$ 同重链的时候再用线段树就可以了。</p>
<p>这样就可以省掉一个 $log$ 的时间。</p>
<h4 id="考虑第2步做法"><a href="#考虑第2步做法" class="headerlink" title="考虑第2步做法"></a>考虑第2步做法</h4><p>求出了上面那个东西，接下考虑如何通过这 $c$ 个集合求得答案。</p>
<p>这个答案是满足单调性的，试试二分？</p>
<p>考虑一个人选 $k$ 种颜色是否可行。</p>
<p>无法很快地判断出来，先试试暴力（假设只有一个询问）？</p>
<p>建一个二分图，$X$ 集合中 $ck$ 个点，每个人有 $k$ 个点；$Y$ 集合有 $m$ 个点，代表每种颜色。</p>
<p>若第 $i$ 个人的集合中出现了颜色 $j$ ，则 $i$ 的 $k$ 个点都连一条边到 $j$。</p>
<p>转换成判断是否存在完美匹配。</p>
<p>根据<a href="/2019/12/29/Hall%E5%AE%9A%E7%90%86/" title="Hall定理">Hall定理</a>，每个 $X$ 集合的子集连出去的点的集合大小必须大于等于该子集的大小。</p>
<p>只要一个人中的某个点出现在该子集中，那么这个人的所有点都要出现该子集中。</p>
<p>所以有 $2^c-1$ 种情况需要考虑。</p>
<p>那么就对于所有的 $S\subseteq X$ 有 $|S|k\leq |N_g(S)|$，也就是 $k\leq \min(\frac{|N_G(S)|}{|S|})$</p>
<p>那么二分的步骤都省略了，答案即为 $\min(\frac{|N_G(S)|}{|S|})$。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>记 $t=\frac{m}{w}$，则时间复杂度 $O(nt\log n+qt(c\log n+2^c))$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 300010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1004</span></span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="keyword">namespace</span> SGT&#123;</span><br><span class="line">	bitset&lt;M&gt; f[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rc (u&lt;&lt;1|1)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ls lc,l,mid</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> rs rc,mid+1,r</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p,<span class="type">int</span> u=<span class="number">1</span>,<span class="type">int</span> l=<span class="number">1</span>,<span class="type">int</span> r=n)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(f[u][p]=<span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">add</span>(x,p,ls);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">add</span>(x,p,rs);</span><br><span class="line">		f[u]=f[lc]|f[rc];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,bitset&lt;M&gt;* A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> (<span class="type">void</span>)((*A)|=f[u]);</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">ask</span>(ls,L,R,A);</span><br><span class="line">		<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">ask</span>(rs,L,R,A);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; adj[N];</span><br><span class="line">	bitset&lt;M&gt; f[N];</span><br><span class="line">	<span class="type">int</span> siz[N],son[N],fa[N],dep[N],top[N],dfn[N],tim;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;adj[x].<span class="built_in">pb</span>(y);&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> pre)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		siz[u]=<span class="number">1</span>; fa[u]=pre; dep[u]=dep[pre]+<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,adj[u].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> v=adj[u][i];</span><br><span class="line">			<span class="built_in">dfs1</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(siz[son[u]]&lt;siz[v]) son[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		f[u][a[u]]=<span class="number">1</span>;</span><br><span class="line">		dfn[u]=++tim;</span><br><span class="line">		SGT::<span class="built_in">add</span>(dfn[u],a[u]);</span><br><span class="line">		top[u]=tp;</span><br><span class="line">		<span class="type">int</span> v=son[u];</span><br><span class="line">		<span class="keyword">if</span>(v) f[v]=f[u],<span class="built_in">dfs2</span>(v,tp);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,adj[u].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(!top[v=adj[u][i]])</span><br><span class="line">				f[v].<span class="built_in">reset</span>(),<span class="built_in">dfs2</span>(v,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top[x]!=top[y];x=fa[top[x]])</span><br><span class="line">			<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">return</span> dep[x]&gt;=dep[y]?y:x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> z,bitset&lt;M&gt;* A)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;top[z]!=top[u];u=fa[top[u]]) *A|=f[u];</span><br><span class="line">		SGT::<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[z],dfn[u],A);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q,c,cnt,ans,p[<span class="number">10</span>];</span><br><span class="line">bitset&lt;M&gt; dp[<span class="number">34</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">2</span>,n) Tree::<span class="built_in">add</span>(<span class="built_in">read</span>(),i);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	Tree::<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	Tree::<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(_,<span class="number">1</span>,q)</span><br><span class="line">	&#123;</span><br><span class="line">		c=<span class="built_in">read</span>(); cnt=<span class="number">1</span>&lt;&lt;c;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,c<span class="number">-1</span>) p[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="type">int</span> LCA=p[<span class="number">0</span>];</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,c<span class="number">-1</span>) LCA=Tree::<span class="built_in">lca</span>(LCA,p[i]);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,cnt<span class="number">-1</span>) dp[i].<span class="built_in">reset</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,c<span class="number">-1</span>) Tree::<span class="built_in">get</span>(p[i],LCA,&amp;dp[<span class="number">1</span>&lt;&lt;i]);</span><br><span class="line">		ans=<span class="number">1e9</span>;</span><br><span class="line">		<span class="built_in">fo</span>(s,<span class="number">1</span>,cnt<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp=<span class="built_in">lowbit</span>(s),k=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(tmp!=s) dp[s]=dp[s^tmp]|dp[tmp];</span><br><span class="line">			<span class="built_in">fo</span>(i,<span class="number">0</span>,c<span class="number">-1</span>) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;i)) k++;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,(<span class="type">int</span>)dp[s].<span class="built_in">count</span>()/k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans*c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hall定理</tag>
        <tag>bitset</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Exhausted[ARC076F]</title>
    <url>/2019/12/30/Exhausted-arc076F/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$m$ 张凳子排成一列，从 $1$ 开始编号。</p>
<p>$n$ 个人，第 $i$ 个人能坐在不比 $l_i$ 大的凳子上，或者不比 $r_i$ 小的凳子上。</p>
<p>问最少有多少个人没地方坐。</p>
<p>$n,m\leq 2\times 10^5,l_i&lt;r_i$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>还是很显然地假设先建一个二分图出来。那么根据<a href="/2019/12/29/Hall%E5%AE%9A%E7%90%86/" title="Hall定理">Hall定理</a>，最大匹配 = $|X|-\max\{|W|-|N_g(W)|\}$。</p>
<p>那么答案就是 $\max \{ |W|-|N_g(W)|\}$。</p>
<p>显然 $N_g(W)$ 只需要考虑所有的 $\{ [1,L] \bigcup [R,m]\}$ 即可。</p>
<p>若 $L,R$ 固定，则$|W|=\sum{[l_i\leq L]\times [r_i\geq R]}$</p>
<p>把 $L$ 看做 $x$ 轴， $R$ 看做 $y$ 轴，则求 $|W|$ 相当于二维数点问题。</p>
<p>那么答案即为 $\max\{|W|-(L+(m-R+1))\}=-(L+m+1)+\max\{ |W|+R\}$</p>
<p>枚举 $L$，将 $(l_i,r_i)$ 按 $l_i$ 排序，扫描线，用线段树维护区间加区间最值即可。</p>
<p>时间复杂度 $O((n+m)\log (n+m))$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A.l!=B.l) <span class="keyword">return</span> A.l&lt;B.l;</span><br><span class="line">		<span class="keyword">return</span> A.r&lt;B.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tag[N&lt;&lt;<span class="number">1</span>],mx[N&lt;&lt;<span class="number">1</span>],ls[N&lt;&lt;<span class="number">1</span>],rs[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span>&#123;tag[u]+=x; mx[u]+=x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(ls[u]) <span class="built_in">pushtag</span>(ls[u],tag[u]);</span><br><span class="line">	<span class="keyword">if</span>(rs[u]) <span class="built_in">pushtag</span>(rs[u],tag[u]);</span><br><span class="line">	tag[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u=++cnt;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;mx[u]=r; <span class="keyword">return</span> u;&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ls[u]=<span class="built_in">build</span>(l,mid);</span><br><span class="line">	rs[u]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,x);</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">add</span>(ls[u],l,mid,L,R,x);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">add</span>(rs[u],mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">0</span>,m+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">	ans=<span class="built_in">max</span>(<span class="number">0</span>,n-m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;=n&amp;&amp;q[i].l==j;i++) <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">0</span>,m+<span class="number">1</span>,<span class="number">0</span>,q[i].r,<span class="number">1</span>);</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,-(j+m+<span class="number">1</span>)+mx[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AtCoder</category>
        <category>ARC</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hall定理</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>圆桌会议[bzoj3693]</title>
    <url>/2019/12/29/%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE-bzoj3693/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>$n$ 组人，第 $i$ 组 $a_i$ 个人，需要安排在一个$m$ 个座位的，编号为 $0,1,\cdots,m-1$ 的圆桌上，每个位置只能最多做一个人。</p>
<p>其中第 $i$ 组的人能坐在 $\{ l_i,(l_i+1)\%m,(l_i+2)\% m,\cdots,r_i\}$的位置上。</p>
<p>问是否存在一种合法的安排。</p>
<p>$n\leq 10^5,m\leq 10^9$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>容易想到建一个二分图，然后变成判断是否存在完美匹配的问题。</p>
<p>我们发现，尽管现在是在环上，但<a href="/2019/12/29/Hall%E5%AE%9A%E7%90%86/" title="Hall定理的结论1">Hall定理的结论1</a>仍然成立。</p>
<p>就可以先考虑简单一点的，在一条链上而不是在一个环上的情况。考虑完链的情况以后破环成链就能解决。</p>
<p>根据Hall定理的结论，我们需要对所有的区间 $[L,R]$ 都查询一遍看是否符合。</p>
<p>但十分显然的，我们只需要考虑 $R=r_i$ 的区间就可以了。</p>
<p>我们需要区间 $[L,R]$ 满足：$\sum a_i\leq R-L+1$，即 $(\sum a_i)+L\leq R+1$</p>
<p>那么把区间按右端点排序，然后枚举区间。每次在 $[1,l_i]$ 中加 $a_i$，查询 $[1,r_i]$ 中 $(\sum a)+L$ 的最大值，看是否小于等于 $R+1$ 即可。</p>
<p>环的话破环成链就可以了。</p>
<p>注意判断 $r_i=l_i-1$ 的情况。</p>
<p>时间复杂度 $O(n\log n)$</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 400010</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,a;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;A,<span class="type">const</span> node &amp;B)&#123;<span class="keyword">return</span> A.r&lt;B.r;&#125;</span><br><span class="line">&#125;q[N&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ls[N&lt;&lt;<span class="number">1</span>],rs[N&lt;&lt;<span class="number">1</span>],mx[N&lt;&lt;<span class="number">1</span>],tag[N&lt;&lt;<span class="number">1</span>],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushtag</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!u) <span class="keyword">return</span>;</span><br><span class="line">	mx[u]+=x; tag[u]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tag[u]) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">pushtag</span>(ls[u],tag[u]);</span><br><span class="line">	<span class="built_in">pushtag</span>(rs[u],tag[u]);</span><br><span class="line">	tag[u]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> u=++cnt;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;mx[u]=a[l]; <span class="keyword">return</span> u;&#125;</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	ls[u]=<span class="built_in">build</span>(l,mid);</span><br><span class="line">	rs[u]=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> <span class="built_in">pushtag</span>(u,x);</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) <span class="built_in">add</span>(ls[u],l,mid,L,R,x);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  <span class="built_in">add</span>(rs[u],mid+<span class="number">1</span>,r,L,R,x);</span><br><span class="line">	mx[u]=<span class="built_in">max</span>(mx[ls[u]],mx[rs[u]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> mx[u];</span><br><span class="line">	<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,mx=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid) mx=<span class="built_in">max</span>(mx,<span class="built_in">ask</span>(ls[u],l,mid,L,R));</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;R)  mx=<span class="built_in">max</span>(mx,<span class="built_in">ask</span>(rs[u],mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">	<span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line">ll sum;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fo</span>(u,<span class="number">1</span>,cnt) ls[u]=rs[u]=tag[u]=mx[u]=<span class="number">0</span>;</span><br><span class="line">	cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pos(x) lower_bound(a+1,a+tot+1,(x))-a</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> _=<span class="built_in">read</span>(),tot,n_tot;_--;)</span><br><span class="line">	&#123;</span><br><span class="line">		n_tot=n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			q[i].l=<span class="built_in">read</span>()+<span class="number">1</span>,q[i].r=<span class="built_in">read</span>()+<span class="number">1</span>;</span><br><span class="line">			sum+=(q[i].a=<span class="built_in">read</span>());</span><br><span class="line">			<span class="keyword">if</span>(q[i].r==q[i].l<span class="number">-1</span>) q[i].l=<span class="number">1</span>,q[i].r=m;<span class="comment">//特判</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(q[i].l&gt;q[i].r) q[i].r+=m;</span><br><span class="line">			<span class="keyword">else</span> q[++n_tot]=(node)&#123;q[i].l+m,q[i].r+m,q[i].a&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;m) &#123;<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">		n=n_tot; tot=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n) a[++tot]=q[i].l,a[++tot]=q[i].r;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>); tot=<span class="built_in">unique</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>)-a<span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">sort</span>(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,tot);</span><br><span class="line">		<span class="type">int</span> l,r;  <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">		&#123;</span><br><span class="line">			l=<span class="built_in">pos</span>(q[i].l); r=<span class="built_in">pos</span>(q[i].r);</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,tot,<span class="number">1</span>,l,q[i].a);</span><br><span class="line">			<span class="type">int</span> p=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,tot,<span class="number">1</span>,r);</span><br><span class="line">			<span class="keyword">if</span>(p&gt;q[i].r+<span class="number">1</span>) &#123;flag=<span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">puts</span>(flag?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>Hall定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Roundgod and Milk Tea[hdu6667]</title>
    <url>/2019/12/29/Roundgod-and-Milk-Tea-hdu6667/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有 $n$ 个班，每个班 $a_i$ 名学生，共做了 $b_i$ 杯奶茶。每个学生最多喝一杯奶茶，但不能喝本班的。问最多有多少个学生能喝到奶茶。</p>
<p>$n\leq 10^6,0\leq a_i,b_i\leq 10^9$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这道题让我学会了 Hall定理。。。</p>
<p>Hall定理详见：<a href="/2019/12/29/Hall%E5%AE%9A%E7%90%86/" title="Hall定理">Hall定理</a></p>
<p>首先先建个二分图，每个班的每个学生代表的点都向别班的每杯奶茶连边，</p>
<p>题目转换成了求该二分图的最大匹配。</p>
<p>Hall定理的推论：最大匹配数 = $|X|-\max(|W|-|N_g(W)|)$。</p>
<p>设 $Q=|W|-|N_g(W)|$ ，</p>
<p>下面考虑如何求 $Q$ 的最大值。</p>
<p>分三种情况讨论：</p>
<p>1，$|W|=0$，此时 $Q=0$。</p>
<p>2，$W$ 内只有第 $i$ 个班的学生，此时 $|N_g(W)|=(\sum b_j) -b_i$，为了让 $|W|$ 最大化，$|W|$ 应为 $a_i$，此时 $Q=a_i+b_i-(\sum b_j)$。</p>
<p>3，$W$ 内有多个班的学生，此时 $|N_g(W)|=\sum b_i$，为了让 $|W|$ 最大化，$|W|$ 应为 $\sum a_i$，此时 $Q=(\sum a_i)-(\sum b_i)$。</p>
<p>所以答案为：$(\sum a_i)-Q$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>学过编程的人都能写出来，懒得贴了。</p>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>Hall定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hall定理</title>
    <url>/2019/12/29/Hall%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>图论中一个比较有趣的定理。</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>二分图的完美匹配：即最大匹配数=$\min(|X|,|Y|)$</p>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>若一个二分图 $G=\{ X+Y,E \}(|X|\leq |Y|)$ 存在完美匹配，则任取一个 $X$ 中的子集 $W$，都会有 $|W|\leq |N_g(W)|$。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>若该二分图存在完美匹配，且不满足上述条件：</p>
<p>则必然存在一个 $X$ 中的子集 $W$，使得 $W&gt; N_g(W)$。那么 $W$ 中的点就无法全部匹配了。</p>
<h3 id="充分性"><a href="#充分性" class="headerlink" title="充分性"></a>充分性</h3><p>若该二分图满足上述条件，且不存在完美匹配：</p>
<p>先进行最大匹配。</p>
<p>然后选择 $X$ 中一个未匹配的点 $x_1$，</p>
<p>由该条件可得，必然存在至少一个点 $y_1$ 与 $x_1$有连边。</p>
<p>又因为这是在最大匹配中，$y_1$ 必须另外一个在 $X$ 中的点 $x_2$ 配对（否则就不是最大匹配了）。</p>
<p>又由该条件得到：$\{ x_1,x_2 \}$ 必然存在至少两个点 $\{ y_1,y_2\}$ 与其相连，即必然存在至少一个点 $y_2$ 与 $x_2$有连边。</p>
<p>又因为这是在最大匹配中，$y_2 $ 必须另外一个在 $X$ 中的点 $x_3$ 配对（否则就不是最大匹配了）。</p>
<p>…</p>
<p>这样下来就找到了一条增广路，与最大匹配矛盾。</p>
<p>仅有这个定理还不够，因为没理由直接枚举全部 $X$ 的子集吧。</p>
<p>因此——</p>
<h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><h3 id="结论1"><a href="#结论1" class="headerlink" title="结论1"></a>结论1</h3><p>若 $X$ 中每个点连的边都是 $|Y|$ 上连续的一段，设 $[ l,r ]$ 为 $|Y|$ 上一段连续的点的集合，$f([l,r])$ 表示只与 $[l,r]$ 中的点连边的 $X$ 点的集合。那么：</p>
<p>   $$\forall 1\leq l\leq r\leq |Y|,|f([l,r])|\leq |[l,r]|\Leftrightarrow \forall W\subseteq X,|W|\leq |N_g(W)|$$</p>
<p>   证明挺显然的。</p>
<h3 id="结论2"><a href="#结论2" class="headerlink" title="结论2"></a>结论2</h3><p>一个二分图的最大匹配数 = $|X|-\max(|W|-|N_g(W)|)$</p>
<p>   不怎么会证。。。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li><a href="/2019/12/29/Roundgod-and-Milk-Tea-hdu6667/" title="Roundgod and Milk Tea[hdu6667]">Roundgod and Milk Tea[hdu6667]</a></li>
<li><a href="/2019/12/29/%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE-bzoj3693/" title="圆桌会议[bzoj3693]">圆桌会议[bzoj3693]</a></li>
<li><a href="/2019/12/30/Exhausted-arc076F/" title="Exhausted[arc076F]">Exhausted[arc076F]</a></li>
<li><a href="/2020/01/02/party-bzoj5404/" title="party[bzoj5404]">party[bzoj5404]</a>

</li>
</ol>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Hall定理</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>Nonsense Time[hdu6635]</title>
    <url>/2019/12/29/Nonsense-Time-hdu6635/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>一个<strong>随机</strong>的排列 $p$，一开始所有位置都不能用。每次<strong>随机</strong>加一个位置使其变得可用，然后求当前最长上升子序列的长度。</p>
<p>$n\leq 50000,T\leq 3$</p>
<p>时限 $14s$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>一个很重要的前置知识：</strong>长度为 $n$ 的排列的最长上升子序列的长度的期望是 $O(\sqrt n)$</p>
<p>记住就好，不会证明…</p>
<p>因此每个位置有 $O(\frac{1}{\sqrt n})$ 的概率在LIS上。</p>
<p>本题倒着做或许会方便一些，每次删掉一个数。</p>
<p>那么每次先暴力求出LIS及其位置。如果每次使其不可用的位置不在LIS上，那么不管它。否则暴力再算一遍LIS。</p>
<p>期望复杂度 $O(\frac{n^2\log n}{\sqrt n})=O(n\sqrt n\log n)$</p>
<p>这是一道用了比较重要的性质的题，在此记录一下以免忘记。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>咕咕咕</p>
]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>期望</tag>
        <tag>树状数组</tag>
        <tag>随机</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2019多校5</title>
    <url>/2019/12/28/hdu2019%E5%A4%9A%E6%A0%A15/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=852">2019 Multi-University Training Contest 5</a></p>
<span id="more"></span>

<h3 id="Problem-A-fraction"><a href="#Problem-A-fraction" class="headerlink" title="Problem A fraction"></a>Problem A fraction</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>给定一个质数 $p$ 和一个小于 $p$ 的正整数 $x$，求出最小的正整数 $b$ 使得存在至少一个正整数 $a$ 满足$a &lt; b$ 且 $a\equiv bx(\bmod p)$</p>
<p>$1\leq T \leq 2\times 10^5$</p>
<p>$1 &lt; x &lt; p$</p>
<p>$3\leq p \leq 10^{15},p\in \mathbb{P}$</p>
<p>保证有解。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>先把 $a\equiv bx(\bmod p) (a &lt; b )$ 换成 $a=bx-py(y&gt;0)$的形式。</p>
<p>根据题意可得 $0&lt;a=bx-py&lt;b$</p>
<p>即：$py&lt;bx,b(x-1)&lt;py$</p>
<p>由 $x&gt;1$，$y&gt;0$，可得： $\frac{p}{x}&lt;\frac{b}{y}&lt;\frac{p}{x-1}$</p>
<p>$p,x,x-1$ 都已知，转换成 $\frac{a}{b}&lt;\frac{x}{y}&lt;\frac{c}{d}$ 且 $x$ 最小的问题。</p>
<p>当 $\frac{a}{b}$ 与 $\frac{c}{d}$ 间存在整数时，取 $y=1$ 会使得 $x$ 的最小值最小。</p>
<p>当不存在整数时，考虑减小范围。</p>
<p>不等式两边同时减去 $z$ 得：</p>
<p>$\frac{a-bz}{b}&lt;\frac{x-yz}{y}&lt;\frac{c-dz}{d}$</p>
<p>$z$ 的最值为 $\left \lceil \frac{a}{b} \right \rceil-1$</p>
<p>不等式取倒数得：</p>
<p>$\frac{d}{c-dz}&lt;\frac{y}{x-yz}&lt;\frac{b}{a-bz}$</p>
<p>变成更小的子问题。</p>
<p>正确性：递归处理同时保证 $y$ 最小的同时 $x-yz$ 最小，而 $x=(x-yz)+yz$，因此能保证 $x$ 最小。</p>
<p>时间复杂度为ex_gcd的时间，即 $O(\log p)$</p>
<h3 id="Problem-B-three-arrays"><a href="#Problem-B-three-arrays" class="headerlink" title="Problem B three arrays"></a>Problem B three arrays</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>有两个长度为 $n$ 的数组 $a,b$，任意排列 $a$ 和 $b$ 后，记 $c_i=a_i\bigoplus b_i$</p>
<p>求字典序最小的 $c$。</p>
<p>$n\leq 10^5$,$a_i,b_i&lt; 2^{30}$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>一道不错的题。</p>
<p>首先是异或，可以想到应该是跟 01trie 有关的东西。</p>
<p>那么对 $a,b$ 上的数分别建一个01trie。</p>
<p>然后两个序列上的数字看成点， 存在有向边 $(a_i,b_j)$ 当且仅当 $j$ 为使得 $a_i\bigoplus b_j$ 最小的 $j$，$(b_i,a_j)$ 同理。这样就得到了一个有向的二分图之类的东西。</p>
<p>若序列中的数两两不同，且同时存在 $(a_i,b_j)$ 和 $(b_j,a_i)$ 两条边，那么显然答案中一定会出现 $a_i$ 和 $b_j$ 配对的情况。因为如果不出现，交换位置一定会更优。</p>
<p>那么配对了以后可以在原来的序列中删去，变成了一个子问题。</p>
<p>如果序列中有相同的数，把这些数合并到一起就好了。</p>
<p>继续深挖性质。</p>
<p>发现不会出现长度大于 $2$ 的环。</p>
<p>一条边 $(x,y)$ 的意义在于 $x$ 最偏向 $y$，那么如果出现了 $(d_1,d_2),(d_2,d_3)$ 这两条边的话就说明 $d_1\bigoplus d_2 &gt; d_2\bigoplus d_3$，如果此时连成了环 $(d_1,d_2,\cdots,d_m)$ 的话，就会有 $d_1\bigoplus d_2&gt;d_2\bigoplus d_3&gt;\cdots&gt;d_{m-1}\bigoplus d_m&gt;d_m\bigoplus d_1&gt;d_1\bigoplus d_2$</p>
<p>矛盾，因此不可能出现。</p>
<p>那么可以dfs，用栈维护当前这条链是什么，当出现了一个长度2的环就尽量配对。当栈顶配对完了就弹出。</p>
<p>时间复杂度 $O(n(\log w+\log n))$，其中 $w$ 为 $a,b$ 中元素的最大值。</p>
<h3 id="Problem-D-equation"><a href="#Problem-D-equation" class="headerlink" title="Problem D equation"></a>Problem D equation</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>两个长度为 $n$ 的序列 $a,b$ 和整数 $C$</p>
<p>求下列方程所有的解，以分数形式输出。</p>
<p>$$\sum_{i=1}^n|xa_i+b_i|=C$$</p>
<p>$n\leq10^5,1\leq a_i,|b_i|\leq 10^3,C\leq 10^9$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>一次函数之和为一次函数，而 $|xa_i+b_i|$ 为一条折线，相当于两个一次函数。</p>
<p>$n$ 条这样的折线相加后，斜率和截距最多只会在 $n$ 个点处发生变化。</p>
<p>因此 $n$ 条折线相加后相当于 $n+1$ 个一次函数。</p>
<p>在每个一次函数的范围内判断一下就可以了。</p>
<h3 id="Problem-E-permutation1"><a href="#Problem-E-permutation1" class="headerlink" title="Problem E permutation1"></a>Problem E permutation1</h3><p>dfs模板题，签到题</p>
<h3 id="Problem-F-string-matching"><a href="#Problem-F-string-matching" class="headerlink" title="Problem F string matching"></a>Problem F string matching</h3><p>扩展kmp模板题，签到题</p>
<h3 id="Problem-G-permutation2"><a href="#Problem-G-permutation2" class="headerlink" title="Problem G permutation2"></a>Problem G permutation2</h3><p>递推模板题，签到题</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Trie</tag>
        <tag>思维题</tag>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>Good Numbers[hdu6618]</title>
    <url>/2019/12/27/Good-Numbers-hdu6618/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6618">Good Numbers</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>定义一个正整数 $n$ 是好数当且仅当 $n$ 在<strong>8进制</strong>表示下所有的数码出现的次数为<strong>3的倍数(出现0次亦可)</strong>。</p>
<p>有多少个 $k$ 位的8进制数（不含前导0），满足这个数是好的，且是 $p$ 的倍数。对 $10^9+9$ 取模。</p>
<p>例如：当 $k=3,p=2$ 时，好数有 $222(8),444(8),666(8)$ 三个。</p>
<p>$1\le k \le 10^{18},p&lt;8$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>因为只有8进制，考虑状压dp，设 $f[i][S][j]$ 表示考虑第 $i$ 位，8个位出现次数模 $3$ 的状态，当前数模 $p$ 的余数为 $j$ 的方案数。时间复杂度 $O(8kpw)$，其中 $w$ 为 $3^8=6561$。</p>
<p>发现瓶颈在于 $k$。</p>
<p>考虑优化 $k$，可以倍增dp，类似于快速幂的处理方法。</p>
<p>考虑从第 $i$ 位转移到第 $2i$ 位：</p>
<p>把 $2i$ 个位拆成前 $i$ 位和后 $i$ 位，枚举这两个状态。</p>
<p>那么有：</p>
<p>$$f[2i][S_1\bigoplus S_2][j_1+t\times j_2]+=f[i][S_1][j_1]\times f[i][S_2][j_2]$$</p>
<p>其中 $\bigoplus$ 代表3进制不进位加法（异或）。</p>
<p>从 $i$ 位转移到 $i+1$ 位比较容易。</p>
<p>时间复杂度 $O(w^2p^2\log k)$。</p>
<p>这时又多了一个瓶颈 $w^2$。</p>
<p>枚举了 $j_1$ 和 $j_2$ 后发现 $S_1,S_2$ 很像异或卷积形式。</p>
<p>实际上就是 3进制的异或卷积，用 3进制FWT加速。</p>
<p>在模 $10^9+9$ 意义下 $1$ 的三次单位根存在。</p>
<p>优化到 $O(wp^2\log w\log k)$</p>
<p>注意前导0的处理。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 6561</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem(x) memset((x),0,sizeof(x))</span></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> ll G=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod) <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll w1=<span class="built_in">Pow</span>(G,(mod<span class="number">-1</span>)/<span class="number">3</span>);</span><br><span class="line"><span class="type">const</span> ll w2=<span class="built_in">Pow</span>(G,(mod<span class="number">-1</span>)/<span class="number">3</span>*<span class="number">2</span>);</span><br><span class="line"><span class="type">const</span> ll inv3=<span class="built_in">Pow</span>(<span class="number">3</span>,mod<span class="number">-2</span>);</span><br><span class="line"><span class="type">const</span> ll inv2=<span class="built_in">Pow</span>(<span class="number">2</span>,mod<span class="number">-2</span>);</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fwt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll c[<span class="number">3</span>],b[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,len=<span class="number">3</span>;len&lt;=n;i*=<span class="number">3</span>,len*=<span class="number">3</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=len)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++) b[l]=a[j+k+l*i];</span><br><span class="line">				<span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					c[<span class="number">0</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]+b[<span class="number">2</span>])%mod;</span><br><span class="line">					c[<span class="number">1</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]*w1+b[<span class="number">2</span>]*w2)%mod;</span><br><span class="line">					c[<span class="number">2</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]*w2+b[<span class="number">2</span>]*w1)%mod;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++) b[l]=c[l];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					c[<span class="number">0</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]+b[<span class="number">2</span>])%mod;</span><br><span class="line">					c[<span class="number">1</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]*w2+b[<span class="number">2</span>]*w1)%mod;</span><br><span class="line">					c[<span class="number">2</span>]=(b[<span class="number">0</span>]+b[<span class="number">1</span>]*w1+b[<span class="number">2</span>]*w2)%mod;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++) b[l]=c[l]*inv3%mod;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;<span class="number">3</span>;l++) a[j+k+l*i]=b[l];</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll p3[<span class="number">10</span>],a[<span class="number">8</span>][M],_a[<span class="number">8</span>][M],b[<span class="number">8</span>][M],_b[<span class="number">8</span>][M],c[<span class="number">8</span>][M],n;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">8</span>;i++) p3[i]=p3[i<span class="number">-1</span>]*<span class="number">3</span>;</span><br><span class="line">	<span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>,&amp;n,&amp;p))</span><br><span class="line">	&#123;</span><br><span class="line">		ll now,tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">59</span>;~t;t--)</span><br><span class="line">		<span class="keyword">if</span>((now=(n&gt;&gt;t)))</span><br><span class="line">			<span class="keyword">if</span>(now==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">mem</span>(a[i]),<span class="built_in">mem</span>(b[i]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">8</span>;i++) a[i%p][p3[i]]=b[i%p][p3[i]]=<span class="number">1</span>;</span><br><span class="line">				a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//之后就可以有前导0</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">fwt</span>(a[i],M,<span class="number">1</span>),<span class="built_in">fwt</span>(b[i],M,<span class="number">1</span>),<span class="built_in">memcpy</span>(c[i],a[i],<span class="built_in">sizeof</span>(a[i]));</span><br><span class="line">				tmp=<span class="number">8</span>%p;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">mem</span>(_a[i]),<span class="built_in">mem</span>(_b[i]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> l=(i*tmp+j)%p;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;M;k++)</span><br><span class="line">							(_a[l][k]+=a[i][k]*a[j][k])%=mod,</span><br><span class="line">							(_b[l][k]+=b[i][k]*a[j][k])%=mod;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">memcpy</span>(a[i],_a[i],<span class="built_in">sizeof</span>(_a[i])),<span class="built_in">memcpy</span>(b[i],_b[i],<span class="built_in">sizeof</span>(_b[i]));</span><br><span class="line">				tmp=tmp*tmp%p;</span><br><span class="line">				<span class="keyword">if</span>(!(now&amp;<span class="number">1ll</span>)) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">mem</span>(_a[i]),<span class="built_in">mem</span>(_b[i]);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;p;j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="type">int</span> l=(i*<span class="number">8</span>+j)%p;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;M;k++)</span><br><span class="line">							(_a[l][k]+=a[i][k]*c[j][k])%=mod,</span><br><span class="line">							(_b[l][k]+=b[i][k]*c[j][k])%=mod;</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;i++) <span class="built_in">memcpy</span>(a[i],_a[i],<span class="built_in">sizeof</span>(a[i])),<span class="built_in">memcpy</span>(b[i],_b[i],<span class="built_in">sizeof</span>(b[i]));</span><br><span class="line">				tmp=tmp*<span class="number">8</span>%p;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">fwt</span>(b[<span class="number">0</span>],M,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,b[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hdu</category>
      </categories>
      <tags>
        <tag>状态压缩</tag>
        <tag>倍增</tag>
        <tag>FWT</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2019多校2</title>
    <url>/2019/12/27/hdu2019%E5%A4%9A%E6%A0%A12/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=849">2019 Multi-University Training Contest 2</a></p>
<span id="more"></span>

<h3 id="Problem-E-Everything-Is-Generated-In-Equal-Probability"><a href="#Problem-E-Everything-Is-Generated-In-Equal-Probability" class="headerlink" title="Problem E  Everything Is Generated In Equal Probability"></a>Problem E  Everything Is Generated In Equal Probability</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>有一序列 $A$ ，$h(A)$ 表示 $A$ 的逆序对个数，设函数 $g(A)=g(B)+h(A)$，其中 $B$ 为 $A$ 的 $2^n$ 种子序列中等概率选取的一个子序列。</p>
<p>设 $f(n)$ 表示任意选取长度为 $n$ 的排列 $P$，$g(P)$ 的期望。</p>
<p>对于 $i\in[1,n]$ ，求 $f(i)$</p>
<p>$n\leq 3000$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>考虑一个长度为 $n$ 的排列，由期望的线性性，可知长度为 $n$ 的排列的逆序对个数 $w(n)$=每对 $(i,j)$ 组成逆序对的期望之和，即 $w(n)=\frac{\binom{n}{2}}{2}$。</p>
<p>因此有：</p>
<p>$$f(i)=\frac{1}{2^i}\sum_{j=0}^{i}\binom{i}{j}f(j)+w(i)$$</p>
<p>将 $f(i)$ 从和式提出，移项得：</p>
<p>$f(i)=\frac{1}{2^i-1}\sum_{j=0}^{i-1}\binom{i}{j}f(j)+\frac{2^i}{2^i-1}w(i)$</p>
<p>$O(n^2)$ 求出 $f(n)$ 。</p>
<h3 id="Problem-H-Harmonious-Army"><a href="#Problem-H-Harmonious-Army" class="headerlink" title="Problem H Harmonious Army"></a>Problem H Harmonious Army</h3><h3 id="Problem-I-I-Love-Palindrome-String"><a href="#Problem-I-I-Love-Palindrome-String" class="headerlink" title="Problem I I Love Palindrome String"></a>Problem I I Love Palindrome String</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给一字符串 $s$，$\forall i\in[1,|S|]$，求有多少个长度为 $i$ 的子串满足它是回文串且该子串的前一半也是回文串。</p>
<p>$|S|\leq 3\times 10^5,\sum|S|\leq 4\times 10^6$ </p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>建出PAM，然后沿着 fail 边 dfs。</p>
<h3 id="Problem-J-Just-Skip-The-Problem"><a href="#Problem-J-Just-Skip-The-Problem" class="headerlink" title="Problem J Just Skip The Problem"></a>Problem J Just Skip The Problem</h3><p>签到题，输出 $n!$ 。</p>
<h3 id="Problem-K-Keen-On-Everything-But-Triangle"><a href="#Problem-K-Keen-On-Everything-But-Triangle" class="headerlink" title="Problem K Keen On Everything But Triangle"></a>Problem K Keen On Everything But Triangle</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>给一个序列 $a$ ，多次询问区间 $[l_i,r_i]$ 中是否存在三个下标不同的数组成三角形。</p>
<p>$n,m\leq 10^5,a_i\leq10^9$</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>首先判断一序列能否形成三角形的方法是把序列排序，然后相邻三个判断。</p>
<p>不能形成三角形的最坏情况是斐波那契数列，$f_{44}$ 左右的时候就大于 $10^9$ 了。</p>
<p>因此一个序列长度 $&gt;45$ 就必能形成三角形。</p>
<p>剩下的暴力即可。</p>
<h3 id="Problem-L-Longest-Subarray"><a href="#Problem-L-Longest-Subarray" class="headerlink" title="Problem L Longest Subarray"></a>Problem L Longest Subarray</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给一个序列 $a$，代表颜色，范围是 $[1,C]$求是否存在一个区间使得在此区间内出现过的每种颜色的出现次数大于等于 $k$。</p>
<p>$n,C,k\leq 10^5$</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>每种颜色分开来考虑：对于每种颜色，假设固定了左端点，那么右端点的合法范围为两段区间。</p>
<p>随着左端点向左移动，这些区间可以比较容易的维护。</p>
<p>那么对每种颜色的合法区间+1，求最大值是否为 $C$ 即可。</p>
<p>这是操作可以很方便的用线段树实现。</p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>思维题</tag>
        <tag>期望</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu2019多校1</title>
    <url>/2019/12/26/hdu2019%E5%A4%9A%E6%A0%A11/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/contests/contest_show.php?cid=848">2019 Multi-University Training Contest 1</a></p>
<span id="more"></span>

<h3 id="Problem-B-Operation"><a href="#Problem-B-Operation" class="headerlink" title="Problem B Operation"></a>Problem B Operation</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>有一个序列 $a$，刚开始长度为 $n$。一共 $m$ 次操作，共两种操作：</p>
<p>1，询问在区间 $[l,r]$ 中选一些元素使得异或和最大。输出异或和。</p>
<p>2，在该序列结尾添加一个数。</p>
<p>$n,m\leq 5\times 10^5,0\leq a_i &lt; 2^{30}$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>一个很显然的做法是线段树维护线性基合并，时间 $O(n\log^2w\log n)$，其中 $w$ 为 $a_i$ 的位数。但是显然过不去。</p>
<p>因为只是从结尾加一个数，考虑维护前缀的线性基。</p>
<p>但查询的时候还需要知道线性基里的数是否满足它的下标比 $l-1$ 大。</p>
<p>这时候可以在线性基里记录第 $i$ 位的下标 $p_i$。</p>
<p>那么插入的时候贪心，如果遇到一个下标比它小的数，那么把 $p_i$ 和值替换，然后拿原来的数继续往下贪心即可。</p>
<p>询问的时候判断一下 $l\leq p_i$ 就可以了。</p>
<p>时间复杂度 $O(n\log w)$。</p>
<h3 id="Problem-D-Vacation"><a href="#Problem-D-Vacation" class="headerlink" title="Problem D Vacation"></a>Problem D Vacation</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>$n+1$ 辆车，每辆车有长度 $l$，车头到终点距离 $s$，最大速度 $v$。模拟整个过程，一辆车无法超过另一辆车，接触后只能以前面的车的速度行驶。问第 $0$ 辆车的车头通过终点的时间。</p>
<p>$n\leq 10^5,l_i,s_i,v_i\leq 10^9,s_i\geq s_{i+1}+l_{i+1}$</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>最后 0 车通过终点的时候肯定是与前面一堆车一起的，枚举最前面的车是哪一辆，计算出通过时间，取最大值即为答案。</p>
<p>时间复杂度 $O(n)$</p>
<h3 id="Problem-E-Path"><a href="#Problem-E-Path" class="headerlink" title="Problem E Path"></a>Problem E Path</h3><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>一个有向图，问需要割哪些边，使得 $1$ 到 $n$ 的最短路变大。一个方案费用为边权之和。输出最小费用。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>建出最短路图，然后跑最小割即可。</p>
<h3 id="Problem-F-Typewriter"><a href="#Problem-F-Typewriter" class="headerlink" title="Problem F Typewriter"></a>Problem F Typewriter</h3><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给一个字符串 $s$，有两种操作：</p>
<p>1，花费 $p$ 在当前字符串后添加一个字母。</p>
<p>2，花费 $q$ 在当前字符串后添加一个当前字符串的子串。</p>
<p>当前字符串刚开始为空串，求使得变为 $s$ 的最少花费。</p>
<p>$n\leq 2\times 10^5$</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>容易想到 dp，设 $f_i$ 表示匹配到第 $i$ 位时的答案。</p>
<p>设 $j$ 为使得 $s[1,j]\in s[j+1,i]$ 的最大的 $j$。</p>
<p>对于每个 $i$ 求出了 $j$ 就可以 dp 了。</p>
<p>发现当 $i$ 增大时 $j$ 不减。</p>
<p>用 SAM 维护 $s[1,j]$ ，若 $s[j+1,i]$ 匹配不了，则把 $s_{j+1}$ 扔进 SAM 里，维护一下 $s[j+1,i]$ 在 SAM 中的位置以及是否匹配。</p>
<p>匹配位置最多往回跳 $n$ 次，最多往前加 $n$ 次。</p>
<p>时间复杂度 $O(n)$</p>
<h3 id="Problem-I-String"><a href="#Problem-I-String" class="headerlink" title="Problem I String"></a>Problem I String</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给一个字符串 $s$，构造一个字典序最小的，第 $i$ 个小写字母出现次数在 $[l_i,r_i]$ 范围内的子序列。</p>
<p>$n\leq 10^5$</p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>贪心，顺次考虑当前位能填的字母，从小到大枚举，判断是否可行的办法是先用序列自动机找到最靠前的那一位，然后记录每个字母是否出现的后缀和，再判断一下就可以了。</p>
<p>时间复杂度 $O(|S|\sum)$，其中 $\sum$ 为字符集大小。</p>
<h3 id="Problem-L-Sequence"><a href="#Problem-L-Sequence" class="headerlink" title="Problem L Sequence"></a>Problem L Sequence</h3><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>一个长度为 $n$ 的序列 $a$，有 $m$ 次操作，每次操作一个 $k(k\in [1,3])$ ，则新的序列 $a$ 满足 $a’<em>{i}=\sum</em>{j=i-kx}a_j(k\geq 0)$</p>
<p>求出 $m$ 次操作后的序列，模 $998244353$。</p>
<p>$n\leq 10^5,m\leq 10^6$</p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p>设该序列生成函数为 $A(x)=\sum_{i=1}^{n}a_ix^i$</p>
<p>那么一次操作相当于给 $A(x)$ 乘上一个 $\sum_{i=0}x^{ik}$</p>
<p>因此最后答案与操作顺序无关。</p>
<p>很显然的做法是多项式快速幂，比较卡常，好像过不了（反正当时没有过）。</p>
<p>那么考虑 $(\sum_{i=0}x^{ik})^m$ 等于什么。</p>
<p>由于 $(\sum_{i=0}x^i)^m=\sum_{i=0}\binom{m-1+i}{m-1}x^i$</p>
<p>那么 $(\sum_{i=0}x^{ik})^m=\sum_{i=0}\binom{m-1+i}{m-1}x^{ik}$</p>
<p>这样对于每个 $k$ 就只需要做一次卷积就可以了。</p>
<p>时间复杂度 $O(n\log n)$ </p>
]]></content>
      <categories>
        <category>hdu</category>
        <category>多校</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>网络流</tag>
        <tag>SAM</tag>
        <tag>FFT</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>局部极小值[cqoi2012]</title>
    <url>/2019/12/26/%E5%B1%80%E9%83%A8%E6%9E%81%E5%B0%8F%E5%80%BC-cqoi2012/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>有一个 $n$ 行 $m$ 列的整数矩阵，其中 $1$ 到 $nm$ 之间的每个整数恰好出现一次。如果一个格子比所有相邻格子（$8$ 连通）都小，我们说这个格子是局部极小值。</p>
<p>给出所有局部极小值的位置，你的任务是判断有多少个可能的矩阵，对 $12345678$ 取模。</p>
<p>$n\leq 4,m\leq 7$</p>
<span id="more"></span>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>范围这么小，比较容易想到的是状压dp，设 $f_{i,S}$ 表示考虑到第 $i$ 个数，局部最小值中的数已经填上的状态是 $S$ 的方案数。</p>
<p>分类讨论一下是否填的是局部最小值的位置，预处理一下，然后转移即可。</p>
<p>时间复杂度 $O(2^{|S|}nm|S|)$。</p>
<p>但是好像有点不对，因为只保证了你钦定的点是极小值，你没钦定的也可能变成极小值。</p>
<p>于是容斥一下，枚举哪一些点可能成为极小值，由子集反演可知容斥系数为 $(-1)^{|T|-|S|}$</p>
<p>用 dfs 枚举，加上一些适当剪枝。</p>
<p>时间复杂度 $O(不会分析)$。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> P 12345678ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="type">int</span> fx[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> fy[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,top;</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;<span class="number">0</span> &amp;&amp; x&lt;=n &amp;&amp; y&gt;<span class="number">0</span> &amp;&amp; y&lt;=m;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;<span class="type">int</span> x,y;&#125;;</span><br><span class="line">Point a[<span class="number">10</span>],st[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> g[<span class="number">260</span>],f[<span class="number">30</span>][<span class="number">260</span>],tot;</span><br><span class="line"><span class="type">bool</span> bo[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function">LL <span class="title">dp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			<span class="keyword">if</span>(s[i][j] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">				a[tot++] = (Point)&#123;i,j&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>;sta&lt;(<span class="number">1</span>&lt;&lt;tot);sta++)</span><br><span class="line">	&#123;</span><br><span class="line">		g[sta] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++) <span class="keyword">if</span>(~sta&amp;(<span class="number">1</span>&lt;&lt;i)) bo[a[i].x][a[i].y] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> k;</span><br><span class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(i+fx[k],j+fy[k]) &amp;&amp; bo[i+fx[k]][j+fy[k]]) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span>(k == <span class="number">9</span>) g[sta]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++) <span class="keyword">if</span>(~sta&amp;(<span class="number">1</span>&lt;&lt;i)) bo[a[i].x][a[i].y] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> sta=<span class="number">0</span>;sta&lt;(<span class="number">1</span>&lt;&lt;tot);sta++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][sta] = f[i<span class="number">-1</span>][sta] * <span class="built_in">max</span>(g[sta]-i+<span class="number">1</span>,<span class="number">0</span>) % P;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;tot;j++)</span><br><span class="line">				<span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j)&amp;sta)</span><br><span class="line">					f[i][sta] = (f[i][sta]+f[i<span class="number">-1</span>][sta^(<span class="number">1</span>&lt;&lt;j)])%P;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n*m][(<span class="number">1</span>&lt;&lt;tot)<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now &gt; top) <span class="keyword">return</span> <span class="built_in">void</span>((ans += d*<span class="built_in">dp</span>()%P+P)%=P);</span><br><span class="line">	<span class="built_in">dfs</span>(now+<span class="number">1</span>,d);</span><br><span class="line">	<span class="type">int</span> x = st[now].x,y = st[now].y,k;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(x+fx[k],y+fy[k]) &amp;&amp; s[x+fx[k]][y+fy[k]] == <span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">if</span>(k!=<span class="number">9</span>) <span class="keyword">return</span>;</span><br><span class="line">	s[x][y] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(now+<span class="number">1</span>,-d);</span><br><span class="line">	s[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,k;j&lt;=m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">9</span>;k++) <span class="keyword">if</span>(<span class="built_in">check</span>(i + fx[k],j + fy[k]) &amp;&amp; s[i+fx[k]][j+fy[k]] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(k == <span class="number">9</span>) st[++top] = (Point)&#123;i,j&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bzoj</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>容斥原理</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>FFT</title>
    <url>/2019/12/25/FFT/</url>
    <content><![CDATA[<p>FFT有关的知识点总结。</p>
<span id="more"></span>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="多项式求导"><a href="#多项式求导" class="headerlink" title="多项式求导"></a>多项式求导</h3><p>根据 $(x^n)’=nx^{n-1}$ 可推出。</p>
<h3 id="多项式不定积分"><a href="#多项式不定积分" class="headerlink" title="多项式不定积分"></a>多项式不定积分</h3><p>根据 $\int x^ndx=\frac{x^{n+1}}{n+1} +C$ 可推出。</p>
<h3 id="多项式加法"><a href="#多项式加法" class="headerlink" title="多项式加法"></a>多项式加法</h3><p>对应系数相加。</p>
<h3 id="多项式减法"><a href="#多项式减法" class="headerlink" title="多项式减法"></a>多项式减法</h3><p>对应系数相减。</p>
<h3 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h3><h4 id="DFT与IDFT的原理"><a href="#DFT与IDFT的原理" class="headerlink" title="DFT与IDFT的原理"></a>DFT与IDFT的原理</h4><p>给定两个多项式 $A(x)=\sum_{i=0}^na_ix^i,B(x)=\sum_{i=0}^nb_ix^i$，则两个多项式相乘后是：$(A * B)(x)=(a_0b_0)+(a_1b_0+a_0b_1)x+\dots+(a_nb_n)x^{2n}$</p>
<p>一个 $n$ 次多项式 $f(x)=\sum_{i=0}^na_ix^i$ 可以由 $n+1$ 个点  $(x_i,f(x_i))$ 唯一表示，那么FFT就是把两个多项式 $A(x),B(x)$（假设系数都为 $n$，不够最高位补0即可）的系数表示法转成由<strong>大于</strong> $2n$ 个（因为相乘后多项式的次数是 $2n$的，要用大于 $2n$ 个点值才能表示）相同的点值 （即$(x_i,A(x_i)),(x_i,B(x_i))$）表示，然后对应函数值相乘，得到点值：$(x_i,A(x_i) \times B(x_i))$，最后再把点值表示换成系数表示的过程。</p>
<p>如果随便取一些 $x_i$，那么每次操作是 $O(n^2)$ 的，毫无卵用。。。</p>
<p>假设我们要取 $n$ 个点值（不妨设 $n$ 为偶数）。</p>
<p>考虑 $x_k$ 为方程 $x^n=1$ 的复数解，即 $x_k=\omega _ n ^ k = e ^ {\frac{2k\pi i}{n}}=\cos(\frac{2k\pi}{n})+i\sin(\frac{2k\pi}{n})$</p>
<p>取 $1$ 的 $n$ 次单位根的作用在于，这个 $\omega _ n ^ k$ 有如下性质：</p>
<p>1，$\omega _ n^k=\omega _ n^{k \bmod n}$</p>
<p>2，若 $n,k$ 为偶数，则 $\omega _ n^k=\omega _ {n/2}^{k/2}$</p>
<p>证明都十分显然。</p>
<p>我们先回到原问题上面，现在要求的是 $f(\omega _ n^0),f(\omega _ n^1)…f(\omega _ n^{n-1})$，考虑分治，把多项式中次数为偶数的系数放在 $f_0$ 中，奇数的放在 $f_1$ 中，即：<br>$$f_0(x)=\sum_{i=0}^{2i\leq n}a_{2i}x^i\\f_1(x)=\sum_{i=0}^{2i+1\leq n}a_{2i+1}x^i$$<br>那么有：$f(\omega _ n^k)=f_0((\omega _ n^k)^2)+(\omega _ n^k)f_1((\omega _ n^k)^2)$</p>
<p>又因为 $(\omega _ n^k)^2=\omega _ n^{2k}=\omega _ {n/2}^k$</p>
<p>所以：$$f(\omega _ n^k)=f_0(\omega _ {n/2}^k)+(\omega _ n^k)f_1((\omega _ {n/2}^k))\ (0\leq k &lt; n)$$</p>
<p>当 $0\leq k &lt; \frac{n}{2} $ 时，有：<br>$$f(\omega _ n^k)=f_0(\omega _ {n/2}^k)+(\omega _ n^k)f_1((\omega _ {n/2}^k))\\f(\omega _ n^{k+\frac{n}{2}})=f_0(\omega _ {n/2}^k)-(\omega _ n^k)f_1((\omega _ {n/2}^k))$$</p>
<p>这样就变成了两个子问题，递归求解即可。时间复杂度 $O(n\log n)$</p>
<p>现在我们已经将多项式用系数表示转成点值表示(dft)了，那么这个操作的逆变换(idft)怎么做呢？</p>
<p>考虑dft的过程，可以变成矩阵相乘的形式：</p>
<p>$$\begin{bmatrix}<br>f(\omega _ n^0)\\<br>f(\omega 1)\\<br>f(\omega 2) \<br>\vdots\\<br>f(\omega _ n^{n-1})<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; \dots &amp; 1\\<br>1 &amp; \omega _ n^1 &amp; \omega _ n^2 &amp; \dots &amp;\omega _ n^{n-1} \\<br>1 &amp; \omega _ n^2 &amp; \omega _ n^4 &amp; \dots &amp; \omega _ n^{2(n-1)}\\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>1 &amp; \omega _ n^{n-1} &amp; \omega _ n^{2(n-1)} &amp; \dots &amp; \omega _ n^{(n-1)(n-1)}<br>\end{bmatrix}<br>\begin{bmatrix}<br>a_0\\<br>a_1\\<br>a_2\\<br>\vdots\\<br>a_{n-1}<br>\end{bmatrix}\$$</p>
<p>将上述表达式从左到右的矩阵记为 $Y,V,A$，则有 $Y=VA$。</p>
<p>因为是逆过程，所以要找到 $V$ 的逆矩阵使得 $V^{-1}Y=A$.</p>
<p>可以发现<del>我也不知道是怎么发现的</del> ，下面这个矩阵就是 $V$ 的逆矩阵：</p>
<p>$$V^{-1}<br>=\frac{1}{n}<br>\begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; \dots &amp; 1\\<br>1 &amp; \omega _ n^{-1} &amp; \omega _ n^{-2} &amp; \dots &amp;\omega _ n^{-(n-1)} \\<br>1 &amp; \omega _ n^{-2} &amp; \omega _ n^{-4} &amp; \dots &amp; \omega _ n^{-2(n-1)}\\<br>\vdots &amp; \vdots &amp; \vdots &amp; \dots &amp; \vdots\\<br>1 &amp; \omega _ n^{-(n-1)} &amp; \omega _ n^{-2(n-1)} &amp; \dots &amp; \omega _ n^{-(n-1)(n-1)}<br>\end{bmatrix}<br>$$</p>
<p>证明的话…可以考虑暴力矩阵乘法：$C_{ij}=\sum_{k}V_{ik}V^{-1} _ {kj}$，把两个矩阵暴力乘起来后可以发现当 $i=j$ 时，$C_{ii}$ 的值为 $n$ ，否则为 $0$.</p>
<p>那么idft的过程就与dft的类似了。</p>
<p>所以只需要将序列分别dft一下，然后对应相乘，最后idft回去就可以啦~</p>
<p><strong>到现在为止我们能做一个递归版的 fft 啦！</strong></p>
<p>但时实测这样的速度非常慢，需要写非递归的。</p>
<p>考虑 fft 的过程，经过一堆分治后，系数 $a_i$最终会到达一个位置上，而这些位置跟 $i$ 有关，如果 $i$ 是偶数就会被分到 $f_0(x)$ 中（即左边），否则会被分到右边，因此 $i$ 最后的位置是将 $i$ 在二进制表示下将位翻转后的位置，预处理即可。</p>
<p><strong>到现在为止我们就会做一个非递归版的 fft 啦！</strong></p>
<h4 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h4><p>那如果要对大质数取模呢？</p>
<p>我们直接跑FFT，最后取个模不就可以了？</p>
<p>但是FFT会有比较大的精度问题，当数字比较大的时候很容易挂掉。</p>
<p>考虑这个质数的一个原根 $g$，它的性质与 $n$ 次单位根相似，即 $g^{P-1} \equiv 1(\bmod p)$，但因为我们必须要保证每次做 dft 时次数 $n$ 必须是偶数，所以一开始的 $n$ 必须是2的次幂。所以要满足：$2^k | (P-1)$。</p>
<p>如当 $P=998244353$ 时， $k$ 最大是 $23$，即 $n$ 最大是 $8388608‬$。这就是<strong>快速数论变换（NTT）</strong>了。此时需满足 $P$ 为质数，且满足 $2^k|(P-1)$ 中最大的 $k$ 要满足 $n\leq 2^k$。</p>
<p>能跑NTT的一些模数有：$998244353,1004535809,469762049$ 等，这三个数的原根都有 $3$。</p>
<p><strong>到现在为止我们就会做一个非递归版的对模数有限制的 ntt 啦！</strong></p>
<p>一个小模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> G 3<span class="comment">//原根</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353ll<span class="comment">//模数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> R[N],L;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre_ntt</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	<span class="keyword">for</span>(m=<span class="number">1</span>,L=<span class="number">0</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>) L++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++) R[i] = (R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(L<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(LL *a,<span class="type">int</span> n,<span class="type">int</span> t)</span><span class="comment">//t=1时为dft,-1时为idft</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="keyword">if</span>(i&gt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(i&lt;&lt;<span class="number">1</span>)&lt;=n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ll wn=<span class="built_in">Pow</span>(G,(mod<span class="number">-1</span>)/(i&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">-1</span>) wn=<span class="built_in">Pow</span>(wn,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			ll w=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++,w=w*wn%mod)</span><br><span class="line">			&#123;</span><br><span class="line">				ll x=a[j+k],y=a[i+j+k]*w%mod;</span><br><span class="line">				a[j+k]=(x+y)%mod; a[i+j+k]=(x-y+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	ll invn=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) a[i]=a[i]*invn%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任意模数FFT"><a href="#任意模数FFT" class="headerlink" title="任意模数FFT"></a>任意模数FFT</h4><p>那如果模数不满足上面的限制呢？</p>
<p>这时有两种方法：</p>
<h5 id="三模数FFT"><a href="#三模数FFT" class="headerlink" title="三模数FFT"></a>三模数FFT</h5><p>先拿几个能做NTT的模数跑一次 NTT，然后用中国剩余定理合并。</p>
<p>显然选三个比较大的模数就可以了。</p>
<h5 id="拆系数FFT"><a href="#拆系数FFT" class="headerlink" title="拆系数FFT"></a>拆系数FFT</h5><p>设 $m=\left \lfloor \sqrt{P} \right \rfloor$，将FFT中每个数表示成 $bm+a$ 的形式，且 $a&lt;m$。那么就可以将两个数的乘法拆成四部分：$(bm+a)(dm+c)=bdm^2+(bc+ad)m+ac$。然后分别做普通的 FFT ，这样就避免了精度问题。此时一共需要 $4$ 次DFT，$3$ 次IDFT。常数大到爆炸。</p>
<p>考虑优化DFT，将两次dft合并到一次。</p>
<p>假设现在要求 $dft(a)$ 与 $dft(b)$。</p>
<p>设 $f_k=a_k+ib_k,g_k=a_k-ib_k$。</p>
<p>将有 $dft(f)<em>k=\text{conj}(dft(g)</em>{n-k})$。其中 $\text{conj}$ 表示共轭。</p>
<p>证明：$dft(f)<em>k=\sum</em>{j=0}^{n-1} w_n^{kj}f_j=\sum_{j=0}^{n-1} \text{conj}(w_n^{-kj}g_j)=\sum_{j=0}^{n-1} w_n^{kj}\text{conj}(g_j)=\text{conj}(dft(g)_{n-k})$。</p>
<p>于是 $dft(a)_k=\frac{dft(f)_k+dft(g)_k}{2}$ ，$dft(b)_k=-i\times \frac{dft(f)_k-dft(g)_k}{2}$。</p>
<p>这样做的前提条件显然是 $a,b$ 中的数均为实数。</p>
<p>考虑优化IDFT，设 $h=dft(a)+i\times dft(b)$。</p>
<p>那么 $idft(h)$ 的实部即为 $a$，虚部即为 $b$。</p>
<p>于是就优化成了分别 $2$ 次的DFT和IDFT了。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> ll mo=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">db pi=<span class="built_in">acos</span>(<span class="number">-1.</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span>&#123;</span><br><span class="line">	db x,y;</span><br><span class="line">	<span class="built_in">P</span>(db _x=<span class="number">0</span>,db _y=<span class="number">0</span>) &#123;x=_x,y=_y;&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> +(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x+B.x,A.y+B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> -(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x-B.x,A.y-B.y&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> *(<span class="type">const</span> P&amp;A,<span class="type">const</span> P&amp;B)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x*B.x-A.y*B.y,A.x*B.y+A.y*B.x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">inline</span> P <span class="keyword">operator</span> /(<span class="type">const</span> P&amp;A,<span class="type">const</span> db &amp;x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> (P)&#123;A.x/x,A.y/x&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">P <span class="title">conj</span><span class="params">(P A)</span> </span>&#123;<span class="keyword">return</span> (P)&#123;A.x,-A.y&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">P W[M]; <span class="type">int</span> R[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">			W[i+j]=(P)&#123;<span class="built_in">cos</span>(pi*j/i),<span class="built_in">sin</span>(pi*j/i)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;P&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(P *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	P w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k],</span><br><span class="line">				a[i+j+k]=a[j+k]-w,</span><br><span class="line">				a[j+k]=a[j+k]+w;</span><br><span class="line">	<span class="keyword">if</span>(t==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=a[i]/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]+B[i];</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Real(A) ((ll)floor(A.x+0.5))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Imag(A) ((ll)floor(A.y+0.5))</span></span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> Poly C,D;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	C.<span class="built_in">resize</span>(len); D.<span class="built_in">resize</span>(len); A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(P)&#123;<span class="built_in">Real</span>(A[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(A[i])&gt;&gt;<span class="number">15</span>&#125;,D[i]=(P)&#123;<span class="built_in">Real</span>(B[i])&amp;<span class="number">32767</span>,<span class="built_in">Real</span>(B[i])&gt;&gt;<span class="number">15</span>&#125;;</span><br><span class="line">	<span class="built_in">ntt</span>(C,len,<span class="number">1</span>); <span class="built_in">ntt</span>(D,len,<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len)</span><br><span class="line">	&#123;</span><br><span class="line">		P d4,d0,d1,d2,d3;</span><br><span class="line">		j=(len-i)&amp;(len<span class="number">-1</span>);</span><br><span class="line">		d4=<span class="built_in">conj</span>(C[j]);</span><br><span class="line">		d0=(d4+C[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>);</span><br><span class="line">		d1=(d4-C[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">		d4=<span class="built_in">conj</span>(D[j]);</span><br><span class="line">		d2=(d4+D[i])*<span class="built_in">P</span>(<span class="number">0.5</span>,<span class="number">0</span>);</span><br><span class="line">		d3=(d4-D[i])*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">		A[i]=d0*d2+d1*d3*<span class="built_in">P</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">		B[i]=d0*d3+d1*d2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) C[i]=(<span class="built_in">Real</span>(A[i]) + (<span class="built_in">Imag</span>(A[i]) % mo &lt;&lt; <span class="number">30</span>) + (<span class="built_in">Real</span>(B[i]) % mo &lt;&lt; <span class="number">15</span>))%mo;</span><br><span class="line">	C.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="一些技能"><a href="#一些技能" class="headerlink" title="一些技能"></a>一些技能</h2><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h3><p>给一个$n$次多项式$A(x)$，求$B(x)$满足$A(x)* B(x)\equiv 1\left ( \bmod x^n \right )$</p>
<p>不妨设$n$为2的次幂：</p>
<p>当$n=1$时，求一个整数的逆就好了。</p>
<p>当$n\geq 2$时，</p>
<p>假设已经求出了$A(x)* C(x)\equiv 1\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>$\because A(x)* B(x)\equiv 1\left ( \bmod x^n \right )$</p>
<p>$\therefore A(x)* B(x)\equiv 1\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>$\therefore A(x)* (B(x)-C(x))\equiv 0\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>又$\because A(x)\not\equiv 0\left ( \bmod x^n \right )$</p>
<p>$\therefore (B(x)-C(x))\equiv 0\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>仔细想一想可以发现$\left (B(x)-C(x)\right )^2\equiv 0\left ( \bmod x^{n} \right )$</p>
<p>化简得$B^{2}(x)+C^{2}(x)-2B(x)C(x)\equiv 0\left ( \bmod x^{n} \right )$</p>
<p>同时乘上$A(x)$得：$B(x)+A(x)* C^{2}(x)-2C(x)\equiv 0\left ( \bmod x^{n} \right )$</p>
<p>移项得：$B(x)\equiv C(x)\left ( 2-A(x)* C(x)\right )\left ( \bmod x^{n} \right )$</p>
<p>多项式乘法+倍增即可。</p>
<p>时间复杂度$T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$</p>
<h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>给两个次数分别为$n$和$m$的多项式$F(x),G(x)$，求$Q(x),R(x)$满足$F(x)=G(x)* Q(x)+R(x)$,且$Q(x)$的次数为$n-m$</p>
<p>$\because F(x)\equiv G(x)* Q(x)+R(x)\left ( \bmod x^{n+1}\right )$</p>
<p>$\therefore  F(\frac{1}{x})\equiv G(\frac{1}{x})* Q(\frac{1}{x})+R(\frac{1}{x})\left ( \bmod x^{n+1}\right )$</p>
<p>同时乘以$x^n$得：$ F^{rev}(x)\equiv G^{rev}(x)* Q^{rev}(x)+R^{rev}(x)\times x^{n-dR}\left ( \bmod x^{n+1}\right )$(其中$rev$表示将多项式系数翻转，$dR$表示$R$这个多项式的次数，其余同理)</p>
<p>$\because dR &lt; m $</p>
<p>$\therefore n-dR&gt;n-m$</p>
<p>因此在$\bmod x^{n-m+1}$意义下，$R^{rev}(x)\times x^{n-dR}\equiv 0$</p>
<p>$\therefore F^{rev}(x)\equiv G^{rev}(x)* Q^{rev}(x) \left ( \bmod x^{n-m+1}\right )$</p>
<p>多项式求逆+翻转即可。</p>
<p>时间复杂度$O(n\log n)$</p>
<h3 id="多项式取模"><a href="#多项式取模" class="headerlink" title="多项式取模"></a>多项式取模</h3><p>求出除法以后，取模变得非常简单。</p>
<p>时间复杂度$O(n\log n)$</p>
<h3 id="多项式开方"><a href="#多项式开方" class="headerlink" title="多项式开方"></a>多项式开方</h3><p>给一个$n$次多项式$A(x)$，求$B(x)$满足$A(x)\equiv B^{2}(x)\left ( \bmod x^n \right )$</p>
<p>还是考虑倍增：</p>
<p>不妨设$n$为2的次幂：</p>
<p>当$n=1$时，求$x^2\equiv a\left ( \bmod p\right )$的解<del>就好了</del>。比较多的题目会保证常数项为1.</p>
<p>当$n\geq 2$时，</p>
<p>假设已经求出了$A(x)\equiv C^2(x)\left ( \bmod x^{\frac{n}{2}} \right )$，</p>
<p>易得$\left ( C(x)-B(x)\right ) * \left ( C(x)+B(x)\right )\equiv 0\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>因此会有两个解，设$C(x)-B(x)\equiv 0\left ( \bmod x^{\frac{n}{2}} \right )$，则有$  C(x)+B(x)\equiv 0\left ( \bmod x^{\frac{n}{2}} \right )$</p>
<p>所以$ \left ( C(x)+B(x)\right )^2\equiv 0\Rightarrow C^2(x)+B^2(x)+2B(x)* C(x)\equiv 0\Rightarrow B(x)\equiv-\frac{C^2(x)+A(x)}{2C(x)}\left ( \bmod x^{n} \right )$</p>
<p>多项式求逆+乘法+倍增即可。</p>
<p>时间复杂度$T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$</p>
<h3 id="多项式ln"><a href="#多项式ln" class="headerlink" title="多项式ln"></a>多项式ln</h3><p>为啥多项式可以求ln啊。。。无法理解。。。</p>
<p>先来看看泰勒展开：</p>
<p>$$e^x=\sum_{i=0}^{\infty}\frac{x^i}{i!}$$</p>
<p>那么多项式求ln实际上就是知道$G(x)=e^{F(x)}$，让你求$F(x)$的过程。</p>
<p>对等式两边同时求$ln$得$\ln(G(x))=F(x)$</p>
<p>求导得：$\frac{G’(x)}{G(x)}=F’(x)$</p>
<p>求积分得：$\int {\frac{G’(x)}{G(x)}}=F(x)$</p>
<p>没了。。。</p>
<p>时间复杂度$O(n\log n)$</p>
<h3 id="多项式exp"><a href="#多项式exp" class="headerlink" title="多项式exp"></a>多项式exp</h3><p>能求ln那当然能求exp啦。</p>
<p>$F(x)=e^{A(x)}$</p>
<p>求ln得：$\ln  F(x)=A(x)$</p>
<p>$\ln F(x)-A(x)=0$</p>
<p>考虑牛顿迭代：</p>
<p>$F_{i+1}(x)=F_i(x)-\frac{\ln F_{i}(x)-A(x)}{\left (\ln F_{i}(x)-A(x) \right )’}=F_{i}(x)-\frac{\ln F_{i}(x)-A(x)}{\frac{1}{F_{i}(x)}}=F_{i}(x)\left ( 1-\ln F_{i}(x)+A(x)\right )\left ( \bmod x^n \right )$</p>
<p>每次迭代 $n$ 会翻一倍，时间复杂度$T(n)=T(\frac{n}{2})+O(n\log n)=O(n\log n)$</p>
<h3 id="多项式求幂"><a href="#多项式求幂" class="headerlink" title="多项式求幂"></a>多项式求幂</h3><p>$F(x)=A^{k}(x)$</p>
<p>两边同时取对数得：$\ln F(x)=k \ln A(x)$</p>
<p>同时取指数得：$F(x)=\exp\left ( k\ln A(x)\right )$</p>
<p>时间复杂度 $O(n\log n)$</p>
<h3 id="多项式三角函数"><a href="#多项式三角函数" class="headerlink" title="多项式三角函数"></a>多项式三角函数</h3><p>不是很清楚这种东西有什么用…</p>
<p>求 $\sin(A),\cos(A)$ ：</p>
<p>直接硬上欧拉公式：</p>
<p>$$e^{ix}=\cos(x)+i\sin(x)\\ e^{-ix}=\cos(x)-i\sin(x)$$</p>
<p>解得：</p>
<p>$$\cos(x)=\frac{e^{ix}+e^{-ix}}{2}\\\sin(x)=\frac{e^{ix}-e^{-ix}}{2}$$</p>
<p>但是在模意义这个 $i$ 该怎么办呢？</p>
<p>考虑 $i^2=-1$，所以在模 $mod$ 的意义下这个 $i$ 就是 $mod-1$ 的二次剩余。</p>
<h3 id="多点求值"><a href="#多点求值" class="headerlink" title="多点求值"></a>多点求值</h3><a href="/2021/09/02/%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/" title="“详见-多点求值”">“详见-多点求值”</a>

<h3 id="多点插值"><a href="#多点插值" class="headerlink" title="多点插值"></a>多点插值</h3><h3 id="常系数齐次线性递推"><a href="#常系数齐次线性递推" class="headerlink" title="常系数齐次线性递推"></a>常系数齐次线性递推</h3><a href="/2021/08/31/%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8/" title="“详见”">“详见”</a>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FO(x) freopen(#x<span class="string">&quot;.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin),freopen(#x<span class="string">&quot;.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fo(i,j,k) for(int i=(j),end_i=(k);i&lt;=end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ff(i,j,k) for(int i=(j),end_i=(k);i&lt; end_i;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fd(i,j,k) for(int i=(j),end_i=(k);i&gt;=end_i;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;x&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cle(x) memset(x,0,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;-(x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned ll</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lb long db</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">bool</span> f=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> f?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CASET fo(___,1,read())</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Add</span><span class="params">(ll x,ll y)</span></span>&#123;x+=y; <span class="keyword">return</span> (x&lt;mod)?x:x-mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Dec</span><span class="params">(ll x,ll y)</span></span>&#123;x-=y; <span class="keyword">return</span> (x&lt;<span class="number">0</span>)?x+mod:x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Mul</span><span class="params">(ll x,ll y)</span></span>&#123;<span class="keyword">return</span> x*y%mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;<span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1</span>,x=x*x%mod)<span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1</span>&lt;&lt;<span class="number">19</span>;</span><br><span class="line">ll W[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">PolyInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;M;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		W[i]=<span class="number">1</span>; w=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">2</span>/i);</span><br><span class="line">		<span class="built_in">fo</span>(j,<span class="number">1</span>,i<span class="number">-1</span>) W[i+j]=W[i+j<span class="number">-1</span>]*w%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; Poly;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,A[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *a,<span class="type">int</span> n,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> R[M];</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R[i]=(R[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;R[i]) <span class="built_in">swap</span>(a[i],a[R[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">				w=W[i+k]*a[i+j+k]%mod,</span><br><span class="line">				a[i+j+k]=<span class="built_in">Dec</span>(a[j+k],w),</span><br><span class="line">				a[j+k]=<span class="built_in">Add</span>(a[j+k],w);</span><br><span class="line">	<span class="keyword">if</span>(t^<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">reverse</span>(a+<span class="number">1</span>,a+n);</span><br><span class="line">		w=<span class="built_in">Pow</span>(n,mod<span class="number">-2</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,n<span class="number">-1</span>) a[i]=w*a[i]%mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ntt</span><span class="params">(Poly &amp;A,<span class="type">int</span> n,<span class="type">int</span> t)</span></span>&#123;<span class="built_in">ntt</span>(&amp;A[<span class="number">0</span>],n,t);&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> +(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Add</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> -(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(<span class="built_in">max</span>(A.<span class="built_in">size</span>(),B.<span class="built_in">size</span>()));</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,B.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=<span class="built_in">Dec</span>(A[i],B[i]);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">df</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i<span class="number">-1</span>]=A[i]*i%mod;</span><br><span class="line">	A.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">jf</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">pb</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,A.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">1</span>) A[i]=A[i<span class="number">-1</span>]*<span class="built_in">Pow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">	A[<span class="number">0</span>]=<span class="number">0</span>; <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*k%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> *(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>(),k=n+m<span class="number">-1</span>,len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;k;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(A,len,<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,len<span class="number">-1</span>) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(k);</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ~(Poly f)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n=f.<span class="built_in">size</span>();</span><br><span class="line">	Poly g,h;</span><br><span class="line">	g.<span class="built_in">pb</span>(<span class="built_in">Pow</span>(f[<span class="number">0</span>],mod<span class="number">-2</span>));</span><br><span class="line">	<span class="type">int</span> m=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;m&lt;n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		h.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,m<span class="number">-1</span>) h[i]=f[i];</span><br><span class="line">		<span class="built_in">ntt</span>(h,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],h[i]),g[i]);</span><br><span class="line">		<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	g.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>); f.<span class="built_in">resize</span>(m&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ntt</span>(f,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>); <span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,(m&lt;&lt;<span class="number">1</span>)<span class="number">-1</span>) g[i]=<span class="built_in">Mul</span>(<span class="number">2</span>+mod-<span class="built_in">Mul</span>(g[i],f[i]),g[i]);</span><br><span class="line">	<span class="built_in">ntt</span>(g,m&lt;&lt;<span class="number">1</span>,<span class="number">-1</span>); g.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Ln</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	A=<span class="built_in">jf</span>((~A)*<span class="built_in">df</span>(A));</span><br><span class="line">	A.<span class="built_in">resize</span>(n); <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Exp</span><span class="params">(<span class="type">const</span> Poly &amp;A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1</span>; <span class="keyword">for</span>(;n&lt;A.<span class="built_in">size</span>();n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	Poly B,C,D; B.<span class="built_in">clear</span>(); B.<span class="built_in">pb</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">2</span>;m&lt;=n;m&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=B; C.<span class="built_in">resize</span>(m); D=A; D.<span class="built_in">resize</span>(m);</span><br><span class="line">		C=D-<span class="built_in">Ln</span>(C); C[<span class="number">0</span>]=<span class="built_in">Add</span>(C[<span class="number">0</span>],<span class="number">1</span>);</span><br><span class="line">		B=B*C; B.<span class="built_in">resize</span>(m);</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(A.<span class="built_in">size</span>()); <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span> ^(Poly A,ll k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!A.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	ll tmp=A[<span class="number">0</span>],w=<span class="built_in">Pow</span>(tmp,k);</span><br><span class="line">	tmp=<span class="built_in">Pow</span>(tmp,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*tmp%mod;</span><br><span class="line">	A=<span class="built_in">Exp</span>(<span class="built_in">Ln</span>(A)*k);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>) A[i]=A[i]*w%mod;</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Cos</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)+<span class="built_in">Exp</span>(A*(mod-w4)))*((mod+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sin</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> ll w4=<span class="built_in">Pow</span>(<span class="number">3</span>,(mod<span class="number">-1</span>)/<span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">Exp</span>(A*w4)-<span class="built_in">Exp</span>(A*(mod-w4)))*(<span class="built_in">Pow</span>(w4,mod<span class="number">-2</span>)*((mod+<span class="number">1</span>)/<span class="number">2</span>)%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Sqrt</span><span class="params">(Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly C,D,<span class="built_in">B</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	C.<span class="built_in">clear</span>(); D.<span class="built_in">clear</span>();</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">4</span>;(l&gt;&gt;<span class="number">2</span>)&lt;n;l&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		C=A; C.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		D=B; D.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>); D=(~D);</span><br><span class="line">		C.<span class="built_in">resize</span>(l); D.<span class="built_in">resize</span>(l);</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">1</span>); <span class="built_in">ntt</span>(D,l,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,l) C[i]=C[i]*D[i]%mod;</span><br><span class="line">		<span class="built_in">ntt</span>(C,l,<span class="number">-1</span>);</span><br><span class="line">		B.<span class="built_in">resize</span>(l&gt;&gt;<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">ff</span>(i,<span class="number">0</span>,(l&gt;&gt;<span class="number">1</span>)) B[i]=<span class="built_in">Add</span>(C[i],B[i])*((mod+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	B.<span class="built_in">resize</span>(n);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>/(Poly A,Poly B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>,deg=A.<span class="built_in">size</span>()-B.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A)); <span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;=deg;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	B.<span class="built_in">resize</span>(len); B=~B; B.<span class="built_in">resize</span>(deg);</span><br><span class="line">	A=A*B; A.<span class="built_in">resize</span>(deg);</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(A));</span><br><span class="line">	<span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> Poly <span class="keyword">operator</span>%(<span class="type">const</span> Poly &amp;A,<span class="type">const</span> Poly &amp;B)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(A.<span class="built_in">size</span>()&lt;B.<span class="built_in">size</span>()) <span class="keyword">return</span> A;</span><br><span class="line">	Poly C=A-(A/B)*B;</span><br><span class="line">	C.<span class="built_in">resize</span>(B.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">Pow</span><span class="params">(Poly A,ll n,Poly M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Poly B=A; n--;</span><br><span class="line">	<span class="keyword">for</span>(;n;n&gt;&gt;=<span class="number">1</span>,A=(A*A)%M) <span class="keyword">if</span>(n&amp;<span class="number">1ll</span>) B=(B*A)%M;</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">64005</span>*<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc (u&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc ((u&lt;&lt;1)|1)</span></span><br><span class="line">Poly P[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll ans[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Poly <span class="title">MulT</span><span class="params">(Poly A,Poly B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=A.<span class="built_in">size</span>(),m=B.<span class="built_in">size</span>();</span><br><span class="line">	<span class="built_in">reverse</span>(<span class="built_in">all</span>(B));</span><br><span class="line">	<span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(;len&lt;n;len&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	A.<span class="built_in">resize</span>(len); B.<span class="built_in">resize</span>(len);</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">1</span>); <span class="built_in">ntt</span>(B,len,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">ff</span>(i,<span class="number">0</span>,len) A[i]=A[i]*B[i]%mod;</span><br><span class="line">	<span class="built_in">ntt</span>(A,len,<span class="number">-1</span>);</span><br><span class="line">	B.<span class="built_in">clear</span>();</span><br><span class="line">	len--;</span><br><span class="line">	<span class="built_in">fo</span>(i,m<span class="number">-1</span>,n+m<span class="number">-2</span>) B.<span class="built_in">pb</span>(A[i&amp;len]);</span><br><span class="line">	<span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)</span><br><span class="line">	&#123;</span><br><span class="line">		P[u].<span class="built_in">pb</span>(<span class="number">1</span>); P[u].<span class="built_in">pb</span>(<span class="built_in">Dec</span>(<span class="number">0</span>,a[l]));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r);</span><br><span class="line">	P[u]=P[lc]*P[rc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,Poly A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A.<span class="built_in">resize</span>(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> (<span class="type">void</span>)(ans[l]=A[<span class="number">0</span>]);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>(lc,l,mid,<span class="built_in">MulT</span>(A,P[rc])); <span class="built_in">solve</span>(rc,mid+<span class="number">1</span>,r,<span class="built_in">MulT</span>(A,P[lc]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line">Poly F,G;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">PolyInit</span>();</span><br><span class="line">	n=<span class="built_in">read</span>(); m=<span class="built_in">read</span>(); k=<span class="built_in">max</span>(n,m);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">0</span>,n) F.<span class="built_in">pb</span>(<span class="built_in">read</span>());</span><br><span class="line">	F.<span class="built_in">resize</span>(n+k+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">	F=<span class="built_in">MulT</span>(F,(~P[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>,<span class="number">1</span>,k,F);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,m) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>FFT</tag>
        <tag>倍增</tag>
        <tag>牛顿迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客挑战赛35</title>
    <url>/2019/12/25/%E7%89%9B%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B35/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/3274">牛客挑战赛35</a></p>
<span id="more"></span>

<h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>签到题，用最大的匹配最小的，次大的匹配次小的…</p>
<p>但是手速还是过于慢了…花了 $2\min$ 才AC此题。</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给一个图 $G_1$，$G_i=L(G_{i-1})$，$L(G)$ 表示 $G$ 的线图。</p>
<p>当 $n$ 无穷大时，求 $|G_n|$ 的值。发散时输出 $-1$。</p>
<p>$n\leq 10^5,m\leq 2\times 10^5$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>显然我们可以只考虑一个连通块的情况。</p>
<p>下面证明几个性质：</p>
<h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>如果存在两个环有共同的点，那么 $|G_n|$ 发散。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>因为共享点，因此必然存在某个点的度数至少为3，求一次线图就至少多一个环，因此环数会一直变多，因此发散。</p>
<h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p>若连通块是一个环，就不能再往里加边加点形成连通块。否组答案发散。</p>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>对该图求一次线图，变成性质1的情况。</p>
<p>因此边数大于点数的连通块都不可行。</p>
<p>边数等于点数的连通块只能是环。</p>
<p>下面考虑树的情况：</p>
<h4 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h4><p>除了一个4个点菊花图，所有出现度数大于等于3的点都会使得答案发散。</p>
<h4 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h4><p>求一次线图，变成性质2的情况或者更坏。</p>
<p>因此只需判断每个连通块是否为4个点的菊花，一条链，一个环的情况即可。</p>
<p>时间复杂度 $O(n)$</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>现在给出长度为 $n$ 的置换 $F$，求所有长度为 $n$ 且字典序严格大于 $F$ 的置换的循环节个数之和模 $998244353$。</p>
<p>$n\leq 2\times 10^5$</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>很显然地，我们考虑固定前 $i-1$ 位，第 $i$ 位可以选和第 $p_i$ 位以后的点相连。</p>
<p>一条还没有成环的链可以看成一个点。</p>
<p>设 $p_i$ 后面一共有 $w$ 个可连的点/链，有 $p$ 个在之前已经成环的环，那么大概就会有三种情况对答案产生贡献：</p>
<p>第一种是直接已经成环的，此时产生 $wp\times (n-i)!$ 的贡献。</p>
<p>第二种是未成环的，此时产生 $w\times f(n-i)$ 的贡献，其中 $f(i)$ 表示所有长度为 $i$ 的置换的循环节个数之和，这个可以 $O(n)$ 算出来。</p>
<p>第三种是自环，产生 $(n-i)!$ 的贡献。</p>
<p>那么用树状数组维护 $w$ ，并查集维护链即可。</p>
<p>时间复杂度$O(n\log n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 200010</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll f[N],ans;</span><br><span class="line">ll fac[N],inv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">	inv[n]=<span class="built_in">Pow</span>(fac[n],mod<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">fd</span>(i,n,<span class="number">1</span>) inv[i<span class="number">-1</span>]=inv[i]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"><span class="type">int</span> Bit[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) Bit[x]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> ans=<span class="number">0</span>)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) ans+=Bit[x]; <span class="keyword">return</span> ans;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">init</span>(n);</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) f[i]=(fac[i<span class="number">-1</span>]+f[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n) fa[i]=i;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>,s=<span class="number">0</span>,w=<span class="number">0</span>,x,y;</span><br><span class="line">	<span class="built_in">fo</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	&#123;</span><br><span class="line">		x=<span class="built_in">read</span>();</span><br><span class="line">		y=<span class="built_in">find</span>(i);</span><br><span class="line">		w=n-x-<span class="built_in">ask</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;x) ans=<span class="built_in">Add</span>(ans,fac[n-i]);</span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(<span class="built_in">Mul</span>(w,p),fac[n-i]));<span class="comment">//已成环的</span></span><br><span class="line">		ans=<span class="built_in">Add</span>(ans,<span class="built_in">Mul</span>(f[n-i],w));<span class="comment">//未成环的</span></span><br><span class="line">		<span class="built_in">add</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">find</span>(i)==x) p++;</span><br><span class="line">		<span class="keyword">else</span> fa[x]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>懒得写了…</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>将S串01反转后，去掉前导0的集合记为 $A$，将集合 $A$ 里01反转后不去掉前导0的集合记为 $B$。可以发现，当且仅当字符串 $t$ 由这两个集合里的字符串拼接而成才合法。</p>
<p>也就是说，从 $t$ 的后缀开始匹配，需要满足 $s,t$ 的某后缀相匹配，要么全相等，要不全不相等，且 $s$ 的这个后缀的第一个字符和前面一个字符不相等。</p>
<p>$O(n^2)$ DP一下就好了。</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p>感觉是全场第2简单的题…</p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>$n$ 个点的树复制 $k$ 遍，变成一个森林。在这个森林里加 $m$ 条边变成一个图。只有一次询问，问某两个点间最短路，边权为 $1$。</p>
<p>$n\leq 2\times 10^5,m,k\leq 50000$</p>
<h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>虚树+Dijkstra即可。</p>
]]></content>
      <categories>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>最短路</tag>
        <tag>虚树</tag>
        <tag>思维题</tag>
        <tag>树状数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
</search>
